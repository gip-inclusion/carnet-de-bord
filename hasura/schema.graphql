"""
This file is autogenerated, do not edit it!
"""

schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

type CreateNotebookFocusOutput {
  id: uuid!
}

input CreateNotebookInput {
  address1: String
  address2: String
  cafNumber: String
  city: String
  dateOfBirth: date!
  email: String
  externalId: String
  firstname: String!
  lastname: String!
  mobileNumber: String
  nir: String!
  postalCode: String
}

type CreateNotebookOutput {
  notebookId: uuid!
}

type CreateNotebookTargetOutput {
  id: uuid!
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

type NPSRatingOutput {
  void: String
}

enum PoleEmploiBesoinValeurEnum {
  BESOIN
  NON_EXPLORE
  POINT_FORT
}

enum PoleEmploiContrainteValeurEnum {
  CLOTUREE
  NON_ABORDEE
  OUI
}

type PoleEmploiDossierIndividu {
  besoinsParDiagnosticIndividuDtos: [PoleEmploiDossierIndividuBesoinsParDiagnosticIndividu!]!
  contraintesIndividusDto: PoleEmploiDossierIndividuContraintesIndividus!
}

type PoleEmploiDossierIndividuBesoins {
  code: String!
  libelle: String!
  valeur: PoleEmploiBesoinValeurEnum!
}

type PoleEmploiDossierIndividuBesoinsParDiagnosticIndividu {
  besoins: [PoleEmploiDossierIndividuBesoins!]!
  dateMiseAJour: String
  estPrioritaire: Boolean!
  idMetierChiffre: String!
  nomMetier: String
  statut: String!
  typologie: String
}

type PoleEmploiDossierIndividuContraintes {
  code: String!
  date: String
  libelle: String!
  objectifs: [PoleEmploiDossierIndividuObjectifs!]!
  situations: [PoleEmploiDossierIndividuSituations!]!
  valeur: PoleEmploiContrainteValeurEnum!
}

type PoleEmploiDossierIndividuContraintesIndividus {
  code: String!
  conseiller: String
  contraintes: [PoleEmploiDossierIndividuContraintes!]!
  dateDeModification: String
  libelle: String!
}

type PoleEmploiDossierIndividuObjectifs {
  code: String!
  libelle: String!
  valeur: PoleEmploiObjectifValeurEnum!
}

type PoleEmploiDossierIndividuSituations {
  code: String!
  libelle: String!
  valeur: PoleEmploiSituationValeurEnum!
}

enum PoleEmploiObjectifValeurEnum {
  ABANDONNE
  EN_COURS
  NON_ABORDE
  REALISE
}

enum PoleEmploiSituationValeurEnum {
  NON
  NON_ABORDEE
  OUI
}

type RemoveNotebookFocusOutput {
  id: uuid!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

type UpdateNotebookFromPoleEmploiOutput {
  data_has_been_updated: Boolean!
  external_data_has_been_updated: Boolean!
  has_pe_diagnostic: Boolean!
}

type UpdateNotebookTargetStatusOutput {
  id: uuid!
}

enum UpdateSocioProContractTypeEnum {
  """Apprentissage"""
  apprentissage

  """CDD"""
  cdd

  """CDI"""
  cdi

  """Contrat de professionnalisation"""
  contrat_professionnalisation

  """Interim"""
  interim

  """Lib√©ral"""
  liberal

  """Portage salarial"""
  portage_salarial

  """Saisonnier"""
  saisonnier
}

enum UpdateSocioProEmploymentTypeEnum {
  """Temps plein"""
  full_time

  """Temps partiel"""
  part_time
}

input UpdateSocioProNotebookSituationInsertInput {
  notebookId: uuid!
  situationId: uuid!
}

type UpdateSocioProOutput {
  id: uuid!
}

input UpdateSocioProProfessionalProjectInsertInput {
  contractTypeId: UpdateSocioProContractTypeEnum
  employmentTypeId: UpdateSocioProEmploymentTypeEnum
  hourlyRate: Int
  mobilityRadius: Int
  notebookId: uuid
  romeCodeId: uuid
}

input UpdateSocioProProfessionalProjectSetInput {
  contractTypeId: UpdateSocioProContractTypeEnum
  employmentTypeId: UpdateSocioProEmploymentTypeEnum
  hourlyRate: Int
  id: uuid!
  mobilityRadius: Int
  notebookId: uuid
  romeCodeId: uuid
}

"""
columns and relationships of "account"
"""
type account {
  accessKey: String
  accessKeyDate: timestamptz

  """An object relationship"""
  admin: admin_cdb
  adminId: uuid
  adminStructureId: uuid

  """An object relationship"""
  admin_structure: admin_structure

  """An object relationship"""
  beneficiary: beneficiary
  beneficiaryId: uuid
  confirmed: Boolean!
  createdAt: timestamptz!
  deletedAt: timestamptz
  id: uuid!
  lastLogin: timestamptz

  """An object relationship"""
  manager: manager
  managerId: uuid

  """An array relationship"""
  notebookActionsCreated(
    """distinct select on columns"""
    distinct_on: [notebook_action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_action_order_by!]

    """filter the rows returned"""
    where: notebook_action_bool_exp
  ): [notebook_action!]!

  """An aggregate relationship"""
  notebookActionsCreated_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_action_order_by!]

    """filter the rows returned"""
    where: notebook_action_bool_exp
  ): notebook_action_aggregate!

  """An array relationship"""
  notebookEventsCreated(
    """distinct select on columns"""
    distinct_on: [notebook_event_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_event_order_by!]

    """filter the rows returned"""
    where: notebook_event_bool_exp
  ): [notebook_event!]!

  """An aggregate relationship"""
  notebookEventsCreated_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_event_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_event_order_by!]

    """filter the rows returned"""
    where: notebook_event_bool_exp
  ): notebook_event_aggregate!

  """An array relationship"""
  notebookFocusesCreated(
    """distinct select on columns"""
    distinct_on: [notebook_focus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_focus_order_by!]

    """filter the rows returned"""
    where: notebook_focus_bool_exp
  ): [notebook_focus!]!

  """An aggregate relationship"""
  notebookFocusesCreated_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_focus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_focus_order_by!]

    """filter the rows returned"""
    where: notebook_focus_bool_exp
  ): notebook_focus_aggregate!

  """An array relationship"""
  notebookTargetsCreated(
    """distinct select on columns"""
    distinct_on: [notebook_target_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_target_order_by!]

    """filter the rows returned"""
    where: notebook_target_bool_exp
  ): [notebook_target!]!

  """An aggregate relationship"""
  notebookTargetsCreated_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_target_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_target_order_by!]

    """filter the rows returned"""
    where: notebook_target_bool_exp
  ): notebook_target_aggregate!

  """An array relationship"""
  notebooksCreated(
    """distinct select on columns"""
    distinct_on: [notebook_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_member_order_by!]

    """filter the rows returned"""
    where: notebook_member_bool_exp
  ): [notebook_member!]!

  """An aggregate relationship"""
  notebooksCreated_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_member_order_by!]

    """filter the rows returned"""
    where: notebook_member_bool_exp
  ): notebook_member_aggregate!

  """An array relationship"""
  notebooksWhereMember(
    """distinct select on columns"""
    distinct_on: [notebook_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_member_order_by!]

    """filter the rows returned"""
    where: notebook_member_bool_exp
  ): [notebook_member!]!

  """An aggregate relationship"""
  notebooksWhereMember_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_member_order_by!]

    """filter the rows returned"""
    where: notebook_member_bool_exp
  ): notebook_member_aggregate!
  onboardingDone: Boolean
  orientationManagerId: uuid

  """An object relationship"""
  orientation_manager: orientation_manager

  """An object relationship"""
  professional: professional
  professionalId: uuid

  """An object relationship"""
  role: role!
  type: role_enum!
  updatedAt: timestamptz!
  username: String!
}

"""
aggregated selection of "account"
"""
type account_aggregate {
  aggregate: account_aggregate_fields
  nodes: [account!]!
}

input account_aggregate_bool_exp {
  bool_and: account_aggregate_bool_exp_bool_and
  bool_or: account_aggregate_bool_exp_bool_or
  count: account_aggregate_bool_exp_count
}

input account_aggregate_bool_exp_bool_and {
  arguments: account_select_column_account_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: account_bool_exp
  predicate: Boolean_comparison_exp!
}

input account_aggregate_bool_exp_bool_or {
  arguments: account_select_column_account_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: account_bool_exp
  predicate: Boolean_comparison_exp!
}

input account_aggregate_bool_exp_count {
  arguments: [account_select_column!]
  distinct: Boolean
  filter: account_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "account"
"""
type account_aggregate_fields {
  count(columns: [account_select_column!], distinct: Boolean): Int!
  max: account_max_fields
  min: account_min_fields
}

"""
order by aggregate values of table "account"
"""
input account_aggregate_order_by {
  count: order_by
  max: account_max_order_by
  min: account_min_order_by
}

"""
input type for inserting array relation for remote table "account"
"""
input account_arr_rel_insert_input {
  data: [account_insert_input!]!

  """upsert condition"""
  on_conflict: account_on_conflict
}

"""
Boolean expression to filter rows from the table "account". All fields are combined with a logical 'AND'.
"""
input account_bool_exp {
  _and: [account_bool_exp!]
  _not: account_bool_exp
  _or: [account_bool_exp!]
  accessKey: String_comparison_exp
  accessKeyDate: timestamptz_comparison_exp
  admin: admin_cdb_bool_exp
  adminId: uuid_comparison_exp
  adminStructureId: uuid_comparison_exp
  admin_structure: admin_structure_bool_exp
  beneficiary: beneficiary_bool_exp
  beneficiaryId: uuid_comparison_exp
  confirmed: Boolean_comparison_exp
  createdAt: timestamptz_comparison_exp
  deletedAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  lastLogin: timestamptz_comparison_exp
  manager: manager_bool_exp
  managerId: uuid_comparison_exp
  notebookActionsCreated: notebook_action_bool_exp
  notebookActionsCreated_aggregate: notebook_action_aggregate_bool_exp
  notebookEventsCreated: notebook_event_bool_exp
  notebookEventsCreated_aggregate: notebook_event_aggregate_bool_exp
  notebookFocusesCreated: notebook_focus_bool_exp
  notebookFocusesCreated_aggregate: notebook_focus_aggregate_bool_exp
  notebookTargetsCreated: notebook_target_bool_exp
  notebookTargetsCreated_aggregate: notebook_target_aggregate_bool_exp
  notebooksCreated: notebook_member_bool_exp
  notebooksCreated_aggregate: notebook_member_aggregate_bool_exp
  notebooksWhereMember: notebook_member_bool_exp
  notebooksWhereMember_aggregate: notebook_member_aggregate_bool_exp
  onboardingDone: Boolean_comparison_exp
  orientationManagerId: uuid_comparison_exp
  orientation_manager: orientation_manager_bool_exp
  professional: professional_bool_exp
  professionalId: uuid_comparison_exp
  role: role_bool_exp
  type: role_enum_comparison_exp
  updatedAt: timestamptz_comparison_exp
  username: String_comparison_exp
}

"""
unique or primary key constraints on table "account"
"""
enum account_constraint {
  """
  unique or primary key constraint on columns "admin_id"
  """
  account_admin_id_key

  """
  unique or primary key constraint on columns "admin_structure_id"
  """
  account_admin_structure_id_key

  """
  unique or primary key constraint on columns "beneficiary_id"
  """
  account_beneficiary_id_key

  """
  unique or primary key constraint on columns "manager_id"
  """
  account_manager_id_key

  """
  unique or primary key constraint on columns "id"
  """
  account_pkey

  """
  unique or primary key constraint on columns "professional_id"
  """
  account_professional_id_key

  """
  unique or primary key constraint on columns "username"
  """
  account_username_unique
}

"""
columns and relationships of "account_info"
"""
type account_info {
  account_id: uuid
  email: citext
  firstname: String
  lastname: String
}

"""
aggregated selection of "account_info"
"""
type account_info_aggregate {
  aggregate: account_info_aggregate_fields
  nodes: [account_info!]!
}

"""
aggregate fields of "account_info"
"""
type account_info_aggregate_fields {
  count(columns: [account_info_select_column!], distinct: Boolean): Int!
  max: account_info_max_fields
  min: account_info_min_fields
}

"""
Boolean expression to filter rows from the table "account_info". All fields are combined with a logical 'AND'.
"""
input account_info_bool_exp {
  _and: [account_info_bool_exp!]
  _not: account_info_bool_exp
  _or: [account_info_bool_exp!]
  account_id: uuid_comparison_exp
  email: citext_comparison_exp
  firstname: String_comparison_exp
  lastname: String_comparison_exp
}

"""aggregate max on columns"""
type account_info_max_fields {
  account_id: uuid
  email: citext
  firstname: String
  lastname: String
}

"""aggregate min on columns"""
type account_info_min_fields {
  account_id: uuid
  email: citext
  firstname: String
  lastname: String
}

"""Ordering options when selecting data from "account_info"."""
input account_info_order_by {
  account_id: order_by
  email: order_by
  firstname: order_by
  lastname: order_by
}

"""
select columns of table "account_info"
"""
enum account_info_select_column {
  """column name"""
  account_id

  """column name"""
  email

  """column name"""
  firstname

  """column name"""
  lastname
}

"""
Streaming cursor of the table "account_info"
"""
input account_info_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: account_info_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input account_info_stream_cursor_value_input {
  account_id: uuid
  email: citext
  firstname: String
  lastname: String
}

"""
input type for inserting data into table "account"
"""
input account_insert_input {
  accessKey: String
  accessKeyDate: timestamptz
  admin: admin_cdb_obj_rel_insert_input
  adminId: uuid
  adminStructureId: uuid
  admin_structure: admin_structure_obj_rel_insert_input
  beneficiary: beneficiary_obj_rel_insert_input
  beneficiaryId: uuid
  confirmed: Boolean
  createdAt: timestamptz
  deletedAt: timestamptz
  id: uuid
  lastLogin: timestamptz
  manager: manager_obj_rel_insert_input
  managerId: uuid
  notebookActionsCreated: notebook_action_arr_rel_insert_input
  notebookEventsCreated: notebook_event_arr_rel_insert_input
  notebookFocusesCreated: notebook_focus_arr_rel_insert_input
  notebookTargetsCreated: notebook_target_arr_rel_insert_input
  notebooksCreated: notebook_member_arr_rel_insert_input
  notebooksWhereMember: notebook_member_arr_rel_insert_input
  onboardingDone: Boolean
  orientationManagerId: uuid
  orientation_manager: orientation_manager_obj_rel_insert_input
  professional: professional_obj_rel_insert_input
  professionalId: uuid
  role: role_obj_rel_insert_input
  type: role_enum
  updatedAt: timestamptz
  username: String
}

"""aggregate max on columns"""
type account_max_fields {
  accessKey: String
  accessKeyDate: timestamptz
  adminId: uuid
  adminStructureId: uuid
  beneficiaryId: uuid
  createdAt: timestamptz
  deletedAt: timestamptz
  id: uuid
  lastLogin: timestamptz
  managerId: uuid
  orientationManagerId: uuid
  professionalId: uuid
  updatedAt: timestamptz
  username: String
}

"""
order by max() on columns of table "account"
"""
input account_max_order_by {
  accessKey: order_by
  accessKeyDate: order_by
  adminId: order_by
  adminStructureId: order_by
  beneficiaryId: order_by
  createdAt: order_by
  deletedAt: order_by
  id: order_by
  lastLogin: order_by
  managerId: order_by
  orientationManagerId: order_by
  professionalId: order_by
  updatedAt: order_by
  username: order_by
}

"""aggregate min on columns"""
type account_min_fields {
  accessKey: String
  accessKeyDate: timestamptz
  adminId: uuid
  adminStructureId: uuid
  beneficiaryId: uuid
  createdAt: timestamptz
  deletedAt: timestamptz
  id: uuid
  lastLogin: timestamptz
  managerId: uuid
  orientationManagerId: uuid
  professionalId: uuid
  updatedAt: timestamptz
  username: String
}

"""
order by min() on columns of table "account"
"""
input account_min_order_by {
  accessKey: order_by
  accessKeyDate: order_by
  adminId: order_by
  adminStructureId: order_by
  beneficiaryId: order_by
  createdAt: order_by
  deletedAt: order_by
  id: order_by
  lastLogin: order_by
  managerId: order_by
  orientationManagerId: order_by
  professionalId: order_by
  updatedAt: order_by
  username: order_by
}

"""
response of any mutation on the table "account"
"""
type account_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [account!]!
}

"""
input type for inserting object relation for remote table "account"
"""
input account_obj_rel_insert_input {
  data: account_insert_input!

  """upsert condition"""
  on_conflict: account_on_conflict
}

"""
on_conflict condition type for table "account"
"""
input account_on_conflict {
  constraint: account_constraint!
  update_columns: [account_update_column!]! = []
  where: account_bool_exp
}

"""Ordering options when selecting data from "account"."""
input account_order_by {
  accessKey: order_by
  accessKeyDate: order_by
  admin: admin_cdb_order_by
  adminId: order_by
  adminStructureId: order_by
  admin_structure: admin_structure_order_by
  beneficiary: beneficiary_order_by
  beneficiaryId: order_by
  confirmed: order_by
  createdAt: order_by
  deletedAt: order_by
  id: order_by
  lastLogin: order_by
  manager: manager_order_by
  managerId: order_by
  notebookActionsCreated_aggregate: notebook_action_aggregate_order_by
  notebookEventsCreated_aggregate: notebook_event_aggregate_order_by
  notebookFocusesCreated_aggregate: notebook_focus_aggregate_order_by
  notebookTargetsCreated_aggregate: notebook_target_aggregate_order_by
  notebooksCreated_aggregate: notebook_member_aggregate_order_by
  notebooksWhereMember_aggregate: notebook_member_aggregate_order_by
  onboardingDone: order_by
  orientationManagerId: order_by
  orientation_manager: orientation_manager_order_by
  professional: professional_order_by
  professionalId: order_by
  role: role_order_by
  type: order_by
  updatedAt: order_by
  username: order_by
}

"""primary key columns input for table: account"""
input account_pk_columns_input {
  id: uuid!
}

"""
select columns of table "account"
"""
enum account_select_column {
  """column name"""
  accessKey

  """column name"""
  accessKeyDate

  """column name"""
  adminId

  """column name"""
  adminStructureId

  """column name"""
  beneficiaryId

  """column name"""
  confirmed

  """column name"""
  createdAt

  """column name"""
  deletedAt

  """column name"""
  id

  """column name"""
  lastLogin

  """column name"""
  managerId

  """column name"""
  onboardingDone

  """column name"""
  orientationManagerId

  """column name"""
  professionalId

  """column name"""
  type

  """column name"""
  updatedAt

  """column name"""
  username
}

"""
select "account_aggregate_bool_exp_bool_and_arguments_columns" columns of table "account"
"""
enum account_select_column_account_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  confirmed

  """column name"""
  onboardingDone
}

"""
select "account_aggregate_bool_exp_bool_or_arguments_columns" columns of table "account"
"""
enum account_select_column_account_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  confirmed

  """column name"""
  onboardingDone
}

"""
input type for updating data in table "account"
"""
input account_set_input {
  accessKey: String
  accessKeyDate: timestamptz
  adminId: uuid
  adminStructureId: uuid
  beneficiaryId: uuid
  confirmed: Boolean
  createdAt: timestamptz
  deletedAt: timestamptz
  id: uuid
  lastLogin: timestamptz
  managerId: uuid
  onboardingDone: Boolean
  orientationManagerId: uuid
  professionalId: uuid
  type: role_enum
  updatedAt: timestamptz
  username: String
}

"""
Streaming cursor of the table "account"
"""
input account_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: account_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input account_stream_cursor_value_input {
  accessKey: String
  accessKeyDate: timestamptz
  adminId: uuid
  adminStructureId: uuid
  beneficiaryId: uuid
  confirmed: Boolean
  createdAt: timestamptz
  deletedAt: timestamptz
  id: uuid
  lastLogin: timestamptz
  managerId: uuid
  onboardingDone: Boolean
  orientationManagerId: uuid
  professionalId: uuid
  type: role_enum
  updatedAt: timestamptz
  username: String
}

"""
update columns of table "account"
"""
enum account_update_column {
  """column name"""
  accessKey

  """column name"""
  accessKeyDate

  """column name"""
  adminId

  """column name"""
  adminStructureId

  """column name"""
  beneficiaryId

  """column name"""
  confirmed

  """column name"""
  createdAt

  """column name"""
  deletedAt

  """column name"""
  id

  """column name"""
  lastLogin

  """column name"""
  managerId

  """column name"""
  onboardingDone

  """column name"""
  orientationManagerId

  """column name"""
  professionalId

  """column name"""
  type

  """column name"""
  updatedAt

  """column name"""
  username
}

input account_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: account_set_input

  """filter the rows which have to be updated"""
  where: account_bool_exp!
}

"""available actions status"""
type action_status {
  """An array relationship"""
  notebook_actions(
    """distinct select on columns"""
    distinct_on: [notebook_action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_action_order_by!]

    """filter the rows returned"""
    where: notebook_action_bool_exp
  ): [notebook_action!]!

  """An aggregate relationship"""
  notebook_actions_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_action_order_by!]

    """filter the rows returned"""
    where: notebook_action_bool_exp
  ): notebook_action_aggregate!
  status: String!
}

"""
aggregated selection of "action_status"
"""
type action_status_aggregate {
  aggregate: action_status_aggregate_fields
  nodes: [action_status!]!
}

"""
aggregate fields of "action_status"
"""
type action_status_aggregate_fields {
  count(columns: [action_status_select_column!], distinct: Boolean): Int!
  max: action_status_max_fields
  min: action_status_min_fields
}

"""
Boolean expression to filter rows from the table "action_status". All fields are combined with a logical 'AND'.
"""
input action_status_bool_exp {
  _and: [action_status_bool_exp!]
  _not: action_status_bool_exp
  _or: [action_status_bool_exp!]
  notebook_actions: notebook_action_bool_exp
  notebook_actions_aggregate: notebook_action_aggregate_bool_exp
  status: String_comparison_exp
}

"""
unique or primary key constraints on table "action_status"
"""
enum action_status_constraint {
  """
  unique or primary key constraint on columns "status"
  """
  action_status_pkey
}

enum action_status_enum {
  abandonned
  canceled
  done
  in_progress
  planned
  standby
}

"""
Boolean expression to compare columns of type "action_status_enum". All fields are combined with logical 'AND'.
"""
input action_status_enum_comparison_exp {
  _eq: action_status_enum
  _in: [action_status_enum!]
  _is_null: Boolean
  _neq: action_status_enum
  _nin: [action_status_enum!]
}

"""
input type for inserting data into table "action_status"
"""
input action_status_insert_input {
  notebook_actions: notebook_action_arr_rel_insert_input
  status: String
}

"""aggregate max on columns"""
type action_status_max_fields {
  status: String
}

"""aggregate min on columns"""
type action_status_min_fields {
  status: String
}

"""
response of any mutation on the table "action_status"
"""
type action_status_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [action_status!]!
}

"""
on_conflict condition type for table "action_status"
"""
input action_status_on_conflict {
  constraint: action_status_constraint!
  update_columns: [action_status_update_column!]! = []
  where: action_status_bool_exp
}

"""Ordering options when selecting data from "action_status"."""
input action_status_order_by {
  notebook_actions_aggregate: notebook_action_aggregate_order_by
  status: order_by
}

"""primary key columns input for table: action_status"""
input action_status_pk_columns_input {
  status: String!
}

"""
select columns of table "action_status"
"""
enum action_status_select_column {
  """column name"""
  status
}

"""
input type for updating data in table "action_status"
"""
input action_status_set_input {
  status: String
}

"""
Streaming cursor of the table "action_status"
"""
input action_status_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: action_status_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input action_status_stream_cursor_value_input {
  status: String
}

"""
update columns of table "action_status"
"""
enum action_status_update_column {
  """column name"""
  status
}

input action_status_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: action_status_set_input

  """filter the rows which have to be updated"""
  where: action_status_bool_exp!
}

"""
columns and relationships of "admin_cdb"
"""
type admin_cdb {
  """An object relationship"""
  account: account
  createdAt: timestamptz!
  email: citext!
  firstname: String!
  id: uuid!
  lastname: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "admin_cdb"
"""
type admin_cdb_aggregate {
  aggregate: admin_cdb_aggregate_fields
  nodes: [admin_cdb!]!
}

"""
aggregate fields of "admin_cdb"
"""
type admin_cdb_aggregate_fields {
  count(columns: [admin_cdb_select_column!], distinct: Boolean): Int!
  max: admin_cdb_max_fields
  min: admin_cdb_min_fields
}

"""
Boolean expression to filter rows from the table "admin_cdb". All fields are combined with a logical 'AND'.
"""
input admin_cdb_bool_exp {
  _and: [admin_cdb_bool_exp!]
  _not: admin_cdb_bool_exp
  _or: [admin_cdb_bool_exp!]
  account: account_bool_exp
  createdAt: timestamptz_comparison_exp
  email: citext_comparison_exp
  firstname: String_comparison_exp
  id: uuid_comparison_exp
  lastname: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "admin_cdb"
"""
enum admin_cdb_constraint {
  """
  unique or primary key constraint on columns "email"
  """
  admin_email_unique

  """
  unique or primary key constraint on columns "id"
  """
  admin_pkey
}

"""
input type for inserting data into table "admin_cdb"
"""
input admin_cdb_insert_input {
  account: account_obj_rel_insert_input
  createdAt: timestamptz
  email: citext
  firstname: String
  id: uuid
  lastname: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type admin_cdb_max_fields {
  createdAt: timestamptz
  email: citext
  firstname: String
  id: uuid
  lastname: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type admin_cdb_min_fields {
  createdAt: timestamptz
  email: citext
  firstname: String
  id: uuid
  lastname: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "admin_cdb"
"""
type admin_cdb_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [admin_cdb!]!
}

"""
input type for inserting object relation for remote table "admin_cdb"
"""
input admin_cdb_obj_rel_insert_input {
  data: admin_cdb_insert_input!

  """upsert condition"""
  on_conflict: admin_cdb_on_conflict
}

"""
on_conflict condition type for table "admin_cdb"
"""
input admin_cdb_on_conflict {
  constraint: admin_cdb_constraint!
  update_columns: [admin_cdb_update_column!]! = []
  where: admin_cdb_bool_exp
}

"""Ordering options when selecting data from "admin_cdb"."""
input admin_cdb_order_by {
  account: account_order_by
  createdAt: order_by
  email: order_by
  firstname: order_by
  id: order_by
  lastname: order_by
  updatedAt: order_by
}

"""primary key columns input for table: admin_cdb"""
input admin_cdb_pk_columns_input {
  id: uuid!
}

"""
select columns of table "admin_cdb"
"""
enum admin_cdb_select_column {
  """column name"""
  createdAt

  """column name"""
  email

  """column name"""
  firstname

  """column name"""
  id

  """column name"""
  lastname

  """column name"""
  updatedAt
}

"""
input type for updating data in table "admin_cdb"
"""
input admin_cdb_set_input {
  createdAt: timestamptz
  email: citext
  firstname: String
  id: uuid
  lastname: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "admin_cdb"
"""
input admin_cdb_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: admin_cdb_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input admin_cdb_stream_cursor_value_input {
  createdAt: timestamptz
  email: citext
  firstname: String
  id: uuid
  lastname: String
  updatedAt: timestamptz
}

"""
update columns of table "admin_cdb"
"""
enum admin_cdb_update_column {
  """column name"""
  createdAt

  """column name"""
  email

  """column name"""
  firstname

  """column name"""
  id

  """column name"""
  lastname

  """column name"""
  updatedAt
}

input admin_cdb_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: admin_cdb_set_input

  """filter the rows which have to be updated"""
  where: admin_cdb_bool_exp!
}

"""Table of structure manager, handle pro and brsa attachment"""
type admin_structure {
  """An object relationship"""
  account: account
  createdAt: timestamptz!

  """An object relationship"""
  deployment: deployment!
  deploymentId: uuid!
  email: citext!
  firstname: String
  id: uuid!
  lastname: String
  phoneNumbers: String
  position: String

  """An array relationship"""
  structures(
    """distinct select on columns"""
    distinct_on: [admin_structure_structure_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admin_structure_structure_order_by!]

    """filter the rows returned"""
    where: admin_structure_structure_bool_exp
  ): [admin_structure_structure!]!

  """An aggregate relationship"""
  structures_aggregate(
    """distinct select on columns"""
    distinct_on: [admin_structure_structure_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admin_structure_structure_order_by!]

    """filter the rows returned"""
    where: admin_structure_structure_bool_exp
  ): admin_structure_structure_aggregate!
  updatedAt: timestamptz!
}

"""
aggregated selection of "admin_structure"
"""
type admin_structure_aggregate {
  aggregate: admin_structure_aggregate_fields
  nodes: [admin_structure!]!
}

input admin_structure_aggregate_bool_exp {
  count: admin_structure_aggregate_bool_exp_count
}

input admin_structure_aggregate_bool_exp_count {
  arguments: [admin_structure_select_column!]
  distinct: Boolean
  filter: admin_structure_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "admin_structure"
"""
type admin_structure_aggregate_fields {
  count(columns: [admin_structure_select_column!], distinct: Boolean): Int!
  max: admin_structure_max_fields
  min: admin_structure_min_fields
}

"""
order by aggregate values of table "admin_structure"
"""
input admin_structure_aggregate_order_by {
  count: order_by
  max: admin_structure_max_order_by
  min: admin_structure_min_order_by
}

"""
input type for inserting array relation for remote table "admin_structure"
"""
input admin_structure_arr_rel_insert_input {
  data: [admin_structure_insert_input!]!

  """upsert condition"""
  on_conflict: admin_structure_on_conflict
}

"""
Boolean expression to filter rows from the table "admin_structure". All fields are combined with a logical 'AND'.
"""
input admin_structure_bool_exp {
  _and: [admin_structure_bool_exp!]
  _not: admin_structure_bool_exp
  _or: [admin_structure_bool_exp!]
  account: account_bool_exp
  createdAt: timestamptz_comparison_exp
  deployment: deployment_bool_exp
  deploymentId: uuid_comparison_exp
  email: citext_comparison_exp
  firstname: String_comparison_exp
  id: uuid_comparison_exp
  lastname: String_comparison_exp
  phoneNumbers: String_comparison_exp
  position: String_comparison_exp
  structures: admin_structure_structure_bool_exp
  structures_aggregate: admin_structure_structure_aggregate_bool_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "admin_structure"
"""
enum admin_structure_constraint {
  """
  unique or primary key constraint on columns "email"
  """
  admin_structure_email_key

  """
  unique or primary key constraint on columns "id"
  """
  admin_structure_pkey
}

"""
input type for inserting data into table "admin_structure"
"""
input admin_structure_insert_input {
  account: account_obj_rel_insert_input
  createdAt: timestamptz
  deployment: deployment_obj_rel_insert_input
  deploymentId: uuid
  email: citext
  firstname: String
  id: uuid
  lastname: String
  phoneNumbers: String
  position: String
  structures: admin_structure_structure_arr_rel_insert_input
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type admin_structure_max_fields {
  createdAt: timestamptz
  deploymentId: uuid
  email: citext
  firstname: String
  id: uuid
  lastname: String
  phoneNumbers: String
  position: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "admin_structure"
"""
input admin_structure_max_order_by {
  createdAt: order_by
  deploymentId: order_by
  email: order_by
  firstname: order_by
  id: order_by
  lastname: order_by
  phoneNumbers: order_by
  position: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type admin_structure_min_fields {
  createdAt: timestamptz
  deploymentId: uuid
  email: citext
  firstname: String
  id: uuid
  lastname: String
  phoneNumbers: String
  position: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "admin_structure"
"""
input admin_structure_min_order_by {
  createdAt: order_by
  deploymentId: order_by
  email: order_by
  firstname: order_by
  id: order_by
  lastname: order_by
  phoneNumbers: order_by
  position: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "admin_structure"
"""
type admin_structure_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [admin_structure!]!
}

"""
input type for inserting object relation for remote table "admin_structure"
"""
input admin_structure_obj_rel_insert_input {
  data: admin_structure_insert_input!

  """upsert condition"""
  on_conflict: admin_structure_on_conflict
}

"""
on_conflict condition type for table "admin_structure"
"""
input admin_structure_on_conflict {
  constraint: admin_structure_constraint!
  update_columns: [admin_structure_update_column!]! = []
  where: admin_structure_bool_exp
}

"""Ordering options when selecting data from "admin_structure"."""
input admin_structure_order_by {
  account: account_order_by
  createdAt: order_by
  deployment: deployment_order_by
  deploymentId: order_by
  email: order_by
  firstname: order_by
  id: order_by
  lastname: order_by
  phoneNumbers: order_by
  position: order_by
  structures_aggregate: admin_structure_structure_aggregate_order_by
  updatedAt: order_by
}

"""primary key columns input for table: admin_structure"""
input admin_structure_pk_columns_input {
  id: uuid!
}

"""
select columns of table "admin_structure"
"""
enum admin_structure_select_column {
  """column name"""
  createdAt

  """column name"""
  deploymentId

  """column name"""
  email

  """column name"""
  firstname

  """column name"""
  id

  """column name"""
  lastname

  """column name"""
  phoneNumbers

  """column name"""
  position

  """column name"""
  updatedAt
}

"""
input type for updating data in table "admin_structure"
"""
input admin_structure_set_input {
  createdAt: timestamptz
  deploymentId: uuid
  email: citext
  firstname: String
  id: uuid
  lastname: String
  phoneNumbers: String
  position: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "admin_structure"
"""
input admin_structure_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: admin_structure_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input admin_structure_stream_cursor_value_input {
  createdAt: timestamptz
  deploymentId: uuid
  email: citext
  firstname: String
  id: uuid
  lastname: String
  phoneNumbers: String
  position: String
  updatedAt: timestamptz
}

"""associative table between admin_structure and structure (many ot many)"""
type admin_structure_structure {
  adminStructureId: uuid!

  """An object relationship"""
  admin_structure: admin_structure!
  createdAt: timestamptz!
  deletedAt: timestamptz
  id: uuid!

  """An object relationship"""
  structure: structure!
  structureId: uuid!
}

"""
aggregated selection of "admin_structure_structure"
"""
type admin_structure_structure_aggregate {
  aggregate: admin_structure_structure_aggregate_fields
  nodes: [admin_structure_structure!]!
}

input admin_structure_structure_aggregate_bool_exp {
  count: admin_structure_structure_aggregate_bool_exp_count
}

input admin_structure_structure_aggregate_bool_exp_count {
  arguments: [admin_structure_structure_select_column!]
  distinct: Boolean
  filter: admin_structure_structure_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "admin_structure_structure"
"""
type admin_structure_structure_aggregate_fields {
  count(columns: [admin_structure_structure_select_column!], distinct: Boolean): Int!
  max: admin_structure_structure_max_fields
  min: admin_structure_structure_min_fields
}

"""
order by aggregate values of table "admin_structure_structure"
"""
input admin_structure_structure_aggregate_order_by {
  count: order_by
  max: admin_structure_structure_max_order_by
  min: admin_structure_structure_min_order_by
}

"""
input type for inserting array relation for remote table "admin_structure_structure"
"""
input admin_structure_structure_arr_rel_insert_input {
  data: [admin_structure_structure_insert_input!]!

  """upsert condition"""
  on_conflict: admin_structure_structure_on_conflict
}

"""
Boolean expression to filter rows from the table "admin_structure_structure". All fields are combined with a logical 'AND'.
"""
input admin_structure_structure_bool_exp {
  _and: [admin_structure_structure_bool_exp!]
  _not: admin_structure_structure_bool_exp
  _or: [admin_structure_structure_bool_exp!]
  adminStructureId: uuid_comparison_exp
  admin_structure: admin_structure_bool_exp
  createdAt: timestamptz_comparison_exp
  deletedAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  structure: structure_bool_exp
  structureId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "admin_structure_structure"
"""
enum admin_structure_structure_constraint {
  """
  unique or primary key constraint on columns "admin_structure_id", "structure_id"
  """
  admin_structure_structure_admin_structure_id_structure_id_key

  """
  unique or primary key constraint on columns "id"
  """
  admin_structure_structure_pkey
}

"""
input type for inserting data into table "admin_structure_structure"
"""
input admin_structure_structure_insert_input {
  adminStructureId: uuid
  admin_structure: admin_structure_obj_rel_insert_input
  createdAt: timestamptz
  deletedAt: timestamptz
  id: uuid
  structure: structure_obj_rel_insert_input
  structureId: uuid
}

"""aggregate max on columns"""
type admin_structure_structure_max_fields {
  adminStructureId: uuid
  createdAt: timestamptz
  deletedAt: timestamptz
  id: uuid
  structureId: uuid
}

"""
order by max() on columns of table "admin_structure_structure"
"""
input admin_structure_structure_max_order_by {
  adminStructureId: order_by
  createdAt: order_by
  deletedAt: order_by
  id: order_by
  structureId: order_by
}

"""aggregate min on columns"""
type admin_structure_structure_min_fields {
  adminStructureId: uuid
  createdAt: timestamptz
  deletedAt: timestamptz
  id: uuid
  structureId: uuid
}

"""
order by min() on columns of table "admin_structure_structure"
"""
input admin_structure_structure_min_order_by {
  adminStructureId: order_by
  createdAt: order_by
  deletedAt: order_by
  id: order_by
  structureId: order_by
}

"""
response of any mutation on the table "admin_structure_structure"
"""
type admin_structure_structure_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [admin_structure_structure!]!
}

"""
on_conflict condition type for table "admin_structure_structure"
"""
input admin_structure_structure_on_conflict {
  constraint: admin_structure_structure_constraint!
  update_columns: [admin_structure_structure_update_column!]! = []
  where: admin_structure_structure_bool_exp
}

"""Ordering options when selecting data from "admin_structure_structure"."""
input admin_structure_structure_order_by {
  adminStructureId: order_by
  admin_structure: admin_structure_order_by
  createdAt: order_by
  deletedAt: order_by
  id: order_by
  structure: structure_order_by
  structureId: order_by
}

"""primary key columns input for table: admin_structure_structure"""
input admin_structure_structure_pk_columns_input {
  id: uuid!
}

"""
select columns of table "admin_structure_structure"
"""
enum admin_structure_structure_select_column {
  """column name"""
  adminStructureId

  """column name"""
  createdAt

  """column name"""
  deletedAt

  """column name"""
  id

  """column name"""
  structureId
}

"""
input type for updating data in table "admin_structure_structure"
"""
input admin_structure_structure_set_input {
  adminStructureId: uuid
  createdAt: timestamptz
  deletedAt: timestamptz
  id: uuid
  structureId: uuid
}

"""
Streaming cursor of the table "admin_structure_structure"
"""
input admin_structure_structure_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: admin_structure_structure_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input admin_structure_structure_stream_cursor_value_input {
  adminStructureId: uuid
  createdAt: timestamptz
  deletedAt: timestamptz
  id: uuid
  structureId: uuid
}

"""
update columns of table "admin_structure_structure"
"""
enum admin_structure_structure_update_column {
  """column name"""
  adminStructureId

  """column name"""
  createdAt

  """column name"""
  deletedAt

  """column name"""
  id

  """column name"""
  structureId
}

input admin_structure_structure_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: admin_structure_structure_set_input

  """filter the rows which have to be updated"""
  where: admin_structure_structure_bool_exp!
}

"""
update columns of table "admin_structure"
"""
enum admin_structure_update_column {
  """column name"""
  createdAt

  """column name"""
  deploymentId

  """column name"""
  email

  """column name"""
  firstname

  """column name"""
  id

  """column name"""
  lastname

  """column name"""
  phoneNumbers

  """column name"""
  position

  """column name"""
  updatedAt
}

input admin_structure_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: admin_structure_set_input

  """filter the rows which have to be updated"""
  where: admin_structure_bool_exp!
}

"""
columns and relationships of "beneficiary"
"""
type beneficiary {
  """An object relationship"""
  account: account
  address1: String
  address2: String
  cafNumber: String
  city: String
  createdAt: timestamptz!
  dateOfBirth: date!

  """An object relationship"""
  deployment: deployment!
  deploymentId: uuid!
  email: citext

  """An array relationship"""
  externalDataInfos(
    """distinct select on columns"""
    distinct_on: [external_data_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [external_data_info_order_by!]

    """filter the rows returned"""
    where: external_data_info_bool_exp
  ): [external_data_info!]!

  """An aggregate relationship"""
  externalDataInfos_aggregate(
    """distinct select on columns"""
    distinct_on: [external_data_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [external_data_info_order_by!]

    """filter the rows returned"""
    where: external_data_info_bool_exp
  ): external_data_info_aggregate!
  externalId: String
  firstname: String!
  id: uuid!
  isHomeless: Boolean
  lastname: String!
  mobileNumber: String
  nir: String

  """An object relationship"""
  notebook: notebook

  """An object relationship"""
  notebook_public_view: notebook_public_view

  """An array relationship"""
  orientationRequest(
    """distinct select on columns"""
    distinct_on: [orientation_request_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [orientation_request_order_by!]

    """filter the rows returned"""
    where: orientation_request_bool_exp
  ): [orientation_request!]!

  """An aggregate relationship"""
  orientationRequest_aggregate(
    """distinct select on columns"""
    distinct_on: [orientation_request_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [orientation_request_order_by!]

    """filter the rows returned"""
    where: orientation_request_bool_exp
  ): orientation_request_aggregate!
  peNumber: String
  peUniqueId: String
  placeOfBirth: String
  postalCode: String
  rightAre: Boolean!
  rightAss: Boolean!
  rightBonus: Boolean!
  rightRsa: String
  rsaClosureDate: date
  rsaClosureReason: rsa_closure_reason_enum
  rsaSuspensionReason: rsa_suspension_reason_enum

  """An array relationship"""
  structures(
    """distinct select on columns"""
    distinct_on: [beneficiary_structure_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [beneficiary_structure_order_by!]

    """filter the rows returned"""
    where: beneficiary_structure_bool_exp
  ): [beneficiary_structure!]!

  """An aggregate relationship"""
  structures_aggregate(
    """distinct select on columns"""
    distinct_on: [beneficiary_structure_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [beneficiary_structure_order_by!]

    """filter the rows returned"""
    where: beneficiary_structure_bool_exp
  ): beneficiary_structure_aggregate!
  subjectToRightAndDuty: Boolean
  updatedAt: timestamptz!
}

"""
aggregated selection of "beneficiary"
"""
type beneficiary_aggregate {
  aggregate: beneficiary_aggregate_fields
  nodes: [beneficiary!]!
}

input beneficiary_aggregate_bool_exp {
  bool_and: beneficiary_aggregate_bool_exp_bool_and
  bool_or: beneficiary_aggregate_bool_exp_bool_or
  count: beneficiary_aggregate_bool_exp_count
}

input beneficiary_aggregate_bool_exp_bool_and {
  arguments: beneficiary_select_column_beneficiary_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: beneficiary_bool_exp
  predicate: Boolean_comparison_exp!
}

input beneficiary_aggregate_bool_exp_bool_or {
  arguments: beneficiary_select_column_beneficiary_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: beneficiary_bool_exp
  predicate: Boolean_comparison_exp!
}

input beneficiary_aggregate_bool_exp_count {
  arguments: [beneficiary_select_column!]
  distinct: Boolean
  filter: beneficiary_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "beneficiary"
"""
type beneficiary_aggregate_fields {
  count(columns: [beneficiary_select_column!], distinct: Boolean): Int!
  max: beneficiary_max_fields
  min: beneficiary_min_fields
}

"""
order by aggregate values of table "beneficiary"
"""
input beneficiary_aggregate_order_by {
  count: order_by
  max: beneficiary_max_order_by
  min: beneficiary_min_order_by
}

"""
input type for inserting array relation for remote table "beneficiary"
"""
input beneficiary_arr_rel_insert_input {
  data: [beneficiary_insert_input!]!

  """upsert condition"""
  on_conflict: beneficiary_on_conflict
}

"""
Boolean expression to filter rows from the table "beneficiary". All fields are combined with a logical 'AND'.
"""
input beneficiary_bool_exp {
  _and: [beneficiary_bool_exp!]
  _not: beneficiary_bool_exp
  _or: [beneficiary_bool_exp!]
  account: account_bool_exp
  address1: String_comparison_exp
  address2: String_comparison_exp
  cafNumber: String_comparison_exp
  city: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  dateOfBirth: date_comparison_exp
  deployment: deployment_bool_exp
  deploymentId: uuid_comparison_exp
  email: citext_comparison_exp
  externalDataInfos: external_data_info_bool_exp
  externalDataInfos_aggregate: external_data_info_aggregate_bool_exp
  externalId: String_comparison_exp
  firstname: String_comparison_exp
  id: uuid_comparison_exp
  isHomeless: Boolean_comparison_exp
  lastname: String_comparison_exp
  mobileNumber: String_comparison_exp
  nir: String_comparison_exp
  notebook: notebook_bool_exp
  notebook_public_view: notebook_public_view_bool_exp
  orientationRequest: orientation_request_bool_exp
  orientationRequest_aggregate: orientation_request_aggregate_bool_exp
  peNumber: String_comparison_exp
  peUniqueId: String_comparison_exp
  placeOfBirth: String_comparison_exp
  postalCode: String_comparison_exp
  rightAre: Boolean_comparison_exp
  rightAss: Boolean_comparison_exp
  rightBonus: Boolean_comparison_exp
  rightRsa: String_comparison_exp
  rsaClosureDate: date_comparison_exp
  rsaClosureReason: rsa_closure_reason_enum_comparison_exp
  rsaSuspensionReason: rsa_suspension_reason_enum_comparison_exp
  structures: beneficiary_structure_bool_exp
  structures_aggregate: beneficiary_structure_aggregate_bool_exp
  subjectToRightAndDuty: Boolean_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "beneficiary"
"""
enum beneficiary_constraint {
  """
  unique or primary key constraint on columns "external_id", "deployment_id"
  """
  beneficiary_deployment_id_external_id_key

  """
  unique or primary key constraint on columns "nir"
  """
  beneficiary_nir_key

  """
  unique or primary key constraint on columns "id"
  """
  beneficiary_pkey

  """
  unique or primary key constraint on columns "deployment_id", "date_of_birth"
  """
  firstname_lastname_date_of_birth_unique_idx
}

"""
input type for inserting data into table "beneficiary"
"""
input beneficiary_insert_input {
  account: account_obj_rel_insert_input
  address1: String
  address2: String
  cafNumber: String
  city: String
  createdAt: timestamptz
  dateOfBirth: date
  deployment: deployment_obj_rel_insert_input
  deploymentId: uuid
  email: citext
  externalDataInfos: external_data_info_arr_rel_insert_input
  externalId: String
  firstname: String
  id: uuid
  isHomeless: Boolean
  lastname: String
  mobileNumber: String
  nir: String
  notebook: notebook_obj_rel_insert_input
  notebook_public_view: notebook_public_view_obj_rel_insert_input
  orientationRequest: orientation_request_arr_rel_insert_input
  peNumber: String
  peUniqueId: String
  placeOfBirth: String
  postalCode: String
  rightAre: Boolean
  rightAss: Boolean
  rightBonus: Boolean
  rightRsa: String
  rsaClosureDate: date
  rsaClosureReason: rsa_closure_reason_enum
  rsaSuspensionReason: rsa_suspension_reason_enum
  structures: beneficiary_structure_arr_rel_insert_input
  subjectToRightAndDuty: Boolean
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type beneficiary_max_fields {
  address1: String
  address2: String
  cafNumber: String
  city: String
  createdAt: timestamptz
  dateOfBirth: date
  deploymentId: uuid
  email: citext
  externalId: String
  firstname: String
  id: uuid
  lastname: String
  mobileNumber: String
  nir: String
  peNumber: String
  peUniqueId: String
  placeOfBirth: String
  postalCode: String
  rightRsa: String
  rsaClosureDate: date
  updatedAt: timestamptz
}

"""
order by max() on columns of table "beneficiary"
"""
input beneficiary_max_order_by {
  address1: order_by
  address2: order_by
  cafNumber: order_by
  city: order_by
  createdAt: order_by
  dateOfBirth: order_by
  deploymentId: order_by
  email: order_by
  externalId: order_by
  firstname: order_by
  id: order_by
  lastname: order_by
  mobileNumber: order_by
  nir: order_by
  peNumber: order_by
  peUniqueId: order_by
  placeOfBirth: order_by
  postalCode: order_by
  rightRsa: order_by
  rsaClosureDate: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type beneficiary_min_fields {
  address1: String
  address2: String
  cafNumber: String
  city: String
  createdAt: timestamptz
  dateOfBirth: date
  deploymentId: uuid
  email: citext
  externalId: String
  firstname: String
  id: uuid
  lastname: String
  mobileNumber: String
  nir: String
  peNumber: String
  peUniqueId: String
  placeOfBirth: String
  postalCode: String
  rightRsa: String
  rsaClosureDate: date
  updatedAt: timestamptz
}

"""
order by min() on columns of table "beneficiary"
"""
input beneficiary_min_order_by {
  address1: order_by
  address2: order_by
  cafNumber: order_by
  city: order_by
  createdAt: order_by
  dateOfBirth: order_by
  deploymentId: order_by
  email: order_by
  externalId: order_by
  firstname: order_by
  id: order_by
  lastname: order_by
  mobileNumber: order_by
  nir: order_by
  peNumber: order_by
  peUniqueId: order_by
  placeOfBirth: order_by
  postalCode: order_by
  rightRsa: order_by
  rsaClosureDate: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "beneficiary"
"""
type beneficiary_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [beneficiary!]!
}

"""
input type for inserting object relation for remote table "beneficiary"
"""
input beneficiary_obj_rel_insert_input {
  data: beneficiary_insert_input!

  """upsert condition"""
  on_conflict: beneficiary_on_conflict
}

"""
on_conflict condition type for table "beneficiary"
"""
input beneficiary_on_conflict {
  constraint: beneficiary_constraint!
  update_columns: [beneficiary_update_column!]! = []
  where: beneficiary_bool_exp
}

"""Ordering options when selecting data from "beneficiary"."""
input beneficiary_order_by {
  account: account_order_by
  address1: order_by
  address2: order_by
  cafNumber: order_by
  city: order_by
  createdAt: order_by
  dateOfBirth: order_by
  deployment: deployment_order_by
  deploymentId: order_by
  email: order_by
  externalDataInfos_aggregate: external_data_info_aggregate_order_by
  externalId: order_by
  firstname: order_by
  id: order_by
  isHomeless: order_by
  lastname: order_by
  mobileNumber: order_by
  nir: order_by
  notebook: notebook_order_by
  notebook_public_view: notebook_public_view_order_by
  orientationRequest_aggregate: orientation_request_aggregate_order_by
  peNumber: order_by
  peUniqueId: order_by
  placeOfBirth: order_by
  postalCode: order_by
  rightAre: order_by
  rightAss: order_by
  rightBonus: order_by
  rightRsa: order_by
  rsaClosureDate: order_by
  rsaClosureReason: order_by
  rsaSuspensionReason: order_by
  structures_aggregate: beneficiary_structure_aggregate_order_by
  subjectToRightAndDuty: order_by
  updatedAt: order_by
}

"""primary key columns input for table: beneficiary"""
input beneficiary_pk_columns_input {
  id: uuid!
}

"""
select columns of table "beneficiary"
"""
enum beneficiary_select_column {
  """column name"""
  address1

  """column name"""
  address2

  """column name"""
  cafNumber

  """column name"""
  city

  """column name"""
  createdAt

  """column name"""
  dateOfBirth

  """column name"""
  deploymentId

  """column name"""
  email

  """column name"""
  externalId

  """column name"""
  firstname

  """column name"""
  id

  """column name"""
  isHomeless

  """column name"""
  lastname

  """column name"""
  mobileNumber

  """column name"""
  nir

  """column name"""
  peNumber

  """column name"""
  peUniqueId

  """column name"""
  placeOfBirth

  """column name"""
  postalCode

  """column name"""
  rightAre

  """column name"""
  rightAss

  """column name"""
  rightBonus

  """column name"""
  rightRsa

  """column name"""
  rsaClosureDate

  """column name"""
  rsaClosureReason

  """column name"""
  rsaSuspensionReason

  """column name"""
  subjectToRightAndDuty

  """column name"""
  updatedAt
}

"""
select "beneficiary_aggregate_bool_exp_bool_and_arguments_columns" columns of table "beneficiary"
"""
enum beneficiary_select_column_beneficiary_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  isHomeless

  """column name"""
  rightAre

  """column name"""
  rightAss

  """column name"""
  rightBonus

  """column name"""
  subjectToRightAndDuty
}

"""
select "beneficiary_aggregate_bool_exp_bool_or_arguments_columns" columns of table "beneficiary"
"""
enum beneficiary_select_column_beneficiary_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  isHomeless

  """column name"""
  rightAre

  """column name"""
  rightAss

  """column name"""
  rightBonus

  """column name"""
  subjectToRightAndDuty
}

"""
input type for updating data in table "beneficiary"
"""
input beneficiary_set_input {
  address1: String
  address2: String
  cafNumber: String
  city: String
  createdAt: timestamptz
  dateOfBirth: date
  deploymentId: uuid
  email: citext
  externalId: String
  firstname: String
  id: uuid
  isHomeless: Boolean
  lastname: String
  mobileNumber: String
  nir: String
  peNumber: String
  peUniqueId: String
  placeOfBirth: String
  postalCode: String
  rightAre: Boolean
  rightAss: Boolean
  rightBonus: Boolean
  rightRsa: String
  rsaClosureDate: date
  rsaClosureReason: rsa_closure_reason_enum
  rsaSuspensionReason: rsa_suspension_reason_enum
  subjectToRightAndDuty: Boolean
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "beneficiary"
"""
input beneficiary_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: beneficiary_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input beneficiary_stream_cursor_value_input {
  address1: String
  address2: String
  cafNumber: String
  city: String
  createdAt: timestamptz
  dateOfBirth: date
  deploymentId: uuid
  email: citext
  externalId: String
  firstname: String
  id: uuid
  isHomeless: Boolean
  lastname: String
  mobileNumber: String
  nir: String
  peNumber: String
  peUniqueId: String
  placeOfBirth: String
  postalCode: String
  rightAre: Boolean
  rightAss: Boolean
  rightBonus: Boolean
  rightRsa: String
  rsaClosureDate: date
  rsaClosureReason: rsa_closure_reason_enum
  rsaSuspensionReason: rsa_suspension_reason_enum
  subjectToRightAndDuty: Boolean
  updatedAt: timestamptz
}

"""associative table between beneficiary and structure (many ot many)"""
type beneficiary_structure {
  """An object relationship"""
  beneficiary: beneficiary!
  beneficiaryId: uuid!
  createdAt: timestamptz!
  data(
    """JSON select path"""
    path: String
  ): jsonb!
  id: uuid!
  status: String!

  """An object relationship"""
  structure: structure!
  structureId: uuid!
  updatedAt: timestamptz!
}

"""
aggregated selection of "beneficiary_structure"
"""
type beneficiary_structure_aggregate {
  aggregate: beneficiary_structure_aggregate_fields
  nodes: [beneficiary_structure!]!
}

input beneficiary_structure_aggregate_bool_exp {
  count: beneficiary_structure_aggregate_bool_exp_count
}

input beneficiary_structure_aggregate_bool_exp_count {
  arguments: [beneficiary_structure_select_column!]
  distinct: Boolean
  filter: beneficiary_structure_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "beneficiary_structure"
"""
type beneficiary_structure_aggregate_fields {
  count(columns: [beneficiary_structure_select_column!], distinct: Boolean): Int!
  max: beneficiary_structure_max_fields
  min: beneficiary_structure_min_fields
}

"""
order by aggregate values of table "beneficiary_structure"
"""
input beneficiary_structure_aggregate_order_by {
  count: order_by
  max: beneficiary_structure_max_order_by
  min: beneficiary_structure_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input beneficiary_structure_append_input {
  data: jsonb
}

"""
input type for inserting array relation for remote table "beneficiary_structure"
"""
input beneficiary_structure_arr_rel_insert_input {
  data: [beneficiary_structure_insert_input!]!

  """upsert condition"""
  on_conflict: beneficiary_structure_on_conflict
}

"""
Boolean expression to filter rows from the table "beneficiary_structure". All fields are combined with a logical 'AND'.
"""
input beneficiary_structure_bool_exp {
  _and: [beneficiary_structure_bool_exp!]
  _not: beneficiary_structure_bool_exp
  _or: [beneficiary_structure_bool_exp!]
  beneficiary: beneficiary_bool_exp
  beneficiaryId: uuid_comparison_exp
  createdAt: timestamptz_comparison_exp
  data: jsonb_comparison_exp
  id: uuid_comparison_exp
  status: String_comparison_exp
  structure: structure_bool_exp
  structureId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "beneficiary_structure"
"""
enum beneficiary_structure_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  beneficiary_structure_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input beneficiary_structure_delete_at_path_input {
  data: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input beneficiary_structure_delete_elem_input {
  data: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input beneficiary_structure_delete_key_input {
  data: String
}

"""
input type for inserting data into table "beneficiary_structure"
"""
input beneficiary_structure_insert_input {
  beneficiary: beneficiary_obj_rel_insert_input
  beneficiaryId: uuid
  createdAt: timestamptz
  data: jsonb
  id: uuid
  status: String
  structure: structure_obj_rel_insert_input
  structureId: uuid
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type beneficiary_structure_max_fields {
  beneficiaryId: uuid
  createdAt: timestamptz
  id: uuid
  status: String
  structureId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "beneficiary_structure"
"""
input beneficiary_structure_max_order_by {
  beneficiaryId: order_by
  createdAt: order_by
  id: order_by
  status: order_by
  structureId: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type beneficiary_structure_min_fields {
  beneficiaryId: uuid
  createdAt: timestamptz
  id: uuid
  status: String
  structureId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "beneficiary_structure"
"""
input beneficiary_structure_min_order_by {
  beneficiaryId: order_by
  createdAt: order_by
  id: order_by
  status: order_by
  structureId: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "beneficiary_structure"
"""
type beneficiary_structure_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [beneficiary_structure!]!
}

"""
on_conflict condition type for table "beneficiary_structure"
"""
input beneficiary_structure_on_conflict {
  constraint: beneficiary_structure_constraint!
  update_columns: [beneficiary_structure_update_column!]! = []
  where: beneficiary_structure_bool_exp
}

"""Ordering options when selecting data from "beneficiary_structure"."""
input beneficiary_structure_order_by {
  beneficiary: beneficiary_order_by
  beneficiaryId: order_by
  createdAt: order_by
  data: order_by
  id: order_by
  status: order_by
  structure: structure_order_by
  structureId: order_by
  updatedAt: order_by
}

"""primary key columns input for table: beneficiary_structure"""
input beneficiary_structure_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input beneficiary_structure_prepend_input {
  data: jsonb
}

"""
select columns of table "beneficiary_structure"
"""
enum beneficiary_structure_select_column {
  """column name"""
  beneficiaryId

  """column name"""
  createdAt

  """column name"""
  data

  """column name"""
  id

  """column name"""
  status

  """column name"""
  structureId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "beneficiary_structure"
"""
input beneficiary_structure_set_input {
  beneficiaryId: uuid
  createdAt: timestamptz
  data: jsonb
  id: uuid
  status: String
  structureId: uuid
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "beneficiary_structure"
"""
input beneficiary_structure_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: beneficiary_structure_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input beneficiary_structure_stream_cursor_value_input {
  beneficiaryId: uuid
  createdAt: timestamptz
  data: jsonb
  id: uuid
  status: String
  structureId: uuid
  updatedAt: timestamptz
}

"""
update columns of table "beneficiary_structure"
"""
enum beneficiary_structure_update_column {
  """column name"""
  beneficiaryId

  """column name"""
  createdAt

  """column name"""
  data

  """column name"""
  id

  """column name"""
  status

  """column name"""
  structureId

  """column name"""
  updatedAt
}

input beneficiary_structure_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: beneficiary_structure_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: beneficiary_structure_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: beneficiary_structure_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: beneficiary_structure_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: beneficiary_structure_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: beneficiary_structure_set_input

  """filter the rows which have to be updated"""
  where: beneficiary_structure_bool_exp!
}

"""
update columns of table "beneficiary"
"""
enum beneficiary_update_column {
  """column name"""
  address1

  """column name"""
  address2

  """column name"""
  cafNumber

  """column name"""
  city

  """column name"""
  createdAt

  """column name"""
  dateOfBirth

  """column name"""
  deploymentId

  """column name"""
  email

  """column name"""
  externalId

  """column name"""
  firstname

  """column name"""
  id

  """column name"""
  isHomeless

  """column name"""
  lastname

  """column name"""
  mobileNumber

  """column name"""
  nir

  """column name"""
  peNumber

  """column name"""
  peUniqueId

  """column name"""
  placeOfBirth

  """column name"""
  postalCode

  """column name"""
  rightAre

  """column name"""
  rightAss

  """column name"""
  rightBonus

  """column name"""
  rightRsa

  """column name"""
  rsaClosureDate

  """column name"""
  rsaClosureReason

  """column name"""
  rsaSuspensionReason

  """column name"""
  subjectToRightAndDuty

  """column name"""
  updatedAt
}

input beneficiary_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: beneficiary_set_input

  """filter the rows which have to be updated"""
  where: beneficiary_bool_exp!
}

scalar citext

"""
Boolean expression to compare columns of type "citext". All fields are combined with logical 'AND'.
"""
input citext_comparison_exp {
  _eq: citext
  _gt: citext
  _gte: citext

  """does the column match the given case-insensitive pattern"""
  _ilike: citext
  _in: [citext!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: citext
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: citext
  _lt: citext
  _lte: citext
  _neq: citext

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: citext
  _nin: [citext!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: citext

  """does the column NOT match the given pattern"""
  _nlike: citext

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: citext

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: citext

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: citext

  """does the column match the given SQL regular expression"""
  _similar: citext
}

"""
columns and relationships of "contract_type"
"""
type contract_type {
  id: String!
  label: String!
}

"""
aggregated selection of "contract_type"
"""
type contract_type_aggregate {
  aggregate: contract_type_aggregate_fields
  nodes: [contract_type!]!
}

"""
aggregate fields of "contract_type"
"""
type contract_type_aggregate_fields {
  count(columns: [contract_type_select_column!], distinct: Boolean): Int!
  max: contract_type_max_fields
  min: contract_type_min_fields
}

"""
Boolean expression to filter rows from the table "contract_type". All fields are combined with a logical 'AND'.
"""
input contract_type_bool_exp {
  _and: [contract_type_bool_exp!]
  _not: contract_type_bool_exp
  _or: [contract_type_bool_exp!]
  id: String_comparison_exp
  label: String_comparison_exp
}

"""
unique or primary key constraints on table "contract_type"
"""
enum contract_type_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  contract_type_pkey
}

enum contract_type_enum {
  """Apprentissage"""
  apprentissage

  """CDD"""
  cdd

  """CDI"""
  cdi

  """Contrat de professionnalisation"""
  contrat_professionnalisation

  """Interim"""
  interim

  """Lib√©ral"""
  liberal

  """Portage salarial"""
  portage_salarial

  """Saisonnier"""
  saisonnier
}

"""
Boolean expression to compare columns of type "contract_type_enum". All fields are combined with logical 'AND'.
"""
input contract_type_enum_comparison_exp {
  _eq: contract_type_enum
  _in: [contract_type_enum!]
  _is_null: Boolean
  _neq: contract_type_enum
  _nin: [contract_type_enum!]
}

"""
input type for inserting data into table "contract_type"
"""
input contract_type_insert_input {
  id: String
  label: String
}

"""aggregate max on columns"""
type contract_type_max_fields {
  id: String
  label: String
}

"""aggregate min on columns"""
type contract_type_min_fields {
  id: String
  label: String
}

"""
response of any mutation on the table "contract_type"
"""
type contract_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [contract_type!]!
}

"""
input type for inserting object relation for remote table "contract_type"
"""
input contract_type_obj_rel_insert_input {
  data: contract_type_insert_input!

  """upsert condition"""
  on_conflict: contract_type_on_conflict
}

"""
on_conflict condition type for table "contract_type"
"""
input contract_type_on_conflict {
  constraint: contract_type_constraint!
  update_columns: [contract_type_update_column!]! = []
  where: contract_type_bool_exp
}

"""Ordering options when selecting data from "contract_type"."""
input contract_type_order_by {
  id: order_by
  label: order_by
}

"""primary key columns input for table: contract_type"""
input contract_type_pk_columns_input {
  id: String!
}

"""
select columns of table "contract_type"
"""
enum contract_type_select_column {
  """column name"""
  id

  """column name"""
  label
}

"""
input type for updating data in table "contract_type"
"""
input contract_type_set_input {
  id: String
  label: String
}

"""
Streaming cursor of the table "contract_type"
"""
input contract_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: contract_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input contract_type_stream_cursor_value_input {
  id: String
  label: String
}

"""
update columns of table "contract_type"
"""
enum contract_type_update_column {
  """column name"""
  id

  """column name"""
  label
}

input contract_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: contract_type_set_input

  """filter the rows which have to be updated"""
  where: contract_type_bool_exp!
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

scalar date

"""
Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'.
"""
input date_comparison_exp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _is_null: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

"""list of carnet-de-bord deployments"""
type deployment {
  """An array relationship"""
  admin_structures(
    """distinct select on columns"""
    distinct_on: [admin_structure_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admin_structure_order_by!]

    """filter the rows returned"""
    where: admin_structure_bool_exp
  ): [admin_structure!]!

  """An aggregate relationship"""
  admin_structures_aggregate(
    """distinct select on columns"""
    distinct_on: [admin_structure_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admin_structure_order_by!]

    """filter the rows returned"""
    where: admin_structure_bool_exp
  ): admin_structure_aggregate!

  """An array relationship"""
  beneficiaries(
    """distinct select on columns"""
    distinct_on: [beneficiary_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [beneficiary_order_by!]

    """filter the rows returned"""
    where: beneficiary_bool_exp
  ): [beneficiary!]!

  """An aggregate relationship"""
  beneficiaries_aggregate(
    """distinct select on columns"""
    distinct_on: [beneficiary_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [beneficiary_order_by!]

    """filter the rows returned"""
    where: beneficiary_bool_exp
  ): beneficiary_aggregate!
  config(
    """JSON select path"""
    path: String
  ): jsonb
  createdAt: timestamptz!
  departmentCode: String
  id: uuid!
  label: String!

  """An array relationship"""
  managers(
    """distinct select on columns"""
    distinct_on: [manager_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [manager_order_by!]

    """filter the rows returned"""
    where: manager_bool_exp
  ): [manager!]!

  """An aggregate relationship"""
  managers_aggregate(
    """distinct select on columns"""
    distinct_on: [manager_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [manager_order_by!]

    """filter the rows returned"""
    where: manager_bool_exp
  ): manager_aggregate!

  """An array relationship"""
  orientationSystems(
    """distinct select on columns"""
    distinct_on: [orientation_system_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [orientation_system_order_by!]

    """filter the rows returned"""
    where: orientation_system_bool_exp
  ): [orientation_system!]!

  """An aggregate relationship"""
  orientationSystems_aggregate(
    """distinct select on columns"""
    distinct_on: [orientation_system_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [orientation_system_order_by!]

    """filter the rows returned"""
    where: orientation_system_bool_exp
  ): orientation_system_aggregate!

  """An array relationship"""
  orientation_managers(
    """distinct select on columns"""
    distinct_on: [orientation_manager_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [orientation_manager_order_by!]

    """filter the rows returned"""
    where: orientation_manager_bool_exp
  ): [orientation_manager!]!

  """An aggregate relationship"""
  orientation_managers_aggregate(
    """distinct select on columns"""
    distinct_on: [orientation_manager_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [orientation_manager_order_by!]

    """filter the rows returned"""
    where: orientation_manager_bool_exp
  ): orientation_manager_aggregate!

  """An array relationship"""
  structures(
    """distinct select on columns"""
    distinct_on: [structure_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [structure_order_by!]

    """filter the rows returned"""
    where: structure_bool_exp
  ): [structure!]!

  """An aggregate relationship"""
  structures_aggregate(
    """distinct select on columns"""
    distinct_on: [structure_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [structure_order_by!]

    """filter the rows returned"""
    where: structure_bool_exp
  ): structure_aggregate!
  updatedAt: timestamptz!
}

"""
aggregated selection of "deployment"
"""
type deployment_aggregate {
  aggregate: deployment_aggregate_fields
  nodes: [deployment!]!
}

"""
aggregate fields of "deployment"
"""
type deployment_aggregate_fields {
  count(columns: [deployment_select_column!], distinct: Boolean): Int!
  max: deployment_max_fields
  min: deployment_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input deployment_append_input {
  config: jsonb
}

"""
Boolean expression to filter rows from the table "deployment". All fields are combined with a logical 'AND'.
"""
input deployment_bool_exp {
  _and: [deployment_bool_exp!]
  _not: deployment_bool_exp
  _or: [deployment_bool_exp!]
  admin_structures: admin_structure_bool_exp
  admin_structures_aggregate: admin_structure_aggregate_bool_exp
  beneficiaries: beneficiary_bool_exp
  beneficiaries_aggregate: beneficiary_aggregate_bool_exp
  config: jsonb_comparison_exp
  createdAt: timestamptz_comparison_exp
  departmentCode: String_comparison_exp
  id: uuid_comparison_exp
  label: String_comparison_exp
  managers: manager_bool_exp
  managers_aggregate: manager_aggregate_bool_exp
  orientationSystems: orientation_system_bool_exp
  orientationSystems_aggregate: orientation_system_aggregate_bool_exp
  orientation_managers: orientation_manager_bool_exp
  orientation_managers_aggregate: orientation_manager_aggregate_bool_exp
  structures: structure_bool_exp
  structures_aggregate: structure_aggregate_bool_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "deployment"
"""
enum deployment_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  deployment_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input deployment_delete_at_path_input {
  config: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input deployment_delete_elem_input {
  config: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input deployment_delete_key_input {
  config: String
}

"""
input type for inserting data into table "deployment"
"""
input deployment_insert_input {
  admin_structures: admin_structure_arr_rel_insert_input
  beneficiaries: beneficiary_arr_rel_insert_input
  config: jsonb
  createdAt: timestamptz
  departmentCode: String
  id: uuid
  label: String
  managers: manager_arr_rel_insert_input
  orientationSystems: orientation_system_arr_rel_insert_input
  orientation_managers: orientation_manager_arr_rel_insert_input
  structures: structure_arr_rel_insert_input
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type deployment_max_fields {
  createdAt: timestamptz
  departmentCode: String
  id: uuid
  label: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type deployment_min_fields {
  createdAt: timestamptz
  departmentCode: String
  id: uuid
  label: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "deployment"
"""
type deployment_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [deployment!]!
}

"""
input type for inserting object relation for remote table "deployment"
"""
input deployment_obj_rel_insert_input {
  data: deployment_insert_input!

  """upsert condition"""
  on_conflict: deployment_on_conflict
}

"""
on_conflict condition type for table "deployment"
"""
input deployment_on_conflict {
  constraint: deployment_constraint!
  update_columns: [deployment_update_column!]! = []
  where: deployment_bool_exp
}

"""Ordering options when selecting data from "deployment"."""
input deployment_order_by {
  admin_structures_aggregate: admin_structure_aggregate_order_by
  beneficiaries_aggregate: beneficiary_aggregate_order_by
  config: order_by
  createdAt: order_by
  departmentCode: order_by
  id: order_by
  label: order_by
  managers_aggregate: manager_aggregate_order_by
  orientationSystems_aggregate: orientation_system_aggregate_order_by
  orientation_managers_aggregate: orientation_manager_aggregate_order_by
  structures_aggregate: structure_aggregate_order_by
  updatedAt: order_by
}

"""primary key columns input for table: deployment"""
input deployment_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input deployment_prepend_input {
  config: jsonb
}

"""
select columns of table "deployment"
"""
enum deployment_select_column {
  """column name"""
  config

  """column name"""
  createdAt

  """column name"""
  departmentCode

  """column name"""
  id

  """column name"""
  label

  """column name"""
  updatedAt
}

"""
input type for updating data in table "deployment"
"""
input deployment_set_input {
  config: jsonb
  createdAt: timestamptz
  departmentCode: String
  id: uuid
  label: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "deployment"
"""
input deployment_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: deployment_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input deployment_stream_cursor_value_input {
  config: jsonb
  createdAt: timestamptz
  departmentCode: String
  id: uuid
  label: String
  updatedAt: timestamptz
}

"""
update columns of table "deployment"
"""
enum deployment_update_column {
  """column name"""
  config

  """column name"""
  createdAt

  """column name"""
  departmentCode

  """column name"""
  id

  """column name"""
  label

  """column name"""
  updatedAt
}

input deployment_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: deployment_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: deployment_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: deployment_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: deployment_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: deployment_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: deployment_set_input

  """filter the rows which have to be updated"""
  where: deployment_bool_exp!
}

"""
columns and relationships of "employment_type"
"""
type employment_type {
  id: String!
  label: String!
}

"""
aggregated selection of "employment_type"
"""
type employment_type_aggregate {
  aggregate: employment_type_aggregate_fields
  nodes: [employment_type!]!
}

"""
aggregate fields of "employment_type"
"""
type employment_type_aggregate_fields {
  count(columns: [employment_type_select_column!], distinct: Boolean): Int!
  max: employment_type_max_fields
  min: employment_type_min_fields
}

"""
Boolean expression to filter rows from the table "employment_type". All fields are combined with a logical 'AND'.
"""
input employment_type_bool_exp {
  _and: [employment_type_bool_exp!]
  _not: employment_type_bool_exp
  _or: [employment_type_bool_exp!]
  id: String_comparison_exp
  label: String_comparison_exp
}

"""
unique or primary key constraints on table "employment_type"
"""
enum employment_type_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  employment_type_pkey
}

enum employment_type_enum {
  """Temps plein"""
  full_time

  """Temps partiel"""
  part_time
}

"""
Boolean expression to compare columns of type "employment_type_enum". All fields are combined with logical 'AND'.
"""
input employment_type_enum_comparison_exp {
  _eq: employment_type_enum
  _in: [employment_type_enum!]
  _is_null: Boolean
  _neq: employment_type_enum
  _nin: [employment_type_enum!]
}

"""
input type for inserting data into table "employment_type"
"""
input employment_type_insert_input {
  id: String
  label: String
}

"""aggregate max on columns"""
type employment_type_max_fields {
  id: String
  label: String
}

"""aggregate min on columns"""
type employment_type_min_fields {
  id: String
  label: String
}

"""
response of any mutation on the table "employment_type"
"""
type employment_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [employment_type!]!
}

"""
input type for inserting object relation for remote table "employment_type"
"""
input employment_type_obj_rel_insert_input {
  data: employment_type_insert_input!

  """upsert condition"""
  on_conflict: employment_type_on_conflict
}

"""
on_conflict condition type for table "employment_type"
"""
input employment_type_on_conflict {
  constraint: employment_type_constraint!
  update_columns: [employment_type_update_column!]! = []
  where: employment_type_bool_exp
}

"""Ordering options when selecting data from "employment_type"."""
input employment_type_order_by {
  id: order_by
  label: order_by
}

"""primary key columns input for table: employment_type"""
input employment_type_pk_columns_input {
  id: String!
}

"""
select columns of table "employment_type"
"""
enum employment_type_select_column {
  """column name"""
  id

  """column name"""
  label
}

"""
input type for updating data in table "employment_type"
"""
input employment_type_set_input {
  id: String
  label: String
}

"""
Streaming cursor of the table "employment_type"
"""
input employment_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: employment_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input employment_type_stream_cursor_value_input {
  id: String
  label: String
}

"""
update columns of table "employment_type"
"""
enum employment_type_update_column {
  """column name"""
  id

  """column name"""
  label
}

input employment_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: employment_type_set_input

  """filter the rows which have to be updated"""
  where: employment_type_bool_exp!
}

"""
columns and relationships of "external_data"
"""
type external_data {
  created_at: timestamptz
  data(
    """JSON select path"""
    path: String
  ): jsonb!

  """An object relationship"""
  externalDataInfo: external_data_info

  """An object relationship"""
  external_source: external_source!
  hash: String!
  id: uuid!
  source: external_source_enum!
  updated_at: timestamptz
}

"""
aggregated selection of "external_data"
"""
type external_data_aggregate {
  aggregate: external_data_aggregate_fields
  nodes: [external_data!]!
}

input external_data_aggregate_bool_exp {
  count: external_data_aggregate_bool_exp_count
}

input external_data_aggregate_bool_exp_count {
  arguments: [external_data_select_column!]
  distinct: Boolean
  filter: external_data_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "external_data"
"""
type external_data_aggregate_fields {
  count(columns: [external_data_select_column!], distinct: Boolean): Int!
  max: external_data_max_fields
  min: external_data_min_fields
}

"""
order by aggregate values of table "external_data"
"""
input external_data_aggregate_order_by {
  count: order_by
  max: external_data_max_order_by
  min: external_data_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input external_data_append_input {
  data: jsonb
}

"""
input type for inserting array relation for remote table "external_data"
"""
input external_data_arr_rel_insert_input {
  data: [external_data_insert_input!]!

  """upsert condition"""
  on_conflict: external_data_on_conflict
}

"""
Boolean expression to filter rows from the table "external_data". All fields are combined with a logical 'AND'.
"""
input external_data_bool_exp {
  _and: [external_data_bool_exp!]
  _not: external_data_bool_exp
  _or: [external_data_bool_exp!]
  created_at: timestamptz_comparison_exp
  data: jsonb_comparison_exp
  externalDataInfo: external_data_info_bool_exp
  external_source: external_source_bool_exp
  hash: String_comparison_exp
  id: uuid_comparison_exp
  source: external_source_enum_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "external_data"
"""
enum external_data_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  external_data_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input external_data_delete_at_path_input {
  data: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input external_data_delete_elem_input {
  data: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input external_data_delete_key_input {
  data: String
}

"""
columns and relationships of "external_data_info"
"""
type external_data_info {
  """An object relationship"""
  beneficiary: beneficiary
  beneficiary_id: uuid
  created_at: timestamptz!

  """An object relationship"""
  externalData: external_data!
  external_data_id: uuid!
  professional_id: uuid
  updated_at: timestamptz!
}

"""
aggregated selection of "external_data_info"
"""
type external_data_info_aggregate {
  aggregate: external_data_info_aggregate_fields
  nodes: [external_data_info!]!
}

input external_data_info_aggregate_bool_exp {
  count: external_data_info_aggregate_bool_exp_count
}

input external_data_info_aggregate_bool_exp_count {
  arguments: [external_data_info_select_column!]
  distinct: Boolean
  filter: external_data_info_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "external_data_info"
"""
type external_data_info_aggregate_fields {
  count(columns: [external_data_info_select_column!], distinct: Boolean): Int!
  max: external_data_info_max_fields
  min: external_data_info_min_fields
}

"""
order by aggregate values of table "external_data_info"
"""
input external_data_info_aggregate_order_by {
  count: order_by
  max: external_data_info_max_order_by
  min: external_data_info_min_order_by
}

"""
input type for inserting array relation for remote table "external_data_info"
"""
input external_data_info_arr_rel_insert_input {
  data: [external_data_info_insert_input!]!

  """upsert condition"""
  on_conflict: external_data_info_on_conflict
}

"""
Boolean expression to filter rows from the table "external_data_info". All fields are combined with a logical 'AND'.
"""
input external_data_info_bool_exp {
  _and: [external_data_info_bool_exp!]
  _not: external_data_info_bool_exp
  _or: [external_data_info_bool_exp!]
  beneficiary: beneficiary_bool_exp
  beneficiary_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  externalData: external_data_bool_exp
  external_data_id: uuid_comparison_exp
  professional_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "external_data_info"
"""
enum external_data_info_constraint {
  """
  unique or primary key constraint on columns "external_data_id"
  """
  external_data_info_pkey
}

"""
input type for inserting data into table "external_data_info"
"""
input external_data_info_insert_input {
  beneficiary: beneficiary_obj_rel_insert_input
  beneficiary_id: uuid
  created_at: timestamptz
  externalData: external_data_obj_rel_insert_input
  external_data_id: uuid
  professional_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type external_data_info_max_fields {
  beneficiary_id: uuid
  created_at: timestamptz
  external_data_id: uuid
  professional_id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "external_data_info"
"""
input external_data_info_max_order_by {
  beneficiary_id: order_by
  created_at: order_by
  external_data_id: order_by
  professional_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type external_data_info_min_fields {
  beneficiary_id: uuid
  created_at: timestamptz
  external_data_id: uuid
  professional_id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "external_data_info"
"""
input external_data_info_min_order_by {
  beneficiary_id: order_by
  created_at: order_by
  external_data_id: order_by
  professional_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "external_data_info"
"""
type external_data_info_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [external_data_info!]!
}

"""
input type for inserting object relation for remote table "external_data_info"
"""
input external_data_info_obj_rel_insert_input {
  data: external_data_info_insert_input!

  """upsert condition"""
  on_conflict: external_data_info_on_conflict
}

"""
on_conflict condition type for table "external_data_info"
"""
input external_data_info_on_conflict {
  constraint: external_data_info_constraint!
  update_columns: [external_data_info_update_column!]! = []
  where: external_data_info_bool_exp
}

"""Ordering options when selecting data from "external_data_info"."""
input external_data_info_order_by {
  beneficiary: beneficiary_order_by
  beneficiary_id: order_by
  created_at: order_by
  externalData: external_data_order_by
  external_data_id: order_by
  professional_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: external_data_info"""
input external_data_info_pk_columns_input {
  external_data_id: uuid!
}

"""
select columns of table "external_data_info"
"""
enum external_data_info_select_column {
  """column name"""
  beneficiary_id

  """column name"""
  created_at

  """column name"""
  external_data_id

  """column name"""
  professional_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "external_data_info"
"""
input external_data_info_set_input {
  beneficiary_id: uuid
  created_at: timestamptz
  external_data_id: uuid
  professional_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "external_data_info"
"""
input external_data_info_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: external_data_info_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input external_data_info_stream_cursor_value_input {
  beneficiary_id: uuid
  created_at: timestamptz
  external_data_id: uuid
  professional_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "external_data_info"
"""
enum external_data_info_update_column {
  """column name"""
  beneficiary_id

  """column name"""
  created_at

  """column name"""
  external_data_id

  """column name"""
  professional_id

  """column name"""
  updated_at
}

input external_data_info_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: external_data_info_set_input

  """filter the rows which have to be updated"""
  where: external_data_info_bool_exp!
}

"""
input type for inserting data into table "external_data"
"""
input external_data_insert_input {
  created_at: timestamptz
  data: jsonb
  externalDataInfo: external_data_info_obj_rel_insert_input
  external_source: external_source_obj_rel_insert_input
  hash: String
  id: uuid
  source: external_source_enum
  updated_at: timestamptz
}

"""aggregate max on columns"""
type external_data_max_fields {
  created_at: timestamptz
  hash: String
  id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "external_data"
"""
input external_data_max_order_by {
  created_at: order_by
  hash: order_by
  id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type external_data_min_fields {
  created_at: timestamptz
  hash: String
  id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "external_data"
"""
input external_data_min_order_by {
  created_at: order_by
  hash: order_by
  id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "external_data"
"""
type external_data_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [external_data!]!
}

"""
input type for inserting object relation for remote table "external_data"
"""
input external_data_obj_rel_insert_input {
  data: external_data_insert_input!

  """upsert condition"""
  on_conflict: external_data_on_conflict
}

"""
on_conflict condition type for table "external_data"
"""
input external_data_on_conflict {
  constraint: external_data_constraint!
  update_columns: [external_data_update_column!]! = []
  where: external_data_bool_exp
}

"""Ordering options when selecting data from "external_data"."""
input external_data_order_by {
  created_at: order_by
  data: order_by
  externalDataInfo: external_data_info_order_by
  external_source: external_source_order_by
  hash: order_by
  id: order_by
  source: order_by
  updated_at: order_by
}

"""primary key columns input for table: external_data"""
input external_data_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input external_data_prepend_input {
  data: jsonb
}

"""
select columns of table "external_data"
"""
enum external_data_select_column {
  """column name"""
  created_at

  """column name"""
  data

  """column name"""
  hash

  """column name"""
  id

  """column name"""
  source

  """column name"""
  updated_at
}

"""
input type for updating data in table "external_data"
"""
input external_data_set_input {
  created_at: timestamptz
  data: jsonb
  hash: String
  id: uuid
  source: external_source_enum
  updated_at: timestamptz
}

"""
Streaming cursor of the table "external_data"
"""
input external_data_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: external_data_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input external_data_stream_cursor_value_input {
  created_at: timestamptz
  data: jsonb
  hash: String
  id: uuid
  source: external_source_enum
  updated_at: timestamptz
}

"""
update columns of table "external_data"
"""
enum external_data_update_column {
  """column name"""
  created_at

  """column name"""
  data

  """column name"""
  hash

  """column name"""
  id

  """column name"""
  source

  """column name"""
  updated_at
}

input external_data_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: external_data_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: external_data_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: external_data_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: external_data_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: external_data_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: external_data_set_input

  """filter the rows which have to be updated"""
  where: external_data_bool_exp!
}

"""
columns and relationships of "external_source"
"""
type external_source {
  comment: String!

  """An array relationship"""
  external_data(
    """distinct select on columns"""
    distinct_on: [external_data_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [external_data_order_by!]

    """filter the rows returned"""
    where: external_data_bool_exp
  ): [external_data!]!

  """An aggregate relationship"""
  external_data_aggregate(
    """distinct select on columns"""
    distinct_on: [external_data_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [external_data_order_by!]

    """filter the rows returned"""
    where: external_data_bool_exp
  ): external_data_aggregate!
  value: String!
}

"""
aggregated selection of "external_source"
"""
type external_source_aggregate {
  aggregate: external_source_aggregate_fields
  nodes: [external_source!]!
}

"""
aggregate fields of "external_source"
"""
type external_source_aggregate_fields {
  count(columns: [external_source_select_column!], distinct: Boolean): Int!
  max: external_source_max_fields
  min: external_source_min_fields
}

"""
Boolean expression to filter rows from the table "external_source". All fields are combined with a logical 'AND'.
"""
input external_source_bool_exp {
  _and: [external_source_bool_exp!]
  _not: external_source_bool_exp
  _or: [external_source_bool_exp!]
  comment: String_comparison_exp
  external_data: external_data_bool_exp
  external_data_aggregate: external_data_aggregate_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "external_source"
"""
enum external_source_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  external_source_pkey
}

enum external_source_enum {
  """Flux caf / msa"""
  cafmsa

  """P√¥le Emploi"""
  pe

  """P√¥le Emploi API"""
  peio
}

"""
Boolean expression to compare columns of type "external_source_enum". All fields are combined with logical 'AND'.
"""
input external_source_enum_comparison_exp {
  _eq: external_source_enum
  _in: [external_source_enum!]
  _is_null: Boolean
  _neq: external_source_enum
  _nin: [external_source_enum!]
}

"""
input type for inserting data into table "external_source"
"""
input external_source_insert_input {
  comment: String
  external_data: external_data_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type external_source_max_fields {
  comment: String
  value: String
}

"""aggregate min on columns"""
type external_source_min_fields {
  comment: String
  value: String
}

"""
response of any mutation on the table "external_source"
"""
type external_source_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [external_source!]!
}

"""
input type for inserting object relation for remote table "external_source"
"""
input external_source_obj_rel_insert_input {
  data: external_source_insert_input!

  """upsert condition"""
  on_conflict: external_source_on_conflict
}

"""
on_conflict condition type for table "external_source"
"""
input external_source_on_conflict {
  constraint: external_source_constraint!
  update_columns: [external_source_update_column!]! = []
  where: external_source_bool_exp
}

"""Ordering options when selecting data from "external_source"."""
input external_source_order_by {
  comment: order_by
  external_data_aggregate: external_data_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: external_source"""
input external_source_pk_columns_input {
  value: String!
}

"""
select columns of table "external_source"
"""
enum external_source_select_column {
  """column name"""
  comment

  """column name"""
  value
}

"""
input type for updating data in table "external_source"
"""
input external_source_set_input {
  comment: String
  value: String
}

"""
Streaming cursor of the table "external_source"
"""
input external_source_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: external_source_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input external_source_stream_cursor_value_input {
  comment: String
  value: String
}

"""
update columns of table "external_source"
"""
enum external_source_update_column {
  """column name"""
  comment

  """column name"""
  value
}

input external_source_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: external_source_set_input

  """filter the rows which have to be updated"""
  where: external_source_bool_exp!
}

input get_beneficiaries_from_nir_args {
  search_nir: String
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""A manager handle structure and professional for a given deployment"""
type manager {
  """An object relationship"""
  account: account
  createdAt: timestamptz!

  """An object relationship"""
  deployment: deployment!
  deploymentId: uuid!
  email: citext!
  firstname: String
  id: uuid!
  lastname: String
  updatedAt: timestamptz!
}

"""
aggregated selection of "manager"
"""
type manager_aggregate {
  aggregate: manager_aggregate_fields
  nodes: [manager!]!
}

input manager_aggregate_bool_exp {
  count: manager_aggregate_bool_exp_count
}

input manager_aggregate_bool_exp_count {
  arguments: [manager_select_column!]
  distinct: Boolean
  filter: manager_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "manager"
"""
type manager_aggregate_fields {
  count(columns: [manager_select_column!], distinct: Boolean): Int!
  max: manager_max_fields
  min: manager_min_fields
}

"""
order by aggregate values of table "manager"
"""
input manager_aggregate_order_by {
  count: order_by
  max: manager_max_order_by
  min: manager_min_order_by
}

"""
input type for inserting array relation for remote table "manager"
"""
input manager_arr_rel_insert_input {
  data: [manager_insert_input!]!

  """upsert condition"""
  on_conflict: manager_on_conflict
}

"""
Boolean expression to filter rows from the table "manager". All fields are combined with a logical 'AND'.
"""
input manager_bool_exp {
  _and: [manager_bool_exp!]
  _not: manager_bool_exp
  _or: [manager_bool_exp!]
  account: account_bool_exp
  createdAt: timestamptz_comparison_exp
  deployment: deployment_bool_exp
  deploymentId: uuid_comparison_exp
  email: citext_comparison_exp
  firstname: String_comparison_exp
  id: uuid_comparison_exp
  lastname: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "manager"
"""
enum manager_constraint {
  """
  unique or primary key constraint on columns "deployment_id", "email"
  """
  manager_email_deployment_id_key

  """
  unique or primary key constraint on columns "id"
  """
  manager_pkey
}

"""
input type for inserting data into table "manager"
"""
input manager_insert_input {
  account: account_obj_rel_insert_input
  createdAt: timestamptz
  deployment: deployment_obj_rel_insert_input
  deploymentId: uuid
  email: citext
  firstname: String
  id: uuid
  lastname: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type manager_max_fields {
  createdAt: timestamptz
  deploymentId: uuid
  email: citext
  firstname: String
  id: uuid
  lastname: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "manager"
"""
input manager_max_order_by {
  createdAt: order_by
  deploymentId: order_by
  email: order_by
  firstname: order_by
  id: order_by
  lastname: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type manager_min_fields {
  createdAt: timestamptz
  deploymentId: uuid
  email: citext
  firstname: String
  id: uuid
  lastname: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "manager"
"""
input manager_min_order_by {
  createdAt: order_by
  deploymentId: order_by
  email: order_by
  firstname: order_by
  id: order_by
  lastname: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "manager"
"""
type manager_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [manager!]!
}

"""
input type for inserting object relation for remote table "manager"
"""
input manager_obj_rel_insert_input {
  data: manager_insert_input!

  """upsert condition"""
  on_conflict: manager_on_conflict
}

"""
on_conflict condition type for table "manager"
"""
input manager_on_conflict {
  constraint: manager_constraint!
  update_columns: [manager_update_column!]! = []
  where: manager_bool_exp
}

"""Ordering options when selecting data from "manager"."""
input manager_order_by {
  account: account_order_by
  createdAt: order_by
  deployment: deployment_order_by
  deploymentId: order_by
  email: order_by
  firstname: order_by
  id: order_by
  lastname: order_by
  updatedAt: order_by
}

"""primary key columns input for table: manager"""
input manager_pk_columns_input {
  id: uuid!
}

"""
select columns of table "manager"
"""
enum manager_select_column {
  """column name"""
  createdAt

  """column name"""
  deploymentId

  """column name"""
  email

  """column name"""
  firstname

  """column name"""
  id

  """column name"""
  lastname

  """column name"""
  updatedAt
}

"""
input type for updating data in table "manager"
"""
input manager_set_input {
  createdAt: timestamptz
  deploymentId: uuid
  email: citext
  firstname: String
  id: uuid
  lastname: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "manager"
"""
input manager_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: manager_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input manager_stream_cursor_value_input {
  createdAt: timestamptz
  deploymentId: uuid
  email: citext
  firstname: String
  id: uuid
  lastname: String
  updatedAt: timestamptz
}

"""
update columns of table "manager"
"""
enum manager_update_column {
  """column name"""
  createdAt

  """column name"""
  deploymentId

  """column name"""
  email

  """column name"""
  firstname

  """column name"""
  id

  """column name"""
  lastname

  """column name"""
  updatedAt
}

input manager_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: manager_set_input

  """filter the rows which have to be updated"""
  where: manager_bool_exp!
}

"""mutation root"""
type mutation_root {
  """Notebook creation"""
  create_notebook(notebook: CreateNotebookInput!, source: String!): CreateNotebookOutput

  """create_notebook_focus"""
  create_notebook_focus(notebookId: uuid!, theme: String!): CreateNotebookFocusOutput

  """create a notebook target"""
  create_notebook_target(focusId: uuid!, linkedTo: String!, target: String!): CreateNotebookTargetOutput

  """Create NPS Rating"""
  create_nps_rating(score: Int!): NPSRatingOutput

  """
  delete data from the table: "account"
  """
  delete_account(
    """filter the rows which have to be deleted"""
    where: account_bool_exp!
  ): account_mutation_response

  """
  delete single row from the table: "account"
  """
  delete_account_by_pk(id: uuid!): account

  """
  delete data from the table: "action_status"
  """
  delete_action_status(
    """filter the rows which have to be deleted"""
    where: action_status_bool_exp!
  ): action_status_mutation_response

  """
  delete single row from the table: "action_status"
  """
  delete_action_status_by_pk(status: String!): action_status

  """
  delete data from the table: "admin_cdb"
  """
  delete_admin_cdb(
    """filter the rows which have to be deleted"""
    where: admin_cdb_bool_exp!
  ): admin_cdb_mutation_response

  """
  delete single row from the table: "admin_cdb"
  """
  delete_admin_cdb_by_pk(id: uuid!): admin_cdb

  """
  delete data from the table: "admin_structure"
  """
  delete_admin_structure(
    """filter the rows which have to be deleted"""
    where: admin_structure_bool_exp!
  ): admin_structure_mutation_response

  """
  delete single row from the table: "admin_structure"
  """
  delete_admin_structure_by_pk(id: uuid!): admin_structure

  """
  delete data from the table: "admin_structure_structure"
  """
  delete_admin_structure_structure(
    """filter the rows which have to be deleted"""
    where: admin_structure_structure_bool_exp!
  ): admin_structure_structure_mutation_response

  """
  delete single row from the table: "admin_structure_structure"
  """
  delete_admin_structure_structure_by_pk(id: uuid!): admin_structure_structure

  """
  delete data from the table: "beneficiary"
  """
  delete_beneficiary(
    """filter the rows which have to be deleted"""
    where: beneficiary_bool_exp!
  ): beneficiary_mutation_response

  """
  delete single row from the table: "beneficiary"
  """
  delete_beneficiary_by_pk(id: uuid!): beneficiary

  """
  delete data from the table: "beneficiary_structure"
  """
  delete_beneficiary_structure(
    """filter the rows which have to be deleted"""
    where: beneficiary_structure_bool_exp!
  ): beneficiary_structure_mutation_response

  """
  delete single row from the table: "beneficiary_structure"
  """
  delete_beneficiary_structure_by_pk(id: uuid!): beneficiary_structure

  """
  delete data from the table: "contract_type"
  """
  delete_contract_type(
    """filter the rows which have to be deleted"""
    where: contract_type_bool_exp!
  ): contract_type_mutation_response

  """
  delete single row from the table: "contract_type"
  """
  delete_contract_type_by_pk(id: String!): contract_type

  """
  delete data from the table: "deployment"
  """
  delete_deployment(
    """filter the rows which have to be deleted"""
    where: deployment_bool_exp!
  ): deployment_mutation_response

  """
  delete single row from the table: "deployment"
  """
  delete_deployment_by_pk(id: uuid!): deployment

  """
  delete data from the table: "employment_type"
  """
  delete_employment_type(
    """filter the rows which have to be deleted"""
    where: employment_type_bool_exp!
  ): employment_type_mutation_response

  """
  delete single row from the table: "employment_type"
  """
  delete_employment_type_by_pk(id: String!): employment_type

  """
  delete data from the table: "external_data"
  """
  delete_external_data(
    """filter the rows which have to be deleted"""
    where: external_data_bool_exp!
  ): external_data_mutation_response

  """
  delete single row from the table: "external_data"
  """
  delete_external_data_by_pk(id: uuid!): external_data

  """
  delete data from the table: "external_data_info"
  """
  delete_external_data_info(
    """filter the rows which have to be deleted"""
    where: external_data_info_bool_exp!
  ): external_data_info_mutation_response

  """
  delete single row from the table: "external_data_info"
  """
  delete_external_data_info_by_pk(external_data_id: uuid!): external_data_info

  """
  delete data from the table: "external_source"
  """
  delete_external_source(
    """filter the rows which have to be deleted"""
    where: external_source_bool_exp!
  ): external_source_mutation_response

  """
  delete single row from the table: "external_source"
  """
  delete_external_source_by_pk(value: String!): external_source

  """
  delete data from the table: "manager"
  """
  delete_manager(
    """filter the rows which have to be deleted"""
    where: manager_bool_exp!
  ): manager_mutation_response

  """
  delete single row from the table: "manager"
  """
  delete_manager_by_pk(id: uuid!): manager

  """
  delete data from the table: "notebook"
  """
  delete_notebook(
    """filter the rows which have to be deleted"""
    where: notebook_bool_exp!
  ): notebook_mutation_response

  """
  delete data from the table: "notebook_action"
  """
  delete_notebook_action(
    """filter the rows which have to be deleted"""
    where: notebook_action_bool_exp!
  ): notebook_action_mutation_response

  """
  delete single row from the table: "notebook_action"
  """
  delete_notebook_action_by_pk(id: uuid!): notebook_action

  """
  delete data from the table: "notebook_appointment"
  """
  delete_notebook_appointment(
    """filter the rows which have to be deleted"""
    where: notebook_appointment_bool_exp!
  ): notebook_appointment_mutation_response

  """
  delete single row from the table: "notebook_appointment"
  """
  delete_notebook_appointment_by_pk(id: uuid!): notebook_appointment

  """
  delete single row from the table: "notebook"
  """
  delete_notebook_by_pk(id: uuid!): notebook

  """
  delete data from the table: "notebook_creation"
  """
  delete_notebook_creation(
    """filter the rows which have to be deleted"""
    where: notebook_creation_bool_exp!
  ): notebook_creation_mutation_response

  """
  delete single row from the table: "notebook_creation"
  """
  delete_notebook_creation_by_pk(id: uuid!): notebook_creation

  """
  delete data from the table: "notebook_creation_source_type"
  """
  delete_notebook_creation_source_type(
    """filter the rows which have to be deleted"""
    where: notebook_creation_source_type_bool_exp!
  ): notebook_creation_source_type_mutation_response

  """
  delete single row from the table: "notebook_creation_source_type"
  """
  delete_notebook_creation_source_type_by_pk(id: String!): notebook_creation_source_type

  """
  delete data from the table: "notebook_event"
  """
  delete_notebook_event(
    """filter the rows which have to be deleted"""
    where: notebook_event_bool_exp!
  ): notebook_event_mutation_response

  """
  delete single row from the table: "notebook_event"
  """
  delete_notebook_event_by_pk(id: uuid!): notebook_event

  """
  delete data from the table: "notebook_event_type"
  """
  delete_notebook_event_type(
    """filter the rows which have to be deleted"""
    where: notebook_event_type_bool_exp!
  ): notebook_event_type_mutation_response

  """
  delete single row from the table: "notebook_event_type"
  """
  delete_notebook_event_type_by_pk(value: String!): notebook_event_type

  """
  delete data from the table: "notebook_focus"
  """
  delete_notebook_focus(
    """filter the rows which have to be deleted"""
    where: notebook_focus_bool_exp!
  ): notebook_focus_mutation_response

  """
  delete single row from the table: "notebook_focus"
  """
  delete_notebook_focus_by_pk(id: uuid!): notebook_focus

  """
  delete data from the table: "notebook_info"
  """
  delete_notebook_info(
    """filter the rows which have to be deleted"""
    where: notebook_info_bool_exp!
  ): notebook_info_mutation_response

  """
  delete single row from the table: "notebook_info"
  """
  delete_notebook_info_by_pk(notebookId: uuid!): notebook_info

  """
  delete data from the table: "notebook_member"
  """
  delete_notebook_member(
    """filter the rows which have to be deleted"""
    where: notebook_member_bool_exp!
  ): notebook_member_mutation_response

  """
  delete single row from the table: "notebook_member"
  """
  delete_notebook_member_by_pk(id: uuid!): notebook_member

  """
  delete data from the table: "notebook_public_view"
  """
  delete_notebook_public_view(
    """filter the rows which have to be deleted"""
    where: notebook_public_view_bool_exp!
  ): notebook_public_view_mutation_response

  """
  delete data from the table: "notebook_situation"
  """
  delete_notebook_situation(
    """filter the rows which have to be deleted"""
    where: notebook_situation_bool_exp!
  ): notebook_situation_mutation_response

  """
  delete single row from the table: "notebook_situation"
  """
  delete_notebook_situation_by_pk(id: uuid!): notebook_situation

  """
  delete data from the table: "notebook_target"
  """
  delete_notebook_target(
    """filter the rows which have to be deleted"""
    where: notebook_target_bool_exp!
  ): notebook_target_mutation_response

  """
  delete single row from the table: "notebook_target"
  """
  delete_notebook_target_by_pk(id: uuid!): notebook_target

  """
  delete data from the table: "notebook_update"
  """
  delete_notebook_update(
    """filter the rows which have to be deleted"""
    where: notebook_update_bool_exp!
  ): notebook_update_mutation_response

  """
  delete single row from the table: "notebook_update"
  """
  delete_notebook_update_by_pk(id: uuid!): notebook_update

  """
  delete data from the table: "notebook_visit"
  """
  delete_notebook_visit(
    """filter the rows which have to be deleted"""
    where: notebook_visit_bool_exp!
  ): notebook_visit_mutation_response

  """
  delete single row from the table: "notebook_visit"
  """
  delete_notebook_visit_by_pk(id: uuid!): notebook_visit

  """
  delete data from the table: "nps_rating"
  """
  delete_nps_rating(
    """filter the rows which have to be deleted"""
    where: nps_rating_bool_exp!
  ): nps_rating_mutation_response

  """
  delete single row from the table: "nps_rating"
  """
  delete_nps_rating_by_pk(id: uuid!): nps_rating

  """
  delete data from the table: "nps_rating_dismissal"
  """
  delete_nps_rating_dismissal(
    """filter the rows which have to be deleted"""
    where: nps_rating_dismissal_bool_exp!
  ): nps_rating_dismissal_mutation_response

  """
  delete single row from the table: "nps_rating_dismissal"
  """
  delete_nps_rating_dismissal_by_pk(id: uuid!): nps_rating_dismissal

  """
  delete data from the table: "orientation_manager"
  """
  delete_orientation_manager(
    """filter the rows which have to be deleted"""
    where: orientation_manager_bool_exp!
  ): orientation_manager_mutation_response

  """
  delete single row from the table: "orientation_manager"
  """
  delete_orientation_manager_by_pk(id: uuid!): orientation_manager

  """
  delete data from the table: "orientation_request"
  """
  delete_orientation_request(
    """filter the rows which have to be deleted"""
    where: orientation_request_bool_exp!
  ): orientation_request_mutation_response

  """
  delete single row from the table: "orientation_request"
  """
  delete_orientation_request_by_pk(id: uuid!): orientation_request

  """
  delete data from the table: "orientation_system"
  """
  delete_orientation_system(
    """filter the rows which have to be deleted"""
    where: orientation_system_bool_exp!
  ): orientation_system_mutation_response

  """
  delete single row from the table: "orientation_system"
  """
  delete_orientation_system_by_pk(id: uuid!): orientation_system

  """
  delete data from the table: "orientation_type"
  """
  delete_orientation_type(
    """filter the rows which have to be deleted"""
    where: orientation_type_bool_exp!
  ): orientation_type_mutation_response

  """
  delete single row from the table: "orientation_type"
  """
  delete_orientation_type_by_pk(id: String!): orientation_type

  """
  delete data from the table: "professional"
  """
  delete_professional(
    """filter the rows which have to be deleted"""
    where: professional_bool_exp!
  ): professional_mutation_response

  """
  delete single row from the table: "professional"
  """
  delete_professional_by_pk(id: uuid!): professional

  """
  delete data from the table: "professional_orientation_system"
  """
  delete_professional_orientation_system(
    """filter the rows which have to be deleted"""
    where: professional_orientation_system_bool_exp!
  ): professional_orientation_system_mutation_response

  """
  delete single row from the table: "professional_orientation_system"
  """
  delete_professional_orientation_system_by_pk(id: uuid!): professional_orientation_system

  """
  delete data from the table: "professional_project"
  """
  delete_professional_project(
    """filter the rows which have to be deleted"""
    where: professional_project_bool_exp!
  ): professional_project_mutation_response

  """
  delete single row from the table: "professional_project"
  """
  delete_professional_project_by_pk(id: uuid!): professional_project

  """
  delete data from the table: "ref_action"
  """
  delete_ref_action(
    """filter the rows which have to be deleted"""
    where: ref_action_bool_exp!
  ): ref_action_mutation_response

  """
  delete single row from the table: "ref_action"
  """
  delete_ref_action_by_pk(id: uuid!): ref_action

  """
  delete data from the table: "ref_situation"
  """
  delete_ref_situation(
    """filter the rows which have to be deleted"""
    where: ref_situation_bool_exp!
  ): ref_situation_mutation_response

  """
  delete single row from the table: "ref_situation"
  """
  delete_ref_situation_by_pk(id: uuid!): ref_situation

  """
  delete data from the table: "ref_target"
  """
  delete_ref_target(
    """filter the rows which have to be deleted"""
    where: ref_target_bool_exp!
  ): ref_target_mutation_response

  """
  delete single row from the table: "ref_target"
  """
  delete_ref_target_by_pk(id: uuid!): ref_target

  """
  delete data from the table: "ref_theme"
  """
  delete_ref_theme(
    """filter the rows which have to be deleted"""
    where: ref_theme_bool_exp!
  ): ref_theme_mutation_response

  """
  delete single row from the table: "ref_theme"
  """
  delete_ref_theme_by_pk(name: String!): ref_theme

  """
  delete data from the table: "role"
  """
  delete_role(
    """filter the rows which have to be deleted"""
    where: role_bool_exp!
  ): role_mutation_response

  """
  delete single row from the table: "role"
  """
  delete_role_by_pk(label: String!): role

  """
  delete data from the table: "rome_code"
  """
  delete_rome_code(
    """filter the rows which have to be deleted"""
    where: rome_code_bool_exp!
  ): rome_code_mutation_response

  """
  delete single row from the table: "rome_code"
  """
  delete_rome_code_by_pk(id: uuid!): rome_code

  """
  delete data from the table: "rsa_closure_reason"
  """
  delete_rsa_closure_reason(
    """filter the rows which have to be deleted"""
    where: rsa_closure_reason_bool_exp!
  ): rsa_closure_reason_mutation_response

  """
  delete single row from the table: "rsa_closure_reason"
  """
  delete_rsa_closure_reason_by_pk(code: String!): rsa_closure_reason

  """
  delete data from the table: "rsa_suspension_reason"
  """
  delete_rsa_suspension_reason(
    """filter the rows which have to be deleted"""
    where: rsa_suspension_reason_bool_exp!
  ): rsa_suspension_reason_mutation_response

  """
  delete single row from the table: "rsa_suspension_reason"
  """
  delete_rsa_suspension_reason_by_pk(code: String!): rsa_suspension_reason

  """
  delete data from the table: "structure"
  """
  delete_structure(
    """filter the rows which have to be deleted"""
    where: structure_bool_exp!
  ): structure_mutation_response

  """
  delete single row from the table: "structure"
  """
  delete_structure_by_pk(id: uuid!): structure

  """
  delete data from the table: "structure_orientation_system"
  """
  delete_structure_orientation_system(
    """filter the rows which have to be deleted"""
    where: structure_orientation_system_bool_exp!
  ): structure_orientation_system_mutation_response

  """
  delete single row from the table: "structure_orientation_system"
  """
  delete_structure_orientation_system_by_pk(id: uuid!): structure_orientation_system

  """
  insert data into the table: "account"
  """
  insert_account(
    """the rows to be inserted"""
    objects: [account_insert_input!]!

    """upsert condition"""
    on_conflict: account_on_conflict
  ): account_mutation_response

  """
  insert a single row into the table: "account"
  """
  insert_account_one(
    """the row to be inserted"""
    object: account_insert_input!

    """upsert condition"""
    on_conflict: account_on_conflict
  ): account

  """
  insert data into the table: "action_status"
  """
  insert_action_status(
    """the rows to be inserted"""
    objects: [action_status_insert_input!]!

    """upsert condition"""
    on_conflict: action_status_on_conflict
  ): action_status_mutation_response

  """
  insert a single row into the table: "action_status"
  """
  insert_action_status_one(
    """the row to be inserted"""
    object: action_status_insert_input!

    """upsert condition"""
    on_conflict: action_status_on_conflict
  ): action_status

  """
  insert data into the table: "admin_cdb"
  """
  insert_admin_cdb(
    """the rows to be inserted"""
    objects: [admin_cdb_insert_input!]!

    """upsert condition"""
    on_conflict: admin_cdb_on_conflict
  ): admin_cdb_mutation_response

  """
  insert a single row into the table: "admin_cdb"
  """
  insert_admin_cdb_one(
    """the row to be inserted"""
    object: admin_cdb_insert_input!

    """upsert condition"""
    on_conflict: admin_cdb_on_conflict
  ): admin_cdb

  """
  insert data into the table: "admin_structure"
  """
  insert_admin_structure(
    """the rows to be inserted"""
    objects: [admin_structure_insert_input!]!

    """upsert condition"""
    on_conflict: admin_structure_on_conflict
  ): admin_structure_mutation_response

  """
  insert a single row into the table: "admin_structure"
  """
  insert_admin_structure_one(
    """the row to be inserted"""
    object: admin_structure_insert_input!

    """upsert condition"""
    on_conflict: admin_structure_on_conflict
  ): admin_structure

  """
  insert data into the table: "admin_structure_structure"
  """
  insert_admin_structure_structure(
    """the rows to be inserted"""
    objects: [admin_structure_structure_insert_input!]!

    """upsert condition"""
    on_conflict: admin_structure_structure_on_conflict
  ): admin_structure_structure_mutation_response

  """
  insert a single row into the table: "admin_structure_structure"
  """
  insert_admin_structure_structure_one(
    """the row to be inserted"""
    object: admin_structure_structure_insert_input!

    """upsert condition"""
    on_conflict: admin_structure_structure_on_conflict
  ): admin_structure_structure

  """
  insert data into the table: "beneficiary"
  """
  insert_beneficiary(
    """the rows to be inserted"""
    objects: [beneficiary_insert_input!]!

    """upsert condition"""
    on_conflict: beneficiary_on_conflict
  ): beneficiary_mutation_response

  """
  insert a single row into the table: "beneficiary"
  """
  insert_beneficiary_one(
    """the row to be inserted"""
    object: beneficiary_insert_input!

    """upsert condition"""
    on_conflict: beneficiary_on_conflict
  ): beneficiary

  """
  insert data into the table: "beneficiary_structure"
  """
  insert_beneficiary_structure(
    """the rows to be inserted"""
    objects: [beneficiary_structure_insert_input!]!

    """upsert condition"""
    on_conflict: beneficiary_structure_on_conflict
  ): beneficiary_structure_mutation_response

  """
  insert a single row into the table: "beneficiary_structure"
  """
  insert_beneficiary_structure_one(
    """the row to be inserted"""
    object: beneficiary_structure_insert_input!

    """upsert condition"""
    on_conflict: beneficiary_structure_on_conflict
  ): beneficiary_structure

  """
  insert data into the table: "contract_type"
  """
  insert_contract_type(
    """the rows to be inserted"""
    objects: [contract_type_insert_input!]!

    """upsert condition"""
    on_conflict: contract_type_on_conflict
  ): contract_type_mutation_response

  """
  insert a single row into the table: "contract_type"
  """
  insert_contract_type_one(
    """the row to be inserted"""
    object: contract_type_insert_input!

    """upsert condition"""
    on_conflict: contract_type_on_conflict
  ): contract_type

  """
  insert data into the table: "deployment"
  """
  insert_deployment(
    """the rows to be inserted"""
    objects: [deployment_insert_input!]!

    """upsert condition"""
    on_conflict: deployment_on_conflict
  ): deployment_mutation_response

  """
  insert a single row into the table: "deployment"
  """
  insert_deployment_one(
    """the row to be inserted"""
    object: deployment_insert_input!

    """upsert condition"""
    on_conflict: deployment_on_conflict
  ): deployment

  """
  insert data into the table: "employment_type"
  """
  insert_employment_type(
    """the rows to be inserted"""
    objects: [employment_type_insert_input!]!

    """upsert condition"""
    on_conflict: employment_type_on_conflict
  ): employment_type_mutation_response

  """
  insert a single row into the table: "employment_type"
  """
  insert_employment_type_one(
    """the row to be inserted"""
    object: employment_type_insert_input!

    """upsert condition"""
    on_conflict: employment_type_on_conflict
  ): employment_type

  """
  insert data into the table: "external_data"
  """
  insert_external_data(
    """the rows to be inserted"""
    objects: [external_data_insert_input!]!

    """upsert condition"""
    on_conflict: external_data_on_conflict
  ): external_data_mutation_response

  """
  insert data into the table: "external_data_info"
  """
  insert_external_data_info(
    """the rows to be inserted"""
    objects: [external_data_info_insert_input!]!

    """upsert condition"""
    on_conflict: external_data_info_on_conflict
  ): external_data_info_mutation_response

  """
  insert a single row into the table: "external_data_info"
  """
  insert_external_data_info_one(
    """the row to be inserted"""
    object: external_data_info_insert_input!

    """upsert condition"""
    on_conflict: external_data_info_on_conflict
  ): external_data_info

  """
  insert a single row into the table: "external_data"
  """
  insert_external_data_one(
    """the row to be inserted"""
    object: external_data_insert_input!

    """upsert condition"""
    on_conflict: external_data_on_conflict
  ): external_data

  """
  insert data into the table: "external_source"
  """
  insert_external_source(
    """the rows to be inserted"""
    objects: [external_source_insert_input!]!

    """upsert condition"""
    on_conflict: external_source_on_conflict
  ): external_source_mutation_response

  """
  insert a single row into the table: "external_source"
  """
  insert_external_source_one(
    """the row to be inserted"""
    object: external_source_insert_input!

    """upsert condition"""
    on_conflict: external_source_on_conflict
  ): external_source

  """
  insert data into the table: "manager"
  """
  insert_manager(
    """the rows to be inserted"""
    objects: [manager_insert_input!]!

    """upsert condition"""
    on_conflict: manager_on_conflict
  ): manager_mutation_response

  """
  insert a single row into the table: "manager"
  """
  insert_manager_one(
    """the row to be inserted"""
    object: manager_insert_input!

    """upsert condition"""
    on_conflict: manager_on_conflict
  ): manager

  """
  insert data into the table: "notebook"
  """
  insert_notebook(
    """the rows to be inserted"""
    objects: [notebook_insert_input!]!

    """upsert condition"""
    on_conflict: notebook_on_conflict
  ): notebook_mutation_response

  """
  insert data into the table: "notebook_action"
  """
  insert_notebook_action(
    """the rows to be inserted"""
    objects: [notebook_action_insert_input!]!

    """upsert condition"""
    on_conflict: notebook_action_on_conflict
  ): notebook_action_mutation_response

  """
  insert a single row into the table: "notebook_action"
  """
  insert_notebook_action_one(
    """the row to be inserted"""
    object: notebook_action_insert_input!

    """upsert condition"""
    on_conflict: notebook_action_on_conflict
  ): notebook_action

  """
  insert data into the table: "notebook_appointment"
  """
  insert_notebook_appointment(
    """the rows to be inserted"""
    objects: [notebook_appointment_insert_input!]!

    """upsert condition"""
    on_conflict: notebook_appointment_on_conflict
  ): notebook_appointment_mutation_response

  """
  insert a single row into the table: "notebook_appointment"
  """
  insert_notebook_appointment_one(
    """the row to be inserted"""
    object: notebook_appointment_insert_input!

    """upsert condition"""
    on_conflict: notebook_appointment_on_conflict
  ): notebook_appointment

  """
  insert data into the table: "notebook_creation"
  """
  insert_notebook_creation(
    """the rows to be inserted"""
    objects: [notebook_creation_insert_input!]!

    """upsert condition"""
    on_conflict: notebook_creation_on_conflict
  ): notebook_creation_mutation_response

  """
  insert a single row into the table: "notebook_creation"
  """
  insert_notebook_creation_one(
    """the row to be inserted"""
    object: notebook_creation_insert_input!

    """upsert condition"""
    on_conflict: notebook_creation_on_conflict
  ): notebook_creation

  """
  insert data into the table: "notebook_creation_source_type"
  """
  insert_notebook_creation_source_type(
    """the rows to be inserted"""
    objects: [notebook_creation_source_type_insert_input!]!

    """upsert condition"""
    on_conflict: notebook_creation_source_type_on_conflict
  ): notebook_creation_source_type_mutation_response

  """
  insert a single row into the table: "notebook_creation_source_type"
  """
  insert_notebook_creation_source_type_one(
    """the row to be inserted"""
    object: notebook_creation_source_type_insert_input!

    """upsert condition"""
    on_conflict: notebook_creation_source_type_on_conflict
  ): notebook_creation_source_type

  """
  insert data into the table: "notebook_event"
  """
  insert_notebook_event(
    """the rows to be inserted"""
    objects: [notebook_event_insert_input!]!

    """upsert condition"""
    on_conflict: notebook_event_on_conflict
  ): notebook_event_mutation_response

  """
  insert a single row into the table: "notebook_event"
  """
  insert_notebook_event_one(
    """the row to be inserted"""
    object: notebook_event_insert_input!

    """upsert condition"""
    on_conflict: notebook_event_on_conflict
  ): notebook_event

  """
  insert data into the table: "notebook_event_type"
  """
  insert_notebook_event_type(
    """the rows to be inserted"""
    objects: [notebook_event_type_insert_input!]!

    """upsert condition"""
    on_conflict: notebook_event_type_on_conflict
  ): notebook_event_type_mutation_response

  """
  insert a single row into the table: "notebook_event_type"
  """
  insert_notebook_event_type_one(
    """the row to be inserted"""
    object: notebook_event_type_insert_input!

    """upsert condition"""
    on_conflict: notebook_event_type_on_conflict
  ): notebook_event_type

  """
  insert data into the table: "notebook_focus"
  """
  insert_notebook_focus(
    """the rows to be inserted"""
    objects: [notebook_focus_insert_input!]!

    """upsert condition"""
    on_conflict: notebook_focus_on_conflict
  ): notebook_focus_mutation_response

  """
  insert a single row into the table: "notebook_focus"
  """
  insert_notebook_focus_one(
    """the row to be inserted"""
    object: notebook_focus_insert_input!

    """upsert condition"""
    on_conflict: notebook_focus_on_conflict
  ): notebook_focus

  """
  insert data into the table: "notebook_info"
  """
  insert_notebook_info(
    """the rows to be inserted"""
    objects: [notebook_info_insert_input!]!

    """upsert condition"""
    on_conflict: notebook_info_on_conflict
  ): notebook_info_mutation_response

  """
  insert a single row into the table: "notebook_info"
  """
  insert_notebook_info_one(
    """the row to be inserted"""
    object: notebook_info_insert_input!

    """upsert condition"""
    on_conflict: notebook_info_on_conflict
  ): notebook_info

  """
  insert data into the table: "notebook_member"
  """
  insert_notebook_member(
    """the rows to be inserted"""
    objects: [notebook_member_insert_input!]!

    """upsert condition"""
    on_conflict: notebook_member_on_conflict
  ): notebook_member_mutation_response

  """
  insert a single row into the table: "notebook_member"
  """
  insert_notebook_member_one(
    """the row to be inserted"""
    object: notebook_member_insert_input!

    """upsert condition"""
    on_conflict: notebook_member_on_conflict
  ): notebook_member

  """
  insert a single row into the table: "notebook"
  """
  insert_notebook_one(
    """the row to be inserted"""
    object: notebook_insert_input!

    """upsert condition"""
    on_conflict: notebook_on_conflict
  ): notebook

  """
  insert data into the table: "notebook_public_view"
  """
  insert_notebook_public_view(
    """the rows to be inserted"""
    objects: [notebook_public_view_insert_input!]!
  ): notebook_public_view_mutation_response

  """
  insert a single row into the table: "notebook_public_view"
  """
  insert_notebook_public_view_one(
    """the row to be inserted"""
    object: notebook_public_view_insert_input!
  ): notebook_public_view

  """
  insert data into the table: "notebook_situation"
  """
  insert_notebook_situation(
    """the rows to be inserted"""
    objects: [notebook_situation_insert_input!]!

    """upsert condition"""
    on_conflict: notebook_situation_on_conflict
  ): notebook_situation_mutation_response

  """
  insert a single row into the table: "notebook_situation"
  """
  insert_notebook_situation_one(
    """the row to be inserted"""
    object: notebook_situation_insert_input!

    """upsert condition"""
    on_conflict: notebook_situation_on_conflict
  ): notebook_situation

  """
  insert data into the table: "notebook_target"
  """
  insert_notebook_target(
    """the rows to be inserted"""
    objects: [notebook_target_insert_input!]!

    """upsert condition"""
    on_conflict: notebook_target_on_conflict
  ): notebook_target_mutation_response

  """
  insert a single row into the table: "notebook_target"
  """
  insert_notebook_target_one(
    """the row to be inserted"""
    object: notebook_target_insert_input!

    """upsert condition"""
    on_conflict: notebook_target_on_conflict
  ): notebook_target

  """
  insert data into the table: "notebook_update"
  """
  insert_notebook_update(
    """the rows to be inserted"""
    objects: [notebook_update_insert_input!]!

    """upsert condition"""
    on_conflict: notebook_update_on_conflict
  ): notebook_update_mutation_response

  """
  insert a single row into the table: "notebook_update"
  """
  insert_notebook_update_one(
    """the row to be inserted"""
    object: notebook_update_insert_input!

    """upsert condition"""
    on_conflict: notebook_update_on_conflict
  ): notebook_update

  """
  insert data into the table: "notebook_visit"
  """
  insert_notebook_visit(
    """the rows to be inserted"""
    objects: [notebook_visit_insert_input!]!

    """upsert condition"""
    on_conflict: notebook_visit_on_conflict
  ): notebook_visit_mutation_response

  """
  insert a single row into the table: "notebook_visit"
  """
  insert_notebook_visit_one(
    """the row to be inserted"""
    object: notebook_visit_insert_input!

    """upsert condition"""
    on_conflict: notebook_visit_on_conflict
  ): notebook_visit

  """
  insert data into the table: "nps_rating"
  """
  insert_nps_rating(
    """the rows to be inserted"""
    objects: [nps_rating_insert_input!]!

    """upsert condition"""
    on_conflict: nps_rating_on_conflict
  ): nps_rating_mutation_response

  """
  insert data into the table: "nps_rating_dismissal"
  """
  insert_nps_rating_dismissal(
    """the rows to be inserted"""
    objects: [nps_rating_dismissal_insert_input!]!

    """upsert condition"""
    on_conflict: nps_rating_dismissal_on_conflict
  ): nps_rating_dismissal_mutation_response

  """
  insert a single row into the table: "nps_rating_dismissal"
  """
  insert_nps_rating_dismissal_one(
    """the row to be inserted"""
    object: nps_rating_dismissal_insert_input!

    """upsert condition"""
    on_conflict: nps_rating_dismissal_on_conflict
  ): nps_rating_dismissal

  """
  insert a single row into the table: "nps_rating"
  """
  insert_nps_rating_one(
    """the row to be inserted"""
    object: nps_rating_insert_input!

    """upsert condition"""
    on_conflict: nps_rating_on_conflict
  ): nps_rating

  """
  insert data into the table: "orientation_manager"
  """
  insert_orientation_manager(
    """the rows to be inserted"""
    objects: [orientation_manager_insert_input!]!

    """upsert condition"""
    on_conflict: orientation_manager_on_conflict
  ): orientation_manager_mutation_response

  """
  insert a single row into the table: "orientation_manager"
  """
  insert_orientation_manager_one(
    """the row to be inserted"""
    object: orientation_manager_insert_input!

    """upsert condition"""
    on_conflict: orientation_manager_on_conflict
  ): orientation_manager

  """
  insert data into the table: "orientation_request"
  """
  insert_orientation_request(
    """the rows to be inserted"""
    objects: [orientation_request_insert_input!]!

    """upsert condition"""
    on_conflict: orientation_request_on_conflict
  ): orientation_request_mutation_response

  """
  insert a single row into the table: "orientation_request"
  """
  insert_orientation_request_one(
    """the row to be inserted"""
    object: orientation_request_insert_input!

    """upsert condition"""
    on_conflict: orientation_request_on_conflict
  ): orientation_request

  """
  insert data into the table: "orientation_system"
  """
  insert_orientation_system(
    """the rows to be inserted"""
    objects: [orientation_system_insert_input!]!

    """upsert condition"""
    on_conflict: orientation_system_on_conflict
  ): orientation_system_mutation_response

  """
  insert a single row into the table: "orientation_system"
  """
  insert_orientation_system_one(
    """the row to be inserted"""
    object: orientation_system_insert_input!

    """upsert condition"""
    on_conflict: orientation_system_on_conflict
  ): orientation_system

  """
  insert data into the table: "orientation_type"
  """
  insert_orientation_type(
    """the rows to be inserted"""
    objects: [orientation_type_insert_input!]!

    """upsert condition"""
    on_conflict: orientation_type_on_conflict
  ): orientation_type_mutation_response

  """
  insert a single row into the table: "orientation_type"
  """
  insert_orientation_type_one(
    """the row to be inserted"""
    object: orientation_type_insert_input!

    """upsert condition"""
    on_conflict: orientation_type_on_conflict
  ): orientation_type

  """
  insert data into the table: "professional"
  """
  insert_professional(
    """the rows to be inserted"""
    objects: [professional_insert_input!]!

    """upsert condition"""
    on_conflict: professional_on_conflict
  ): professional_mutation_response

  """
  insert a single row into the table: "professional"
  """
  insert_professional_one(
    """the row to be inserted"""
    object: professional_insert_input!

    """upsert condition"""
    on_conflict: professional_on_conflict
  ): professional

  """
  insert data into the table: "professional_orientation_system"
  """
  insert_professional_orientation_system(
    """the rows to be inserted"""
    objects: [professional_orientation_system_insert_input!]!

    """upsert condition"""
    on_conflict: professional_orientation_system_on_conflict
  ): professional_orientation_system_mutation_response

  """
  insert a single row into the table: "professional_orientation_system"
  """
  insert_professional_orientation_system_one(
    """the row to be inserted"""
    object: professional_orientation_system_insert_input!

    """upsert condition"""
    on_conflict: professional_orientation_system_on_conflict
  ): professional_orientation_system

  """
  insert data into the table: "professional_project"
  """
  insert_professional_project(
    """the rows to be inserted"""
    objects: [professional_project_insert_input!]!

    """upsert condition"""
    on_conflict: professional_project_on_conflict
  ): professional_project_mutation_response

  """
  insert a single row into the table: "professional_project"
  """
  insert_professional_project_one(
    """the row to be inserted"""
    object: professional_project_insert_input!

    """upsert condition"""
    on_conflict: professional_project_on_conflict
  ): professional_project

  """
  insert data into the table: "ref_action"
  """
  insert_ref_action(
    """the rows to be inserted"""
    objects: [ref_action_insert_input!]!

    """upsert condition"""
    on_conflict: ref_action_on_conflict
  ): ref_action_mutation_response

  """
  insert a single row into the table: "ref_action"
  """
  insert_ref_action_one(
    """the row to be inserted"""
    object: ref_action_insert_input!

    """upsert condition"""
    on_conflict: ref_action_on_conflict
  ): ref_action

  """
  insert data into the table: "ref_situation"
  """
  insert_ref_situation(
    """the rows to be inserted"""
    objects: [ref_situation_insert_input!]!

    """upsert condition"""
    on_conflict: ref_situation_on_conflict
  ): ref_situation_mutation_response

  """
  insert a single row into the table: "ref_situation"
  """
  insert_ref_situation_one(
    """the row to be inserted"""
    object: ref_situation_insert_input!

    """upsert condition"""
    on_conflict: ref_situation_on_conflict
  ): ref_situation

  """
  insert data into the table: "ref_target"
  """
  insert_ref_target(
    """the rows to be inserted"""
    objects: [ref_target_insert_input!]!

    """upsert condition"""
    on_conflict: ref_target_on_conflict
  ): ref_target_mutation_response

  """
  insert a single row into the table: "ref_target"
  """
  insert_ref_target_one(
    """the row to be inserted"""
    object: ref_target_insert_input!

    """upsert condition"""
    on_conflict: ref_target_on_conflict
  ): ref_target

  """
  insert data into the table: "ref_theme"
  """
  insert_ref_theme(
    """the rows to be inserted"""
    objects: [ref_theme_insert_input!]!

    """upsert condition"""
    on_conflict: ref_theme_on_conflict
  ): ref_theme_mutation_response

  """
  insert a single row into the table: "ref_theme"
  """
  insert_ref_theme_one(
    """the row to be inserted"""
    object: ref_theme_insert_input!

    """upsert condition"""
    on_conflict: ref_theme_on_conflict
  ): ref_theme

  """
  insert data into the table: "role"
  """
  insert_role(
    """the rows to be inserted"""
    objects: [role_insert_input!]!

    """upsert condition"""
    on_conflict: role_on_conflict
  ): role_mutation_response

  """
  insert a single row into the table: "role"
  """
  insert_role_one(
    """the row to be inserted"""
    object: role_insert_input!

    """upsert condition"""
    on_conflict: role_on_conflict
  ): role

  """
  insert data into the table: "rome_code"
  """
  insert_rome_code(
    """the rows to be inserted"""
    objects: [rome_code_insert_input!]!

    """upsert condition"""
    on_conflict: rome_code_on_conflict
  ): rome_code_mutation_response

  """
  insert a single row into the table: "rome_code"
  """
  insert_rome_code_one(
    """the row to be inserted"""
    object: rome_code_insert_input!

    """upsert condition"""
    on_conflict: rome_code_on_conflict
  ): rome_code

  """
  insert data into the table: "rsa_closure_reason"
  """
  insert_rsa_closure_reason(
    """the rows to be inserted"""
    objects: [rsa_closure_reason_insert_input!]!

    """upsert condition"""
    on_conflict: rsa_closure_reason_on_conflict
  ): rsa_closure_reason_mutation_response

  """
  insert a single row into the table: "rsa_closure_reason"
  """
  insert_rsa_closure_reason_one(
    """the row to be inserted"""
    object: rsa_closure_reason_insert_input!

    """upsert condition"""
    on_conflict: rsa_closure_reason_on_conflict
  ): rsa_closure_reason

  """
  insert data into the table: "rsa_suspension_reason"
  """
  insert_rsa_suspension_reason(
    """the rows to be inserted"""
    objects: [rsa_suspension_reason_insert_input!]!

    """upsert condition"""
    on_conflict: rsa_suspension_reason_on_conflict
  ): rsa_suspension_reason_mutation_response

  """
  insert a single row into the table: "rsa_suspension_reason"
  """
  insert_rsa_suspension_reason_one(
    """the row to be inserted"""
    object: rsa_suspension_reason_insert_input!

    """upsert condition"""
    on_conflict: rsa_suspension_reason_on_conflict
  ): rsa_suspension_reason

  """
  insert data into the table: "structure"
  """
  insert_structure(
    """the rows to be inserted"""
    objects: [structure_insert_input!]!

    """upsert condition"""
    on_conflict: structure_on_conflict
  ): structure_mutation_response

  """
  insert a single row into the table: "structure"
  """
  insert_structure_one(
    """the row to be inserted"""
    object: structure_insert_input!

    """upsert condition"""
    on_conflict: structure_on_conflict
  ): structure

  """
  insert data into the table: "structure_orientation_system"
  """
  insert_structure_orientation_system(
    """the rows to be inserted"""
    objects: [structure_orientation_system_insert_input!]!

    """upsert condition"""
    on_conflict: structure_orientation_system_on_conflict
  ): structure_orientation_system_mutation_response

  """
  insert a single row into the table: "structure_orientation_system"
  """
  insert_structure_orientation_system_one(
    """the row to be inserted"""
    object: structure_orientation_system_insert_input!

    """upsert condition"""
    on_conflict: structure_orientation_system_on_conflict
  ): structure_orientation_system

  """Remove notebook focus"""
  remove_notebook_focus(id: uuid!): RemoveNotebookFocusOutput

  """
  update data of the table: "account"
  """
  update_account(
    """sets the columns of the filtered rows to the given values"""
    _set: account_set_input

    """filter the rows which have to be updated"""
    where: account_bool_exp!
  ): account_mutation_response

  """
  update single row of the table: "account"
  """
  update_account_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: account_set_input
    pk_columns: account_pk_columns_input!
  ): account

  """
  update multiples rows of table: "account"
  """
  update_account_many(
    """updates to execute, in order"""
    updates: [account_updates!]!
  ): [account_mutation_response]

  """
  update data of the table: "action_status"
  """
  update_action_status(
    """sets the columns of the filtered rows to the given values"""
    _set: action_status_set_input

    """filter the rows which have to be updated"""
    where: action_status_bool_exp!
  ): action_status_mutation_response

  """
  update single row of the table: "action_status"
  """
  update_action_status_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: action_status_set_input
    pk_columns: action_status_pk_columns_input!
  ): action_status

  """
  update multiples rows of table: "action_status"
  """
  update_action_status_many(
    """updates to execute, in order"""
    updates: [action_status_updates!]!
  ): [action_status_mutation_response]

  """
  update data of the table: "admin_cdb"
  """
  update_admin_cdb(
    """sets the columns of the filtered rows to the given values"""
    _set: admin_cdb_set_input

    """filter the rows which have to be updated"""
    where: admin_cdb_bool_exp!
  ): admin_cdb_mutation_response

  """
  update single row of the table: "admin_cdb"
  """
  update_admin_cdb_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: admin_cdb_set_input
    pk_columns: admin_cdb_pk_columns_input!
  ): admin_cdb

  """
  update multiples rows of table: "admin_cdb"
  """
  update_admin_cdb_many(
    """updates to execute, in order"""
    updates: [admin_cdb_updates!]!
  ): [admin_cdb_mutation_response]

  """
  update data of the table: "admin_structure"
  """
  update_admin_structure(
    """sets the columns of the filtered rows to the given values"""
    _set: admin_structure_set_input

    """filter the rows which have to be updated"""
    where: admin_structure_bool_exp!
  ): admin_structure_mutation_response

  """
  update single row of the table: "admin_structure"
  """
  update_admin_structure_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: admin_structure_set_input
    pk_columns: admin_structure_pk_columns_input!
  ): admin_structure

  """
  update multiples rows of table: "admin_structure"
  """
  update_admin_structure_many(
    """updates to execute, in order"""
    updates: [admin_structure_updates!]!
  ): [admin_structure_mutation_response]

  """
  update data of the table: "admin_structure_structure"
  """
  update_admin_structure_structure(
    """sets the columns of the filtered rows to the given values"""
    _set: admin_structure_structure_set_input

    """filter the rows which have to be updated"""
    where: admin_structure_structure_bool_exp!
  ): admin_structure_structure_mutation_response

  """
  update single row of the table: "admin_structure_structure"
  """
  update_admin_structure_structure_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: admin_structure_structure_set_input
    pk_columns: admin_structure_structure_pk_columns_input!
  ): admin_structure_structure

  """
  update multiples rows of table: "admin_structure_structure"
  """
  update_admin_structure_structure_many(
    """updates to execute, in order"""
    updates: [admin_structure_structure_updates!]!
  ): [admin_structure_structure_mutation_response]

  """
  update data of the table: "beneficiary"
  """
  update_beneficiary(
    """sets the columns of the filtered rows to the given values"""
    _set: beneficiary_set_input

    """filter the rows which have to be updated"""
    where: beneficiary_bool_exp!
  ): beneficiary_mutation_response

  """
  update single row of the table: "beneficiary"
  """
  update_beneficiary_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: beneficiary_set_input
    pk_columns: beneficiary_pk_columns_input!
  ): beneficiary

  """
  update multiples rows of table: "beneficiary"
  """
  update_beneficiary_many(
    """updates to execute, in order"""
    updates: [beneficiary_updates!]!
  ): [beneficiary_mutation_response]

  """
  update data of the table: "beneficiary_structure"
  """
  update_beneficiary_structure(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: beneficiary_structure_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: beneficiary_structure_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: beneficiary_structure_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: beneficiary_structure_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: beneficiary_structure_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: beneficiary_structure_set_input

    """filter the rows which have to be updated"""
    where: beneficiary_structure_bool_exp!
  ): beneficiary_structure_mutation_response

  """
  update single row of the table: "beneficiary_structure"
  """
  update_beneficiary_structure_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: beneficiary_structure_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: beneficiary_structure_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: beneficiary_structure_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: beneficiary_structure_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: beneficiary_structure_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: beneficiary_structure_set_input
    pk_columns: beneficiary_structure_pk_columns_input!
  ): beneficiary_structure

  """
  update multiples rows of table: "beneficiary_structure"
  """
  update_beneficiary_structure_many(
    """updates to execute, in order"""
    updates: [beneficiary_structure_updates!]!
  ): [beneficiary_structure_mutation_response]

  """
  update data of the table: "contract_type"
  """
  update_contract_type(
    """sets the columns of the filtered rows to the given values"""
    _set: contract_type_set_input

    """filter the rows which have to be updated"""
    where: contract_type_bool_exp!
  ): contract_type_mutation_response

  """
  update single row of the table: "contract_type"
  """
  update_contract_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: contract_type_set_input
    pk_columns: contract_type_pk_columns_input!
  ): contract_type

  """
  update multiples rows of table: "contract_type"
  """
  update_contract_type_many(
    """updates to execute, in order"""
    updates: [contract_type_updates!]!
  ): [contract_type_mutation_response]

  """
  update data of the table: "deployment"
  """
  update_deployment(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: deployment_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: deployment_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: deployment_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: deployment_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: deployment_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: deployment_set_input

    """filter the rows which have to be updated"""
    where: deployment_bool_exp!
  ): deployment_mutation_response

  """
  update single row of the table: "deployment"
  """
  update_deployment_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: deployment_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: deployment_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: deployment_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: deployment_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: deployment_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: deployment_set_input
    pk_columns: deployment_pk_columns_input!
  ): deployment

  """
  update multiples rows of table: "deployment"
  """
  update_deployment_many(
    """updates to execute, in order"""
    updates: [deployment_updates!]!
  ): [deployment_mutation_response]

  """
  update data of the table: "employment_type"
  """
  update_employment_type(
    """sets the columns of the filtered rows to the given values"""
    _set: employment_type_set_input

    """filter the rows which have to be updated"""
    where: employment_type_bool_exp!
  ): employment_type_mutation_response

  """
  update single row of the table: "employment_type"
  """
  update_employment_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: employment_type_set_input
    pk_columns: employment_type_pk_columns_input!
  ): employment_type

  """
  update multiples rows of table: "employment_type"
  """
  update_employment_type_many(
    """updates to execute, in order"""
    updates: [employment_type_updates!]!
  ): [employment_type_mutation_response]

  """
  update data of the table: "external_data"
  """
  update_external_data(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: external_data_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: external_data_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: external_data_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: external_data_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: external_data_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: external_data_set_input

    """filter the rows which have to be updated"""
    where: external_data_bool_exp!
  ): external_data_mutation_response

  """
  update single row of the table: "external_data"
  """
  update_external_data_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: external_data_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: external_data_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: external_data_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: external_data_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: external_data_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: external_data_set_input
    pk_columns: external_data_pk_columns_input!
  ): external_data

  """
  update data of the table: "external_data_info"
  """
  update_external_data_info(
    """sets the columns of the filtered rows to the given values"""
    _set: external_data_info_set_input

    """filter the rows which have to be updated"""
    where: external_data_info_bool_exp!
  ): external_data_info_mutation_response

  """
  update single row of the table: "external_data_info"
  """
  update_external_data_info_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: external_data_info_set_input
    pk_columns: external_data_info_pk_columns_input!
  ): external_data_info

  """
  update multiples rows of table: "external_data_info"
  """
  update_external_data_info_many(
    """updates to execute, in order"""
    updates: [external_data_info_updates!]!
  ): [external_data_info_mutation_response]

  """
  update multiples rows of table: "external_data"
  """
  update_external_data_many(
    """updates to execute, in order"""
    updates: [external_data_updates!]!
  ): [external_data_mutation_response]

  """
  update data of the table: "external_source"
  """
  update_external_source(
    """sets the columns of the filtered rows to the given values"""
    _set: external_source_set_input

    """filter the rows which have to be updated"""
    where: external_source_bool_exp!
  ): external_source_mutation_response

  """
  update single row of the table: "external_source"
  """
  update_external_source_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: external_source_set_input
    pk_columns: external_source_pk_columns_input!
  ): external_source

  """
  update multiples rows of table: "external_source"
  """
  update_external_source_many(
    """updates to execute, in order"""
    updates: [external_source_updates!]!
  ): [external_source_mutation_response]

  """
  update data of the table: "manager"
  """
  update_manager(
    """sets the columns of the filtered rows to the given values"""
    _set: manager_set_input

    """filter the rows which have to be updated"""
    where: manager_bool_exp!
  ): manager_mutation_response

  """
  update single row of the table: "manager"
  """
  update_manager_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: manager_set_input
    pk_columns: manager_pk_columns_input!
  ): manager

  """
  update multiples rows of table: "manager"
  """
  update_manager_many(
    """updates to execute, in order"""
    updates: [manager_updates!]!
  ): [manager_mutation_response]

  """
  update data of the table: "notebook"
  """
  update_notebook(
    """sets the columns of the filtered rows to the given values"""
    _set: notebook_set_input

    """filter the rows which have to be updated"""
    where: notebook_bool_exp!
  ): notebook_mutation_response

  """
  update data of the table: "notebook_action"
  """
  update_notebook_action(
    """sets the columns of the filtered rows to the given values"""
    _set: notebook_action_set_input

    """filter the rows which have to be updated"""
    where: notebook_action_bool_exp!
  ): notebook_action_mutation_response

  """
  update single row of the table: "notebook_action"
  """
  update_notebook_action_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: notebook_action_set_input
    pk_columns: notebook_action_pk_columns_input!
  ): notebook_action

  """
  update multiples rows of table: "notebook_action"
  """
  update_notebook_action_many(
    """updates to execute, in order"""
    updates: [notebook_action_updates!]!
  ): [notebook_action_mutation_response]

  """
  update data of the table: "notebook_appointment"
  """
  update_notebook_appointment(
    """sets the columns of the filtered rows to the given values"""
    _set: notebook_appointment_set_input

    """filter the rows which have to be updated"""
    where: notebook_appointment_bool_exp!
  ): notebook_appointment_mutation_response

  """
  update single row of the table: "notebook_appointment"
  """
  update_notebook_appointment_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: notebook_appointment_set_input
    pk_columns: notebook_appointment_pk_columns_input!
  ): notebook_appointment

  """
  update multiples rows of table: "notebook_appointment"
  """
  update_notebook_appointment_many(
    """updates to execute, in order"""
    updates: [notebook_appointment_updates!]!
  ): [notebook_appointment_mutation_response]

  """
  update single row of the table: "notebook"
  """
  update_notebook_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: notebook_set_input
    pk_columns: notebook_pk_columns_input!
  ): notebook

  """
  update data of the table: "notebook_creation"
  """
  update_notebook_creation(
    """sets the columns of the filtered rows to the given values"""
    _set: notebook_creation_set_input

    """filter the rows which have to be updated"""
    where: notebook_creation_bool_exp!
  ): notebook_creation_mutation_response

  """
  update single row of the table: "notebook_creation"
  """
  update_notebook_creation_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: notebook_creation_set_input
    pk_columns: notebook_creation_pk_columns_input!
  ): notebook_creation

  """
  update multiples rows of table: "notebook_creation"
  """
  update_notebook_creation_many(
    """updates to execute, in order"""
    updates: [notebook_creation_updates!]!
  ): [notebook_creation_mutation_response]

  """
  update data of the table: "notebook_creation_source_type"
  """
  update_notebook_creation_source_type(
    """sets the columns of the filtered rows to the given values"""
    _set: notebook_creation_source_type_set_input

    """filter the rows which have to be updated"""
    where: notebook_creation_source_type_bool_exp!
  ): notebook_creation_source_type_mutation_response

  """
  update single row of the table: "notebook_creation_source_type"
  """
  update_notebook_creation_source_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: notebook_creation_source_type_set_input
    pk_columns: notebook_creation_source_type_pk_columns_input!
  ): notebook_creation_source_type

  """
  update multiples rows of table: "notebook_creation_source_type"
  """
  update_notebook_creation_source_type_many(
    """updates to execute, in order"""
    updates: [notebook_creation_source_type_updates!]!
  ): [notebook_creation_source_type_mutation_response]

  """
  update data of the table: "notebook_event"
  """
  update_notebook_event(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: notebook_event_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: notebook_event_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: notebook_event_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: notebook_event_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: notebook_event_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: notebook_event_set_input

    """filter the rows which have to be updated"""
    where: notebook_event_bool_exp!
  ): notebook_event_mutation_response

  """
  update single row of the table: "notebook_event"
  """
  update_notebook_event_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: notebook_event_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: notebook_event_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: notebook_event_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: notebook_event_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: notebook_event_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: notebook_event_set_input
    pk_columns: notebook_event_pk_columns_input!
  ): notebook_event

  """
  update multiples rows of table: "notebook_event"
  """
  update_notebook_event_many(
    """updates to execute, in order"""
    updates: [notebook_event_updates!]!
  ): [notebook_event_mutation_response]

  """
  update data of the table: "notebook_event_type"
  """
  update_notebook_event_type(
    """sets the columns of the filtered rows to the given values"""
    _set: notebook_event_type_set_input

    """filter the rows which have to be updated"""
    where: notebook_event_type_bool_exp!
  ): notebook_event_type_mutation_response

  """
  update single row of the table: "notebook_event_type"
  """
  update_notebook_event_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: notebook_event_type_set_input
    pk_columns: notebook_event_type_pk_columns_input!
  ): notebook_event_type

  """
  update multiples rows of table: "notebook_event_type"
  """
  update_notebook_event_type_many(
    """updates to execute, in order"""
    updates: [notebook_event_type_updates!]!
  ): [notebook_event_type_mutation_response]

  """
  update data of the table: "notebook_focus"
  """
  update_notebook_focus(
    """sets the columns of the filtered rows to the given values"""
    _set: notebook_focus_set_input

    """filter the rows which have to be updated"""
    where: notebook_focus_bool_exp!
  ): notebook_focus_mutation_response

  """
  update single row of the table: "notebook_focus"
  """
  update_notebook_focus_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: notebook_focus_set_input
    pk_columns: notebook_focus_pk_columns_input!
  ): notebook_focus

  """
  update multiples rows of table: "notebook_focus"
  """
  update_notebook_focus_many(
    """updates to execute, in order"""
    updates: [notebook_focus_updates!]!
  ): [notebook_focus_mutation_response]
  update_notebook_from_pole_emploi(notebookId: uuid!): UpdateNotebookFromPoleEmploiOutput

  """
  update data of the table: "notebook_info"
  """
  update_notebook_info(
    """sets the columns of the filtered rows to the given values"""
    _set: notebook_info_set_input

    """filter the rows which have to be updated"""
    where: notebook_info_bool_exp!
  ): notebook_info_mutation_response

  """
  update single row of the table: "notebook_info"
  """
  update_notebook_info_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: notebook_info_set_input
    pk_columns: notebook_info_pk_columns_input!
  ): notebook_info

  """
  update multiples rows of table: "notebook_info"
  """
  update_notebook_info_many(
    """updates to execute, in order"""
    updates: [notebook_info_updates!]!
  ): [notebook_info_mutation_response]

  """
  update multiples rows of table: "notebook"
  """
  update_notebook_many(
    """updates to execute, in order"""
    updates: [notebook_updates!]!
  ): [notebook_mutation_response]

  """
  update data of the table: "notebook_member"
  """
  update_notebook_member(
    """sets the columns of the filtered rows to the given values"""
    _set: notebook_member_set_input

    """filter the rows which have to be updated"""
    where: notebook_member_bool_exp!
  ): notebook_member_mutation_response

  """
  update single row of the table: "notebook_member"
  """
  update_notebook_member_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: notebook_member_set_input
    pk_columns: notebook_member_pk_columns_input!
  ): notebook_member

  """
  update multiples rows of table: "notebook_member"
  """
  update_notebook_member_many(
    """updates to execute, in order"""
    updates: [notebook_member_updates!]!
  ): [notebook_member_mutation_response]

  """
  update data of the table: "notebook_public_view"
  """
  update_notebook_public_view(
    """sets the columns of the filtered rows to the given values"""
    _set: notebook_public_view_set_input

    """filter the rows which have to be updated"""
    where: notebook_public_view_bool_exp!
  ): notebook_public_view_mutation_response

  """
  update multiples rows of table: "notebook_public_view"
  """
  update_notebook_public_view_many(
    """updates to execute, in order"""
    updates: [notebook_public_view_updates!]!
  ): [notebook_public_view_mutation_response]

  """
  update data of the table: "notebook_situation"
  """
  update_notebook_situation(
    """sets the columns of the filtered rows to the given values"""
    _set: notebook_situation_set_input

    """filter the rows which have to be updated"""
    where: notebook_situation_bool_exp!
  ): notebook_situation_mutation_response

  """
  update single row of the table: "notebook_situation"
  """
  update_notebook_situation_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: notebook_situation_set_input
    pk_columns: notebook_situation_pk_columns_input!
  ): notebook_situation

  """
  update multiples rows of table: "notebook_situation"
  """
  update_notebook_situation_many(
    """updates to execute, in order"""
    updates: [notebook_situation_updates!]!
  ): [notebook_situation_mutation_response]

  """
  update data of the table: "notebook_target"
  """
  update_notebook_target(
    """sets the columns of the filtered rows to the given values"""
    _set: notebook_target_set_input

    """filter the rows which have to be updated"""
    where: notebook_target_bool_exp!
  ): notebook_target_mutation_response

  """update_notebook_target_action"""
  update_notebook_target_action(id: uuid!, linkedTo: String!, status: String!): UpdateNotebookTargetStatusOutput

  """
  update single row of the table: "notebook_target"
  """
  update_notebook_target_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: notebook_target_set_input
    pk_columns: notebook_target_pk_columns_input!
  ): notebook_target

  """
  update multiples rows of table: "notebook_target"
  """
  update_notebook_target_many(
    """updates to execute, in order"""
    updates: [notebook_target_updates!]!
  ): [notebook_target_mutation_response]

  """
  update data of the table: "notebook_update"
  """
  update_notebook_update(
    """sets the columns of the filtered rows to the given values"""
    _set: notebook_update_set_input

    """filter the rows which have to be updated"""
    where: notebook_update_bool_exp!
  ): notebook_update_mutation_response

  """
  update single row of the table: "notebook_update"
  """
  update_notebook_update_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: notebook_update_set_input
    pk_columns: notebook_update_pk_columns_input!
  ): notebook_update

  """
  update multiples rows of table: "notebook_update"
  """
  update_notebook_update_many(
    """updates to execute, in order"""
    updates: [notebook_update_updates!]!
  ): [notebook_update_mutation_response]

  """
  update data of the table: "notebook_visit"
  """
  update_notebook_visit(
    """sets the columns of the filtered rows to the given values"""
    _set: notebook_visit_set_input

    """filter the rows which have to be updated"""
    where: notebook_visit_bool_exp!
  ): notebook_visit_mutation_response

  """
  update single row of the table: "notebook_visit"
  """
  update_notebook_visit_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: notebook_visit_set_input
    pk_columns: notebook_visit_pk_columns_input!
  ): notebook_visit

  """
  update multiples rows of table: "notebook_visit"
  """
  update_notebook_visit_many(
    """updates to execute, in order"""
    updates: [notebook_visit_updates!]!
  ): [notebook_visit_mutation_response]

  """
  update data of the table: "nps_rating"
  """
  update_nps_rating(
    """increments the numeric columns with given value of the filtered values"""
    _inc: nps_rating_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: nps_rating_set_input

    """filter the rows which have to be updated"""
    where: nps_rating_bool_exp!
  ): nps_rating_mutation_response

  """
  update single row of the table: "nps_rating"
  """
  update_nps_rating_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: nps_rating_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: nps_rating_set_input
    pk_columns: nps_rating_pk_columns_input!
  ): nps_rating

  """
  update data of the table: "nps_rating_dismissal"
  """
  update_nps_rating_dismissal(
    """sets the columns of the filtered rows to the given values"""
    _set: nps_rating_dismissal_set_input

    """filter the rows which have to be updated"""
    where: nps_rating_dismissal_bool_exp!
  ): nps_rating_dismissal_mutation_response

  """
  update single row of the table: "nps_rating_dismissal"
  """
  update_nps_rating_dismissal_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: nps_rating_dismissal_set_input
    pk_columns: nps_rating_dismissal_pk_columns_input!
  ): nps_rating_dismissal

  """
  update multiples rows of table: "nps_rating_dismissal"
  """
  update_nps_rating_dismissal_many(
    """updates to execute, in order"""
    updates: [nps_rating_dismissal_updates!]!
  ): [nps_rating_dismissal_mutation_response]

  """
  update multiples rows of table: "nps_rating"
  """
  update_nps_rating_many(
    """updates to execute, in order"""
    updates: [nps_rating_updates!]!
  ): [nps_rating_mutation_response]

  """
  update data of the table: "orientation_manager"
  """
  update_orientation_manager(
    """sets the columns of the filtered rows to the given values"""
    _set: orientation_manager_set_input

    """filter the rows which have to be updated"""
    where: orientation_manager_bool_exp!
  ): orientation_manager_mutation_response

  """
  update single row of the table: "orientation_manager"
  """
  update_orientation_manager_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: orientation_manager_set_input
    pk_columns: orientation_manager_pk_columns_input!
  ): orientation_manager

  """
  update multiples rows of table: "orientation_manager"
  """
  update_orientation_manager_many(
    """updates to execute, in order"""
    updates: [orientation_manager_updates!]!
  ): [orientation_manager_mutation_response]

  """
  update data of the table: "orientation_request"
  """
  update_orientation_request(
    """sets the columns of the filtered rows to the given values"""
    _set: orientation_request_set_input

    """filter the rows which have to be updated"""
    where: orientation_request_bool_exp!
  ): orientation_request_mutation_response

  """
  update single row of the table: "orientation_request"
  """
  update_orientation_request_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: orientation_request_set_input
    pk_columns: orientation_request_pk_columns_input!
  ): orientation_request

  """
  update multiples rows of table: "orientation_request"
  """
  update_orientation_request_many(
    """updates to execute, in order"""
    updates: [orientation_request_updates!]!
  ): [orientation_request_mutation_response]

  """
  update data of the table: "orientation_system"
  """
  update_orientation_system(
    """sets the columns of the filtered rows to the given values"""
    _set: orientation_system_set_input

    """filter the rows which have to be updated"""
    where: orientation_system_bool_exp!
  ): orientation_system_mutation_response

  """
  update single row of the table: "orientation_system"
  """
  update_orientation_system_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: orientation_system_set_input
    pk_columns: orientation_system_pk_columns_input!
  ): orientation_system

  """
  update multiples rows of table: "orientation_system"
  """
  update_orientation_system_many(
    """updates to execute, in order"""
    updates: [orientation_system_updates!]!
  ): [orientation_system_mutation_response]

  """
  update data of the table: "orientation_type"
  """
  update_orientation_type(
    """sets the columns of the filtered rows to the given values"""
    _set: orientation_type_set_input

    """filter the rows which have to be updated"""
    where: orientation_type_bool_exp!
  ): orientation_type_mutation_response

  """
  update single row of the table: "orientation_type"
  """
  update_orientation_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: orientation_type_set_input
    pk_columns: orientation_type_pk_columns_input!
  ): orientation_type

  """
  update multiples rows of table: "orientation_type"
  """
  update_orientation_type_many(
    """updates to execute, in order"""
    updates: [orientation_type_updates!]!
  ): [orientation_type_mutation_response]

  """
  update data of the table: "professional"
  """
  update_professional(
    """sets the columns of the filtered rows to the given values"""
    _set: professional_set_input

    """filter the rows which have to be updated"""
    where: professional_bool_exp!
  ): professional_mutation_response

  """
  update single row of the table: "professional"
  """
  update_professional_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: professional_set_input
    pk_columns: professional_pk_columns_input!
  ): professional

  """
  update multiples rows of table: "professional"
  """
  update_professional_many(
    """updates to execute, in order"""
    updates: [professional_updates!]!
  ): [professional_mutation_response]

  """
  update data of the table: "professional_orientation_system"
  """
  update_professional_orientation_system(
    """sets the columns of the filtered rows to the given values"""
    _set: professional_orientation_system_set_input

    """filter the rows which have to be updated"""
    where: professional_orientation_system_bool_exp!
  ): professional_orientation_system_mutation_response

  """
  update single row of the table: "professional_orientation_system"
  """
  update_professional_orientation_system_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: professional_orientation_system_set_input
    pk_columns: professional_orientation_system_pk_columns_input!
  ): professional_orientation_system

  """
  update multiples rows of table: "professional_orientation_system"
  """
  update_professional_orientation_system_many(
    """updates to execute, in order"""
    updates: [professional_orientation_system_updates!]!
  ): [professional_orientation_system_mutation_response]

  """
  update data of the table: "professional_project"
  """
  update_professional_project(
    """increments the numeric columns with given value of the filtered values"""
    _inc: professional_project_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: professional_project_set_input

    """filter the rows which have to be updated"""
    where: professional_project_bool_exp!
  ): professional_project_mutation_response

  """
  update single row of the table: "professional_project"
  """
  update_professional_project_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: professional_project_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: professional_project_set_input
    pk_columns: professional_project_pk_columns_input!
  ): professional_project

  """
  update multiples rows of table: "professional_project"
  """
  update_professional_project_many(
    """updates to execute, in order"""
    updates: [professional_project_updates!]!
  ): [professional_project_mutation_response]

  """
  update data of the table: "ref_action"
  """
  update_ref_action(
    """sets the columns of the filtered rows to the given values"""
    _set: ref_action_set_input

    """filter the rows which have to be updated"""
    where: ref_action_bool_exp!
  ): ref_action_mutation_response

  """
  update single row of the table: "ref_action"
  """
  update_ref_action_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: ref_action_set_input
    pk_columns: ref_action_pk_columns_input!
  ): ref_action

  """
  update multiples rows of table: "ref_action"
  """
  update_ref_action_many(
    """updates to execute, in order"""
    updates: [ref_action_updates!]!
  ): [ref_action_mutation_response]

  """
  update data of the table: "ref_situation"
  """
  update_ref_situation(
    """sets the columns of the filtered rows to the given values"""
    _set: ref_situation_set_input

    """filter the rows which have to be updated"""
    where: ref_situation_bool_exp!
  ): ref_situation_mutation_response

  """
  update single row of the table: "ref_situation"
  """
  update_ref_situation_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: ref_situation_set_input
    pk_columns: ref_situation_pk_columns_input!
  ): ref_situation

  """
  update multiples rows of table: "ref_situation"
  """
  update_ref_situation_many(
    """updates to execute, in order"""
    updates: [ref_situation_updates!]!
  ): [ref_situation_mutation_response]

  """
  update data of the table: "ref_target"
  """
  update_ref_target(
    """sets the columns of the filtered rows to the given values"""
    _set: ref_target_set_input

    """filter the rows which have to be updated"""
    where: ref_target_bool_exp!
  ): ref_target_mutation_response

  """
  update single row of the table: "ref_target"
  """
  update_ref_target_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: ref_target_set_input
    pk_columns: ref_target_pk_columns_input!
  ): ref_target

  """
  update multiples rows of table: "ref_target"
  """
  update_ref_target_many(
    """updates to execute, in order"""
    updates: [ref_target_updates!]!
  ): [ref_target_mutation_response]

  """
  update data of the table: "ref_theme"
  """
  update_ref_theme(
    """sets the columns of the filtered rows to the given values"""
    _set: ref_theme_set_input

    """filter the rows which have to be updated"""
    where: ref_theme_bool_exp!
  ): ref_theme_mutation_response

  """
  update single row of the table: "ref_theme"
  """
  update_ref_theme_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: ref_theme_set_input
    pk_columns: ref_theme_pk_columns_input!
  ): ref_theme

  """
  update multiples rows of table: "ref_theme"
  """
  update_ref_theme_many(
    """updates to execute, in order"""
    updates: [ref_theme_updates!]!
  ): [ref_theme_mutation_response]

  """
  update data of the table: "role"
  """
  update_role(
    """sets the columns of the filtered rows to the given values"""
    _set: role_set_input

    """filter the rows which have to be updated"""
    where: role_bool_exp!
  ): role_mutation_response

  """
  update single row of the table: "role"
  """
  update_role_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: role_set_input
    pk_columns: role_pk_columns_input!
  ): role

  """
  update multiples rows of table: "role"
  """
  update_role_many(
    """updates to execute, in order"""
    updates: [role_updates!]!
  ): [role_mutation_response]

  """
  update data of the table: "rome_code"
  """
  update_rome_code(
    """sets the columns of the filtered rows to the given values"""
    _set: rome_code_set_input

    """filter the rows which have to be updated"""
    where: rome_code_bool_exp!
  ): rome_code_mutation_response

  """
  update single row of the table: "rome_code"
  """
  update_rome_code_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: rome_code_set_input
    pk_columns: rome_code_pk_columns_input!
  ): rome_code

  """
  update multiples rows of table: "rome_code"
  """
  update_rome_code_many(
    """updates to execute, in order"""
    updates: [rome_code_updates!]!
  ): [rome_code_mutation_response]

  """
  update data of the table: "rsa_closure_reason"
  """
  update_rsa_closure_reason(
    """sets the columns of the filtered rows to the given values"""
    _set: rsa_closure_reason_set_input

    """filter the rows which have to be updated"""
    where: rsa_closure_reason_bool_exp!
  ): rsa_closure_reason_mutation_response

  """
  update single row of the table: "rsa_closure_reason"
  """
  update_rsa_closure_reason_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: rsa_closure_reason_set_input
    pk_columns: rsa_closure_reason_pk_columns_input!
  ): rsa_closure_reason

  """
  update multiples rows of table: "rsa_closure_reason"
  """
  update_rsa_closure_reason_many(
    """updates to execute, in order"""
    updates: [rsa_closure_reason_updates!]!
  ): [rsa_closure_reason_mutation_response]

  """
  update data of the table: "rsa_suspension_reason"
  """
  update_rsa_suspension_reason(
    """sets the columns of the filtered rows to the given values"""
    _set: rsa_suspension_reason_set_input

    """filter the rows which have to be updated"""
    where: rsa_suspension_reason_bool_exp!
  ): rsa_suspension_reason_mutation_response

  """
  update single row of the table: "rsa_suspension_reason"
  """
  update_rsa_suspension_reason_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: rsa_suspension_reason_set_input
    pk_columns: rsa_suspension_reason_pk_columns_input!
  ): rsa_suspension_reason

  """
  update multiples rows of table: "rsa_suspension_reason"
  """
  update_rsa_suspension_reason_many(
    """updates to execute, in order"""
    updates: [rsa_suspension_reason_updates!]!
  ): [rsa_suspension_reason_mutation_response]

  """Update professionnal project and create notebook event"""
  update_socio_pro(educationLevel: String, id: uuid!, lastJobEndedAt: date, professionalProjectIdsToDelete: [uuid!]!, professionalProjectsToAdd: [UpdateSocioProProfessionalProjectInsertInput!]!, professionalProjectsToUpdate: [UpdateSocioProProfessionalProjectSetInput!]!, rightRqth: Boolean, situationIdsToDelete: [uuid!]!, situationsToAdd: [UpdateSocioProNotebookSituationInsertInput!]!, workSituation: String, workSituationDate: date, workSituationEndDate: date): UpdateSocioProOutput

  """
  update data of the table: "structure"
  """
  update_structure(
    """sets the columns of the filtered rows to the given values"""
    _set: structure_set_input

    """filter the rows which have to be updated"""
    where: structure_bool_exp!
  ): structure_mutation_response

  """
  update single row of the table: "structure"
  """
  update_structure_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: structure_set_input
    pk_columns: structure_pk_columns_input!
  ): structure

  """
  update multiples rows of table: "structure"
  """
  update_structure_many(
    """updates to execute, in order"""
    updates: [structure_updates!]!
  ): [structure_mutation_response]

  """
  update data of the table: "structure_orientation_system"
  """
  update_structure_orientation_system(
    """sets the columns of the filtered rows to the given values"""
    _set: structure_orientation_system_set_input

    """filter the rows which have to be updated"""
    where: structure_orientation_system_bool_exp!
  ): structure_orientation_system_mutation_response

  """
  update single row of the table: "structure_orientation_system"
  """
  update_structure_orientation_system_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: structure_orientation_system_set_input
    pk_columns: structure_orientation_system_pk_columns_input!
  ): structure_orientation_system

  """
  update multiples rows of table: "structure_orientation_system"
  """
  update_structure_orientation_system_many(
    """updates to execute, in order"""
    updates: [structure_orientation_system_updates!]!
  ): [structure_orientation_system_mutation_response]
}

"""
columns and relationships of "notebook"
"""
type notebook {
  """An array relationship"""
  appointments(
    """distinct select on columns"""
    distinct_on: [notebook_appointment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_appointment_order_by!]

    """filter the rows returned"""
    where: notebook_appointment_bool_exp
  ): [notebook_appointment!]!

  """An aggregate relationship"""
  appointments_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_appointment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_appointment_order_by!]

    """filter the rows returned"""
    where: notebook_appointment_bool_exp
  ): notebook_appointment_aggregate!

  """An object relationship"""
  beneficiary: beneficiary!
  beneficiaryId: uuid!
  contractEndDate: date
  contractSignDate: date
  contractStartDate: date
  contractType: String
  createdAt: timestamptz!
  diagnosticFetchedAt: timestamptz
  educationLevel: String

  """An array relationship"""
  events(
    """distinct select on columns"""
    distinct_on: [notebook_event_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_event_order_by!]

    """filter the rows returned"""
    where: notebook_event_bool_exp
  ): [notebook_event!]!

  """An aggregate relationship"""
  events_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_event_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_event_order_by!]

    """filter the rows returned"""
    where: notebook_event_bool_exp
  ): notebook_event_aggregate!

  """An array relationship"""
  focuses(
    """distinct select on columns"""
    distinct_on: [notebook_focus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_focus_order_by!]

    """filter the rows returned"""
    where: notebook_focus_bool_exp
  ): [notebook_focus!]!

  """An aggregate relationship"""
  focuses_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_focus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_focus_order_by!]

    """filter the rows returned"""
    where: notebook_focus_bool_exp
  ): notebook_focus_aggregate!
  id: uuid!
  lastJobEndedAt: date

  """An array relationship"""
  members(
    """distinct select on columns"""
    distinct_on: [notebook_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_member_order_by!]

    """filter the rows returned"""
    where: notebook_member_bool_exp
  ): [notebook_member!]!

  """An aggregate relationship"""
  members_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_member_order_by!]

    """filter the rows returned"""
    where: notebook_member_bool_exp
  ): notebook_member_aggregate!

  """An object relationship"""
  notebookInfo: notebook_info

  """An array relationship"""
  professionalProjects(
    """distinct select on columns"""
    distinct_on: [professional_project_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [professional_project_order_by!]

    """filter the rows returned"""
    where: professional_project_bool_exp
  ): [professional_project!]!

  """An aggregate relationship"""
  professionalProjects_aggregate(
    """distinct select on columns"""
    distinct_on: [professional_project_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [professional_project_order_by!]

    """filter the rows returned"""
    where: professional_project_bool_exp
  ): professional_project_aggregate!
  rightRqth: Boolean!

  """An array relationship"""
  situations(
    """distinct select on columns"""
    distinct_on: [notebook_situation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_situation_order_by!]

    """filter the rows returned"""
    where: notebook_situation_bool_exp
  ): [notebook_situation!]!

  """An aggregate relationship"""
  situations_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_situation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_situation_order_by!]

    """filter the rows returned"""
    where: notebook_situation_bool_exp
  ): notebook_situation_aggregate!
  updatedAt: timestamptz!
  workSituation: String
  workSituationDate: date
  workSituationEndDate: date
}

"""
columns and relationships of "notebook_action"
"""
type notebook_action {
  action: String!
  createdAt: timestamptz!

  """An object relationship"""
  creator: account!
  creatorId: uuid!
  id: uuid!
  startingAt: timestamptz!
  status: action_status_enum!

  """An object relationship"""
  target: notebook_target!
  targetId: uuid!
  updatedAt: timestamptz!
}

"""
aggregated selection of "notebook_action"
"""
type notebook_action_aggregate {
  aggregate: notebook_action_aggregate_fields
  nodes: [notebook_action!]!
}

input notebook_action_aggregate_bool_exp {
  count: notebook_action_aggregate_bool_exp_count
}

input notebook_action_aggregate_bool_exp_count {
  arguments: [notebook_action_select_column!]
  distinct: Boolean
  filter: notebook_action_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "notebook_action"
"""
type notebook_action_aggregate_fields {
  count(columns: [notebook_action_select_column!], distinct: Boolean): Int!
  max: notebook_action_max_fields
  min: notebook_action_min_fields
}

"""
order by aggregate values of table "notebook_action"
"""
input notebook_action_aggregate_order_by {
  count: order_by
  max: notebook_action_max_order_by
  min: notebook_action_min_order_by
}

"""
input type for inserting array relation for remote table "notebook_action"
"""
input notebook_action_arr_rel_insert_input {
  data: [notebook_action_insert_input!]!

  """upsert condition"""
  on_conflict: notebook_action_on_conflict
}

"""
Boolean expression to filter rows from the table "notebook_action". All fields are combined with a logical 'AND'.
"""
input notebook_action_bool_exp {
  _and: [notebook_action_bool_exp!]
  _not: notebook_action_bool_exp
  _or: [notebook_action_bool_exp!]
  action: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  creator: account_bool_exp
  creatorId: uuid_comparison_exp
  id: uuid_comparison_exp
  startingAt: timestamptz_comparison_exp
  status: action_status_enum_comparison_exp
  target: notebook_target_bool_exp
  targetId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "notebook_action"
"""
enum notebook_action_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  notebook_action_pkey
}

"""
input type for inserting data into table "notebook_action"
"""
input notebook_action_insert_input {
  action: String
  createdAt: timestamptz
  creator: account_obj_rel_insert_input
  creatorId: uuid
  id: uuid
  startingAt: timestamptz
  status: action_status_enum
  target: notebook_target_obj_rel_insert_input
  targetId: uuid
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type notebook_action_max_fields {
  action: String
  createdAt: timestamptz
  creatorId: uuid
  id: uuid
  startingAt: timestamptz
  targetId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "notebook_action"
"""
input notebook_action_max_order_by {
  action: order_by
  createdAt: order_by
  creatorId: order_by
  id: order_by
  startingAt: order_by
  targetId: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type notebook_action_min_fields {
  action: String
  createdAt: timestamptz
  creatorId: uuid
  id: uuid
  startingAt: timestamptz
  targetId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "notebook_action"
"""
input notebook_action_min_order_by {
  action: order_by
  createdAt: order_by
  creatorId: order_by
  id: order_by
  startingAt: order_by
  targetId: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "notebook_action"
"""
type notebook_action_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notebook_action!]!
}

"""
on_conflict condition type for table "notebook_action"
"""
input notebook_action_on_conflict {
  constraint: notebook_action_constraint!
  update_columns: [notebook_action_update_column!]! = []
  where: notebook_action_bool_exp
}

"""Ordering options when selecting data from "notebook_action"."""
input notebook_action_order_by {
  action: order_by
  createdAt: order_by
  creator: account_order_by
  creatorId: order_by
  id: order_by
  startingAt: order_by
  status: order_by
  target: notebook_target_order_by
  targetId: order_by
  updatedAt: order_by
}

"""primary key columns input for table: notebook_action"""
input notebook_action_pk_columns_input {
  id: uuid!
}

"""
select columns of table "notebook_action"
"""
enum notebook_action_select_column {
  """column name"""
  action

  """column name"""
  createdAt

  """column name"""
  creatorId

  """column name"""
  id

  """column name"""
  startingAt

  """column name"""
  status

  """column name"""
  targetId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "notebook_action"
"""
input notebook_action_set_input {
  action: String
  createdAt: timestamptz
  creatorId: uuid
  id: uuid
  startingAt: timestamptz
  status: action_status_enum
  targetId: uuid
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "notebook_action"
"""
input notebook_action_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notebook_action_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notebook_action_stream_cursor_value_input {
  action: String
  createdAt: timestamptz
  creatorId: uuid
  id: uuid
  startingAt: timestamptz
  status: action_status_enum
  targetId: uuid
  updatedAt: timestamptz
}

"""
update columns of table "notebook_action"
"""
enum notebook_action_update_column {
  """column name"""
  action

  """column name"""
  createdAt

  """column name"""
  creatorId

  """column name"""
  id

  """column name"""
  startingAt

  """column name"""
  status

  """column name"""
  targetId

  """column name"""
  updatedAt
}

input notebook_action_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: notebook_action_set_input

  """filter the rows which have to be updated"""
  where: notebook_action_bool_exp!
}

"""
aggregated selection of "notebook"
"""
type notebook_aggregate {
  aggregate: notebook_aggregate_fields
  nodes: [notebook!]!
}

"""
aggregate fields of "notebook"
"""
type notebook_aggregate_fields {
  count(columns: [notebook_select_column!], distinct: Boolean): Int!
  max: notebook_max_fields
  min: notebook_min_fields
}

"""
columns and relationships of "notebook_appointment"
"""
type notebook_appointment {
  """An object relationship"""
  account: account!

  """An object relationship"""
  accountByDeletedBy: account
  created_at: timestamptz
  date: timestamptz!
  deleted_at: timestamptz
  deleted_by: uuid
  id: uuid!
  memberAccountId: uuid!

  """An object relationship"""
  notebook: notebook!
  notebookId: uuid!
  status: String!
  updated_at: timestamptz
}

"""
aggregated selection of "notebook_appointment"
"""
type notebook_appointment_aggregate {
  aggregate: notebook_appointment_aggregate_fields
  nodes: [notebook_appointment!]!
}

input notebook_appointment_aggregate_bool_exp {
  count: notebook_appointment_aggregate_bool_exp_count
}

input notebook_appointment_aggregate_bool_exp_count {
  arguments: [notebook_appointment_select_column!]
  distinct: Boolean
  filter: notebook_appointment_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "notebook_appointment"
"""
type notebook_appointment_aggregate_fields {
  count(columns: [notebook_appointment_select_column!], distinct: Boolean): Int!
  max: notebook_appointment_max_fields
  min: notebook_appointment_min_fields
}

"""
order by aggregate values of table "notebook_appointment"
"""
input notebook_appointment_aggregate_order_by {
  count: order_by
  max: notebook_appointment_max_order_by
  min: notebook_appointment_min_order_by
}

"""
input type for inserting array relation for remote table "notebook_appointment"
"""
input notebook_appointment_arr_rel_insert_input {
  data: [notebook_appointment_insert_input!]!

  """upsert condition"""
  on_conflict: notebook_appointment_on_conflict
}

"""
Boolean expression to filter rows from the table "notebook_appointment". All fields are combined with a logical 'AND'.
"""
input notebook_appointment_bool_exp {
  _and: [notebook_appointment_bool_exp!]
  _not: notebook_appointment_bool_exp
  _or: [notebook_appointment_bool_exp!]
  account: account_bool_exp
  accountByDeletedBy: account_bool_exp
  created_at: timestamptz_comparison_exp
  date: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  deleted_by: uuid_comparison_exp
  id: uuid_comparison_exp
  memberAccountId: uuid_comparison_exp
  notebook: notebook_bool_exp
  notebookId: uuid_comparison_exp
  status: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "notebook_appointment"
"""
enum notebook_appointment_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  notebook_appointment_pkey
}

"""
input type for inserting data into table "notebook_appointment"
"""
input notebook_appointment_insert_input {
  account: account_obj_rel_insert_input
  accountByDeletedBy: account_obj_rel_insert_input
  created_at: timestamptz
  date: timestamptz
  deleted_at: timestamptz
  deleted_by: uuid
  id: uuid
  memberAccountId: uuid
  notebook: notebook_obj_rel_insert_input
  notebookId: uuid
  status: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type notebook_appointment_max_fields {
  created_at: timestamptz
  date: timestamptz
  deleted_at: timestamptz
  deleted_by: uuid
  id: uuid
  memberAccountId: uuid
  notebookId: uuid
  status: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "notebook_appointment"
"""
input notebook_appointment_max_order_by {
  created_at: order_by
  date: order_by
  deleted_at: order_by
  deleted_by: order_by
  id: order_by
  memberAccountId: order_by
  notebookId: order_by
  status: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type notebook_appointment_min_fields {
  created_at: timestamptz
  date: timestamptz
  deleted_at: timestamptz
  deleted_by: uuid
  id: uuid
  memberAccountId: uuid
  notebookId: uuid
  status: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "notebook_appointment"
"""
input notebook_appointment_min_order_by {
  created_at: order_by
  date: order_by
  deleted_at: order_by
  deleted_by: order_by
  id: order_by
  memberAccountId: order_by
  notebookId: order_by
  status: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "notebook_appointment"
"""
type notebook_appointment_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notebook_appointment!]!
}

"""
on_conflict condition type for table "notebook_appointment"
"""
input notebook_appointment_on_conflict {
  constraint: notebook_appointment_constraint!
  update_columns: [notebook_appointment_update_column!]! = []
  where: notebook_appointment_bool_exp
}

"""Ordering options when selecting data from "notebook_appointment"."""
input notebook_appointment_order_by {
  account: account_order_by
  accountByDeletedBy: account_order_by
  created_at: order_by
  date: order_by
  deleted_at: order_by
  deleted_by: order_by
  id: order_by
  memberAccountId: order_by
  notebook: notebook_order_by
  notebookId: order_by
  status: order_by
  updated_at: order_by
}

"""primary key columns input for table: notebook_appointment"""
input notebook_appointment_pk_columns_input {
  id: uuid!
}

"""
select columns of table "notebook_appointment"
"""
enum notebook_appointment_select_column {
  """column name"""
  created_at

  """column name"""
  date

  """column name"""
  deleted_at

  """column name"""
  deleted_by

  """column name"""
  id

  """column name"""
  memberAccountId

  """column name"""
  notebookId

  """column name"""
  status

  """column name"""
  updated_at
}

"""
input type for updating data in table "notebook_appointment"
"""
input notebook_appointment_set_input {
  created_at: timestamptz
  date: timestamptz
  deleted_at: timestamptz
  deleted_by: uuid
  id: uuid
  memberAccountId: uuid
  notebookId: uuid
  status: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "notebook_appointment"
"""
input notebook_appointment_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notebook_appointment_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notebook_appointment_stream_cursor_value_input {
  created_at: timestamptz
  date: timestamptz
  deleted_at: timestamptz
  deleted_by: uuid
  id: uuid
  memberAccountId: uuid
  notebookId: uuid
  status: String
  updated_at: timestamptz
}

"""
update columns of table "notebook_appointment"
"""
enum notebook_appointment_update_column {
  """column name"""
  created_at

  """column name"""
  date

  """column name"""
  deleted_at

  """column name"""
  deleted_by

  """column name"""
  id

  """column name"""
  memberAccountId

  """column name"""
  notebookId

  """column name"""
  status

  """column name"""
  updated_at
}

input notebook_appointment_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: notebook_appointment_set_input

  """filter the rows which have to be updated"""
  where: notebook_appointment_bool_exp!
}

"""
Boolean expression to filter rows from the table "notebook". All fields are combined with a logical 'AND'.
"""
input notebook_bool_exp {
  _and: [notebook_bool_exp!]
  _not: notebook_bool_exp
  _or: [notebook_bool_exp!]
  appointments: notebook_appointment_bool_exp
  appointments_aggregate: notebook_appointment_aggregate_bool_exp
  beneficiary: beneficiary_bool_exp
  beneficiaryId: uuid_comparison_exp
  contractEndDate: date_comparison_exp
  contractSignDate: date_comparison_exp
  contractStartDate: date_comparison_exp
  contractType: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  diagnosticFetchedAt: timestamptz_comparison_exp
  educationLevel: String_comparison_exp
  events: notebook_event_bool_exp
  events_aggregate: notebook_event_aggregate_bool_exp
  focuses: notebook_focus_bool_exp
  focuses_aggregate: notebook_focus_aggregate_bool_exp
  id: uuid_comparison_exp
  lastJobEndedAt: date_comparison_exp
  members: notebook_member_bool_exp
  members_aggregate: notebook_member_aggregate_bool_exp
  notebookInfo: notebook_info_bool_exp
  professionalProjects: professional_project_bool_exp
  professionalProjects_aggregate: professional_project_aggregate_bool_exp
  rightRqth: Boolean_comparison_exp
  situations: notebook_situation_bool_exp
  situations_aggregate: notebook_situation_aggregate_bool_exp
  updatedAt: timestamptz_comparison_exp
  workSituation: String_comparison_exp
  workSituationDate: date_comparison_exp
  workSituationEndDate: date_comparison_exp
}

"""
unique or primary key constraints on table "notebook"
"""
enum notebook_constraint {
  """
  unique or primary key constraint on columns "beneficiary_id"
  """
  notebook_beneficiary_id_key

  """
  unique or primary key constraint on columns "id"
  """
  notebook_pkey
}

"""tracks notebook creations"""
type notebook_creation {
  createdAt: timestamptz!

  """An object relationship"""
  creator: account!
  creatorAccountId: uuid!
  id: uuid!

  """An object relationship"""
  notebook: notebook!
  notebookId: uuid!
  source: notebook_creation_source_type_enum!
}

"""
aggregated selection of "notebook_creation"
"""
type notebook_creation_aggregate {
  aggregate: notebook_creation_aggregate_fields
  nodes: [notebook_creation!]!
}

"""
aggregate fields of "notebook_creation"
"""
type notebook_creation_aggregate_fields {
  count(columns: [notebook_creation_select_column!], distinct: Boolean): Int!
  max: notebook_creation_max_fields
  min: notebook_creation_min_fields
}

"""
Boolean expression to filter rows from the table "notebook_creation". All fields are combined with a logical 'AND'.
"""
input notebook_creation_bool_exp {
  _and: [notebook_creation_bool_exp!]
  _not: notebook_creation_bool_exp
  _or: [notebook_creation_bool_exp!]
  createdAt: timestamptz_comparison_exp
  creator: account_bool_exp
  creatorAccountId: uuid_comparison_exp
  id: uuid_comparison_exp
  notebook: notebook_bool_exp
  notebookId: uuid_comparison_exp
  source: notebook_creation_source_type_enum_comparison_exp
}

"""
unique or primary key constraints on table "notebook_creation"
"""
enum notebook_creation_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  notebook_creation_pkey
}

"""
input type for inserting data into table "notebook_creation"
"""
input notebook_creation_insert_input {
  createdAt: timestamptz
  creator: account_obj_rel_insert_input
  creatorAccountId: uuid
  id: uuid
  notebook: notebook_obj_rel_insert_input
  notebookId: uuid
  source: notebook_creation_source_type_enum
}

"""aggregate max on columns"""
type notebook_creation_max_fields {
  createdAt: timestamptz
  creatorAccountId: uuid
  id: uuid
  notebookId: uuid
}

"""aggregate min on columns"""
type notebook_creation_min_fields {
  createdAt: timestamptz
  creatorAccountId: uuid
  id: uuid
  notebookId: uuid
}

"""
response of any mutation on the table "notebook_creation"
"""
type notebook_creation_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notebook_creation!]!
}

"""
on_conflict condition type for table "notebook_creation"
"""
input notebook_creation_on_conflict {
  constraint: notebook_creation_constraint!
  update_columns: [notebook_creation_update_column!]! = []
  where: notebook_creation_bool_exp
}

"""Ordering options when selecting data from "notebook_creation"."""
input notebook_creation_order_by {
  createdAt: order_by
  creator: account_order_by
  creatorAccountId: order_by
  id: order_by
  notebook: notebook_order_by
  notebookId: order_by
  source: order_by
}

"""primary key columns input for table: notebook_creation"""
input notebook_creation_pk_columns_input {
  id: uuid!
}

"""
select columns of table "notebook_creation"
"""
enum notebook_creation_select_column {
  """column name"""
  createdAt

  """column name"""
  creatorAccountId

  """column name"""
  id

  """column name"""
  notebookId

  """column name"""
  source
}

"""
input type for updating data in table "notebook_creation"
"""
input notebook_creation_set_input {
  createdAt: timestamptz
  creatorAccountId: uuid
  id: uuid
  notebookId: uuid
  source: notebook_creation_source_type_enum
}

"""Enum table which contains available sources that create notebooks"""
type notebook_creation_source_type {
  comment: String
  id: String!
}

"""
aggregated selection of "notebook_creation_source_type"
"""
type notebook_creation_source_type_aggregate {
  aggregate: notebook_creation_source_type_aggregate_fields
  nodes: [notebook_creation_source_type!]!
}

"""
aggregate fields of "notebook_creation_source_type"
"""
type notebook_creation_source_type_aggregate_fields {
  count(columns: [notebook_creation_source_type_select_column!], distinct: Boolean): Int!
  max: notebook_creation_source_type_max_fields
  min: notebook_creation_source_type_min_fields
}

"""
Boolean expression to filter rows from the table "notebook_creation_source_type". All fields are combined with a logical 'AND'.
"""
input notebook_creation_source_type_bool_exp {
  _and: [notebook_creation_source_type_bool_exp!]
  _not: notebook_creation_source_type_bool_exp
  _or: [notebook_creation_source_type_bool_exp!]
  comment: String_comparison_exp
  id: String_comparison_exp
}

"""
unique or primary key constraints on table "notebook_creation_source_type"
"""
enum notebook_creation_source_type_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  notebook_creation_source_type_pkey
}

enum notebook_creation_source_type_enum {
  """Service Rendez-vous Insertion"""
  rdvi
}

"""
Boolean expression to compare columns of type "notebook_creation_source_type_enum". All fields are combined with logical 'AND'.
"""
input notebook_creation_source_type_enum_comparison_exp {
  _eq: notebook_creation_source_type_enum
  _in: [notebook_creation_source_type_enum!]
  _is_null: Boolean
  _neq: notebook_creation_source_type_enum
  _nin: [notebook_creation_source_type_enum!]
}

"""
input type for inserting data into table "notebook_creation_source_type"
"""
input notebook_creation_source_type_insert_input {
  comment: String
  id: String
}

"""aggregate max on columns"""
type notebook_creation_source_type_max_fields {
  comment: String
  id: String
}

"""aggregate min on columns"""
type notebook_creation_source_type_min_fields {
  comment: String
  id: String
}

"""
response of any mutation on the table "notebook_creation_source_type"
"""
type notebook_creation_source_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notebook_creation_source_type!]!
}

"""
on_conflict condition type for table "notebook_creation_source_type"
"""
input notebook_creation_source_type_on_conflict {
  constraint: notebook_creation_source_type_constraint!
  update_columns: [notebook_creation_source_type_update_column!]! = []
  where: notebook_creation_source_type_bool_exp
}

"""
Ordering options when selecting data from "notebook_creation_source_type".
"""
input notebook_creation_source_type_order_by {
  comment: order_by
  id: order_by
}

"""primary key columns input for table: notebook_creation_source_type"""
input notebook_creation_source_type_pk_columns_input {
  id: String!
}

"""
select columns of table "notebook_creation_source_type"
"""
enum notebook_creation_source_type_select_column {
  """column name"""
  comment

  """column name"""
  id
}

"""
input type for updating data in table "notebook_creation_source_type"
"""
input notebook_creation_source_type_set_input {
  comment: String
  id: String
}

"""
Streaming cursor of the table "notebook_creation_source_type"
"""
input notebook_creation_source_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notebook_creation_source_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notebook_creation_source_type_stream_cursor_value_input {
  comment: String
  id: String
}

"""
update columns of table "notebook_creation_source_type"
"""
enum notebook_creation_source_type_update_column {
  """column name"""
  comment

  """column name"""
  id
}

input notebook_creation_source_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: notebook_creation_source_type_set_input

  """filter the rows which have to be updated"""
  where: notebook_creation_source_type_bool_exp!
}

"""
Streaming cursor of the table "notebook_creation"
"""
input notebook_creation_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notebook_creation_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notebook_creation_stream_cursor_value_input {
  createdAt: timestamptz
  creatorAccountId: uuid
  id: uuid
  notebookId: uuid
  source: notebook_creation_source_type_enum
}

"""
update columns of table "notebook_creation"
"""
enum notebook_creation_update_column {
  """column name"""
  createdAt

  """column name"""
  creatorAccountId

  """column name"""
  id

  """column name"""
  notebookId

  """column name"""
  source
}

input notebook_creation_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: notebook_creation_set_input

  """filter the rows which have to be updated"""
  where: notebook_creation_bool_exp!
}

"""
columns and relationships of "notebook_event"
"""
type notebook_event {
  creationDate: timestamptz!

  """An object relationship"""
  creator: account
  creatorId: uuid
  event(
    """JSON select path"""
    path: String
  ): jsonb!
  eventDate: timestamptz!
  eventType: notebook_event_type_enum!
  id: uuid!

  """An object relationship"""
  notebook: notebook!
  notebookId: uuid!

  """An object relationship"""
  notebook_event_type: notebook_event_type!
}

"""
aggregated selection of "notebook_event"
"""
type notebook_event_aggregate {
  aggregate: notebook_event_aggregate_fields
  nodes: [notebook_event!]!
}

input notebook_event_aggregate_bool_exp {
  count: notebook_event_aggregate_bool_exp_count
}

input notebook_event_aggregate_bool_exp_count {
  arguments: [notebook_event_select_column!]
  distinct: Boolean
  filter: notebook_event_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "notebook_event"
"""
type notebook_event_aggregate_fields {
  count(columns: [notebook_event_select_column!], distinct: Boolean): Int!
  max: notebook_event_max_fields
  min: notebook_event_min_fields
}

"""
order by aggregate values of table "notebook_event"
"""
input notebook_event_aggregate_order_by {
  count: order_by
  max: notebook_event_max_order_by
  min: notebook_event_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input notebook_event_append_input {
  event: jsonb
}

"""
input type for inserting array relation for remote table "notebook_event"
"""
input notebook_event_arr_rel_insert_input {
  data: [notebook_event_insert_input!]!

  """upsert condition"""
  on_conflict: notebook_event_on_conflict
}

"""
Boolean expression to filter rows from the table "notebook_event". All fields are combined with a logical 'AND'.
"""
input notebook_event_bool_exp {
  _and: [notebook_event_bool_exp!]
  _not: notebook_event_bool_exp
  _or: [notebook_event_bool_exp!]
  creationDate: timestamptz_comparison_exp
  creator: account_bool_exp
  creatorId: uuid_comparison_exp
  event: jsonb_comparison_exp
  eventDate: timestamptz_comparison_exp
  eventType: notebook_event_type_enum_comparison_exp
  id: uuid_comparison_exp
  notebook: notebook_bool_exp
  notebookId: uuid_comparison_exp
  notebook_event_type: notebook_event_type_bool_exp
}

"""
unique or primary key constraints on table "notebook_event"
"""
enum notebook_event_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  notebook_event_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input notebook_event_delete_at_path_input {
  event: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input notebook_event_delete_elem_input {
  event: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input notebook_event_delete_key_input {
  event: String
}

"""
input type for inserting data into table "notebook_event"
"""
input notebook_event_insert_input {
  creationDate: timestamptz
  creator: account_obj_rel_insert_input
  creatorId: uuid
  event: jsonb
  eventDate: timestamptz
  eventType: notebook_event_type_enum
  id: uuid
  notebook: notebook_obj_rel_insert_input
  notebookId: uuid
  notebook_event_type: notebook_event_type_obj_rel_insert_input
}

"""aggregate max on columns"""
type notebook_event_max_fields {
  creationDate: timestamptz
  creatorId: uuid
  eventDate: timestamptz
  id: uuid
  notebookId: uuid
}

"""
order by max() on columns of table "notebook_event"
"""
input notebook_event_max_order_by {
  creationDate: order_by
  creatorId: order_by
  eventDate: order_by
  id: order_by
  notebookId: order_by
}

"""aggregate min on columns"""
type notebook_event_min_fields {
  creationDate: timestamptz
  creatorId: uuid
  eventDate: timestamptz
  id: uuid
  notebookId: uuid
}

"""
order by min() on columns of table "notebook_event"
"""
input notebook_event_min_order_by {
  creationDate: order_by
  creatorId: order_by
  eventDate: order_by
  id: order_by
  notebookId: order_by
}

"""
response of any mutation on the table "notebook_event"
"""
type notebook_event_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notebook_event!]!
}

"""
on_conflict condition type for table "notebook_event"
"""
input notebook_event_on_conflict {
  constraint: notebook_event_constraint!
  update_columns: [notebook_event_update_column!]! = []
  where: notebook_event_bool_exp
}

"""Ordering options when selecting data from "notebook_event"."""
input notebook_event_order_by {
  creationDate: order_by
  creator: account_order_by
  creatorId: order_by
  event: order_by
  eventDate: order_by
  eventType: order_by
  id: order_by
  notebook: notebook_order_by
  notebookId: order_by
  notebook_event_type: notebook_event_type_order_by
}

"""primary key columns input for table: notebook_event"""
input notebook_event_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input notebook_event_prepend_input {
  event: jsonb
}

"""
select columns of table "notebook_event"
"""
enum notebook_event_select_column {
  """column name"""
  creationDate

  """column name"""
  creatorId

  """column name"""
  event

  """column name"""
  eventDate

  """column name"""
  eventType

  """column name"""
  id

  """column name"""
  notebookId
}

"""
input type for updating data in table "notebook_event"
"""
input notebook_event_set_input {
  creationDate: timestamptz
  creatorId: uuid
  event: jsonb
  eventDate: timestamptz
  eventType: notebook_event_type_enum
  id: uuid
  notebookId: uuid
}

"""
Streaming cursor of the table "notebook_event"
"""
input notebook_event_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notebook_event_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notebook_event_stream_cursor_value_input {
  creationDate: timestamptz
  creatorId: uuid
  event: jsonb
  eventDate: timestamptz
  eventType: notebook_event_type_enum
  id: uuid
  notebookId: uuid
}

"""
columns and relationships of "notebook_event_type"
"""
type notebook_event_type {
  comment: String!

  """An array relationship"""
  notebook_events(
    """distinct select on columns"""
    distinct_on: [notebook_event_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_event_order_by!]

    """filter the rows returned"""
    where: notebook_event_bool_exp
  ): [notebook_event!]!

  """An aggregate relationship"""
  notebook_events_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_event_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_event_order_by!]

    """filter the rows returned"""
    where: notebook_event_bool_exp
  ): notebook_event_aggregate!
  value: String!
}

"""
aggregated selection of "notebook_event_type"
"""
type notebook_event_type_aggregate {
  aggregate: notebook_event_type_aggregate_fields
  nodes: [notebook_event_type!]!
}

"""
aggregate fields of "notebook_event_type"
"""
type notebook_event_type_aggregate_fields {
  count(columns: [notebook_event_type_select_column!], distinct: Boolean): Int!
  max: notebook_event_type_max_fields
  min: notebook_event_type_min_fields
}

"""
Boolean expression to filter rows from the table "notebook_event_type". All fields are combined with a logical 'AND'.
"""
input notebook_event_type_bool_exp {
  _and: [notebook_event_type_bool_exp!]
  _not: notebook_event_type_bool_exp
  _or: [notebook_event_type_bool_exp!]
  comment: String_comparison_exp
  notebook_events: notebook_event_bool_exp
  notebook_events_aggregate: notebook_event_aggregate_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "notebook_event_type"
"""
enum notebook_event_type_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  notebook_event_type_pkey
}

enum notebook_event_type_enum {
  """Action d'un objectif"""
  action

  """Orientation ou r√©orientation"""
  orientation

  """Objectif d'un parcours"""
  target
}

"""
Boolean expression to compare columns of type "notebook_event_type_enum". All fields are combined with logical 'AND'.
"""
input notebook_event_type_enum_comparison_exp {
  _eq: notebook_event_type_enum
  _in: [notebook_event_type_enum!]
  _is_null: Boolean
  _neq: notebook_event_type_enum
  _nin: [notebook_event_type_enum!]
}

"""
input type for inserting data into table "notebook_event_type"
"""
input notebook_event_type_insert_input {
  comment: String
  notebook_events: notebook_event_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type notebook_event_type_max_fields {
  comment: String
  value: String
}

"""aggregate min on columns"""
type notebook_event_type_min_fields {
  comment: String
  value: String
}

"""
response of any mutation on the table "notebook_event_type"
"""
type notebook_event_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notebook_event_type!]!
}

"""
input type for inserting object relation for remote table "notebook_event_type"
"""
input notebook_event_type_obj_rel_insert_input {
  data: notebook_event_type_insert_input!

  """upsert condition"""
  on_conflict: notebook_event_type_on_conflict
}

"""
on_conflict condition type for table "notebook_event_type"
"""
input notebook_event_type_on_conflict {
  constraint: notebook_event_type_constraint!
  update_columns: [notebook_event_type_update_column!]! = []
  where: notebook_event_type_bool_exp
}

"""Ordering options when selecting data from "notebook_event_type"."""
input notebook_event_type_order_by {
  comment: order_by
  notebook_events_aggregate: notebook_event_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: notebook_event_type"""
input notebook_event_type_pk_columns_input {
  value: String!
}

"""
select columns of table "notebook_event_type"
"""
enum notebook_event_type_select_column {
  """column name"""
  comment

  """column name"""
  value
}

"""
input type for updating data in table "notebook_event_type"
"""
input notebook_event_type_set_input {
  comment: String
  value: String
}

"""
Streaming cursor of the table "notebook_event_type"
"""
input notebook_event_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notebook_event_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notebook_event_type_stream_cursor_value_input {
  comment: String
  value: String
}

"""
update columns of table "notebook_event_type"
"""
enum notebook_event_type_update_column {
  """column name"""
  comment

  """column name"""
  value
}

input notebook_event_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: notebook_event_type_set_input

  """filter the rows which have to be updated"""
  where: notebook_event_type_bool_exp!
}

"""
update columns of table "notebook_event"
"""
enum notebook_event_update_column {
  """column name"""
  creationDate

  """column name"""
  creatorId

  """column name"""
  event

  """column name"""
  eventDate

  """column name"""
  eventType

  """column name"""
  id

  """column name"""
  notebookId
}

input notebook_event_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: notebook_event_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: notebook_event_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: notebook_event_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: notebook_event_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: notebook_event_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: notebook_event_set_input

  """filter the rows which have to be updated"""
  where: notebook_event_bool_exp!
}

"""
columns and relationships of "notebook_focus"
"""
type notebook_focus {
  createdAt: timestamptz!

  """An object relationship"""
  creator: account!
  creatorId: uuid!
  id: uuid!

  """An object relationship"""
  notebook: notebook!
  notebookId: uuid!

  """An array relationship"""
  targets(
    """distinct select on columns"""
    distinct_on: [notebook_target_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_target_order_by!]

    """filter the rows returned"""
    where: notebook_target_bool_exp
  ): [notebook_target!]!

  """An aggregate relationship"""
  targets_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_target_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_target_order_by!]

    """filter the rows returned"""
    where: notebook_target_bool_exp
  ): notebook_target_aggregate!
  theme: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "notebook_focus"
"""
type notebook_focus_aggregate {
  aggregate: notebook_focus_aggregate_fields
  nodes: [notebook_focus!]!
}

input notebook_focus_aggregate_bool_exp {
  count: notebook_focus_aggregate_bool_exp_count
}

input notebook_focus_aggregate_bool_exp_count {
  arguments: [notebook_focus_select_column!]
  distinct: Boolean
  filter: notebook_focus_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "notebook_focus"
"""
type notebook_focus_aggregate_fields {
  count(columns: [notebook_focus_select_column!], distinct: Boolean): Int!
  max: notebook_focus_max_fields
  min: notebook_focus_min_fields
}

"""
order by aggregate values of table "notebook_focus"
"""
input notebook_focus_aggregate_order_by {
  count: order_by
  max: notebook_focus_max_order_by
  min: notebook_focus_min_order_by
}

"""
input type for inserting array relation for remote table "notebook_focus"
"""
input notebook_focus_arr_rel_insert_input {
  data: [notebook_focus_insert_input!]!

  """upsert condition"""
  on_conflict: notebook_focus_on_conflict
}

"""
Boolean expression to filter rows from the table "notebook_focus". All fields are combined with a logical 'AND'.
"""
input notebook_focus_bool_exp {
  _and: [notebook_focus_bool_exp!]
  _not: notebook_focus_bool_exp
  _or: [notebook_focus_bool_exp!]
  createdAt: timestamptz_comparison_exp
  creator: account_bool_exp
  creatorId: uuid_comparison_exp
  id: uuid_comparison_exp
  notebook: notebook_bool_exp
  notebookId: uuid_comparison_exp
  targets: notebook_target_bool_exp
  targets_aggregate: notebook_target_aggregate_bool_exp
  theme: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "notebook_focus"
"""
enum notebook_focus_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  notebook_focus_pkey
}

"""
input type for inserting data into table "notebook_focus"
"""
input notebook_focus_insert_input {
  createdAt: timestamptz
  creator: account_obj_rel_insert_input
  creatorId: uuid
  id: uuid
  notebook: notebook_obj_rel_insert_input
  notebookId: uuid
  targets: notebook_target_arr_rel_insert_input
  theme: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type notebook_focus_max_fields {
  createdAt: timestamptz
  creatorId: uuid
  id: uuid
  notebookId: uuid
  theme: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "notebook_focus"
"""
input notebook_focus_max_order_by {
  createdAt: order_by
  creatorId: order_by
  id: order_by
  notebookId: order_by
  theme: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type notebook_focus_min_fields {
  createdAt: timestamptz
  creatorId: uuid
  id: uuid
  notebookId: uuid
  theme: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "notebook_focus"
"""
input notebook_focus_min_order_by {
  createdAt: order_by
  creatorId: order_by
  id: order_by
  notebookId: order_by
  theme: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "notebook_focus"
"""
type notebook_focus_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notebook_focus!]!
}

"""
input type for inserting object relation for remote table "notebook_focus"
"""
input notebook_focus_obj_rel_insert_input {
  data: notebook_focus_insert_input!

  """upsert condition"""
  on_conflict: notebook_focus_on_conflict
}

"""
on_conflict condition type for table "notebook_focus"
"""
input notebook_focus_on_conflict {
  constraint: notebook_focus_constraint!
  update_columns: [notebook_focus_update_column!]! = []
  where: notebook_focus_bool_exp
}

"""Ordering options when selecting data from "notebook_focus"."""
input notebook_focus_order_by {
  createdAt: order_by
  creator: account_order_by
  creatorId: order_by
  id: order_by
  notebook: notebook_order_by
  notebookId: order_by
  targets_aggregate: notebook_target_aggregate_order_by
  theme: order_by
  updatedAt: order_by
}

"""primary key columns input for table: notebook_focus"""
input notebook_focus_pk_columns_input {
  id: uuid!
}

"""
select columns of table "notebook_focus"
"""
enum notebook_focus_select_column {
  """column name"""
  createdAt

  """column name"""
  creatorId

  """column name"""
  id

  """column name"""
  notebookId

  """column name"""
  theme

  """column name"""
  updatedAt
}

"""
input type for updating data in table "notebook_focus"
"""
input notebook_focus_set_input {
  createdAt: timestamptz
  creatorId: uuid
  id: uuid
  notebookId: uuid
  theme: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "notebook_focus"
"""
input notebook_focus_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notebook_focus_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notebook_focus_stream_cursor_value_input {
  createdAt: timestamptz
  creatorId: uuid
  id: uuid
  notebookId: uuid
  theme: String
  updatedAt: timestamptz
}

"""
update columns of table "notebook_focus"
"""
enum notebook_focus_update_column {
  """column name"""
  createdAt

  """column name"""
  creatorId

  """column name"""
  id

  """column name"""
  notebookId

  """column name"""
  theme

  """column name"""
  updatedAt
}

input notebook_focus_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: notebook_focus_set_input

  """filter the rows which have to be updated"""
  where: notebook_focus_bool_exp!
}

"""notebook orientation infos"""
type notebook_info {
  createdAt: timestamptz!

  """An object relationship"""
  notebook: notebook!
  notebookId: uuid!

  """motif de l'orientation, saisi par le charg√© d'orientation"""
  orientationReason: String

  """An object relationship"""
  orientationSystem: orientation_system
  orientationSystemId: uuid
  updatedAt: timestamptz!
}

"""
aggregated selection of "notebook_info"
"""
type notebook_info_aggregate {
  aggregate: notebook_info_aggregate_fields
  nodes: [notebook_info!]!
}

"""
aggregate fields of "notebook_info"
"""
type notebook_info_aggregate_fields {
  count(columns: [notebook_info_select_column!], distinct: Boolean): Int!
  max: notebook_info_max_fields
  min: notebook_info_min_fields
}

"""
Boolean expression to filter rows from the table "notebook_info". All fields are combined with a logical 'AND'.
"""
input notebook_info_bool_exp {
  _and: [notebook_info_bool_exp!]
  _not: notebook_info_bool_exp
  _or: [notebook_info_bool_exp!]
  createdAt: timestamptz_comparison_exp
  notebook: notebook_bool_exp
  notebookId: uuid_comparison_exp
  orientationReason: String_comparison_exp
  orientationSystem: orientation_system_bool_exp
  orientationSystemId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "notebook_info"
"""
enum notebook_info_constraint {
  """
  unique or primary key constraint on columns "notebook_id"
  """
  notebook_info_pkey
}

"""
input type for inserting data into table "notebook_info"
"""
input notebook_info_insert_input {
  createdAt: timestamptz
  notebook: notebook_obj_rel_insert_input
  notebookId: uuid

  """motif de l'orientation, saisi par le charg√© d'orientation"""
  orientationReason: String
  orientationSystem: orientation_system_obj_rel_insert_input
  orientationSystemId: uuid
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type notebook_info_max_fields {
  createdAt: timestamptz
  notebookId: uuid

  """motif de l'orientation, saisi par le charg√© d'orientation"""
  orientationReason: String
  orientationSystemId: uuid
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type notebook_info_min_fields {
  createdAt: timestamptz
  notebookId: uuid

  """motif de l'orientation, saisi par le charg√© d'orientation"""
  orientationReason: String
  orientationSystemId: uuid
  updatedAt: timestamptz
}

"""
response of any mutation on the table "notebook_info"
"""
type notebook_info_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notebook_info!]!
}

"""
input type for inserting object relation for remote table "notebook_info"
"""
input notebook_info_obj_rel_insert_input {
  data: notebook_info_insert_input!

  """upsert condition"""
  on_conflict: notebook_info_on_conflict
}

"""
on_conflict condition type for table "notebook_info"
"""
input notebook_info_on_conflict {
  constraint: notebook_info_constraint!
  update_columns: [notebook_info_update_column!]! = []
  where: notebook_info_bool_exp
}

"""Ordering options when selecting data from "notebook_info"."""
input notebook_info_order_by {
  createdAt: order_by
  notebook: notebook_order_by
  notebookId: order_by
  orientationReason: order_by
  orientationSystem: orientation_system_order_by
  orientationSystemId: order_by
  updatedAt: order_by
}

"""primary key columns input for table: notebook_info"""
input notebook_info_pk_columns_input {
  notebookId: uuid!
}

"""
select columns of table "notebook_info"
"""
enum notebook_info_select_column {
  """column name"""
  createdAt

  """column name"""
  notebookId

  """column name"""
  orientationReason

  """column name"""
  orientationSystemId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "notebook_info"
"""
input notebook_info_set_input {
  createdAt: timestamptz
  notebookId: uuid

  """motif de l'orientation, saisi par le charg√© d'orientation"""
  orientationReason: String
  orientationSystemId: uuid
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "notebook_info"
"""
input notebook_info_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notebook_info_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notebook_info_stream_cursor_value_input {
  createdAt: timestamptz
  notebookId: uuid

  """motif de l'orientation, saisi par le charg√© d'orientation"""
  orientationReason: String
  orientationSystemId: uuid
  updatedAt: timestamptz
}

"""
update columns of table "notebook_info"
"""
enum notebook_info_update_column {
  """column name"""
  createdAt

  """column name"""
  notebookId

  """column name"""
  orientationReason

  """column name"""
  orientationSystemId

  """column name"""
  updatedAt
}

input notebook_info_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: notebook_info_set_input

  """filter the rows which have to be updated"""
  where: notebook_info_bool_exp!
}

"""
input type for inserting data into table "notebook"
"""
input notebook_insert_input {
  appointments: notebook_appointment_arr_rel_insert_input
  beneficiary: beneficiary_obj_rel_insert_input
  beneficiaryId: uuid
  contractEndDate: date
  contractSignDate: date
  contractStartDate: date
  contractType: String
  createdAt: timestamptz
  diagnosticFetchedAt: timestamptz
  educationLevel: String
  events: notebook_event_arr_rel_insert_input
  focuses: notebook_focus_arr_rel_insert_input
  id: uuid
  lastJobEndedAt: date
  members: notebook_member_arr_rel_insert_input
  notebookInfo: notebook_info_obj_rel_insert_input
  professionalProjects: professional_project_arr_rel_insert_input
  rightRqth: Boolean
  situations: notebook_situation_arr_rel_insert_input
  updatedAt: timestamptz
  workSituation: String
  workSituationDate: date
  workSituationEndDate: date
}

"""aggregate max on columns"""
type notebook_max_fields {
  beneficiaryId: uuid
  contractEndDate: date
  contractSignDate: date
  contractStartDate: date
  contractType: String
  createdAt: timestamptz
  diagnosticFetchedAt: timestamptz
  educationLevel: String
  id: uuid
  lastJobEndedAt: date
  updatedAt: timestamptz
  workSituation: String
  workSituationDate: date
  workSituationEndDate: date
}

"""
columns and relationships of "notebook_member"
"""
type notebook_member {
  """An object relationship"""
  account: account!
  accountId: uuid!
  active: Boolean!
  createdAt: timestamptz!

  """An object relationship"""
  creator: account
  creatorId: uuid
  id: uuid!
  invitationSendAt: timestamptz
  lastModifiedAt: timestamptz
  lastVisitedAt: timestamptz
  memberType: String!
  membershipEndedAt: timestamptz

  """An object relationship"""
  notebook: notebook!
  notebookId: uuid!
}

"""
aggregated selection of "notebook_member"
"""
type notebook_member_aggregate {
  aggregate: notebook_member_aggregate_fields
  nodes: [notebook_member!]!
}

input notebook_member_aggregate_bool_exp {
  bool_and: notebook_member_aggregate_bool_exp_bool_and
  bool_or: notebook_member_aggregate_bool_exp_bool_or
  count: notebook_member_aggregate_bool_exp_count
}

input notebook_member_aggregate_bool_exp_bool_and {
  arguments: notebook_member_select_column_notebook_member_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: notebook_member_bool_exp
  predicate: Boolean_comparison_exp!
}

input notebook_member_aggregate_bool_exp_bool_or {
  arguments: notebook_member_select_column_notebook_member_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: notebook_member_bool_exp
  predicate: Boolean_comparison_exp!
}

input notebook_member_aggregate_bool_exp_count {
  arguments: [notebook_member_select_column!]
  distinct: Boolean
  filter: notebook_member_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "notebook_member"
"""
type notebook_member_aggregate_fields {
  count(columns: [notebook_member_select_column!], distinct: Boolean): Int!
  max: notebook_member_max_fields
  min: notebook_member_min_fields
}

"""
order by aggregate values of table "notebook_member"
"""
input notebook_member_aggregate_order_by {
  count: order_by
  max: notebook_member_max_order_by
  min: notebook_member_min_order_by
}

"""
input type for inserting array relation for remote table "notebook_member"
"""
input notebook_member_arr_rel_insert_input {
  data: [notebook_member_insert_input!]!

  """upsert condition"""
  on_conflict: notebook_member_on_conflict
}

"""
Boolean expression to filter rows from the table "notebook_member". All fields are combined with a logical 'AND'.
"""
input notebook_member_bool_exp {
  _and: [notebook_member_bool_exp!]
  _not: notebook_member_bool_exp
  _or: [notebook_member_bool_exp!]
  account: account_bool_exp
  accountId: uuid_comparison_exp
  active: Boolean_comparison_exp
  createdAt: timestamptz_comparison_exp
  creator: account_bool_exp
  creatorId: uuid_comparison_exp
  id: uuid_comparison_exp
  invitationSendAt: timestamptz_comparison_exp
  lastModifiedAt: timestamptz_comparison_exp
  lastVisitedAt: timestamptz_comparison_exp
  memberType: String_comparison_exp
  membershipEndedAt: timestamptz_comparison_exp
  notebook: notebook_bool_exp
  notebookId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "notebook_member"
"""
enum notebook_member_constraint {
  """
  unique or primary key constraint on columns "account_id", "notebook_id"
  """
  notebook_member_notebook_id_account_id_if_active

  """
  unique or primary key constraint on columns "id"
  """
  notebook_member_pkey

  """
  unique or primary key constraint on columns "notebook_id"
  """
  notebook_member_unique_referent
}

"""
input type for inserting data into table "notebook_member"
"""
input notebook_member_insert_input {
  account: account_obj_rel_insert_input
  accountId: uuid
  active: Boolean
  createdAt: timestamptz
  creator: account_obj_rel_insert_input
  creatorId: uuid
  id: uuid
  invitationSendAt: timestamptz
  lastModifiedAt: timestamptz
  lastVisitedAt: timestamptz
  memberType: String
  membershipEndedAt: timestamptz
  notebook: notebook_obj_rel_insert_input
  notebookId: uuid
}

"""aggregate max on columns"""
type notebook_member_max_fields {
  accountId: uuid
  createdAt: timestamptz
  creatorId: uuid
  id: uuid
  invitationSendAt: timestamptz
  lastModifiedAt: timestamptz
  lastVisitedAt: timestamptz
  memberType: String
  membershipEndedAt: timestamptz
  notebookId: uuid
}

"""
order by max() on columns of table "notebook_member"
"""
input notebook_member_max_order_by {
  accountId: order_by
  createdAt: order_by
  creatorId: order_by
  id: order_by
  invitationSendAt: order_by
  lastModifiedAt: order_by
  lastVisitedAt: order_by
  memberType: order_by
  membershipEndedAt: order_by
  notebookId: order_by
}

"""aggregate min on columns"""
type notebook_member_min_fields {
  accountId: uuid
  createdAt: timestamptz
  creatorId: uuid
  id: uuid
  invitationSendAt: timestamptz
  lastModifiedAt: timestamptz
  lastVisitedAt: timestamptz
  memberType: String
  membershipEndedAt: timestamptz
  notebookId: uuid
}

"""
order by min() on columns of table "notebook_member"
"""
input notebook_member_min_order_by {
  accountId: order_by
  createdAt: order_by
  creatorId: order_by
  id: order_by
  invitationSendAt: order_by
  lastModifiedAt: order_by
  lastVisitedAt: order_by
  memberType: order_by
  membershipEndedAt: order_by
  notebookId: order_by
}

"""
response of any mutation on the table "notebook_member"
"""
type notebook_member_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notebook_member!]!
}

"""
on_conflict condition type for table "notebook_member"
"""
input notebook_member_on_conflict {
  constraint: notebook_member_constraint!
  update_columns: [notebook_member_update_column!]! = []
  where: notebook_member_bool_exp
}

"""Ordering options when selecting data from "notebook_member"."""
input notebook_member_order_by {
  account: account_order_by
  accountId: order_by
  active: order_by
  createdAt: order_by
  creator: account_order_by
  creatorId: order_by
  id: order_by
  invitationSendAt: order_by
  lastModifiedAt: order_by
  lastVisitedAt: order_by
  memberType: order_by
  membershipEndedAt: order_by
  notebook: notebook_order_by
  notebookId: order_by
}

"""primary key columns input for table: notebook_member"""
input notebook_member_pk_columns_input {
  id: uuid!
}

"""
select columns of table "notebook_member"
"""
enum notebook_member_select_column {
  """column name"""
  accountId

  """column name"""
  active

  """column name"""
  createdAt

  """column name"""
  creatorId

  """column name"""
  id

  """column name"""
  invitationSendAt

  """column name"""
  lastModifiedAt

  """column name"""
  lastVisitedAt

  """column name"""
  memberType

  """column name"""
  membershipEndedAt

  """column name"""
  notebookId
}

"""
select "notebook_member_aggregate_bool_exp_bool_and_arguments_columns" columns of table "notebook_member"
"""
enum notebook_member_select_column_notebook_member_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  active
}

"""
select "notebook_member_aggregate_bool_exp_bool_or_arguments_columns" columns of table "notebook_member"
"""
enum notebook_member_select_column_notebook_member_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  active
}

"""
input type for updating data in table "notebook_member"
"""
input notebook_member_set_input {
  accountId: uuid
  active: Boolean
  createdAt: timestamptz
  creatorId: uuid
  id: uuid
  invitationSendAt: timestamptz
  lastModifiedAt: timestamptz
  lastVisitedAt: timestamptz
  memberType: String
  membershipEndedAt: timestamptz
  notebookId: uuid
}

"""
Streaming cursor of the table "notebook_member"
"""
input notebook_member_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notebook_member_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notebook_member_stream_cursor_value_input {
  accountId: uuid
  active: Boolean
  createdAt: timestamptz
  creatorId: uuid
  id: uuid
  invitationSendAt: timestamptz
  lastModifiedAt: timestamptz
  lastVisitedAt: timestamptz
  memberType: String
  membershipEndedAt: timestamptz
  notebookId: uuid
}

"""
update columns of table "notebook_member"
"""
enum notebook_member_update_column {
  """column name"""
  accountId

  """column name"""
  active

  """column name"""
  createdAt

  """column name"""
  creatorId

  """column name"""
  id

  """column name"""
  invitationSendAt

  """column name"""
  lastModifiedAt

  """column name"""
  lastVisitedAt

  """column name"""
  memberType

  """column name"""
  membershipEndedAt

  """column name"""
  notebookId
}

input notebook_member_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: notebook_member_set_input

  """filter the rows which have to be updated"""
  where: notebook_member_bool_exp!
}

"""aggregate min on columns"""
type notebook_min_fields {
  beneficiaryId: uuid
  contractEndDate: date
  contractSignDate: date
  contractStartDate: date
  contractType: String
  createdAt: timestamptz
  diagnosticFetchedAt: timestamptz
  educationLevel: String
  id: uuid
  lastJobEndedAt: date
  updatedAt: timestamptz
  workSituation: String
  workSituationDate: date
  workSituationEndDate: date
}

"""
response of any mutation on the table "notebook"
"""
type notebook_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notebook!]!
}

"""
input type for inserting object relation for remote table "notebook"
"""
input notebook_obj_rel_insert_input {
  data: notebook_insert_input!

  """upsert condition"""
  on_conflict: notebook_on_conflict
}

"""
on_conflict condition type for table "notebook"
"""
input notebook_on_conflict {
  constraint: notebook_constraint!
  update_columns: [notebook_update_column!]! = []
  where: notebook_bool_exp
}

"""Ordering options when selecting data from "notebook"."""
input notebook_order_by {
  appointments_aggregate: notebook_appointment_aggregate_order_by
  beneficiary: beneficiary_order_by
  beneficiaryId: order_by
  contractEndDate: order_by
  contractSignDate: order_by
  contractStartDate: order_by
  contractType: order_by
  createdAt: order_by
  diagnosticFetchedAt: order_by
  educationLevel: order_by
  events_aggregate: notebook_event_aggregate_order_by
  focuses_aggregate: notebook_focus_aggregate_order_by
  id: order_by
  lastJobEndedAt: order_by
  members_aggregate: notebook_member_aggregate_order_by
  notebookInfo: notebook_info_order_by
  professionalProjects_aggregate: professional_project_aggregate_order_by
  rightRqth: order_by
  situations_aggregate: notebook_situation_aggregate_order_by
  updatedAt: order_by
  workSituation: order_by
  workSituationDate: order_by
  workSituationEndDate: order_by
}

"""primary key columns input for table: notebook"""
input notebook_pk_columns_input {
  id: uuid!
}

"""
columns and relationships of "notebook_public_view"
"""
type notebook_public_view {
  """An object relationship"""
  beneficiary: beneficiary
  beneficiary_id: uuid
  created_at: timestamptz
  id: uuid

  """An array relationship"""
  members(
    """distinct select on columns"""
    distinct_on: [notebook_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_member_order_by!]

    """filter the rows returned"""
    where: notebook_member_bool_exp
  ): [notebook_member!]!

  """An aggregate relationship"""
  members_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_member_order_by!]

    """filter the rows returned"""
    where: notebook_member_bool_exp
  ): notebook_member_aggregate!

  """An object relationship"""
  notebook: notebook
  updated_at: timestamptz
}

"""
aggregated selection of "notebook_public_view"
"""
type notebook_public_view_aggregate {
  aggregate: notebook_public_view_aggregate_fields
  nodes: [notebook_public_view!]!
}

"""
aggregate fields of "notebook_public_view"
"""
type notebook_public_view_aggregate_fields {
  count(columns: [notebook_public_view_select_column!], distinct: Boolean): Int!
  max: notebook_public_view_max_fields
  min: notebook_public_view_min_fields
}

"""
Boolean expression to filter rows from the table "notebook_public_view". All fields are combined with a logical 'AND'.
"""
input notebook_public_view_bool_exp {
  _and: [notebook_public_view_bool_exp!]
  _not: notebook_public_view_bool_exp
  _or: [notebook_public_view_bool_exp!]
  beneficiary: beneficiary_bool_exp
  beneficiary_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  members: notebook_member_bool_exp
  members_aggregate: notebook_member_aggregate_bool_exp
  notebook: notebook_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
input type for inserting data into table "notebook_public_view"
"""
input notebook_public_view_insert_input {
  beneficiary: beneficiary_obj_rel_insert_input
  beneficiary_id: uuid
  created_at: timestamptz
  id: uuid
  members: notebook_member_arr_rel_insert_input
  notebook: notebook_obj_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type notebook_public_view_max_fields {
  beneficiary_id: uuid
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type notebook_public_view_min_fields {
  beneficiary_id: uuid
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "notebook_public_view"
"""
type notebook_public_view_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notebook_public_view!]!
}

"""
input type for inserting object relation for remote table "notebook_public_view"
"""
input notebook_public_view_obj_rel_insert_input {
  data: notebook_public_view_insert_input!
}

"""Ordering options when selecting data from "notebook_public_view"."""
input notebook_public_view_order_by {
  beneficiary: beneficiary_order_by
  beneficiary_id: order_by
  created_at: order_by
  id: order_by
  members_aggregate: notebook_member_aggregate_order_by
  notebook: notebook_order_by
  updated_at: order_by
}

"""
select columns of table "notebook_public_view"
"""
enum notebook_public_view_select_column {
  """column name"""
  beneficiary_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  updated_at
}

"""
input type for updating data in table "notebook_public_view"
"""
input notebook_public_view_set_input {
  beneficiary_id: uuid
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "notebook_public_view"
"""
input notebook_public_view_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notebook_public_view_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notebook_public_view_stream_cursor_value_input {
  beneficiary_id: uuid
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

input notebook_public_view_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: notebook_public_view_set_input

  """filter the rows which have to be updated"""
  where: notebook_public_view_bool_exp!
}

"""
select columns of table "notebook"
"""
enum notebook_select_column {
  """column name"""
  beneficiaryId

  """column name"""
  contractEndDate

  """column name"""
  contractSignDate

  """column name"""
  contractStartDate

  """column name"""
  contractType

  """column name"""
  createdAt

  """column name"""
  diagnosticFetchedAt

  """column name"""
  educationLevel

  """column name"""
  id

  """column name"""
  lastJobEndedAt

  """column name"""
  rightRqth

  """column name"""
  updatedAt

  """column name"""
  workSituation

  """column name"""
  workSituationDate

  """column name"""
  workSituationEndDate
}

"""
input type for updating data in table "notebook"
"""
input notebook_set_input {
  beneficiaryId: uuid
  contractEndDate: date
  contractSignDate: date
  contractStartDate: date
  contractType: String
  createdAt: timestamptz
  diagnosticFetchedAt: timestamptz
  educationLevel: String
  id: uuid
  lastJobEndedAt: date
  rightRqth: Boolean
  updatedAt: timestamptz
  workSituation: String
  workSituationDate: date
  workSituationEndDate: date
}

"""
columns and relationships of "notebook_situation"
"""
type notebook_situation {
  createdAt: timestamptz!
  createdBy: uuid

  """An object relationship"""
  creator: account
  deletedAt: timestamptz
  deletedBy: uuid

  """An object relationship"""
  deletor: account
  id: uuid!

  """An object relationship"""
  notebook: notebook
  notebookId: uuid!

  """An object relationship"""
  refSituation: ref_situation
  situationId: uuid!
}

"""
aggregated selection of "notebook_situation"
"""
type notebook_situation_aggregate {
  aggregate: notebook_situation_aggregate_fields
  nodes: [notebook_situation!]!
}

input notebook_situation_aggregate_bool_exp {
  count: notebook_situation_aggregate_bool_exp_count
}

input notebook_situation_aggregate_bool_exp_count {
  arguments: [notebook_situation_select_column!]
  distinct: Boolean
  filter: notebook_situation_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "notebook_situation"
"""
type notebook_situation_aggregate_fields {
  count(columns: [notebook_situation_select_column!], distinct: Boolean): Int!
  max: notebook_situation_max_fields
  min: notebook_situation_min_fields
}

"""
order by aggregate values of table "notebook_situation"
"""
input notebook_situation_aggregate_order_by {
  count: order_by
  max: notebook_situation_max_order_by
  min: notebook_situation_min_order_by
}

"""
input type for inserting array relation for remote table "notebook_situation"
"""
input notebook_situation_arr_rel_insert_input {
  data: [notebook_situation_insert_input!]!

  """upsert condition"""
  on_conflict: notebook_situation_on_conflict
}

"""
Boolean expression to filter rows from the table "notebook_situation". All fields are combined with a logical 'AND'.
"""
input notebook_situation_bool_exp {
  _and: [notebook_situation_bool_exp!]
  _not: notebook_situation_bool_exp
  _or: [notebook_situation_bool_exp!]
  createdAt: timestamptz_comparison_exp
  createdBy: uuid_comparison_exp
  creator: account_bool_exp
  deletedAt: timestamptz_comparison_exp
  deletedBy: uuid_comparison_exp
  deletor: account_bool_exp
  id: uuid_comparison_exp
  notebook: notebook_bool_exp
  notebookId: uuid_comparison_exp
  refSituation: ref_situation_bool_exp
  situationId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "notebook_situation"
"""
enum notebook_situation_constraint {
  """
  unique or primary key constraint on columns "situation_id", "deleted_at", "notebook_id"
  """
  notebook_situation_notebook_id_situation_id_deleted_at_key

  """
  unique or primary key constraint on columns "id"
  """
  notebook_situation_pkey
}

"""
input type for inserting data into table "notebook_situation"
"""
input notebook_situation_insert_input {
  createdAt: timestamptz
  createdBy: uuid
  creator: account_obj_rel_insert_input
  deletedAt: timestamptz
  deletedBy: uuid
  deletor: account_obj_rel_insert_input
  id: uuid
  notebook: notebook_obj_rel_insert_input
  notebookId: uuid
  refSituation: ref_situation_obj_rel_insert_input
  situationId: uuid
}

"""aggregate max on columns"""
type notebook_situation_max_fields {
  createdAt: timestamptz
  createdBy: uuid
  deletedAt: timestamptz
  deletedBy: uuid
  id: uuid
  notebookId: uuid
  situationId: uuid
}

"""
order by max() on columns of table "notebook_situation"
"""
input notebook_situation_max_order_by {
  createdAt: order_by
  createdBy: order_by
  deletedAt: order_by
  deletedBy: order_by
  id: order_by
  notebookId: order_by
  situationId: order_by
}

"""aggregate min on columns"""
type notebook_situation_min_fields {
  createdAt: timestamptz
  createdBy: uuid
  deletedAt: timestamptz
  deletedBy: uuid
  id: uuid
  notebookId: uuid
  situationId: uuid
}

"""
order by min() on columns of table "notebook_situation"
"""
input notebook_situation_min_order_by {
  createdAt: order_by
  createdBy: order_by
  deletedAt: order_by
  deletedBy: order_by
  id: order_by
  notebookId: order_by
  situationId: order_by
}

"""
response of any mutation on the table "notebook_situation"
"""
type notebook_situation_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notebook_situation!]!
}

"""
on_conflict condition type for table "notebook_situation"
"""
input notebook_situation_on_conflict {
  constraint: notebook_situation_constraint!
  update_columns: [notebook_situation_update_column!]! = []
  where: notebook_situation_bool_exp
}

"""Ordering options when selecting data from "notebook_situation"."""
input notebook_situation_order_by {
  createdAt: order_by
  createdBy: order_by
  creator: account_order_by
  deletedAt: order_by
  deletedBy: order_by
  deletor: account_order_by
  id: order_by
  notebook: notebook_order_by
  notebookId: order_by
  refSituation: ref_situation_order_by
  situationId: order_by
}

"""primary key columns input for table: notebook_situation"""
input notebook_situation_pk_columns_input {
  id: uuid!
}

"""
select columns of table "notebook_situation"
"""
enum notebook_situation_select_column {
  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  deletedAt

  """column name"""
  deletedBy

  """column name"""
  id

  """column name"""
  notebookId

  """column name"""
  situationId
}

"""
input type for updating data in table "notebook_situation"
"""
input notebook_situation_set_input {
  createdAt: timestamptz
  createdBy: uuid
  deletedAt: timestamptz
  deletedBy: uuid
  id: uuid
  notebookId: uuid
  situationId: uuid
}

"""
Streaming cursor of the table "notebook_situation"
"""
input notebook_situation_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notebook_situation_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notebook_situation_stream_cursor_value_input {
  createdAt: timestamptz
  createdBy: uuid
  deletedAt: timestamptz
  deletedBy: uuid
  id: uuid
  notebookId: uuid
  situationId: uuid
}

"""
update columns of table "notebook_situation"
"""
enum notebook_situation_update_column {
  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  deletedAt

  """column name"""
  deletedBy

  """column name"""
  id

  """column name"""
  notebookId

  """column name"""
  situationId
}

input notebook_situation_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: notebook_situation_set_input

  """filter the rows which have to be updated"""
  where: notebook_situation_bool_exp!
}

"""
Streaming cursor of the table "notebook"
"""
input notebook_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notebook_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notebook_stream_cursor_value_input {
  beneficiaryId: uuid
  contractEndDate: date
  contractSignDate: date
  contractStartDate: date
  contractType: String
  createdAt: timestamptz
  diagnosticFetchedAt: timestamptz
  educationLevel: String
  id: uuid
  lastJobEndedAt: date
  rightRqth: Boolean
  updatedAt: timestamptz
  workSituation: String
  workSituationDate: date
  workSituationEndDate: date
}

"""
columns and relationships of "notebook_target"
"""
type notebook_target {
  """An array relationship"""
  actions(
    """distinct select on columns"""
    distinct_on: [notebook_action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_action_order_by!]

    """filter the rows returned"""
    where: notebook_action_bool_exp
  ): [notebook_action!]!

  """An aggregate relationship"""
  actions_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_action_order_by!]

    """filter the rows returned"""
    where: notebook_action_bool_exp
  ): notebook_action_aggregate!
  createdAt: timestamptz!

  """An object relationship"""
  creator: account!
  creatorId: uuid!

  """An object relationship"""
  focus: notebook_focus!
  focusId: uuid!
  id: uuid!
  linkedTo: String
  status: String!
  target: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "notebook_target"
"""
type notebook_target_aggregate {
  aggregate: notebook_target_aggregate_fields
  nodes: [notebook_target!]!
}

input notebook_target_aggregate_bool_exp {
  count: notebook_target_aggregate_bool_exp_count
}

input notebook_target_aggregate_bool_exp_count {
  arguments: [notebook_target_select_column!]
  distinct: Boolean
  filter: notebook_target_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "notebook_target"
"""
type notebook_target_aggregate_fields {
  count(columns: [notebook_target_select_column!], distinct: Boolean): Int!
  max: notebook_target_max_fields
  min: notebook_target_min_fields
}

"""
order by aggregate values of table "notebook_target"
"""
input notebook_target_aggregate_order_by {
  count: order_by
  max: notebook_target_max_order_by
  min: notebook_target_min_order_by
}

"""
input type for inserting array relation for remote table "notebook_target"
"""
input notebook_target_arr_rel_insert_input {
  data: [notebook_target_insert_input!]!

  """upsert condition"""
  on_conflict: notebook_target_on_conflict
}

"""
Boolean expression to filter rows from the table "notebook_target". All fields are combined with a logical 'AND'.
"""
input notebook_target_bool_exp {
  _and: [notebook_target_bool_exp!]
  _not: notebook_target_bool_exp
  _or: [notebook_target_bool_exp!]
  actions: notebook_action_bool_exp
  actions_aggregate: notebook_action_aggregate_bool_exp
  createdAt: timestamptz_comparison_exp
  creator: account_bool_exp
  creatorId: uuid_comparison_exp
  focus: notebook_focus_bool_exp
  focusId: uuid_comparison_exp
  id: uuid_comparison_exp
  linkedTo: String_comparison_exp
  status: String_comparison_exp
  target: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "notebook_target"
"""
enum notebook_target_constraint {
  """
  unique or primary key constraint on columns "focus_id", "target"
  """
  notebook_target_focus_id_target_key

  """
  unique or primary key constraint on columns "id"
  """
  notebook_target_pkey
}

"""
input type for inserting data into table "notebook_target"
"""
input notebook_target_insert_input {
  actions: notebook_action_arr_rel_insert_input
  createdAt: timestamptz
  creator: account_obj_rel_insert_input
  creatorId: uuid
  focus: notebook_focus_obj_rel_insert_input
  focusId: uuid
  id: uuid
  linkedTo: String
  status: String
  target: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type notebook_target_max_fields {
  createdAt: timestamptz
  creatorId: uuid
  focusId: uuid
  id: uuid
  linkedTo: String
  status: String
  target: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "notebook_target"
"""
input notebook_target_max_order_by {
  createdAt: order_by
  creatorId: order_by
  focusId: order_by
  id: order_by
  linkedTo: order_by
  status: order_by
  target: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type notebook_target_min_fields {
  createdAt: timestamptz
  creatorId: uuid
  focusId: uuid
  id: uuid
  linkedTo: String
  status: String
  target: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "notebook_target"
"""
input notebook_target_min_order_by {
  createdAt: order_by
  creatorId: order_by
  focusId: order_by
  id: order_by
  linkedTo: order_by
  status: order_by
  target: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "notebook_target"
"""
type notebook_target_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notebook_target!]!
}

"""
input type for inserting object relation for remote table "notebook_target"
"""
input notebook_target_obj_rel_insert_input {
  data: notebook_target_insert_input!

  """upsert condition"""
  on_conflict: notebook_target_on_conflict
}

"""
on_conflict condition type for table "notebook_target"
"""
input notebook_target_on_conflict {
  constraint: notebook_target_constraint!
  update_columns: [notebook_target_update_column!]! = []
  where: notebook_target_bool_exp
}

"""Ordering options when selecting data from "notebook_target"."""
input notebook_target_order_by {
  actions_aggregate: notebook_action_aggregate_order_by
  createdAt: order_by
  creator: account_order_by
  creatorId: order_by
  focus: notebook_focus_order_by
  focusId: order_by
  id: order_by
  linkedTo: order_by
  status: order_by
  target: order_by
  updatedAt: order_by
}

"""primary key columns input for table: notebook_target"""
input notebook_target_pk_columns_input {
  id: uuid!
}

"""
select columns of table "notebook_target"
"""
enum notebook_target_select_column {
  """column name"""
  createdAt

  """column name"""
  creatorId

  """column name"""
  focusId

  """column name"""
  id

  """column name"""
  linkedTo

  """column name"""
  status

  """column name"""
  target

  """column name"""
  updatedAt
}

"""
input type for updating data in table "notebook_target"
"""
input notebook_target_set_input {
  createdAt: timestamptz
  creatorId: uuid
  focusId: uuid
  id: uuid
  linkedTo: String
  status: String
  target: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "notebook_target"
"""
input notebook_target_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notebook_target_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notebook_target_stream_cursor_value_input {
  createdAt: timestamptz
  creatorId: uuid
  focusId: uuid
  id: uuid
  linkedTo: String
  status: String
  target: String
  updatedAt: timestamptz
}

"""
update columns of table "notebook_target"
"""
enum notebook_target_update_column {
  """column name"""
  createdAt

  """column name"""
  creatorId

  """column name"""
  focusId

  """column name"""
  id

  """column name"""
  linkedTo

  """column name"""
  status

  """column name"""
  target

  """column name"""
  updatedAt
}

input notebook_target_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: notebook_target_set_input

  """filter the rows which have to be updated"""
  where: notebook_target_bool_exp!
}

"""
columns and relationships of "notebook_update"
"""
type notebook_update {
  account_id: uuid!
  id: uuid!
  notebook_id: uuid!
  type: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "notebook_update"
"""
type notebook_update_aggregate {
  aggregate: notebook_update_aggregate_fields
  nodes: [notebook_update!]!
}

"""
aggregate fields of "notebook_update"
"""
type notebook_update_aggregate_fields {
  count(columns: [notebook_update_select_column!], distinct: Boolean): Int!
  max: notebook_update_max_fields
  min: notebook_update_min_fields
}

"""
Boolean expression to filter rows from the table "notebook_update". All fields are combined with a logical 'AND'.
"""
input notebook_update_bool_exp {
  _and: [notebook_update_bool_exp!]
  _not: notebook_update_bool_exp
  _or: [notebook_update_bool_exp!]
  account_id: uuid_comparison_exp
  id: uuid_comparison_exp
  notebook_id: uuid_comparison_exp
  type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
update columns of table "notebook"
"""
enum notebook_update_column {
  """column name"""
  beneficiaryId

  """column name"""
  contractEndDate

  """column name"""
  contractSignDate

  """column name"""
  contractStartDate

  """column name"""
  contractType

  """column name"""
  createdAt

  """column name"""
  diagnosticFetchedAt

  """column name"""
  educationLevel

  """column name"""
  id

  """column name"""
  lastJobEndedAt

  """column name"""
  rightRqth

  """column name"""
  updatedAt

  """column name"""
  workSituation

  """column name"""
  workSituationDate

  """column name"""
  workSituationEndDate
}

"""
unique or primary key constraints on table "notebook_update"
"""
enum notebook_update_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  notebook_update_pkey
}

"""
input type for inserting data into table "notebook_update"
"""
input notebook_update_insert_input {
  account_id: uuid
  id: uuid
  notebook_id: uuid
  type: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type notebook_update_max_fields {
  account_id: uuid
  id: uuid
  notebook_id: uuid
  type: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type notebook_update_min_fields {
  account_id: uuid
  id: uuid
  notebook_id: uuid
  type: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "notebook_update"
"""
type notebook_update_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notebook_update!]!
}

"""
on_conflict condition type for table "notebook_update"
"""
input notebook_update_on_conflict {
  constraint: notebook_update_constraint!
  update_columns: [notebook_update_update_column!]! = []
  where: notebook_update_bool_exp
}

"""Ordering options when selecting data from "notebook_update"."""
input notebook_update_order_by {
  account_id: order_by
  id: order_by
  notebook_id: order_by
  type: order_by
  updated_at: order_by
}

"""primary key columns input for table: notebook_update"""
input notebook_update_pk_columns_input {
  id: uuid!
}

"""
select columns of table "notebook_update"
"""
enum notebook_update_select_column {
  """column name"""
  account_id

  """column name"""
  id

  """column name"""
  notebook_id

  """column name"""
  type

  """column name"""
  updated_at
}

"""
input type for updating data in table "notebook_update"
"""
input notebook_update_set_input {
  account_id: uuid
  id: uuid
  notebook_id: uuid
  type: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "notebook_update"
"""
input notebook_update_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notebook_update_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notebook_update_stream_cursor_value_input {
  account_id: uuid
  id: uuid
  notebook_id: uuid
  type: String
  updated_at: timestamptz
}

"""
update columns of table "notebook_update"
"""
enum notebook_update_update_column {
  """column name"""
  account_id

  """column name"""
  id

  """column name"""
  notebook_id

  """column name"""
  type

  """column name"""
  updated_at
}

input notebook_update_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: notebook_update_set_input

  """filter the rows which have to be updated"""
  where: notebook_update_bool_exp!
}

input notebook_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: notebook_set_input

  """filter the rows which have to be updated"""
  where: notebook_bool_exp!
}

"""store notebook visit on a given notebook"""
type notebook_visit {
  accountId: uuid!
  id: uuid!
  notebookId: uuid!
  visitedAt: timestamptz!
}

"""
aggregated selection of "notebook_visit"
"""
type notebook_visit_aggregate {
  aggregate: notebook_visit_aggregate_fields
  nodes: [notebook_visit!]!
}

"""
aggregate fields of "notebook_visit"
"""
type notebook_visit_aggregate_fields {
  count(columns: [notebook_visit_select_column!], distinct: Boolean): Int!
  max: notebook_visit_max_fields
  min: notebook_visit_min_fields
}

"""
Boolean expression to filter rows from the table "notebook_visit". All fields are combined with a logical 'AND'.
"""
input notebook_visit_bool_exp {
  _and: [notebook_visit_bool_exp!]
  _not: notebook_visit_bool_exp
  _or: [notebook_visit_bool_exp!]
  accountId: uuid_comparison_exp
  id: uuid_comparison_exp
  notebookId: uuid_comparison_exp
  visitedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "notebook_visit"
"""
enum notebook_visit_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  notebook_visit_pkey
}

"""
input type for inserting data into table "notebook_visit"
"""
input notebook_visit_insert_input {
  accountId: uuid
  id: uuid
  notebookId: uuid
  visitedAt: timestamptz
}

"""aggregate max on columns"""
type notebook_visit_max_fields {
  accountId: uuid
  id: uuid
  notebookId: uuid
  visitedAt: timestamptz
}

"""aggregate min on columns"""
type notebook_visit_min_fields {
  accountId: uuid
  id: uuid
  notebookId: uuid
  visitedAt: timestamptz
}

"""
response of any mutation on the table "notebook_visit"
"""
type notebook_visit_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notebook_visit!]!
}

"""
on_conflict condition type for table "notebook_visit"
"""
input notebook_visit_on_conflict {
  constraint: notebook_visit_constraint!
  update_columns: [notebook_visit_update_column!]! = []
  where: notebook_visit_bool_exp
}

"""Ordering options when selecting data from "notebook_visit"."""
input notebook_visit_order_by {
  accountId: order_by
  id: order_by
  notebookId: order_by
  visitedAt: order_by
}

"""primary key columns input for table: notebook_visit"""
input notebook_visit_pk_columns_input {
  id: uuid!
}

"""
select columns of table "notebook_visit"
"""
enum notebook_visit_select_column {
  """column name"""
  accountId

  """column name"""
  id

  """column name"""
  notebookId

  """column name"""
  visitedAt
}

"""
input type for updating data in table "notebook_visit"
"""
input notebook_visit_set_input {
  accountId: uuid
  id: uuid
  notebookId: uuid
  visitedAt: timestamptz
}

"""
Streaming cursor of the table "notebook_visit"
"""
input notebook_visit_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notebook_visit_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notebook_visit_stream_cursor_value_input {
  accountId: uuid
  id: uuid
  notebookId: uuid
  visitedAt: timestamptz
}

"""
update columns of table "notebook_visit"
"""
enum notebook_visit_update_column {
  """column name"""
  accountId

  """column name"""
  id

  """column name"""
  notebookId

  """column name"""
  visitedAt
}

input notebook_visit_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: notebook_visit_set_input

  """filter the rows which have to be updated"""
  where: notebook_visit_bool_exp!
}

"""NPS ratings from users"""
type nps_rating {
  accountId: uuid!
  createdAt: timestamptz!
  id: uuid!
  score: Int!
}

"""
aggregated selection of "nps_rating"
"""
type nps_rating_aggregate {
  aggregate: nps_rating_aggregate_fields
  nodes: [nps_rating!]!
}

"""
aggregate fields of "nps_rating"
"""
type nps_rating_aggregate_fields {
  avg: nps_rating_avg_fields
  count(columns: [nps_rating_select_column!], distinct: Boolean): Int!
  max: nps_rating_max_fields
  min: nps_rating_min_fields
  stddev: nps_rating_stddev_fields
  stddev_pop: nps_rating_stddev_pop_fields
  stddev_samp: nps_rating_stddev_samp_fields
  sum: nps_rating_sum_fields
  var_pop: nps_rating_var_pop_fields
  var_samp: nps_rating_var_samp_fields
  variance: nps_rating_variance_fields
}

"""aggregate avg on columns"""
type nps_rating_avg_fields {
  score: Float
}

"""
Boolean expression to filter rows from the table "nps_rating". All fields are combined with a logical 'AND'.
"""
input nps_rating_bool_exp {
  _and: [nps_rating_bool_exp!]
  _not: nps_rating_bool_exp
  _or: [nps_rating_bool_exp!]
  accountId: uuid_comparison_exp
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  score: Int_comparison_exp
}

"""
unique or primary key constraints on table "nps_rating"
"""
enum nps_rating_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  nps_rating_pkey
}

"""Store when a user dismisses an NPS rating"""
type nps_rating_dismissal {
  accountId: uuid!
  dismissedAt: timestamptz!
  id: uuid!
}

"""
aggregated selection of "nps_rating_dismissal"
"""
type nps_rating_dismissal_aggregate {
  aggregate: nps_rating_dismissal_aggregate_fields
  nodes: [nps_rating_dismissal!]!
}

"""
aggregate fields of "nps_rating_dismissal"
"""
type nps_rating_dismissal_aggregate_fields {
  count(columns: [nps_rating_dismissal_select_column!], distinct: Boolean): Int!
  max: nps_rating_dismissal_max_fields
  min: nps_rating_dismissal_min_fields
}

"""
Boolean expression to filter rows from the table "nps_rating_dismissal". All fields are combined with a logical 'AND'.
"""
input nps_rating_dismissal_bool_exp {
  _and: [nps_rating_dismissal_bool_exp!]
  _not: nps_rating_dismissal_bool_exp
  _or: [nps_rating_dismissal_bool_exp!]
  accountId: uuid_comparison_exp
  dismissedAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "nps_rating_dismissal"
"""
enum nps_rating_dismissal_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  nps_rating_dismissal_pkey
}

"""
input type for inserting data into table "nps_rating_dismissal"
"""
input nps_rating_dismissal_insert_input {
  accountId: uuid
  dismissedAt: timestamptz
  id: uuid
}

"""aggregate max on columns"""
type nps_rating_dismissal_max_fields {
  accountId: uuid
  dismissedAt: timestamptz
  id: uuid
}

"""aggregate min on columns"""
type nps_rating_dismissal_min_fields {
  accountId: uuid
  dismissedAt: timestamptz
  id: uuid
}

"""
response of any mutation on the table "nps_rating_dismissal"
"""
type nps_rating_dismissal_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [nps_rating_dismissal!]!
}

"""
on_conflict condition type for table "nps_rating_dismissal"
"""
input nps_rating_dismissal_on_conflict {
  constraint: nps_rating_dismissal_constraint!
  update_columns: [nps_rating_dismissal_update_column!]! = []
  where: nps_rating_dismissal_bool_exp
}

"""Ordering options when selecting data from "nps_rating_dismissal"."""
input nps_rating_dismissal_order_by {
  accountId: order_by
  dismissedAt: order_by
  id: order_by
}

"""primary key columns input for table: nps_rating_dismissal"""
input nps_rating_dismissal_pk_columns_input {
  id: uuid!
}

"""
select columns of table "nps_rating_dismissal"
"""
enum nps_rating_dismissal_select_column {
  """column name"""
  accountId

  """column name"""
  dismissedAt

  """column name"""
  id
}

"""
input type for updating data in table "nps_rating_dismissal"
"""
input nps_rating_dismissal_set_input {
  accountId: uuid
  dismissedAt: timestamptz
  id: uuid
}

"""
Streaming cursor of the table "nps_rating_dismissal"
"""
input nps_rating_dismissal_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: nps_rating_dismissal_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input nps_rating_dismissal_stream_cursor_value_input {
  accountId: uuid
  dismissedAt: timestamptz
  id: uuid
}

"""
update columns of table "nps_rating_dismissal"
"""
enum nps_rating_dismissal_update_column {
  """column name"""
  accountId

  """column name"""
  dismissedAt

  """column name"""
  id
}

input nps_rating_dismissal_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: nps_rating_dismissal_set_input

  """filter the rows which have to be updated"""
  where: nps_rating_dismissal_bool_exp!
}

"""
input type for incrementing numeric columns in table "nps_rating"
"""
input nps_rating_inc_input {
  score: Int
}

"""
input type for inserting data into table "nps_rating"
"""
input nps_rating_insert_input {
  accountId: uuid
  createdAt: timestamptz
  id: uuid
  score: Int
}

"""aggregate max on columns"""
type nps_rating_max_fields {
  accountId: uuid
  createdAt: timestamptz
  id: uuid
  score: Int
}

"""aggregate min on columns"""
type nps_rating_min_fields {
  accountId: uuid
  createdAt: timestamptz
  id: uuid
  score: Int
}

"""
response of any mutation on the table "nps_rating"
"""
type nps_rating_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [nps_rating!]!
}

"""
on_conflict condition type for table "nps_rating"
"""
input nps_rating_on_conflict {
  constraint: nps_rating_constraint!
  update_columns: [nps_rating_update_column!]! = []
  where: nps_rating_bool_exp
}

"""Ordering options when selecting data from "nps_rating"."""
input nps_rating_order_by {
  accountId: order_by
  createdAt: order_by
  id: order_by
  score: order_by
}

"""primary key columns input for table: nps_rating"""
input nps_rating_pk_columns_input {
  id: uuid!
}

"""
select columns of table "nps_rating"
"""
enum nps_rating_select_column {
  """column name"""
  accountId

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  score
}

"""
input type for updating data in table "nps_rating"
"""
input nps_rating_set_input {
  accountId: uuid
  createdAt: timestamptz
  id: uuid
  score: Int
}

"""aggregate stddev on columns"""
type nps_rating_stddev_fields {
  score: Float
}

"""aggregate stddev_pop on columns"""
type nps_rating_stddev_pop_fields {
  score: Float
}

"""aggregate stddev_samp on columns"""
type nps_rating_stddev_samp_fields {
  score: Float
}

"""
Streaming cursor of the table "nps_rating"
"""
input nps_rating_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: nps_rating_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input nps_rating_stream_cursor_value_input {
  accountId: uuid
  createdAt: timestamptz
  id: uuid
  score: Int
}

"""aggregate sum on columns"""
type nps_rating_sum_fields {
  score: Int
}

"""
update columns of table "nps_rating"
"""
enum nps_rating_update_column {
  """column name"""
  accountId

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  score
}

input nps_rating_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: nps_rating_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: nps_rating_set_input

  """filter the rows which have to be updated"""
  where: nps_rating_bool_exp!
}

"""aggregate var_pop on columns"""
type nps_rating_var_pop_fields {
  score: Float
}

"""aggregate var_samp on columns"""
type nps_rating_var_samp_fields {
  score: Float
}

"""aggregate variance on columns"""
type nps_rating_variance_fields {
  score: Float
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""Table des charg√©s d‚Äôorientation"""
type orientation_manager {
  """An object relationship"""
  account: account

  """An array relationship"""
  accounts(
    """distinct select on columns"""
    distinct_on: [account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_order_by!]

    """filter the rows returned"""
    where: account_bool_exp
  ): [account!]!

  """An aggregate relationship"""
  accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_order_by!]

    """filter the rows returned"""
    where: account_bool_exp
  ): account_aggregate!
  createdAt: timestamptz!

  """An object relationship"""
  deployment: deployment!
  deploymentId: uuid!
  email: citext!
  firstname: String
  id: uuid!
  lastname: String

  """liste des num√©ros de t√©l√©phones s√©par√©s par des virgules"""
  phoneNumbers: String
  updatedAt: timestamptz!
}

"""
aggregated selection of "orientation_manager"
"""
type orientation_manager_aggregate {
  aggregate: orientation_manager_aggregate_fields
  nodes: [orientation_manager!]!
}

input orientation_manager_aggregate_bool_exp {
  count: orientation_manager_aggregate_bool_exp_count
}

input orientation_manager_aggregate_bool_exp_count {
  arguments: [orientation_manager_select_column!]
  distinct: Boolean
  filter: orientation_manager_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "orientation_manager"
"""
type orientation_manager_aggregate_fields {
  count(columns: [orientation_manager_select_column!], distinct: Boolean): Int!
  max: orientation_manager_max_fields
  min: orientation_manager_min_fields
}

"""
order by aggregate values of table "orientation_manager"
"""
input orientation_manager_aggregate_order_by {
  count: order_by
  max: orientation_manager_max_order_by
  min: orientation_manager_min_order_by
}

"""
input type for inserting array relation for remote table "orientation_manager"
"""
input orientation_manager_arr_rel_insert_input {
  data: [orientation_manager_insert_input!]!

  """upsert condition"""
  on_conflict: orientation_manager_on_conflict
}

"""
Boolean expression to filter rows from the table "orientation_manager". All fields are combined with a logical 'AND'.
"""
input orientation_manager_bool_exp {
  _and: [orientation_manager_bool_exp!]
  _not: orientation_manager_bool_exp
  _or: [orientation_manager_bool_exp!]
  account: account_bool_exp
  accounts: account_bool_exp
  accounts_aggregate: account_aggregate_bool_exp
  createdAt: timestamptz_comparison_exp
  deployment: deployment_bool_exp
  deploymentId: uuid_comparison_exp
  email: citext_comparison_exp
  firstname: String_comparison_exp
  id: uuid_comparison_exp
  lastname: String_comparison_exp
  phoneNumbers: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "orientation_manager"
"""
enum orientation_manager_constraint {
  """
  unique or primary key constraint on columns "email"
  """
  orientation_manager_email_key

  """
  unique or primary key constraint on columns "id"
  """
  orientation_manager_pkey
}

"""
input type for inserting data into table "orientation_manager"
"""
input orientation_manager_insert_input {
  account: account_obj_rel_insert_input
  accounts: account_arr_rel_insert_input
  createdAt: timestamptz
  deployment: deployment_obj_rel_insert_input
  deploymentId: uuid
  email: citext
  firstname: String
  id: uuid
  lastname: String

  """liste des num√©ros de t√©l√©phones s√©par√©s par des virgules"""
  phoneNumbers: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type orientation_manager_max_fields {
  createdAt: timestamptz
  deploymentId: uuid
  email: citext
  firstname: String
  id: uuid
  lastname: String

  """liste des num√©ros de t√©l√©phones s√©par√©s par des virgules"""
  phoneNumbers: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "orientation_manager"
"""
input orientation_manager_max_order_by {
  createdAt: order_by
  deploymentId: order_by
  email: order_by
  firstname: order_by
  id: order_by
  lastname: order_by

  """liste des num√©ros de t√©l√©phones s√©par√©s par des virgules"""
  phoneNumbers: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type orientation_manager_min_fields {
  createdAt: timestamptz
  deploymentId: uuid
  email: citext
  firstname: String
  id: uuid
  lastname: String

  """liste des num√©ros de t√©l√©phones s√©par√©s par des virgules"""
  phoneNumbers: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "orientation_manager"
"""
input orientation_manager_min_order_by {
  createdAt: order_by
  deploymentId: order_by
  email: order_by
  firstname: order_by
  id: order_by
  lastname: order_by

  """liste des num√©ros de t√©l√©phones s√©par√©s par des virgules"""
  phoneNumbers: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "orientation_manager"
"""
type orientation_manager_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [orientation_manager!]!
}

"""
input type for inserting object relation for remote table "orientation_manager"
"""
input orientation_manager_obj_rel_insert_input {
  data: orientation_manager_insert_input!

  """upsert condition"""
  on_conflict: orientation_manager_on_conflict
}

"""
on_conflict condition type for table "orientation_manager"
"""
input orientation_manager_on_conflict {
  constraint: orientation_manager_constraint!
  update_columns: [orientation_manager_update_column!]! = []
  where: orientation_manager_bool_exp
}

"""Ordering options when selecting data from "orientation_manager"."""
input orientation_manager_order_by {
  account: account_order_by
  accounts_aggregate: account_aggregate_order_by
  createdAt: order_by
  deployment: deployment_order_by
  deploymentId: order_by
  email: order_by
  firstname: order_by
  id: order_by
  lastname: order_by
  phoneNumbers: order_by
  updatedAt: order_by
}

"""primary key columns input for table: orientation_manager"""
input orientation_manager_pk_columns_input {
  id: uuid!
}

"""
select columns of table "orientation_manager"
"""
enum orientation_manager_select_column {
  """column name"""
  createdAt

  """column name"""
  deploymentId

  """column name"""
  email

  """column name"""
  firstname

  """column name"""
  id

  """column name"""
  lastname

  """column name"""
  phoneNumbers

  """column name"""
  updatedAt
}

"""
input type for updating data in table "orientation_manager"
"""
input orientation_manager_set_input {
  createdAt: timestamptz
  deploymentId: uuid
  email: citext
  firstname: String
  id: uuid
  lastname: String

  """liste des num√©ros de t√©l√©phones s√©par√©s par des virgules"""
  phoneNumbers: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "orientation_manager"
"""
input orientation_manager_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: orientation_manager_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input orientation_manager_stream_cursor_value_input {
  createdAt: timestamptz
  deploymentId: uuid
  email: citext
  firstname: String
  id: uuid
  lastname: String

  """liste des num√©ros de t√©l√©phones s√©par√©s par des virgules"""
  phoneNumbers: String
  updatedAt: timestamptz
}

"""
update columns of table "orientation_manager"
"""
enum orientation_manager_update_column {
  """column name"""
  createdAt

  """column name"""
  deploymentId

  """column name"""
  email

  """column name"""
  firstname

  """column name"""
  id

  """column name"""
  lastname

  """column name"""
  phoneNumbers

  """column name"""
  updatedAt
}

input orientation_manager_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: orientation_manager_set_input

  """filter the rows which have to be updated"""
  where: orientation_manager_bool_exp!
}

"""
columns and relationships of "orientation_request"
"""
type orientation_request {
  """An object relationship"""
  beneficiary: beneficiary
  beneficiaryId: uuid!
  createdAt: timestamptz!
  decidedAt: timestamptz

  """An object relationship"""
  decidedOrientationSystem: orientation_system
  decidedOrientationSystemId: uuid
  decisionReason: String
  id: uuid!
  reason: String

  """An object relationship"""
  requestedOrientationSystem: orientation_system!
  requestedOrientationSystemId: uuid!

  """An object relationship"""
  requestor: account
  requestor_account_id: uuid!
  status: String
  updatedAt: timestamptz!
}

"""
aggregated selection of "orientation_request"
"""
type orientation_request_aggregate {
  aggregate: orientation_request_aggregate_fields
  nodes: [orientation_request!]!
}

input orientation_request_aggregate_bool_exp {
  count: orientation_request_aggregate_bool_exp_count
}

input orientation_request_aggregate_bool_exp_count {
  arguments: [orientation_request_select_column!]
  distinct: Boolean
  filter: orientation_request_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "orientation_request"
"""
type orientation_request_aggregate_fields {
  count(columns: [orientation_request_select_column!], distinct: Boolean): Int!
  max: orientation_request_max_fields
  min: orientation_request_min_fields
}

"""
order by aggregate values of table "orientation_request"
"""
input orientation_request_aggregate_order_by {
  count: order_by
  max: orientation_request_max_order_by
  min: orientation_request_min_order_by
}

"""
input type for inserting array relation for remote table "orientation_request"
"""
input orientation_request_arr_rel_insert_input {
  data: [orientation_request_insert_input!]!

  """upsert condition"""
  on_conflict: orientation_request_on_conflict
}

"""
Boolean expression to filter rows from the table "orientation_request". All fields are combined with a logical 'AND'.
"""
input orientation_request_bool_exp {
  _and: [orientation_request_bool_exp!]
  _not: orientation_request_bool_exp
  _or: [orientation_request_bool_exp!]
  beneficiary: beneficiary_bool_exp
  beneficiaryId: uuid_comparison_exp
  createdAt: timestamptz_comparison_exp
  decidedAt: timestamptz_comparison_exp
  decidedOrientationSystem: orientation_system_bool_exp
  decidedOrientationSystemId: uuid_comparison_exp
  decisionReason: String_comparison_exp
  id: uuid_comparison_exp
  reason: String_comparison_exp
  requestedOrientationSystem: orientation_system_bool_exp
  requestedOrientationSystemId: uuid_comparison_exp
  requestor: account_bool_exp
  requestor_account_id: uuid_comparison_exp
  status: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "orientation_request"
"""
enum orientation_request_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  orientation_request_pkey
}

"""
input type for inserting data into table "orientation_request"
"""
input orientation_request_insert_input {
  beneficiary: beneficiary_obj_rel_insert_input
  beneficiaryId: uuid
  createdAt: timestamptz
  decidedAt: timestamptz
  decidedOrientationSystem: orientation_system_obj_rel_insert_input
  decidedOrientationSystemId: uuid
  decisionReason: String
  id: uuid
  reason: String
  requestedOrientationSystem: orientation_system_obj_rel_insert_input
  requestedOrientationSystemId: uuid
  requestor: account_obj_rel_insert_input
  requestor_account_id: uuid
  status: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type orientation_request_max_fields {
  beneficiaryId: uuid
  createdAt: timestamptz
  decidedAt: timestamptz
  decidedOrientationSystemId: uuid
  decisionReason: String
  id: uuid
  reason: String
  requestedOrientationSystemId: uuid
  requestor_account_id: uuid
  status: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "orientation_request"
"""
input orientation_request_max_order_by {
  beneficiaryId: order_by
  createdAt: order_by
  decidedAt: order_by
  decidedOrientationSystemId: order_by
  decisionReason: order_by
  id: order_by
  reason: order_by
  requestedOrientationSystemId: order_by
  requestor_account_id: order_by
  status: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type orientation_request_min_fields {
  beneficiaryId: uuid
  createdAt: timestamptz
  decidedAt: timestamptz
  decidedOrientationSystemId: uuid
  decisionReason: String
  id: uuid
  reason: String
  requestedOrientationSystemId: uuid
  requestor_account_id: uuid
  status: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "orientation_request"
"""
input orientation_request_min_order_by {
  beneficiaryId: order_by
  createdAt: order_by
  decidedAt: order_by
  decidedOrientationSystemId: order_by
  decisionReason: order_by
  id: order_by
  reason: order_by
  requestedOrientationSystemId: order_by
  requestor_account_id: order_by
  status: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "orientation_request"
"""
type orientation_request_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [orientation_request!]!
}

"""
on_conflict condition type for table "orientation_request"
"""
input orientation_request_on_conflict {
  constraint: orientation_request_constraint!
  update_columns: [orientation_request_update_column!]! = []
  where: orientation_request_bool_exp
}

"""Ordering options when selecting data from "orientation_request"."""
input orientation_request_order_by {
  beneficiary: beneficiary_order_by
  beneficiaryId: order_by
  createdAt: order_by
  decidedAt: order_by
  decidedOrientationSystem: orientation_system_order_by
  decidedOrientationSystemId: order_by
  decisionReason: order_by
  id: order_by
  reason: order_by
  requestedOrientationSystem: orientation_system_order_by
  requestedOrientationSystemId: order_by
  requestor: account_order_by
  requestor_account_id: order_by
  status: order_by
  updatedAt: order_by
}

"""primary key columns input for table: orientation_request"""
input orientation_request_pk_columns_input {
  id: uuid!
}

"""
select columns of table "orientation_request"
"""
enum orientation_request_select_column {
  """column name"""
  beneficiaryId

  """column name"""
  createdAt

  """column name"""
  decidedAt

  """column name"""
  decidedOrientationSystemId

  """column name"""
  decisionReason

  """column name"""
  id

  """column name"""
  reason

  """column name"""
  requestedOrientationSystemId

  """column name"""
  requestor_account_id

  """column name"""
  status

  """column name"""
  updatedAt
}

"""
input type for updating data in table "orientation_request"
"""
input orientation_request_set_input {
  beneficiaryId: uuid
  createdAt: timestamptz
  decidedAt: timestamptz
  decidedOrientationSystemId: uuid
  decisionReason: String
  id: uuid
  reason: String
  requestedOrientationSystemId: uuid
  requestor_account_id: uuid
  status: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "orientation_request"
"""
input orientation_request_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: orientation_request_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input orientation_request_stream_cursor_value_input {
  beneficiaryId: uuid
  createdAt: timestamptz
  decidedAt: timestamptz
  decidedOrientationSystemId: uuid
  decisionReason: String
  id: uuid
  reason: String
  requestedOrientationSystemId: uuid
  requestor_account_id: uuid
  status: String
  updatedAt: timestamptz
}

"""
update columns of table "orientation_request"
"""
enum orientation_request_update_column {
  """column name"""
  beneficiaryId

  """column name"""
  createdAt

  """column name"""
  decidedAt

  """column name"""
  decidedOrientationSystemId

  """column name"""
  decisionReason

  """column name"""
  id

  """column name"""
  reason

  """column name"""
  requestedOrientationSystemId

  """column name"""
  requestor_account_id

  """column name"""
  status

  """column name"""
  updatedAt
}

input orientation_request_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: orientation_request_set_input

  """filter the rows which have to be updated"""
  where: orientation_request_bool_exp!
}

"""
columns and relationships of "orientation_system"
"""
type orientation_system {
  """An object relationship"""
  beneficiaries: notebook_info
  createdAt: timestamptz!

  """An object relationship"""
  deployment: deployment!
  deployment_id: uuid!
  id: uuid!
  name: String!
  orientationType: orientation_type_enum!

  """An object relationship"""
  orientationTypeByOrientationType: orientation_type!

  """An array relationship"""
  professionalOrientationSystems(
    """distinct select on columns"""
    distinct_on: [professional_orientation_system_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [professional_orientation_system_order_by!]

    """filter the rows returned"""
    where: professional_orientation_system_bool_exp
  ): [professional_orientation_system!]!

  """An aggregate relationship"""
  professionalOrientationSystems_aggregate(
    """distinct select on columns"""
    distinct_on: [professional_orientation_system_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [professional_orientation_system_order_by!]

    """filter the rows returned"""
    where: professional_orientation_system_bool_exp
  ): professional_orientation_system_aggregate!

  """An array relationship"""
  structureOrientationSystems(
    """distinct select on columns"""
    distinct_on: [structure_orientation_system_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [structure_orientation_system_order_by!]

    """filter the rows returned"""
    where: structure_orientation_system_bool_exp
  ): [structure_orientation_system!]!

  """An aggregate relationship"""
  structureOrientationSystems_aggregate(
    """distinct select on columns"""
    distinct_on: [structure_orientation_system_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [structure_orientation_system_order_by!]

    """filter the rows returned"""
    where: structure_orientation_system_bool_exp
  ): structure_orientation_system_aggregate!
  updatedAt: timestamptz!
}

"""
aggregated selection of "orientation_system"
"""
type orientation_system_aggregate {
  aggregate: orientation_system_aggregate_fields
  nodes: [orientation_system!]!
}

input orientation_system_aggregate_bool_exp {
  count: orientation_system_aggregate_bool_exp_count
}

input orientation_system_aggregate_bool_exp_count {
  arguments: [orientation_system_select_column!]
  distinct: Boolean
  filter: orientation_system_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "orientation_system"
"""
type orientation_system_aggregate_fields {
  count(columns: [orientation_system_select_column!], distinct: Boolean): Int!
  max: orientation_system_max_fields
  min: orientation_system_min_fields
}

"""
order by aggregate values of table "orientation_system"
"""
input orientation_system_aggregate_order_by {
  count: order_by
  max: orientation_system_max_order_by
  min: orientation_system_min_order_by
}

"""
input type for inserting array relation for remote table "orientation_system"
"""
input orientation_system_arr_rel_insert_input {
  data: [orientation_system_insert_input!]!

  """upsert condition"""
  on_conflict: orientation_system_on_conflict
}

"""
Boolean expression to filter rows from the table "orientation_system". All fields are combined with a logical 'AND'.
"""
input orientation_system_bool_exp {
  _and: [orientation_system_bool_exp!]
  _not: orientation_system_bool_exp
  _or: [orientation_system_bool_exp!]
  beneficiaries: notebook_info_bool_exp
  createdAt: timestamptz_comparison_exp
  deployment: deployment_bool_exp
  deployment_id: uuid_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  orientationType: orientation_type_enum_comparison_exp
  orientationTypeByOrientationType: orientation_type_bool_exp
  professionalOrientationSystems: professional_orientation_system_bool_exp
  professionalOrientationSystems_aggregate: professional_orientation_system_aggregate_bool_exp
  structureOrientationSystems: structure_orientation_system_bool_exp
  structureOrientationSystems_aggregate: structure_orientation_system_aggregate_bool_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "orientation_system"
"""
enum orientation_system_constraint {
  """
  unique or primary key constraint on columns "deployment_id"
  """
  name_deployment_id_unique_idx

  """
  unique or primary key constraint on columns "id"
  """
  orientation_system_pkey
}

"""
input type for inserting data into table "orientation_system"
"""
input orientation_system_insert_input {
  beneficiaries: notebook_info_obj_rel_insert_input
  createdAt: timestamptz
  deployment: deployment_obj_rel_insert_input
  deployment_id: uuid
  id: uuid
  name: String
  orientationType: orientation_type_enum
  orientationTypeByOrientationType: orientation_type_obj_rel_insert_input
  professionalOrientationSystems: professional_orientation_system_arr_rel_insert_input
  structureOrientationSystems: structure_orientation_system_arr_rel_insert_input
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type orientation_system_max_fields {
  createdAt: timestamptz
  deployment_id: uuid
  id: uuid
  name: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "orientation_system"
"""
input orientation_system_max_order_by {
  createdAt: order_by
  deployment_id: order_by
  id: order_by
  name: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type orientation_system_min_fields {
  createdAt: timestamptz
  deployment_id: uuid
  id: uuid
  name: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "orientation_system"
"""
input orientation_system_min_order_by {
  createdAt: order_by
  deployment_id: order_by
  id: order_by
  name: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "orientation_system"
"""
type orientation_system_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [orientation_system!]!
}

"""
input type for inserting object relation for remote table "orientation_system"
"""
input orientation_system_obj_rel_insert_input {
  data: orientation_system_insert_input!

  """upsert condition"""
  on_conflict: orientation_system_on_conflict
}

"""
on_conflict condition type for table "orientation_system"
"""
input orientation_system_on_conflict {
  constraint: orientation_system_constraint!
  update_columns: [orientation_system_update_column!]! = []
  where: orientation_system_bool_exp
}

"""Ordering options when selecting data from "orientation_system"."""
input orientation_system_order_by {
  beneficiaries: notebook_info_order_by
  createdAt: order_by
  deployment: deployment_order_by
  deployment_id: order_by
  id: order_by
  name: order_by
  orientationType: order_by
  orientationTypeByOrientationType: orientation_type_order_by
  professionalOrientationSystems_aggregate: professional_orientation_system_aggregate_order_by
  structureOrientationSystems_aggregate: structure_orientation_system_aggregate_order_by
  updatedAt: order_by
}

"""primary key columns input for table: orientation_system"""
input orientation_system_pk_columns_input {
  id: uuid!
}

"""
select columns of table "orientation_system"
"""
enum orientation_system_select_column {
  """column name"""
  createdAt

  """column name"""
  deployment_id

  """column name"""
  id

  """column name"""
  name

  """column name"""
  orientationType

  """column name"""
  updatedAt
}

"""
input type for updating data in table "orientation_system"
"""
input orientation_system_set_input {
  createdAt: timestamptz
  deployment_id: uuid
  id: uuid
  name: String
  orientationType: orientation_type_enum
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "orientation_system"
"""
input orientation_system_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: orientation_system_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input orientation_system_stream_cursor_value_input {
  createdAt: timestamptz
  deployment_id: uuid
  id: uuid
  name: String
  orientationType: orientation_type_enum
  updatedAt: timestamptz
}

"""
update columns of table "orientation_system"
"""
enum orientation_system_update_column {
  """column name"""
  createdAt

  """column name"""
  deployment_id

  """column name"""
  id

  """column name"""
  name

  """column name"""
  orientationType

  """column name"""
  updatedAt
}

input orientation_system_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: orientation_system_set_input

  """filter the rows which have to be updated"""
  where: orientation_system_bool_exp!
}

"""table contenant les diff√©rents types d‚Äôorientation"""
type orientation_type {
  id: String!
  label: String!

  """An array relationship"""
  orientationType(
    """distinct select on columns"""
    distinct_on: [orientation_system_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [orientation_system_order_by!]

    """filter the rows returned"""
    where: orientation_system_bool_exp
  ): [orientation_system!]!

  """An aggregate relationship"""
  orientationType_aggregate(
    """distinct select on columns"""
    distinct_on: [orientation_system_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [orientation_system_order_by!]

    """filter the rows returned"""
    where: orientation_system_bool_exp
  ): orientation_system_aggregate!
}

"""
aggregated selection of "orientation_type"
"""
type orientation_type_aggregate {
  aggregate: orientation_type_aggregate_fields
  nodes: [orientation_type!]!
}

"""
aggregate fields of "orientation_type"
"""
type orientation_type_aggregate_fields {
  count(columns: [orientation_type_select_column!], distinct: Boolean): Int!
  max: orientation_type_max_fields
  min: orientation_type_min_fields
}

"""
Boolean expression to filter rows from the table "orientation_type". All fields are combined with a logical 'AND'.
"""
input orientation_type_bool_exp {
  _and: [orientation_type_bool_exp!]
  _not: orientation_type_bool_exp
  _or: [orientation_type_bool_exp!]
  id: String_comparison_exp
  label: String_comparison_exp
  orientationType: orientation_system_bool_exp
  orientationType_aggregate: orientation_system_aggregate_bool_exp
}

"""
unique or primary key constraints on table "orientation_type"
"""
enum orientation_type_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  orientation_type_pkey
}

enum orientation_type_enum {
  """Autre"""
  autre

  """Professionnel"""
  pro

  """Social"""
  social

  """Socio-professionnel"""
  sociopro
}

"""
Boolean expression to compare columns of type "orientation_type_enum". All fields are combined with logical 'AND'.
"""
input orientation_type_enum_comparison_exp {
  _eq: orientation_type_enum
  _in: [orientation_type_enum!]
  _is_null: Boolean
  _neq: orientation_type_enum
  _nin: [orientation_type_enum!]
}

"""
input type for inserting data into table "orientation_type"
"""
input orientation_type_insert_input {
  id: String
  label: String
  orientationType: orientation_system_arr_rel_insert_input
}

"""aggregate max on columns"""
type orientation_type_max_fields {
  id: String
  label: String
}

"""aggregate min on columns"""
type orientation_type_min_fields {
  id: String
  label: String
}

"""
response of any mutation on the table "orientation_type"
"""
type orientation_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [orientation_type!]!
}

"""
input type for inserting object relation for remote table "orientation_type"
"""
input orientation_type_obj_rel_insert_input {
  data: orientation_type_insert_input!

  """upsert condition"""
  on_conflict: orientation_type_on_conflict
}

"""
on_conflict condition type for table "orientation_type"
"""
input orientation_type_on_conflict {
  constraint: orientation_type_constraint!
  update_columns: [orientation_type_update_column!]! = []
  where: orientation_type_bool_exp
}

"""Ordering options when selecting data from "orientation_type"."""
input orientation_type_order_by {
  id: order_by
  label: order_by
  orientationType_aggregate: orientation_system_aggregate_order_by
}

"""primary key columns input for table: orientation_type"""
input orientation_type_pk_columns_input {
  id: String!
}

"""
select columns of table "orientation_type"
"""
enum orientation_type_select_column {
  """column name"""
  id

  """column name"""
  label
}

"""
input type for updating data in table "orientation_type"
"""
input orientation_type_set_input {
  id: String
  label: String
}

"""
Streaming cursor of the table "orientation_type"
"""
input orientation_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: orientation_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input orientation_type_stream_cursor_value_input {
  id: String
  label: String
}

"""
update columns of table "orientation_type"
"""
enum orientation_type_update_column {
  """column name"""
  id

  """column name"""
  label
}

input orientation_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: orientation_type_set_input

  """filter the rows which have to be updated"""
  where: orientation_type_bool_exp!
}

"""
columns and relationships of "professional"
"""
type professional {
  """An object relationship"""
  account: account
  createdAt: timestamptz!
  email: citext!
  firstname: String!
  id: uuid!
  lastname: String!
  mobileNumber: String

  """An array relationship"""
  orientationSystems(
    """distinct select on columns"""
    distinct_on: [professional_orientation_system_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [professional_orientation_system_order_by!]

    """filter the rows returned"""
    where: professional_orientation_system_bool_exp
  ): [professional_orientation_system!]!

  """An aggregate relationship"""
  orientationSystems_aggregate(
    """distinct select on columns"""
    distinct_on: [professional_orientation_system_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [professional_orientation_system_order_by!]

    """filter the rows returned"""
    where: professional_orientation_system_bool_exp
  ): professional_orientation_system_aggregate!
  position: String

  """An object relationship"""
  structure: structure!
  structureId: uuid!
  updatedAt: timestamptz!
}

"""
aggregated selection of "professional"
"""
type professional_aggregate {
  aggregate: professional_aggregate_fields
  nodes: [professional!]!
}

input professional_aggregate_bool_exp {
  count: professional_aggregate_bool_exp_count
}

input professional_aggregate_bool_exp_count {
  arguments: [professional_select_column!]
  distinct: Boolean
  filter: professional_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "professional"
"""
type professional_aggregate_fields {
  count(columns: [professional_select_column!], distinct: Boolean): Int!
  max: professional_max_fields
  min: professional_min_fields
}

"""
order by aggregate values of table "professional"
"""
input professional_aggregate_order_by {
  count: order_by
  max: professional_max_order_by
  min: professional_min_order_by
}

"""
input type for inserting array relation for remote table "professional"
"""
input professional_arr_rel_insert_input {
  data: [professional_insert_input!]!

  """upsert condition"""
  on_conflict: professional_on_conflict
}

"""
Boolean expression to filter rows from the table "professional". All fields are combined with a logical 'AND'.
"""
input professional_bool_exp {
  _and: [professional_bool_exp!]
  _not: professional_bool_exp
  _or: [professional_bool_exp!]
  account: account_bool_exp
  createdAt: timestamptz_comparison_exp
  email: citext_comparison_exp
  firstname: String_comparison_exp
  id: uuid_comparison_exp
  lastname: String_comparison_exp
  mobileNumber: String_comparison_exp
  orientationSystems: professional_orientation_system_bool_exp
  orientationSystems_aggregate: professional_orientation_system_aggregate_bool_exp
  position: String_comparison_exp
  structure: structure_bool_exp
  structureId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "professional"
"""
enum professional_constraint {
  """
  unique or primary key constraint on columns "email"
  """
  professional_email_unique

  """
  unique or primary key constraint on columns "id"
  """
  professional_pkey
}

"""
input type for inserting data into table "professional"
"""
input professional_insert_input {
  account: account_obj_rel_insert_input
  createdAt: timestamptz
  email: citext
  firstname: String
  id: uuid
  lastname: String
  mobileNumber: String
  orientationSystems: professional_orientation_system_arr_rel_insert_input
  position: String
  structure: structure_obj_rel_insert_input
  structureId: uuid
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type professional_max_fields {
  createdAt: timestamptz
  email: citext
  firstname: String
  id: uuid
  lastname: String
  mobileNumber: String
  position: String
  structureId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "professional"
"""
input professional_max_order_by {
  createdAt: order_by
  email: order_by
  firstname: order_by
  id: order_by
  lastname: order_by
  mobileNumber: order_by
  position: order_by
  structureId: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type professional_min_fields {
  createdAt: timestamptz
  email: citext
  firstname: String
  id: uuid
  lastname: String
  mobileNumber: String
  position: String
  structureId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "professional"
"""
input professional_min_order_by {
  createdAt: order_by
  email: order_by
  firstname: order_by
  id: order_by
  lastname: order_by
  mobileNumber: order_by
  position: order_by
  structureId: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "professional"
"""
type professional_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [professional!]!
}

"""
input type for inserting object relation for remote table "professional"
"""
input professional_obj_rel_insert_input {
  data: professional_insert_input!

  """upsert condition"""
  on_conflict: professional_on_conflict
}

"""
on_conflict condition type for table "professional"
"""
input professional_on_conflict {
  constraint: professional_constraint!
  update_columns: [professional_update_column!]! = []
  where: professional_bool_exp
}

"""Ordering options when selecting data from "professional"."""
input professional_order_by {
  account: account_order_by
  createdAt: order_by
  email: order_by
  firstname: order_by
  id: order_by
  lastname: order_by
  mobileNumber: order_by
  orientationSystems_aggregate: professional_orientation_system_aggregate_order_by
  position: order_by
  structure: structure_order_by
  structureId: order_by
  updatedAt: order_by
}

"""
columns and relationships of "professional_orientation_system"
"""
type professional_orientation_system {
  createdAt: timestamptz!
  id: uuid!

  """An object relationship"""
  orientationSystem: orientation_system!
  orientationSystemId: uuid!

  """An object relationship"""
  professional: professional!
  professionalId: uuid!
}

"""
aggregated selection of "professional_orientation_system"
"""
type professional_orientation_system_aggregate {
  aggregate: professional_orientation_system_aggregate_fields
  nodes: [professional_orientation_system!]!
}

input professional_orientation_system_aggregate_bool_exp {
  count: professional_orientation_system_aggregate_bool_exp_count
}

input professional_orientation_system_aggregate_bool_exp_count {
  arguments: [professional_orientation_system_select_column!]
  distinct: Boolean
  filter: professional_orientation_system_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "professional_orientation_system"
"""
type professional_orientation_system_aggregate_fields {
  count(columns: [professional_orientation_system_select_column!], distinct: Boolean): Int!
  max: professional_orientation_system_max_fields
  min: professional_orientation_system_min_fields
}

"""
order by aggregate values of table "professional_orientation_system"
"""
input professional_orientation_system_aggregate_order_by {
  count: order_by
  max: professional_orientation_system_max_order_by
  min: professional_orientation_system_min_order_by
}

"""
input type for inserting array relation for remote table "professional_orientation_system"
"""
input professional_orientation_system_arr_rel_insert_input {
  data: [professional_orientation_system_insert_input!]!

  """upsert condition"""
  on_conflict: professional_orientation_system_on_conflict
}

"""
Boolean expression to filter rows from the table "professional_orientation_system". All fields are combined with a logical 'AND'.
"""
input professional_orientation_system_bool_exp {
  _and: [professional_orientation_system_bool_exp!]
  _not: professional_orientation_system_bool_exp
  _or: [professional_orientation_system_bool_exp!]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  orientationSystem: orientation_system_bool_exp
  orientationSystemId: uuid_comparison_exp
  professional: professional_bool_exp
  professionalId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "professional_orientation_system"
"""
enum professional_orientation_system_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  professional_orientation_system_pkey

  """
  unique or primary key constraint on columns "orientation_system_id", "professional_id"
  """
  professional_orientation_system_professional_id_orientation_sys
}

"""
input type for inserting data into table "professional_orientation_system"
"""
input professional_orientation_system_insert_input {
  createdAt: timestamptz
  id: uuid
  orientationSystem: orientation_system_obj_rel_insert_input
  orientationSystemId: uuid
  professional: professional_obj_rel_insert_input
  professionalId: uuid
}

"""aggregate max on columns"""
type professional_orientation_system_max_fields {
  createdAt: timestamptz
  id: uuid
  orientationSystemId: uuid
  professionalId: uuid
}

"""
order by max() on columns of table "professional_orientation_system"
"""
input professional_orientation_system_max_order_by {
  createdAt: order_by
  id: order_by
  orientationSystemId: order_by
  professionalId: order_by
}

"""aggregate min on columns"""
type professional_orientation_system_min_fields {
  createdAt: timestamptz
  id: uuid
  orientationSystemId: uuid
  professionalId: uuid
}

"""
order by min() on columns of table "professional_orientation_system"
"""
input professional_orientation_system_min_order_by {
  createdAt: order_by
  id: order_by
  orientationSystemId: order_by
  professionalId: order_by
}

"""
response of any mutation on the table "professional_orientation_system"
"""
type professional_orientation_system_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [professional_orientation_system!]!
}

"""
on_conflict condition type for table "professional_orientation_system"
"""
input professional_orientation_system_on_conflict {
  constraint: professional_orientation_system_constraint!
  update_columns: [professional_orientation_system_update_column!]! = []
  where: professional_orientation_system_bool_exp
}

"""
Ordering options when selecting data from "professional_orientation_system".
"""
input professional_orientation_system_order_by {
  createdAt: order_by
  id: order_by
  orientationSystem: orientation_system_order_by
  orientationSystemId: order_by
  professional: professional_order_by
  professionalId: order_by
}

"""primary key columns input for table: professional_orientation_system"""
input professional_orientation_system_pk_columns_input {
  id: uuid!
}

"""
select columns of table "professional_orientation_system"
"""
enum professional_orientation_system_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  orientationSystemId

  """column name"""
  professionalId
}

"""
input type for updating data in table "professional_orientation_system"
"""
input professional_orientation_system_set_input {
  createdAt: timestamptz
  id: uuid
  orientationSystemId: uuid
  professionalId: uuid
}

"""
Streaming cursor of the table "professional_orientation_system"
"""
input professional_orientation_system_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: professional_orientation_system_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input professional_orientation_system_stream_cursor_value_input {
  createdAt: timestamptz
  id: uuid
  orientationSystemId: uuid
  professionalId: uuid
}

"""
update columns of table "professional_orientation_system"
"""
enum professional_orientation_system_update_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  orientationSystemId

  """column name"""
  professionalId
}

input professional_orientation_system_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: professional_orientation_system_set_input

  """filter the rows which have to be updated"""
  where: professional_orientation_system_bool_exp!
}

"""primary key columns input for table: professional"""
input professional_pk_columns_input {
  id: uuid!
}

"""Stores the jobs wanted for a notebook beneficiary"""
type professional_project {
  contractTypeId: contract_type_enum

  """An object relationship"""
  contract_type: contract_type
  createdAt: timestamptz
  employmentTypeId: employment_type_enum

  """An object relationship"""
  employment_type: employment_type

  """in cents (divide by 100 for the EUR value)"""
  hourlyRate: Int
  id: uuid!
  mobilityRadius: Int

  """An object relationship"""
  notebook: notebook!
  notebookId: uuid!
  romeCodeId: uuid

  """An object relationship"""
  rome_code: rome_code
  updatedAt: timestamptz
  updatedBy: uuid

  """An object relationship"""
  updater: account
}

"""
aggregated selection of "professional_project"
"""
type professional_project_aggregate {
  aggregate: professional_project_aggregate_fields
  nodes: [professional_project!]!
}

input professional_project_aggregate_bool_exp {
  count: professional_project_aggregate_bool_exp_count
}

input professional_project_aggregate_bool_exp_count {
  arguments: [professional_project_select_column!]
  distinct: Boolean
  filter: professional_project_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "professional_project"
"""
type professional_project_aggregate_fields {
  avg: professional_project_avg_fields
  count(columns: [professional_project_select_column!], distinct: Boolean): Int!
  max: professional_project_max_fields
  min: professional_project_min_fields
  stddev: professional_project_stddev_fields
  stddev_pop: professional_project_stddev_pop_fields
  stddev_samp: professional_project_stddev_samp_fields
  sum: professional_project_sum_fields
  var_pop: professional_project_var_pop_fields
  var_samp: professional_project_var_samp_fields
  variance: professional_project_variance_fields
}

"""
order by aggregate values of table "professional_project"
"""
input professional_project_aggregate_order_by {
  avg: professional_project_avg_order_by
  count: order_by
  max: professional_project_max_order_by
  min: professional_project_min_order_by
  stddev: professional_project_stddev_order_by
  stddev_pop: professional_project_stddev_pop_order_by
  stddev_samp: professional_project_stddev_samp_order_by
  sum: professional_project_sum_order_by
  var_pop: professional_project_var_pop_order_by
  var_samp: professional_project_var_samp_order_by
  variance: professional_project_variance_order_by
}

"""
input type for inserting array relation for remote table "professional_project"
"""
input professional_project_arr_rel_insert_input {
  data: [professional_project_insert_input!]!

  """upsert condition"""
  on_conflict: professional_project_on_conflict
}

"""aggregate avg on columns"""
type professional_project_avg_fields {
  """in cents (divide by 100 for the EUR value)"""
  hourlyRate: Float
  mobilityRadius: Float
}

"""
order by avg() on columns of table "professional_project"
"""
input professional_project_avg_order_by {
  """in cents (divide by 100 for the EUR value)"""
  hourlyRate: order_by
  mobilityRadius: order_by
}

"""
Boolean expression to filter rows from the table "professional_project". All fields are combined with a logical 'AND'.
"""
input professional_project_bool_exp {
  _and: [professional_project_bool_exp!]
  _not: professional_project_bool_exp
  _or: [professional_project_bool_exp!]
  contractTypeId: contract_type_enum_comparison_exp
  contract_type: contract_type_bool_exp
  createdAt: timestamptz_comparison_exp
  employmentTypeId: employment_type_enum_comparison_exp
  employment_type: employment_type_bool_exp
  hourlyRate: Int_comparison_exp
  id: uuid_comparison_exp
  mobilityRadius: Int_comparison_exp
  notebook: notebook_bool_exp
  notebookId: uuid_comparison_exp
  romeCodeId: uuid_comparison_exp
  rome_code: rome_code_bool_exp
  updatedAt: timestamptz_comparison_exp
  updatedBy: uuid_comparison_exp
  updater: account_bool_exp
}

"""
unique or primary key constraints on table "professional_project"
"""
enum professional_project_constraint {
  """
  unique or primary key constraint on columns "notebook_id"
  """
  notebook_id_rome_code_id_null_idx

  """
  unique or primary key constraint on columns "id"
  """
  professional_project_pkey
}

"""
input type for incrementing numeric columns in table "professional_project"
"""
input professional_project_inc_input {
  """in cents (divide by 100 for the EUR value)"""
  hourlyRate: Int
  mobilityRadius: Int
}

"""
input type for inserting data into table "professional_project"
"""
input professional_project_insert_input {
  contractTypeId: contract_type_enum
  contract_type: contract_type_obj_rel_insert_input
  createdAt: timestamptz
  employmentTypeId: employment_type_enum
  employment_type: employment_type_obj_rel_insert_input

  """in cents (divide by 100 for the EUR value)"""
  hourlyRate: Int
  id: uuid
  mobilityRadius: Int
  notebook: notebook_obj_rel_insert_input
  notebookId: uuid
  romeCodeId: uuid
  rome_code: rome_code_obj_rel_insert_input
  updatedAt: timestamptz
  updatedBy: uuid
  updater: account_obj_rel_insert_input
}

"""aggregate max on columns"""
type professional_project_max_fields {
  createdAt: timestamptz

  """in cents (divide by 100 for the EUR value)"""
  hourlyRate: Int
  id: uuid
  mobilityRadius: Int
  notebookId: uuid
  romeCodeId: uuid
  updatedAt: timestamptz
  updatedBy: uuid
}

"""
order by max() on columns of table "professional_project"
"""
input professional_project_max_order_by {
  createdAt: order_by

  """in cents (divide by 100 for the EUR value)"""
  hourlyRate: order_by
  id: order_by
  mobilityRadius: order_by
  notebookId: order_by
  romeCodeId: order_by
  updatedAt: order_by
  updatedBy: order_by
}

"""aggregate min on columns"""
type professional_project_min_fields {
  createdAt: timestamptz

  """in cents (divide by 100 for the EUR value)"""
  hourlyRate: Int
  id: uuid
  mobilityRadius: Int
  notebookId: uuid
  romeCodeId: uuid
  updatedAt: timestamptz
  updatedBy: uuid
}

"""
order by min() on columns of table "professional_project"
"""
input professional_project_min_order_by {
  createdAt: order_by

  """in cents (divide by 100 for the EUR value)"""
  hourlyRate: order_by
  id: order_by
  mobilityRadius: order_by
  notebookId: order_by
  romeCodeId: order_by
  updatedAt: order_by
  updatedBy: order_by
}

"""
response of any mutation on the table "professional_project"
"""
type professional_project_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [professional_project!]!
}

"""
on_conflict condition type for table "professional_project"
"""
input professional_project_on_conflict {
  constraint: professional_project_constraint!
  update_columns: [professional_project_update_column!]! = []
  where: professional_project_bool_exp
}

"""Ordering options when selecting data from "professional_project"."""
input professional_project_order_by {
  contractTypeId: order_by
  contract_type: contract_type_order_by
  createdAt: order_by
  employmentTypeId: order_by
  employment_type: employment_type_order_by
  hourlyRate: order_by
  id: order_by
  mobilityRadius: order_by
  notebook: notebook_order_by
  notebookId: order_by
  romeCodeId: order_by
  rome_code: rome_code_order_by
  updatedAt: order_by
  updatedBy: order_by
  updater: account_order_by
}

"""primary key columns input for table: professional_project"""
input professional_project_pk_columns_input {
  id: uuid!
}

"""
select columns of table "professional_project"
"""
enum professional_project_select_column {
  """column name"""
  contractTypeId

  """column name"""
  createdAt

  """column name"""
  employmentTypeId

  """column name"""
  hourlyRate

  """column name"""
  id

  """column name"""
  mobilityRadius

  """column name"""
  notebookId

  """column name"""
  romeCodeId

  """column name"""
  updatedAt

  """column name"""
  updatedBy
}

"""
input type for updating data in table "professional_project"
"""
input professional_project_set_input {
  contractTypeId: contract_type_enum
  createdAt: timestamptz
  employmentTypeId: employment_type_enum

  """in cents (divide by 100 for the EUR value)"""
  hourlyRate: Int
  id: uuid
  mobilityRadius: Int
  notebookId: uuid
  romeCodeId: uuid
  updatedAt: timestamptz
  updatedBy: uuid
}

"""aggregate stddev on columns"""
type professional_project_stddev_fields {
  """in cents (divide by 100 for the EUR value)"""
  hourlyRate: Float
  mobilityRadius: Float
}

"""
order by stddev() on columns of table "professional_project"
"""
input professional_project_stddev_order_by {
  """in cents (divide by 100 for the EUR value)"""
  hourlyRate: order_by
  mobilityRadius: order_by
}

"""aggregate stddev_pop on columns"""
type professional_project_stddev_pop_fields {
  """in cents (divide by 100 for the EUR value)"""
  hourlyRate: Float
  mobilityRadius: Float
}

"""
order by stddev_pop() on columns of table "professional_project"
"""
input professional_project_stddev_pop_order_by {
  """in cents (divide by 100 for the EUR value)"""
  hourlyRate: order_by
  mobilityRadius: order_by
}

"""aggregate stddev_samp on columns"""
type professional_project_stddev_samp_fields {
  """in cents (divide by 100 for the EUR value)"""
  hourlyRate: Float
  mobilityRadius: Float
}

"""
order by stddev_samp() on columns of table "professional_project"
"""
input professional_project_stddev_samp_order_by {
  """in cents (divide by 100 for the EUR value)"""
  hourlyRate: order_by
  mobilityRadius: order_by
}

"""
Streaming cursor of the table "professional_project"
"""
input professional_project_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: professional_project_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input professional_project_stream_cursor_value_input {
  contractTypeId: contract_type_enum
  createdAt: timestamptz
  employmentTypeId: employment_type_enum

  """in cents (divide by 100 for the EUR value)"""
  hourlyRate: Int
  id: uuid
  mobilityRadius: Int
  notebookId: uuid
  romeCodeId: uuid
  updatedAt: timestamptz
  updatedBy: uuid
}

"""aggregate sum on columns"""
type professional_project_sum_fields {
  """in cents (divide by 100 for the EUR value)"""
  hourlyRate: Int
  mobilityRadius: Int
}

"""
order by sum() on columns of table "professional_project"
"""
input professional_project_sum_order_by {
  """in cents (divide by 100 for the EUR value)"""
  hourlyRate: order_by
  mobilityRadius: order_by
}

"""
update columns of table "professional_project"
"""
enum professional_project_update_column {
  """column name"""
  contractTypeId

  """column name"""
  createdAt

  """column name"""
  employmentTypeId

  """column name"""
  hourlyRate

  """column name"""
  id

  """column name"""
  mobilityRadius

  """column name"""
  notebookId

  """column name"""
  romeCodeId

  """column name"""
  updatedAt

  """column name"""
  updatedBy
}

input professional_project_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: professional_project_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: professional_project_set_input

  """filter the rows which have to be updated"""
  where: professional_project_bool_exp!
}

"""aggregate var_pop on columns"""
type professional_project_var_pop_fields {
  """in cents (divide by 100 for the EUR value)"""
  hourlyRate: Float
  mobilityRadius: Float
}

"""
order by var_pop() on columns of table "professional_project"
"""
input professional_project_var_pop_order_by {
  """in cents (divide by 100 for the EUR value)"""
  hourlyRate: order_by
  mobilityRadius: order_by
}

"""aggregate var_samp on columns"""
type professional_project_var_samp_fields {
  """in cents (divide by 100 for the EUR value)"""
  hourlyRate: Float
  mobilityRadius: Float
}

"""
order by var_samp() on columns of table "professional_project"
"""
input professional_project_var_samp_order_by {
  """in cents (divide by 100 for the EUR value)"""
  hourlyRate: order_by
  mobilityRadius: order_by
}

"""aggregate variance on columns"""
type professional_project_variance_fields {
  """in cents (divide by 100 for the EUR value)"""
  hourlyRate: Float
  mobilityRadius: Float
}

"""
order by variance() on columns of table "professional_project"
"""
input professional_project_variance_order_by {
  """in cents (divide by 100 for the EUR value)"""
  hourlyRate: order_by
  mobilityRadius: order_by
}

"""
select columns of table "professional"
"""
enum professional_select_column {
  """column name"""
  createdAt

  """column name"""
  email

  """column name"""
  firstname

  """column name"""
  id

  """column name"""
  lastname

  """column name"""
  mobileNumber

  """column name"""
  position

  """column name"""
  structureId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "professional"
"""
input professional_set_input {
  createdAt: timestamptz
  email: citext
  firstname: String
  id: uuid
  lastname: String
  mobileNumber: String
  position: String
  structureId: uuid
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "professional"
"""
input professional_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: professional_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input professional_stream_cursor_value_input {
  createdAt: timestamptz
  email: citext
  firstname: String
  id: uuid
  lastname: String
  mobileNumber: String
  position: String
  structureId: uuid
  updatedAt: timestamptz
}

"""
update columns of table "professional"
"""
enum professional_update_column {
  """column name"""
  createdAt

  """column name"""
  email

  """column name"""
  firstname

  """column name"""
  id

  """column name"""
  lastname

  """column name"""
  mobileNumber

  """column name"""
  position

  """column name"""
  structureId

  """column name"""
  updatedAt
}

input professional_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: professional_set_input

  """filter the rows which have to be updated"""
  where: professional_bool_exp!
}

type query_root {
  """
  fetch data from the table: "account"
  """
  account(
    """distinct select on columns"""
    distinct_on: [account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_order_by!]

    """filter the rows returned"""
    where: account_bool_exp
  ): [account!]!

  """
  fetch aggregated fields from the table: "account"
  """
  account_aggregate(
    """distinct select on columns"""
    distinct_on: [account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_order_by!]

    """filter the rows returned"""
    where: account_bool_exp
  ): account_aggregate!

  """fetch data from the table: "account" using primary key columns"""
  account_by_pk(id: uuid!): account

  """
  fetch data from the table: "account_info"
  """
  account_info(
    """distinct select on columns"""
    distinct_on: [account_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_info_order_by!]

    """filter the rows returned"""
    where: account_info_bool_exp
  ): [account_info!]!

  """
  fetch aggregated fields from the table: "account_info"
  """
  account_info_aggregate(
    """distinct select on columns"""
    distinct_on: [account_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_info_order_by!]

    """filter the rows returned"""
    where: account_info_bool_exp
  ): account_info_aggregate!

  """
  fetch data from the table: "action_status"
  """
  action_status(
    """distinct select on columns"""
    distinct_on: [action_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_status_order_by!]

    """filter the rows returned"""
    where: action_status_bool_exp
  ): [action_status!]!

  """
  fetch aggregated fields from the table: "action_status"
  """
  action_status_aggregate(
    """distinct select on columns"""
    distinct_on: [action_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_status_order_by!]

    """filter the rows returned"""
    where: action_status_bool_exp
  ): action_status_aggregate!

  """fetch data from the table: "action_status" using primary key columns"""
  action_status_by_pk(status: String!): action_status

  """
  fetch data from the table: "admin_cdb"
  """
  admin_cdb(
    """distinct select on columns"""
    distinct_on: [admin_cdb_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admin_cdb_order_by!]

    """filter the rows returned"""
    where: admin_cdb_bool_exp
  ): [admin_cdb!]!

  """
  fetch aggregated fields from the table: "admin_cdb"
  """
  admin_cdb_aggregate(
    """distinct select on columns"""
    distinct_on: [admin_cdb_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admin_cdb_order_by!]

    """filter the rows returned"""
    where: admin_cdb_bool_exp
  ): admin_cdb_aggregate!

  """fetch data from the table: "admin_cdb" using primary key columns"""
  admin_cdb_by_pk(id: uuid!): admin_cdb

  """
  fetch data from the table: "admin_structure"
  """
  admin_structure(
    """distinct select on columns"""
    distinct_on: [admin_structure_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admin_structure_order_by!]

    """filter the rows returned"""
    where: admin_structure_bool_exp
  ): [admin_structure!]!

  """
  fetch aggregated fields from the table: "admin_structure"
  """
  admin_structure_aggregate(
    """distinct select on columns"""
    distinct_on: [admin_structure_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admin_structure_order_by!]

    """filter the rows returned"""
    where: admin_structure_bool_exp
  ): admin_structure_aggregate!

  """fetch data from the table: "admin_structure" using primary key columns"""
  admin_structure_by_pk(id: uuid!): admin_structure

  """
  fetch data from the table: "admin_structure_structure"
  """
  admin_structure_structure(
    """distinct select on columns"""
    distinct_on: [admin_structure_structure_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admin_structure_structure_order_by!]

    """filter the rows returned"""
    where: admin_structure_structure_bool_exp
  ): [admin_structure_structure!]!

  """
  fetch aggregated fields from the table: "admin_structure_structure"
  """
  admin_structure_structure_aggregate(
    """distinct select on columns"""
    distinct_on: [admin_structure_structure_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admin_structure_structure_order_by!]

    """filter the rows returned"""
    where: admin_structure_structure_bool_exp
  ): admin_structure_structure_aggregate!

  """
  fetch data from the table: "admin_structure_structure" using primary key columns
  """
  admin_structure_structure_by_pk(id: uuid!): admin_structure_structure

  """
  fetch data from the table: "beneficiary"
  """
  beneficiary(
    """distinct select on columns"""
    distinct_on: [beneficiary_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [beneficiary_order_by!]

    """filter the rows returned"""
    where: beneficiary_bool_exp
  ): [beneficiary!]!

  """
  fetch aggregated fields from the table: "beneficiary"
  """
  beneficiary_aggregate(
    """distinct select on columns"""
    distinct_on: [beneficiary_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [beneficiary_order_by!]

    """filter the rows returned"""
    where: beneficiary_bool_exp
  ): beneficiary_aggregate!

  """fetch data from the table: "beneficiary" using primary key columns"""
  beneficiary_by_pk(id: uuid!): beneficiary

  """
  fetch data from the table: "beneficiary_structure"
  """
  beneficiary_structure(
    """distinct select on columns"""
    distinct_on: [beneficiary_structure_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [beneficiary_structure_order_by!]

    """filter the rows returned"""
    where: beneficiary_structure_bool_exp
  ): [beneficiary_structure!]!

  """
  fetch aggregated fields from the table: "beneficiary_structure"
  """
  beneficiary_structure_aggregate(
    """distinct select on columns"""
    distinct_on: [beneficiary_structure_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [beneficiary_structure_order_by!]

    """filter the rows returned"""
    where: beneficiary_structure_bool_exp
  ): beneficiary_structure_aggregate!

  """
  fetch data from the table: "beneficiary_structure" using primary key columns
  """
  beneficiary_structure_by_pk(id: uuid!): beneficiary_structure

  """
  fetch data from the table: "contract_type"
  """
  contract_type(
    """distinct select on columns"""
    distinct_on: [contract_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [contract_type_order_by!]

    """filter the rows returned"""
    where: contract_type_bool_exp
  ): [contract_type!]!

  """
  fetch aggregated fields from the table: "contract_type"
  """
  contract_type_aggregate(
    """distinct select on columns"""
    distinct_on: [contract_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [contract_type_order_by!]

    """filter the rows returned"""
    where: contract_type_bool_exp
  ): contract_type_aggregate!

  """fetch data from the table: "contract_type" using primary key columns"""
  contract_type_by_pk(id: String!): contract_type

  """
  fetch data from the table: "deployment"
  """
  deployment(
    """distinct select on columns"""
    distinct_on: [deployment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [deployment_order_by!]

    """filter the rows returned"""
    where: deployment_bool_exp
  ): [deployment!]!

  """
  fetch aggregated fields from the table: "deployment"
  """
  deployment_aggregate(
    """distinct select on columns"""
    distinct_on: [deployment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [deployment_order_by!]

    """filter the rows returned"""
    where: deployment_bool_exp
  ): deployment_aggregate!

  """fetch data from the table: "deployment" using primary key columns"""
  deployment_by_pk(id: uuid!): deployment

  """R√©cup√©ration du diagnostic individu pole-emploi"""
  diagnostic_pole_emploi(notebookId: uuid!): PoleEmploiDossierIndividu

  """
  fetch data from the table: "employment_type"
  """
  employment_type(
    """distinct select on columns"""
    distinct_on: [employment_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employment_type_order_by!]

    """filter the rows returned"""
    where: employment_type_bool_exp
  ): [employment_type!]!

  """
  fetch aggregated fields from the table: "employment_type"
  """
  employment_type_aggregate(
    """distinct select on columns"""
    distinct_on: [employment_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employment_type_order_by!]

    """filter the rows returned"""
    where: employment_type_bool_exp
  ): employment_type_aggregate!

  """fetch data from the table: "employment_type" using primary key columns"""
  employment_type_by_pk(id: String!): employment_type

  """An array relationship"""
  external_data(
    """distinct select on columns"""
    distinct_on: [external_data_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [external_data_order_by!]

    """filter the rows returned"""
    where: external_data_bool_exp
  ): [external_data!]!

  """An aggregate relationship"""
  external_data_aggregate(
    """distinct select on columns"""
    distinct_on: [external_data_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [external_data_order_by!]

    """filter the rows returned"""
    where: external_data_bool_exp
  ): external_data_aggregate!

  """fetch data from the table: "external_data" using primary key columns"""
  external_data_by_pk(id: uuid!): external_data

  """
  fetch data from the table: "external_data_info"
  """
  external_data_info(
    """distinct select on columns"""
    distinct_on: [external_data_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [external_data_info_order_by!]

    """filter the rows returned"""
    where: external_data_info_bool_exp
  ): [external_data_info!]!

  """
  fetch aggregated fields from the table: "external_data_info"
  """
  external_data_info_aggregate(
    """distinct select on columns"""
    distinct_on: [external_data_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [external_data_info_order_by!]

    """filter the rows returned"""
    where: external_data_info_bool_exp
  ): external_data_info_aggregate!

  """
  fetch data from the table: "external_data_info" using primary key columns
  """
  external_data_info_by_pk(external_data_id: uuid!): external_data_info

  """
  fetch data from the table: "external_source"
  """
  external_source(
    """distinct select on columns"""
    distinct_on: [external_source_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [external_source_order_by!]

    """filter the rows returned"""
    where: external_source_bool_exp
  ): [external_source!]!

  """
  fetch aggregated fields from the table: "external_source"
  """
  external_source_aggregate(
    """distinct select on columns"""
    distinct_on: [external_source_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [external_source_order_by!]

    """filter the rows returned"""
    where: external_source_bool_exp
  ): external_source_aggregate!

  """fetch data from the table: "external_source" using primary key columns"""
  external_source_by_pk(value: String!): external_source

  """
  execute function "get_beneficiaries_from_nir" which returns "beneficiary"
  """
  get_beneficiaries_from_nir(
    """
    input parameters for function "get_beneficiaries_from_nir"
    """
    args: get_beneficiaries_from_nir_args!

    """distinct select on columns"""
    distinct_on: [beneficiary_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [beneficiary_order_by!]

    """filter the rows returned"""
    where: beneficiary_bool_exp
  ): [beneficiary!]!

  """
  execute function "get_beneficiaries_from_nir" and query aggregates on result of table type "beneficiary"
  """
  get_beneficiaries_from_nir_aggregate(
    """
    input parameters for function "get_beneficiaries_from_nir_aggregate"
    """
    args: get_beneficiaries_from_nir_args!

    """distinct select on columns"""
    distinct_on: [beneficiary_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [beneficiary_order_by!]

    """filter the rows returned"""
    where: beneficiary_bool_exp
  ): beneficiary_aggregate!

  """
  fetch data from the table: "manager"
  """
  manager(
    """distinct select on columns"""
    distinct_on: [manager_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [manager_order_by!]

    """filter the rows returned"""
    where: manager_bool_exp
  ): [manager!]!

  """
  fetch aggregated fields from the table: "manager"
  """
  manager_aggregate(
    """distinct select on columns"""
    distinct_on: [manager_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [manager_order_by!]

    """filter the rows returned"""
    where: manager_bool_exp
  ): manager_aggregate!

  """fetch data from the table: "manager" using primary key columns"""
  manager_by_pk(id: uuid!): manager

  """
  fetch data from the table: "notebook"
  """
  notebook(
    """distinct select on columns"""
    distinct_on: [notebook_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_order_by!]

    """filter the rows returned"""
    where: notebook_bool_exp
  ): [notebook!]!

  """
  fetch data from the table: "notebook_action"
  """
  notebook_action(
    """distinct select on columns"""
    distinct_on: [notebook_action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_action_order_by!]

    """filter the rows returned"""
    where: notebook_action_bool_exp
  ): [notebook_action!]!

  """
  fetch aggregated fields from the table: "notebook_action"
  """
  notebook_action_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_action_order_by!]

    """filter the rows returned"""
    where: notebook_action_bool_exp
  ): notebook_action_aggregate!

  """fetch data from the table: "notebook_action" using primary key columns"""
  notebook_action_by_pk(id: uuid!): notebook_action

  """
  fetch aggregated fields from the table: "notebook"
  """
  notebook_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_order_by!]

    """filter the rows returned"""
    where: notebook_bool_exp
  ): notebook_aggregate!

  """
  fetch data from the table: "notebook_appointment"
  """
  notebook_appointment(
    """distinct select on columns"""
    distinct_on: [notebook_appointment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_appointment_order_by!]

    """filter the rows returned"""
    where: notebook_appointment_bool_exp
  ): [notebook_appointment!]!

  """
  fetch aggregated fields from the table: "notebook_appointment"
  """
  notebook_appointment_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_appointment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_appointment_order_by!]

    """filter the rows returned"""
    where: notebook_appointment_bool_exp
  ): notebook_appointment_aggregate!

  """
  fetch data from the table: "notebook_appointment" using primary key columns
  """
  notebook_appointment_by_pk(id: uuid!): notebook_appointment

  """fetch data from the table: "notebook" using primary key columns"""
  notebook_by_pk(id: uuid!): notebook

  """
  fetch data from the table: "notebook_creation"
  """
  notebook_creation(
    """distinct select on columns"""
    distinct_on: [notebook_creation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_creation_order_by!]

    """filter the rows returned"""
    where: notebook_creation_bool_exp
  ): [notebook_creation!]!

  """
  fetch aggregated fields from the table: "notebook_creation"
  """
  notebook_creation_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_creation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_creation_order_by!]

    """filter the rows returned"""
    where: notebook_creation_bool_exp
  ): notebook_creation_aggregate!

  """
  fetch data from the table: "notebook_creation" using primary key columns
  """
  notebook_creation_by_pk(id: uuid!): notebook_creation

  """
  fetch data from the table: "notebook_creation_source_type"
  """
  notebook_creation_source_type(
    """distinct select on columns"""
    distinct_on: [notebook_creation_source_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_creation_source_type_order_by!]

    """filter the rows returned"""
    where: notebook_creation_source_type_bool_exp
  ): [notebook_creation_source_type!]!

  """
  fetch aggregated fields from the table: "notebook_creation_source_type"
  """
  notebook_creation_source_type_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_creation_source_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_creation_source_type_order_by!]

    """filter the rows returned"""
    where: notebook_creation_source_type_bool_exp
  ): notebook_creation_source_type_aggregate!

  """
  fetch data from the table: "notebook_creation_source_type" using primary key columns
  """
  notebook_creation_source_type_by_pk(id: String!): notebook_creation_source_type

  """
  fetch data from the table: "notebook_event"
  """
  notebook_event(
    """distinct select on columns"""
    distinct_on: [notebook_event_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_event_order_by!]

    """filter the rows returned"""
    where: notebook_event_bool_exp
  ): [notebook_event!]!

  """
  fetch aggregated fields from the table: "notebook_event"
  """
  notebook_event_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_event_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_event_order_by!]

    """filter the rows returned"""
    where: notebook_event_bool_exp
  ): notebook_event_aggregate!

  """fetch data from the table: "notebook_event" using primary key columns"""
  notebook_event_by_pk(id: uuid!): notebook_event

  """
  fetch data from the table: "notebook_event_type"
  """
  notebook_event_type(
    """distinct select on columns"""
    distinct_on: [notebook_event_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_event_type_order_by!]

    """filter the rows returned"""
    where: notebook_event_type_bool_exp
  ): [notebook_event_type!]!

  """
  fetch aggregated fields from the table: "notebook_event_type"
  """
  notebook_event_type_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_event_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_event_type_order_by!]

    """filter the rows returned"""
    where: notebook_event_type_bool_exp
  ): notebook_event_type_aggregate!

  """
  fetch data from the table: "notebook_event_type" using primary key columns
  """
  notebook_event_type_by_pk(value: String!): notebook_event_type

  """
  fetch data from the table: "notebook_focus"
  """
  notebook_focus(
    """distinct select on columns"""
    distinct_on: [notebook_focus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_focus_order_by!]

    """filter the rows returned"""
    where: notebook_focus_bool_exp
  ): [notebook_focus!]!

  """
  fetch aggregated fields from the table: "notebook_focus"
  """
  notebook_focus_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_focus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_focus_order_by!]

    """filter the rows returned"""
    where: notebook_focus_bool_exp
  ): notebook_focus_aggregate!

  """fetch data from the table: "notebook_focus" using primary key columns"""
  notebook_focus_by_pk(id: uuid!): notebook_focus

  """
  fetch data from the table: "notebook_info"
  """
  notebook_info(
    """distinct select on columns"""
    distinct_on: [notebook_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_info_order_by!]

    """filter the rows returned"""
    where: notebook_info_bool_exp
  ): [notebook_info!]!

  """
  fetch aggregated fields from the table: "notebook_info"
  """
  notebook_info_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_info_order_by!]

    """filter the rows returned"""
    where: notebook_info_bool_exp
  ): notebook_info_aggregate!

  """fetch data from the table: "notebook_info" using primary key columns"""
  notebook_info_by_pk(notebookId: uuid!): notebook_info

  """
  fetch data from the table: "notebook_member"
  """
  notebook_member(
    """distinct select on columns"""
    distinct_on: [notebook_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_member_order_by!]

    """filter the rows returned"""
    where: notebook_member_bool_exp
  ): [notebook_member!]!

  """
  fetch aggregated fields from the table: "notebook_member"
  """
  notebook_member_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_member_order_by!]

    """filter the rows returned"""
    where: notebook_member_bool_exp
  ): notebook_member_aggregate!

  """fetch data from the table: "notebook_member" using primary key columns"""
  notebook_member_by_pk(id: uuid!): notebook_member

  """
  fetch data from the table: "notebook_public_view"
  """
  notebook_public_view(
    """distinct select on columns"""
    distinct_on: [notebook_public_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_public_view_order_by!]

    """filter the rows returned"""
    where: notebook_public_view_bool_exp
  ): [notebook_public_view!]!

  """
  fetch aggregated fields from the table: "notebook_public_view"
  """
  notebook_public_view_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_public_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_public_view_order_by!]

    """filter the rows returned"""
    where: notebook_public_view_bool_exp
  ): notebook_public_view_aggregate!

  """
  fetch data from the table: "notebook_situation"
  """
  notebook_situation(
    """distinct select on columns"""
    distinct_on: [notebook_situation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_situation_order_by!]

    """filter the rows returned"""
    where: notebook_situation_bool_exp
  ): [notebook_situation!]!

  """
  fetch aggregated fields from the table: "notebook_situation"
  """
  notebook_situation_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_situation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_situation_order_by!]

    """filter the rows returned"""
    where: notebook_situation_bool_exp
  ): notebook_situation_aggregate!

  """
  fetch data from the table: "notebook_situation" using primary key columns
  """
  notebook_situation_by_pk(id: uuid!): notebook_situation

  """
  fetch data from the table: "notebook_target"
  """
  notebook_target(
    """distinct select on columns"""
    distinct_on: [notebook_target_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_target_order_by!]

    """filter the rows returned"""
    where: notebook_target_bool_exp
  ): [notebook_target!]!

  """
  fetch aggregated fields from the table: "notebook_target"
  """
  notebook_target_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_target_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_target_order_by!]

    """filter the rows returned"""
    where: notebook_target_bool_exp
  ): notebook_target_aggregate!

  """fetch data from the table: "notebook_target" using primary key columns"""
  notebook_target_by_pk(id: uuid!): notebook_target

  """
  fetch data from the table: "notebook_update"
  """
  notebook_update(
    """distinct select on columns"""
    distinct_on: [notebook_update_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_update_order_by!]

    """filter the rows returned"""
    where: notebook_update_bool_exp
  ): [notebook_update!]!

  """
  fetch aggregated fields from the table: "notebook_update"
  """
  notebook_update_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_update_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_update_order_by!]

    """filter the rows returned"""
    where: notebook_update_bool_exp
  ): notebook_update_aggregate!

  """fetch data from the table: "notebook_update" using primary key columns"""
  notebook_update_by_pk(id: uuid!): notebook_update

  """
  fetch data from the table: "notebook_visit"
  """
  notebook_visit(
    """distinct select on columns"""
    distinct_on: [notebook_visit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_visit_order_by!]

    """filter the rows returned"""
    where: notebook_visit_bool_exp
  ): [notebook_visit!]!

  """
  fetch aggregated fields from the table: "notebook_visit"
  """
  notebook_visit_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_visit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_visit_order_by!]

    """filter the rows returned"""
    where: notebook_visit_bool_exp
  ): notebook_visit_aggregate!

  """fetch data from the table: "notebook_visit" using primary key columns"""
  notebook_visit_by_pk(id: uuid!): notebook_visit

  """
  fetch data from the table: "nps_rating"
  """
  nps_rating(
    """distinct select on columns"""
    distinct_on: [nps_rating_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [nps_rating_order_by!]

    """filter the rows returned"""
    where: nps_rating_bool_exp
  ): [nps_rating!]!

  """
  fetch aggregated fields from the table: "nps_rating"
  """
  nps_rating_aggregate(
    """distinct select on columns"""
    distinct_on: [nps_rating_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [nps_rating_order_by!]

    """filter the rows returned"""
    where: nps_rating_bool_exp
  ): nps_rating_aggregate!

  """fetch data from the table: "nps_rating" using primary key columns"""
  nps_rating_by_pk(id: uuid!): nps_rating

  """
  fetch data from the table: "nps_rating_dismissal"
  """
  nps_rating_dismissal(
    """distinct select on columns"""
    distinct_on: [nps_rating_dismissal_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [nps_rating_dismissal_order_by!]

    """filter the rows returned"""
    where: nps_rating_dismissal_bool_exp
  ): [nps_rating_dismissal!]!

  """
  fetch aggregated fields from the table: "nps_rating_dismissal"
  """
  nps_rating_dismissal_aggregate(
    """distinct select on columns"""
    distinct_on: [nps_rating_dismissal_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [nps_rating_dismissal_order_by!]

    """filter the rows returned"""
    where: nps_rating_dismissal_bool_exp
  ): nps_rating_dismissal_aggregate!

  """
  fetch data from the table: "nps_rating_dismissal" using primary key columns
  """
  nps_rating_dismissal_by_pk(id: uuid!): nps_rating_dismissal

  """
  fetch data from the table: "orientation_manager"
  """
  orientation_manager(
    """distinct select on columns"""
    distinct_on: [orientation_manager_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [orientation_manager_order_by!]

    """filter the rows returned"""
    where: orientation_manager_bool_exp
  ): [orientation_manager!]!

  """
  fetch aggregated fields from the table: "orientation_manager"
  """
  orientation_manager_aggregate(
    """distinct select on columns"""
    distinct_on: [orientation_manager_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [orientation_manager_order_by!]

    """filter the rows returned"""
    where: orientation_manager_bool_exp
  ): orientation_manager_aggregate!

  """
  fetch data from the table: "orientation_manager" using primary key columns
  """
  orientation_manager_by_pk(id: uuid!): orientation_manager

  """
  fetch data from the table: "orientation_request"
  """
  orientation_request(
    """distinct select on columns"""
    distinct_on: [orientation_request_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [orientation_request_order_by!]

    """filter the rows returned"""
    where: orientation_request_bool_exp
  ): [orientation_request!]!

  """
  fetch aggregated fields from the table: "orientation_request"
  """
  orientation_request_aggregate(
    """distinct select on columns"""
    distinct_on: [orientation_request_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [orientation_request_order_by!]

    """filter the rows returned"""
    where: orientation_request_bool_exp
  ): orientation_request_aggregate!

  """
  fetch data from the table: "orientation_request" using primary key columns
  """
  orientation_request_by_pk(id: uuid!): orientation_request

  """
  fetch data from the table: "orientation_system"
  """
  orientation_system(
    """distinct select on columns"""
    distinct_on: [orientation_system_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [orientation_system_order_by!]

    """filter the rows returned"""
    where: orientation_system_bool_exp
  ): [orientation_system!]!

  """
  fetch aggregated fields from the table: "orientation_system"
  """
  orientation_system_aggregate(
    """distinct select on columns"""
    distinct_on: [orientation_system_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [orientation_system_order_by!]

    """filter the rows returned"""
    where: orientation_system_bool_exp
  ): orientation_system_aggregate!

  """
  fetch data from the table: "orientation_system" using primary key columns
  """
  orientation_system_by_pk(id: uuid!): orientation_system

  """
  fetch data from the table: "orientation_type"
  """
  orientation_type(
    """distinct select on columns"""
    distinct_on: [orientation_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [orientation_type_order_by!]

    """filter the rows returned"""
    where: orientation_type_bool_exp
  ): [orientation_type!]!

  """
  fetch aggregated fields from the table: "orientation_type"
  """
  orientation_type_aggregate(
    """distinct select on columns"""
    distinct_on: [orientation_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [orientation_type_order_by!]

    """filter the rows returned"""
    where: orientation_type_bool_exp
  ): orientation_type_aggregate!

  """
  fetch data from the table: "orientation_type" using primary key columns
  """
  orientation_type_by_pk(id: String!): orientation_type

  """
  fetch data from the table: "professional"
  """
  professional(
    """distinct select on columns"""
    distinct_on: [professional_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [professional_order_by!]

    """filter the rows returned"""
    where: professional_bool_exp
  ): [professional!]!

  """
  fetch aggregated fields from the table: "professional"
  """
  professional_aggregate(
    """distinct select on columns"""
    distinct_on: [professional_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [professional_order_by!]

    """filter the rows returned"""
    where: professional_bool_exp
  ): professional_aggregate!

  """fetch data from the table: "professional" using primary key columns"""
  professional_by_pk(id: uuid!): professional

  """
  fetch data from the table: "professional_orientation_system"
  """
  professional_orientation_system(
    """distinct select on columns"""
    distinct_on: [professional_orientation_system_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [professional_orientation_system_order_by!]

    """filter the rows returned"""
    where: professional_orientation_system_bool_exp
  ): [professional_orientation_system!]!

  """
  fetch aggregated fields from the table: "professional_orientation_system"
  """
  professional_orientation_system_aggregate(
    """distinct select on columns"""
    distinct_on: [professional_orientation_system_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [professional_orientation_system_order_by!]

    """filter the rows returned"""
    where: professional_orientation_system_bool_exp
  ): professional_orientation_system_aggregate!

  """
  fetch data from the table: "professional_orientation_system" using primary key columns
  """
  professional_orientation_system_by_pk(id: uuid!): professional_orientation_system

  """
  fetch data from the table: "professional_project"
  """
  professional_project(
    """distinct select on columns"""
    distinct_on: [professional_project_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [professional_project_order_by!]

    """filter the rows returned"""
    where: professional_project_bool_exp
  ): [professional_project!]!

  """
  fetch aggregated fields from the table: "professional_project"
  """
  professional_project_aggregate(
    """distinct select on columns"""
    distinct_on: [professional_project_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [professional_project_order_by!]

    """filter the rows returned"""
    where: professional_project_bool_exp
  ): professional_project_aggregate!

  """
  fetch data from the table: "professional_project" using primary key columns
  """
  professional_project_by_pk(id: uuid!): professional_project

  """
  fetch data from the table: "ref_action"
  """
  ref_action(
    """distinct select on columns"""
    distinct_on: [ref_action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_action_order_by!]

    """filter the rows returned"""
    where: ref_action_bool_exp
  ): [ref_action!]!

  """
  fetch aggregated fields from the table: "ref_action"
  """
  ref_action_aggregate(
    """distinct select on columns"""
    distinct_on: [ref_action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_action_order_by!]

    """filter the rows returned"""
    where: ref_action_bool_exp
  ): ref_action_aggregate!

  """fetch data from the table: "ref_action" using primary key columns"""
  ref_action_by_pk(id: uuid!): ref_action

  """
  fetch data from the table: "ref_situation"
  """
  ref_situation(
    """distinct select on columns"""
    distinct_on: [ref_situation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_situation_order_by!]

    """filter the rows returned"""
    where: ref_situation_bool_exp
  ): [ref_situation!]!

  """
  fetch aggregated fields from the table: "ref_situation"
  """
  ref_situation_aggregate(
    """distinct select on columns"""
    distinct_on: [ref_situation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_situation_order_by!]

    """filter the rows returned"""
    where: ref_situation_bool_exp
  ): ref_situation_aggregate!

  """fetch data from the table: "ref_situation" using primary key columns"""
  ref_situation_by_pk(id: uuid!): ref_situation

  """
  fetch data from the table: "ref_target"
  """
  ref_target(
    """distinct select on columns"""
    distinct_on: [ref_target_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_target_order_by!]

    """filter the rows returned"""
    where: ref_target_bool_exp
  ): [ref_target!]!

  """
  fetch aggregated fields from the table: "ref_target"
  """
  ref_target_aggregate(
    """distinct select on columns"""
    distinct_on: [ref_target_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_target_order_by!]

    """filter the rows returned"""
    where: ref_target_bool_exp
  ): ref_target_aggregate!

  """fetch data from the table: "ref_target" using primary key columns"""
  ref_target_by_pk(id: uuid!): ref_target

  """
  fetch data from the table: "ref_theme"
  """
  ref_theme(
    """distinct select on columns"""
    distinct_on: [ref_theme_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_theme_order_by!]

    """filter the rows returned"""
    where: ref_theme_bool_exp
  ): [ref_theme!]!

  """
  fetch aggregated fields from the table: "ref_theme"
  """
  ref_theme_aggregate(
    """distinct select on columns"""
    distinct_on: [ref_theme_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_theme_order_by!]

    """filter the rows returned"""
    where: ref_theme_bool_exp
  ): ref_theme_aggregate!

  """fetch data from the table: "ref_theme" using primary key columns"""
  ref_theme_by_pk(name: String!): ref_theme

  """
  fetch data from the table: "role"
  """
  role(
    """distinct select on columns"""
    distinct_on: [role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_order_by!]

    """filter the rows returned"""
    where: role_bool_exp
  ): [role!]!

  """
  fetch aggregated fields from the table: "role"
  """
  role_aggregate(
    """distinct select on columns"""
    distinct_on: [role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_order_by!]

    """filter the rows returned"""
    where: role_bool_exp
  ): role_aggregate!

  """fetch data from the table: "role" using primary key columns"""
  role_by_pk(label: String!): role

  """
  fetch data from the table: "rome_code"
  """
  rome_code(
    """distinct select on columns"""
    distinct_on: [rome_code_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rome_code_order_by!]

    """filter the rows returned"""
    where: rome_code_bool_exp
  ): [rome_code!]!

  """
  fetch aggregated fields from the table: "rome_code"
  """
  rome_code_aggregate(
    """distinct select on columns"""
    distinct_on: [rome_code_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rome_code_order_by!]

    """filter the rows returned"""
    where: rome_code_bool_exp
  ): rome_code_aggregate!

  """fetch data from the table: "rome_code" using primary key columns"""
  rome_code_by_pk(id: uuid!): rome_code

  """
  fetch data from the table: "rsa_closure_reason"
  """
  rsa_closure_reason(
    """distinct select on columns"""
    distinct_on: [rsa_closure_reason_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rsa_closure_reason_order_by!]

    """filter the rows returned"""
    where: rsa_closure_reason_bool_exp
  ): [rsa_closure_reason!]!

  """
  fetch aggregated fields from the table: "rsa_closure_reason"
  """
  rsa_closure_reason_aggregate(
    """distinct select on columns"""
    distinct_on: [rsa_closure_reason_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rsa_closure_reason_order_by!]

    """filter the rows returned"""
    where: rsa_closure_reason_bool_exp
  ): rsa_closure_reason_aggregate!

  """
  fetch data from the table: "rsa_closure_reason" using primary key columns
  """
  rsa_closure_reason_by_pk(code: String!): rsa_closure_reason

  """
  fetch data from the table: "rsa_suspension_reason"
  """
  rsa_suspension_reason(
    """distinct select on columns"""
    distinct_on: [rsa_suspension_reason_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rsa_suspension_reason_order_by!]

    """filter the rows returned"""
    where: rsa_suspension_reason_bool_exp
  ): [rsa_suspension_reason!]!

  """
  fetch aggregated fields from the table: "rsa_suspension_reason"
  """
  rsa_suspension_reason_aggregate(
    """distinct select on columns"""
    distinct_on: [rsa_suspension_reason_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rsa_suspension_reason_order_by!]

    """filter the rows returned"""
    where: rsa_suspension_reason_bool_exp
  ): rsa_suspension_reason_aggregate!

  """
  fetch data from the table: "rsa_suspension_reason" using primary key columns
  """
  rsa_suspension_reason_by_pk(code: String!): rsa_suspension_reason

  """
  execute function "search_beneficiaries" which returns "beneficiary"
  """
  search_beneficiaries(
    """
    input parameters for function "search_beneficiaries"
    """
    args: search_beneficiaries_args!

    """distinct select on columns"""
    distinct_on: [beneficiary_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [beneficiary_order_by!]

    """filter the rows returned"""
    where: beneficiary_bool_exp
  ): [beneficiary!]!

  """
  execute function "search_beneficiaries" and query aggregates on result of table type "beneficiary"
  """
  search_beneficiaries_aggregate(
    """
    input parameters for function "search_beneficiaries_aggregate"
    """
    args: search_beneficiaries_args!

    """distinct select on columns"""
    distinct_on: [beneficiary_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [beneficiary_order_by!]

    """filter the rows returned"""
    where: beneficiary_bool_exp
  ): beneficiary_aggregate!

  """
  execute function "search_notebook_members" which returns "notebook_member"
  """
  search_notebook_members(
    """
    input parameters for function "search_notebook_members"
    """
    args: search_notebook_members_args!

    """distinct select on columns"""
    distinct_on: [notebook_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_member_order_by!]

    """filter the rows returned"""
    where: notebook_member_bool_exp
  ): [notebook_member!]!

  """
  execute function "search_notebook_members" and query aggregates on result of table type "notebook_member"
  """
  search_notebook_members_aggregate(
    """
    input parameters for function "search_notebook_members_aggregate"
    """
    args: search_notebook_members_args!

    """distinct select on columns"""
    distinct_on: [notebook_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_member_order_by!]

    """filter the rows returned"""
    where: notebook_member_bool_exp
  ): notebook_member_aggregate!

  """
  execute function "search_public_notebooks" which returns "notebook_public_view"
  """
  search_public_notebooks(
    """
    input parameters for function "search_public_notebooks"
    """
    args: search_public_notebooks_args!

    """distinct select on columns"""
    distinct_on: [notebook_public_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_public_view_order_by!]

    """filter the rows returned"""
    where: notebook_public_view_bool_exp
  ): [notebook_public_view!]!

  """
  execute function "search_public_notebooks" and query aggregates on result of table type "notebook_public_view"
  """
  search_public_notebooks_aggregate(
    """
    input parameters for function "search_public_notebooks_aggregate"
    """
    args: search_public_notebooks_args!

    """distinct select on columns"""
    distinct_on: [notebook_public_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_public_view_order_by!]

    """filter the rows returned"""
    where: notebook_public_view_bool_exp
  ): notebook_public_view_aggregate!

  """
  execute function "search_ref_action" which returns "ref_action"
  """
  search_ref_action(
    """
    input parameters for function "search_ref_action"
    """
    args: search_ref_action_args!

    """distinct select on columns"""
    distinct_on: [ref_action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_action_order_by!]

    """filter the rows returned"""
    where: ref_action_bool_exp
  ): [ref_action!]!

  """
  execute function "search_ref_action" and query aggregates on result of table type "ref_action"
  """
  search_ref_action_aggregate(
    """
    input parameters for function "search_ref_action_aggregate"
    """
    args: search_ref_action_args!

    """distinct select on columns"""
    distinct_on: [ref_action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_action_order_by!]

    """filter the rows returned"""
    where: ref_action_bool_exp
  ): ref_action_aggregate!

  """
  execute function "search_rome_codes" which returns "rome_code"
  """
  search_rome_codes(
    """
    input parameters for function "search_rome_codes"
    """
    args: search_rome_codes_args!

    """distinct select on columns"""
    distinct_on: [rome_code_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rome_code_order_by!]

    """filter the rows returned"""
    where: rome_code_bool_exp
  ): [rome_code!]!

  """
  execute function "search_rome_codes" and query aggregates on result of table type "rome_code"
  """
  search_rome_codes_aggregate(
    """
    input parameters for function "search_rome_codes_aggregate"
    """
    args: search_rome_codes_args!

    """distinct select on columns"""
    distinct_on: [rome_code_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rome_code_order_by!]

    """filter the rows returned"""
    where: rome_code_bool_exp
  ): rome_code_aggregate!

  """
  fetch data from the table: "structure"
  """
  structure(
    """distinct select on columns"""
    distinct_on: [structure_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [structure_order_by!]

    """filter the rows returned"""
    where: structure_bool_exp
  ): [structure!]!

  """
  fetch aggregated fields from the table: "structure"
  """
  structure_aggregate(
    """distinct select on columns"""
    distinct_on: [structure_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [structure_order_by!]

    """filter the rows returned"""
    where: structure_bool_exp
  ): structure_aggregate!

  """fetch data from the table: "structure" using primary key columns"""
  structure_by_pk(id: uuid!): structure

  """
  fetch data from the table: "structure_orientation_system"
  """
  structure_orientation_system(
    """distinct select on columns"""
    distinct_on: [structure_orientation_system_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [structure_orientation_system_order_by!]

    """filter the rows returned"""
    where: structure_orientation_system_bool_exp
  ): [structure_orientation_system!]!

  """
  fetch aggregated fields from the table: "structure_orientation_system"
  """
  structure_orientation_system_aggregate(
    """distinct select on columns"""
    distinct_on: [structure_orientation_system_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [structure_orientation_system_order_by!]

    """filter the rows returned"""
    where: structure_orientation_system_bool_exp
  ): structure_orientation_system_aggregate!

  """
  fetch data from the table: "structure_orientation_system" using primary key columns
  """
  structure_orientation_system_by_pk(id: uuid!): structure_orientation_system
}

"""
columns and relationships of "ref_action"
"""
type ref_action {
  description: String!
  id: uuid!

  """An object relationship"""
  refTheme: ref_theme!
  theme: ref_theme_enum!
}

"""
aggregated selection of "ref_action"
"""
type ref_action_aggregate {
  aggregate: ref_action_aggregate_fields
  nodes: [ref_action!]!
}

"""
aggregate fields of "ref_action"
"""
type ref_action_aggregate_fields {
  count(columns: [ref_action_select_column!], distinct: Boolean): Int!
  max: ref_action_max_fields
  min: ref_action_min_fields
}

"""
Boolean expression to filter rows from the table "ref_action". All fields are combined with a logical 'AND'.
"""
input ref_action_bool_exp {
  _and: [ref_action_bool_exp!]
  _not: ref_action_bool_exp
  _or: [ref_action_bool_exp!]
  description: String_comparison_exp
  id: uuid_comparison_exp
  refTheme: ref_theme_bool_exp
  theme: ref_theme_enum_comparison_exp
}

"""
unique or primary key constraints on table "ref_action"
"""
enum ref_action_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  ref_action_pkey
}

"""
input type for inserting data into table "ref_action"
"""
input ref_action_insert_input {
  description: String
  id: uuid
  refTheme: ref_theme_obj_rel_insert_input
  theme: ref_theme_enum
}

"""aggregate max on columns"""
type ref_action_max_fields {
  description: String
  id: uuid
}

"""aggregate min on columns"""
type ref_action_min_fields {
  description: String
  id: uuid
}

"""
response of any mutation on the table "ref_action"
"""
type ref_action_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [ref_action!]!
}

"""
on_conflict condition type for table "ref_action"
"""
input ref_action_on_conflict {
  constraint: ref_action_constraint!
  update_columns: [ref_action_update_column!]! = []
  where: ref_action_bool_exp
}

"""Ordering options when selecting data from "ref_action"."""
input ref_action_order_by {
  description: order_by
  id: order_by
  refTheme: ref_theme_order_by
  theme: order_by
}

"""primary key columns input for table: ref_action"""
input ref_action_pk_columns_input {
  id: uuid!
}

"""
select columns of table "ref_action"
"""
enum ref_action_select_column {
  """column name"""
  description

  """column name"""
  id

  """column name"""
  theme
}

"""
input type for updating data in table "ref_action"
"""
input ref_action_set_input {
  description: String
  id: uuid
  theme: ref_theme_enum
}

"""
Streaming cursor of the table "ref_action"
"""
input ref_action_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: ref_action_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input ref_action_stream_cursor_value_input {
  description: String
  id: uuid
  theme: ref_theme_enum
}

"""
update columns of table "ref_action"
"""
enum ref_action_update_column {
  """column name"""
  description

  """column name"""
  id

  """column name"""
  theme
}

input ref_action_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: ref_action_set_input

  """filter the rows which have to be updated"""
  where: ref_action_bool_exp!
}

"""
columns and relationships of "ref_situation"
"""
type ref_situation {
  description: String!
  id: uuid!

  """An object relationship"""
  refTheme: ref_theme!
  theme: ref_theme_enum!
}

"""
aggregated selection of "ref_situation"
"""
type ref_situation_aggregate {
  aggregate: ref_situation_aggregate_fields
  nodes: [ref_situation!]!
}

"""
aggregate fields of "ref_situation"
"""
type ref_situation_aggregate_fields {
  count(columns: [ref_situation_select_column!], distinct: Boolean): Int!
  max: ref_situation_max_fields
  min: ref_situation_min_fields
}

"""
Boolean expression to filter rows from the table "ref_situation". All fields are combined with a logical 'AND'.
"""
input ref_situation_bool_exp {
  _and: [ref_situation_bool_exp!]
  _not: ref_situation_bool_exp
  _or: [ref_situation_bool_exp!]
  description: String_comparison_exp
  id: uuid_comparison_exp
  refTheme: ref_theme_bool_exp
  theme: ref_theme_enum_comparison_exp
}

"""
unique or primary key constraints on table "ref_situation"
"""
enum ref_situation_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  ref_situation_pkey
}

"""
input type for inserting data into table "ref_situation"
"""
input ref_situation_insert_input {
  description: String
  id: uuid
  refTheme: ref_theme_obj_rel_insert_input
  theme: ref_theme_enum
}

"""aggregate max on columns"""
type ref_situation_max_fields {
  description: String
  id: uuid
}

"""aggregate min on columns"""
type ref_situation_min_fields {
  description: String
  id: uuid
}

"""
response of any mutation on the table "ref_situation"
"""
type ref_situation_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [ref_situation!]!
}

"""
input type for inserting object relation for remote table "ref_situation"
"""
input ref_situation_obj_rel_insert_input {
  data: ref_situation_insert_input!

  """upsert condition"""
  on_conflict: ref_situation_on_conflict
}

"""
on_conflict condition type for table "ref_situation"
"""
input ref_situation_on_conflict {
  constraint: ref_situation_constraint!
  update_columns: [ref_situation_update_column!]! = []
  where: ref_situation_bool_exp
}

"""Ordering options when selecting data from "ref_situation"."""
input ref_situation_order_by {
  description: order_by
  id: order_by
  refTheme: ref_theme_order_by
  theme: order_by
}

"""primary key columns input for table: ref_situation"""
input ref_situation_pk_columns_input {
  id: uuid!
}

"""
select columns of table "ref_situation"
"""
enum ref_situation_select_column {
  """column name"""
  description

  """column name"""
  id

  """column name"""
  theme
}

"""
input type for updating data in table "ref_situation"
"""
input ref_situation_set_input {
  description: String
  id: uuid
  theme: ref_theme_enum
}

"""
Streaming cursor of the table "ref_situation"
"""
input ref_situation_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: ref_situation_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input ref_situation_stream_cursor_value_input {
  description: String
  id: uuid
  theme: ref_theme_enum
}

"""
update columns of table "ref_situation"
"""
enum ref_situation_update_column {
  """column name"""
  description

  """column name"""
  id

  """column name"""
  theme
}

input ref_situation_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: ref_situation_set_input

  """filter the rows which have to be updated"""
  where: ref_situation_bool_exp!
}

"""
columns and relationships of "ref_target"
"""
type ref_target {
  description: String!
  id: uuid!

  """An object relationship"""
  refTheme: ref_theme!
  theme: ref_theme_enum!
}

"""
aggregated selection of "ref_target"
"""
type ref_target_aggregate {
  aggregate: ref_target_aggregate_fields
  nodes: [ref_target!]!
}

"""
aggregate fields of "ref_target"
"""
type ref_target_aggregate_fields {
  count(columns: [ref_target_select_column!], distinct: Boolean): Int!
  max: ref_target_max_fields
  min: ref_target_min_fields
}

"""
Boolean expression to filter rows from the table "ref_target". All fields are combined with a logical 'AND'.
"""
input ref_target_bool_exp {
  _and: [ref_target_bool_exp!]
  _not: ref_target_bool_exp
  _or: [ref_target_bool_exp!]
  description: String_comparison_exp
  id: uuid_comparison_exp
  refTheme: ref_theme_bool_exp
  theme: ref_theme_enum_comparison_exp
}

"""
unique or primary key constraints on table "ref_target"
"""
enum ref_target_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  ref_target_pkey
}

"""
input type for inserting data into table "ref_target"
"""
input ref_target_insert_input {
  description: String
  id: uuid
  refTheme: ref_theme_obj_rel_insert_input
  theme: ref_theme_enum
}

"""aggregate max on columns"""
type ref_target_max_fields {
  description: String
  id: uuid
}

"""aggregate min on columns"""
type ref_target_min_fields {
  description: String
  id: uuid
}

"""
response of any mutation on the table "ref_target"
"""
type ref_target_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [ref_target!]!
}

"""
on_conflict condition type for table "ref_target"
"""
input ref_target_on_conflict {
  constraint: ref_target_constraint!
  update_columns: [ref_target_update_column!]! = []
  where: ref_target_bool_exp
}

"""Ordering options when selecting data from "ref_target"."""
input ref_target_order_by {
  description: order_by
  id: order_by
  refTheme: ref_theme_order_by
  theme: order_by
}

"""primary key columns input for table: ref_target"""
input ref_target_pk_columns_input {
  id: uuid!
}

"""
select columns of table "ref_target"
"""
enum ref_target_select_column {
  """column name"""
  description

  """column name"""
  id

  """column name"""
  theme
}

"""
input type for updating data in table "ref_target"
"""
input ref_target_set_input {
  description: String
  id: uuid
  theme: ref_theme_enum
}

"""
Streaming cursor of the table "ref_target"
"""
input ref_target_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: ref_target_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input ref_target_stream_cursor_value_input {
  description: String
  id: uuid
  theme: ref_theme_enum
}

"""
update columns of table "ref_target"
"""
enum ref_target_update_column {
  """column name"""
  description

  """column name"""
  id

  """column name"""
  theme
}

input ref_target_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: ref_target_set_input

  """filter the rows which have to be updated"""
  where: ref_target_bool_exp!
}

"""contains the availables themes for focus, sitations, targets, actions"""
type ref_theme {
  label: String!
  name: String!
}

"""
aggregated selection of "ref_theme"
"""
type ref_theme_aggregate {
  aggregate: ref_theme_aggregate_fields
  nodes: [ref_theme!]!
}

"""
aggregate fields of "ref_theme"
"""
type ref_theme_aggregate_fields {
  count(columns: [ref_theme_select_column!], distinct: Boolean): Int!
  max: ref_theme_max_fields
  min: ref_theme_min_fields
}

"""
Boolean expression to filter rows from the table "ref_theme". All fields are combined with a logical 'AND'.
"""
input ref_theme_bool_exp {
  _and: [ref_theme_bool_exp!]
  _not: ref_theme_bool_exp
  _or: [ref_theme_bool_exp!]
  label: String_comparison_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "ref_theme"
"""
enum ref_theme_constraint {
  """
  unique or primary key constraint on columns "name"
  """
  ref_theme_pkey
}

enum ref_theme_enum {
  """Choisir un m√©tier"""
  choisir_un_metier

  """Contraintes familiales"""
  contraintes_familiales

  """Cr√©er une entreprise"""
  creer_une_entreprise

  """Difficult√©s administratives"""
  difficulte_administrative

  """Difficult√©s financi√®res"""
  difficulte_financiere

  """Emploi"""
  emploi

  """Formation"""
  formation

  """Logement"""
  logement

  """Ma√Ætrise de la langue fran√ßaise"""
  maitrise_langue

  """Mobilit√©"""
  mobilite

  """Num√©rique"""
  numerique

  """Pr√©parer sa candidature"""
  preparer_sa_candidature

  """S'ouvrir √† l'international"""
  s_ouvrir_a_l_international

  """Sant√©"""
  sante

  """Se former"""
  se_former

  """Trouver un emploi"""
  trouver_un_emploi
}

"""
Boolean expression to compare columns of type "ref_theme_enum". All fields are combined with logical 'AND'.
"""
input ref_theme_enum_comparison_exp {
  _eq: ref_theme_enum
  _in: [ref_theme_enum!]
  _is_null: Boolean
  _neq: ref_theme_enum
  _nin: [ref_theme_enum!]
}

"""
input type for inserting data into table "ref_theme"
"""
input ref_theme_insert_input {
  label: String
  name: String
}

"""aggregate max on columns"""
type ref_theme_max_fields {
  label: String
  name: String
}

"""aggregate min on columns"""
type ref_theme_min_fields {
  label: String
  name: String
}

"""
response of any mutation on the table "ref_theme"
"""
type ref_theme_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [ref_theme!]!
}

"""
input type for inserting object relation for remote table "ref_theme"
"""
input ref_theme_obj_rel_insert_input {
  data: ref_theme_insert_input!

  """upsert condition"""
  on_conflict: ref_theme_on_conflict
}

"""
on_conflict condition type for table "ref_theme"
"""
input ref_theme_on_conflict {
  constraint: ref_theme_constraint!
  update_columns: [ref_theme_update_column!]! = []
  where: ref_theme_bool_exp
}

"""Ordering options when selecting data from "ref_theme"."""
input ref_theme_order_by {
  label: order_by
  name: order_by
}

"""primary key columns input for table: ref_theme"""
input ref_theme_pk_columns_input {
  name: String!
}

"""
select columns of table "ref_theme"
"""
enum ref_theme_select_column {
  """column name"""
  label

  """column name"""
  name
}

"""
input type for updating data in table "ref_theme"
"""
input ref_theme_set_input {
  label: String
  name: String
}

"""
Streaming cursor of the table "ref_theme"
"""
input ref_theme_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: ref_theme_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input ref_theme_stream_cursor_value_input {
  label: String
  name: String
}

"""
update columns of table "ref_theme"
"""
enum ref_theme_update_column {
  """column name"""
  label

  """column name"""
  name
}

input ref_theme_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: ref_theme_set_input

  """filter the rows which have to be updated"""
  where: ref_theme_bool_exp!
}

"""liste des roles"""
type role {
  """An array relationship"""
  accounts(
    """distinct select on columns"""
    distinct_on: [account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_order_by!]

    """filter the rows returned"""
    where: account_bool_exp
  ): [account!]!

  """An aggregate relationship"""
  accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_order_by!]

    """filter the rows returned"""
    where: account_bool_exp
  ): account_aggregate!
  label: String!
}

"""
aggregated selection of "role"
"""
type role_aggregate {
  aggregate: role_aggregate_fields
  nodes: [role!]!
}

"""
aggregate fields of "role"
"""
type role_aggregate_fields {
  count(columns: [role_select_column!], distinct: Boolean): Int!
  max: role_max_fields
  min: role_min_fields
}

"""
Boolean expression to filter rows from the table "role". All fields are combined with a logical 'AND'.
"""
input role_bool_exp {
  _and: [role_bool_exp!]
  _not: role_bool_exp
  _or: [role_bool_exp!]
  accounts: account_bool_exp
  accounts_aggregate: account_aggregate_bool_exp
  label: String_comparison_exp
}

"""
unique or primary key constraints on table "role"
"""
enum role_constraint {
  """
  unique or primary key constraint on columns "label"
  """
  role_pkey
}

enum role_enum {
  admin_cdb
  admin_structure
  beneficiary
  manager
  orientation_manager
  professional
  service
}

"""
Boolean expression to compare columns of type "role_enum". All fields are combined with logical 'AND'.
"""
input role_enum_comparison_exp {
  _eq: role_enum
  _in: [role_enum!]
  _is_null: Boolean
  _neq: role_enum
  _nin: [role_enum!]
}

"""
input type for inserting data into table "role"
"""
input role_insert_input {
  accounts: account_arr_rel_insert_input
  label: String
}

"""aggregate max on columns"""
type role_max_fields {
  label: String
}

"""aggregate min on columns"""
type role_min_fields {
  label: String
}

"""
response of any mutation on the table "role"
"""
type role_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [role!]!
}

"""
input type for inserting object relation for remote table "role"
"""
input role_obj_rel_insert_input {
  data: role_insert_input!

  """upsert condition"""
  on_conflict: role_on_conflict
}

"""
on_conflict condition type for table "role"
"""
input role_on_conflict {
  constraint: role_constraint!
  update_columns: [role_update_column!]! = []
  where: role_bool_exp
}

"""Ordering options when selecting data from "role"."""
input role_order_by {
  accounts_aggregate: account_aggregate_order_by
  label: order_by
}

"""primary key columns input for table: role"""
input role_pk_columns_input {
  label: String!
}

"""
select columns of table "role"
"""
enum role_select_column {
  """column name"""
  label
}

"""
input type for updating data in table "role"
"""
input role_set_input {
  label: String
}

"""
Streaming cursor of the table "role"
"""
input role_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: role_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input role_stream_cursor_value_input {
  label: String
}

"""
update columns of table "role"
"""
enum role_update_column {
  """column name"""
  label
}

input role_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: role_set_input

  """filter the rows which have to be updated"""
  where: role_bool_exp!
}

"""
columns and relationships of "rome_code"
"""
type rome_code {
  code: String!
  description: String!
  id: uuid!
  label: String!

  """An array relationship"""
  professionalProjects(
    """distinct select on columns"""
    distinct_on: [professional_project_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [professional_project_order_by!]

    """filter the rows returned"""
    where: professional_project_bool_exp
  ): [professional_project!]!

  """An aggregate relationship"""
  professionalProjects_aggregate(
    """distinct select on columns"""
    distinct_on: [professional_project_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [professional_project_order_by!]

    """filter the rows returned"""
    where: professional_project_bool_exp
  ): professional_project_aggregate!
}

"""
aggregated selection of "rome_code"
"""
type rome_code_aggregate {
  aggregate: rome_code_aggregate_fields
  nodes: [rome_code!]!
}

"""
aggregate fields of "rome_code"
"""
type rome_code_aggregate_fields {
  count(columns: [rome_code_select_column!], distinct: Boolean): Int!
  max: rome_code_max_fields
  min: rome_code_min_fields
}

"""
Boolean expression to filter rows from the table "rome_code". All fields are combined with a logical 'AND'.
"""
input rome_code_bool_exp {
  _and: [rome_code_bool_exp!]
  _not: rome_code_bool_exp
  _or: [rome_code_bool_exp!]
  code: String_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  label: String_comparison_exp
  professionalProjects: professional_project_bool_exp
  professionalProjects_aggregate: professional_project_aggregate_bool_exp
}

"""
unique or primary key constraints on table "rome_code"
"""
enum rome_code_constraint {
  """
  unique or primary key constraint on columns "label"
  """
  rome_codes_label_key

  """
  unique or primary key constraint on columns "id"
  """
  rome_codes_pkey
}

"""
input type for inserting data into table "rome_code"
"""
input rome_code_insert_input {
  code: String
  description: String
  id: uuid
  label: String
  professionalProjects: professional_project_arr_rel_insert_input
}

"""aggregate max on columns"""
type rome_code_max_fields {
  code: String
  description: String
  id: uuid
  label: String
}

"""aggregate min on columns"""
type rome_code_min_fields {
  code: String
  description: String
  id: uuid
  label: String
}

"""
response of any mutation on the table "rome_code"
"""
type rome_code_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rome_code!]!
}

"""
input type for inserting object relation for remote table "rome_code"
"""
input rome_code_obj_rel_insert_input {
  data: rome_code_insert_input!

  """upsert condition"""
  on_conflict: rome_code_on_conflict
}

"""
on_conflict condition type for table "rome_code"
"""
input rome_code_on_conflict {
  constraint: rome_code_constraint!
  update_columns: [rome_code_update_column!]! = []
  where: rome_code_bool_exp
}

"""Ordering options when selecting data from "rome_code"."""
input rome_code_order_by {
  code: order_by
  description: order_by
  id: order_by
  label: order_by
  professionalProjects_aggregate: professional_project_aggregate_order_by
}

"""primary key columns input for table: rome_code"""
input rome_code_pk_columns_input {
  id: uuid!
}

"""
select columns of table "rome_code"
"""
enum rome_code_select_column {
  """column name"""
  code

  """column name"""
  description

  """column name"""
  id

  """column name"""
  label
}

"""
input type for updating data in table "rome_code"
"""
input rome_code_set_input {
  code: String
  description: String
  id: uuid
  label: String
}

"""
Streaming cursor of the table "rome_code"
"""
input rome_code_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rome_code_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rome_code_stream_cursor_value_input {
  code: String
  description: String
  id: uuid
  label: String
}

"""
update columns of table "rome_code"
"""
enum rome_code_update_column {
  """column name"""
  code

  """column name"""
  description

  """column name"""
  id

  """column name"""
  label
}

input rome_code_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: rome_code_set_input

  """filter the rows which have to be updated"""
  where: rome_code_bool_exp!
}

"""code and reason for rsa closure reason"""
type rsa_closure_reason {
  code: String!
  label: String!
}

"""
aggregated selection of "rsa_closure_reason"
"""
type rsa_closure_reason_aggregate {
  aggregate: rsa_closure_reason_aggregate_fields
  nodes: [rsa_closure_reason!]!
}

"""
aggregate fields of "rsa_closure_reason"
"""
type rsa_closure_reason_aggregate_fields {
  count(columns: [rsa_closure_reason_select_column!], distinct: Boolean): Int!
  max: rsa_closure_reason_max_fields
  min: rsa_closure_reason_min_fields
}

"""
Boolean expression to filter rows from the table "rsa_closure_reason". All fields are combined with a logical 'AND'.
"""
input rsa_closure_reason_bool_exp {
  _and: [rsa_closure_reason_bool_exp!]
  _not: rsa_closure_reason_bool_exp
  _or: [rsa_closure_reason_bool_exp!]
  code: String_comparison_exp
  label: String_comparison_exp
}

"""
unique or primary key constraints on table "rsa_closure_reason"
"""
enum rsa_closure_reason_constraint {
  """
  unique or primary key constraint on columns "code"
  """
  rsa_closure_reason_pkey
}

enum rsa_closure_reason_enum {
  """Cl√¥ture suite √† l'annulation de la bascule RMI/API"""
  caf_annulation_bascule_rmi

  """Cl√¥ture suite d√©cision du Pr√©sident du Conseil g√©n√©ral"""
  caf_decision_pcg

  """Cl√¥ture suite √† √©ch√©ance (4 mois sans droits)"""
  caf_echeance

  """Cl√¥ture suite √† mutation du dossier dans un autre organisme"""
  caf_mutation

  """Radi√© autre motif"""
  caf_radie_autre_motif

  """Radi√© fin de droit"""
  caf_radie_fin_droit

  """Radi√© option RSO DOM"""
  caf_radie_option_rso

  """Radi√© option RSTA DOM"""
  caf_radie_option_rsta

  """Cl√¥ture pour regroupement de dossier"""
  caf_regroupement
}

"""
Boolean expression to compare columns of type "rsa_closure_reason_enum". All fields are combined with logical 'AND'.
"""
input rsa_closure_reason_enum_comparison_exp {
  _eq: rsa_closure_reason_enum
  _in: [rsa_closure_reason_enum!]
  _is_null: Boolean
  _neq: rsa_closure_reason_enum
  _nin: [rsa_closure_reason_enum!]
}

"""
input type for inserting data into table "rsa_closure_reason"
"""
input rsa_closure_reason_insert_input {
  code: String
  label: String
}

"""aggregate max on columns"""
type rsa_closure_reason_max_fields {
  code: String
  label: String
}

"""aggregate min on columns"""
type rsa_closure_reason_min_fields {
  code: String
  label: String
}

"""
response of any mutation on the table "rsa_closure_reason"
"""
type rsa_closure_reason_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rsa_closure_reason!]!
}

"""
on_conflict condition type for table "rsa_closure_reason"
"""
input rsa_closure_reason_on_conflict {
  constraint: rsa_closure_reason_constraint!
  update_columns: [rsa_closure_reason_update_column!]! = []
  where: rsa_closure_reason_bool_exp
}

"""Ordering options when selecting data from "rsa_closure_reason"."""
input rsa_closure_reason_order_by {
  code: order_by
  label: order_by
}

"""primary key columns input for table: rsa_closure_reason"""
input rsa_closure_reason_pk_columns_input {
  code: String!
}

"""
select columns of table "rsa_closure_reason"
"""
enum rsa_closure_reason_select_column {
  """column name"""
  code

  """column name"""
  label
}

"""
input type for updating data in table "rsa_closure_reason"
"""
input rsa_closure_reason_set_input {
  code: String
  label: String
}

"""
Streaming cursor of the table "rsa_closure_reason"
"""
input rsa_closure_reason_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rsa_closure_reason_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rsa_closure_reason_stream_cursor_value_input {
  code: String
  label: String
}

"""
update columns of table "rsa_closure_reason"
"""
enum rsa_closure_reason_update_column {
  """column name"""
  code

  """column name"""
  label
}

input rsa_closure_reason_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: rsa_closure_reason_set_input

  """filter the rows which have to be updated"""
  where: rsa_closure_reason_bool_exp!
}

"""rsa suspension code and reason for enum"""
type rsa_suspension_reason {
  code: String!
  label: String!
}

"""
aggregated selection of "rsa_suspension_reason"
"""
type rsa_suspension_reason_aggregate {
  aggregate: rsa_suspension_reason_aggregate_fields
  nodes: [rsa_suspension_reason!]!
}

"""
aggregate fields of "rsa_suspension_reason"
"""
type rsa_suspension_reason_aggregate_fields {
  count(columns: [rsa_suspension_reason_select_column!], distinct: Boolean): Int!
  max: rsa_suspension_reason_max_fields
  min: rsa_suspension_reason_min_fields
}

"""
Boolean expression to filter rows from the table "rsa_suspension_reason". All fields are combined with a logical 'AND'.
"""
input rsa_suspension_reason_bool_exp {
  _and: [rsa_suspension_reason_bool_exp!]
  _not: rsa_suspension_reason_bool_exp
  _or: [rsa_suspension_reason_bool_exp!]
  code: String_comparison_exp
  label: String_comparison_exp
}

"""
unique or primary key constraints on table "rsa_suspension_reason"
"""
enum rsa_suspension_reason_constraint {
  """
  unique or primary key constraint on columns "code"
  """
  rsa_suspension_reason_pkey
}

enum rsa_suspension_reason_enum {
  """Action non engag√©e"""
  caf_action_non_engagee

  """Activit√© ant√©rieure insuffisante"""
  caf_activite_anterieur_insuffisante

  """Activit√© ant√©rieure absente"""
  caf_activite_anterieure_absente

  """Activit√© ant√©rieure non conforme"""
  caf_activite_anterieure_non_conforme

  """Activit√© non conforme"""
  caf_activite_non_conforme

  """Allocataire absent du foyer"""
  caf_allocataire_absent

  """Attente d√©cision PCG (le droit reste th√©orique jusqu'au retour)"""
  caf_attente_decision_PCG

  """B√©n√©ficiaire AAH r√©duite"""
  caf_beneficiaire_aah

  """D√©claration Trimestrielle Ressources non fournie"""
  caf_declaration_ressource_non_fournie

  """Demande avantage vieillesse absent ou tardif"""
  caf_demande_avantage_vieillesse_absent

  """Droit √©teint ou autre cas"""
  caf_droit_eteint

  """√âtudiant r√©mun√©ration insuffisante"""
  caf_etudiant_remuneration_insuffisante

  """Hospitalisation"""
  caf_hospitalisation

  """Moins de 25 ans sans enfant ni autre personne √† charge"""
  caf_moins_25_sans_personne_charge

  """Pas d'allocataire"""
  caf_pas_allocataire

  """Pas d'isolement"""
  caf_pas_isolement

  """Prestation exclue affiliation partielle"""
  caf_prestation_exclue

  """R√©gime non conforme"""
  caf_regime_non_conforme

  """R√©sidence non conforme"""
  caf_residence_non_conforme

  """Ressources trop √©l√©v√©es"""
  caf_ressources_trop_elevees

  """RSA inf√©rieur au seuil"""
  caf_rsa_inferieur_seuil

  """Surface pond√©r√©e sup√©rieure au plafond ou inconnue"""
  caf_surface_ponderee_sup

  """Titre de s√©jour absent"""
  caf_titre_sejour_absent

  """Titre de s√©jour non valide"""
  caf_titre_sejour_invalid
}

"""
Boolean expression to compare columns of type "rsa_suspension_reason_enum". All fields are combined with logical 'AND'.
"""
input rsa_suspension_reason_enum_comparison_exp {
  _eq: rsa_suspension_reason_enum
  _in: [rsa_suspension_reason_enum!]
  _is_null: Boolean
  _neq: rsa_suspension_reason_enum
  _nin: [rsa_suspension_reason_enum!]
}

"""
input type for inserting data into table "rsa_suspension_reason"
"""
input rsa_suspension_reason_insert_input {
  code: String
  label: String
}

"""aggregate max on columns"""
type rsa_suspension_reason_max_fields {
  code: String
  label: String
}

"""aggregate min on columns"""
type rsa_suspension_reason_min_fields {
  code: String
  label: String
}

"""
response of any mutation on the table "rsa_suspension_reason"
"""
type rsa_suspension_reason_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rsa_suspension_reason!]!
}

"""
on_conflict condition type for table "rsa_suspension_reason"
"""
input rsa_suspension_reason_on_conflict {
  constraint: rsa_suspension_reason_constraint!
  update_columns: [rsa_suspension_reason_update_column!]! = []
  where: rsa_suspension_reason_bool_exp
}

"""Ordering options when selecting data from "rsa_suspension_reason"."""
input rsa_suspension_reason_order_by {
  code: order_by
  label: order_by
}

"""primary key columns input for table: rsa_suspension_reason"""
input rsa_suspension_reason_pk_columns_input {
  code: String!
}

"""
select columns of table "rsa_suspension_reason"
"""
enum rsa_suspension_reason_select_column {
  """column name"""
  code

  """column name"""
  label
}

"""
input type for updating data in table "rsa_suspension_reason"
"""
input rsa_suspension_reason_set_input {
  code: String
  label: String
}

"""
Streaming cursor of the table "rsa_suspension_reason"
"""
input rsa_suspension_reason_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rsa_suspension_reason_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rsa_suspension_reason_stream_cursor_value_input {
  code: String
  label: String
}

"""
update columns of table "rsa_suspension_reason"
"""
enum rsa_suspension_reason_update_column {
  """column name"""
  code

  """column name"""
  label
}

input rsa_suspension_reason_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: rsa_suspension_reason_set_input

  """filter the rows which have to be updated"""
  where: rsa_suspension_reason_bool_exp!
}

input search_beneficiaries_args {
  search: String
}

input search_notebook_members_args {
  search: String
}

input search_public_notebooks_args {
  search: String
}

input search_ref_action_args {
  search: String
}

input search_rome_codes_args {
  search: String
}

"""
columns and relationships of "structure"
"""
type structure {
  address1: String
  address2: String

  """An array relationship"""
  admins(
    """distinct select on columns"""
    distinct_on: [admin_structure_structure_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admin_structure_structure_order_by!]

    """filter the rows returned"""
    where: admin_structure_structure_bool_exp
  ): [admin_structure_structure!]!

  """An aggregate relationship"""
  admins_aggregate(
    """distinct select on columns"""
    distinct_on: [admin_structure_structure_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admin_structure_structure_order_by!]

    """filter the rows returned"""
    where: admin_structure_structure_bool_exp
  ): admin_structure_structure_aggregate!

  """An array relationship"""
  beneficiaries(
    """distinct select on columns"""
    distinct_on: [beneficiary_structure_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [beneficiary_structure_order_by!]

    """filter the rows returned"""
    where: beneficiary_structure_bool_exp
  ): [beneficiary_structure!]!

  """An aggregate relationship"""
  beneficiaries_aggregate(
    """distinct select on columns"""
    distinct_on: [beneficiary_structure_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [beneficiary_structure_order_by!]

    """filter the rows returned"""
    where: beneficiary_structure_bool_exp
  ): beneficiary_structure_aggregate!
  city: String
  createdAt: timestamptz

  """An object relationship"""
  deployment: deployment!
  deploymentId: uuid!
  email: String
  id: uuid!
  name: citext!

  """An array relationship"""
  orientationSystems(
    """distinct select on columns"""
    distinct_on: [structure_orientation_system_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [structure_orientation_system_order_by!]

    """filter the rows returned"""
    where: structure_orientation_system_bool_exp
  ): [structure_orientation_system!]!

  """An aggregate relationship"""
  orientationSystems_aggregate(
    """distinct select on columns"""
    distinct_on: [structure_orientation_system_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [structure_orientation_system_order_by!]

    """filter the rows returned"""
    where: structure_orientation_system_bool_exp
  ): structure_orientation_system_aggregate!
  phone: String
  postalCode: String

  """An array relationship"""
  professionals(
    """distinct select on columns"""
    distinct_on: [professional_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [professional_order_by!]

    """filter the rows returned"""
    where: professional_bool_exp
  ): [professional!]!

  """An aggregate relationship"""
  professionals_aggregate(
    """distinct select on columns"""
    distinct_on: [professional_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [professional_order_by!]

    """filter the rows returned"""
    where: professional_bool_exp
  ): professional_aggregate!
  sensitive: Boolean!
  shortDesc: String
  siret: String
  updatedAt: timestamptz
  website: String
}

"""
aggregated selection of "structure"
"""
type structure_aggregate {
  aggregate: structure_aggregate_fields
  nodes: [structure!]!
}

input structure_aggregate_bool_exp {
  bool_and: structure_aggregate_bool_exp_bool_and
  bool_or: structure_aggregate_bool_exp_bool_or
  count: structure_aggregate_bool_exp_count
}

input structure_aggregate_bool_exp_bool_and {
  arguments: structure_select_column_structure_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: structure_bool_exp
  predicate: Boolean_comparison_exp!
}

input structure_aggregate_bool_exp_bool_or {
  arguments: structure_select_column_structure_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: structure_bool_exp
  predicate: Boolean_comparison_exp!
}

input structure_aggregate_bool_exp_count {
  arguments: [structure_select_column!]
  distinct: Boolean
  filter: structure_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "structure"
"""
type structure_aggregate_fields {
  count(columns: [structure_select_column!], distinct: Boolean): Int!
  max: structure_max_fields
  min: structure_min_fields
}

"""
order by aggregate values of table "structure"
"""
input structure_aggregate_order_by {
  count: order_by
  max: structure_max_order_by
  min: structure_min_order_by
}

"""
input type for inserting array relation for remote table "structure"
"""
input structure_arr_rel_insert_input {
  data: [structure_insert_input!]!

  """upsert condition"""
  on_conflict: structure_on_conflict
}

"""
Boolean expression to filter rows from the table "structure". All fields are combined with a logical 'AND'.
"""
input structure_bool_exp {
  _and: [structure_bool_exp!]
  _not: structure_bool_exp
  _or: [structure_bool_exp!]
  address1: String_comparison_exp
  address2: String_comparison_exp
  admins: admin_structure_structure_bool_exp
  admins_aggregate: admin_structure_structure_aggregate_bool_exp
  beneficiaries: beneficiary_structure_bool_exp
  beneficiaries_aggregate: beneficiary_structure_aggregate_bool_exp
  city: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  deployment: deployment_bool_exp
  deploymentId: uuid_comparison_exp
  email: String_comparison_exp
  id: uuid_comparison_exp
  name: citext_comparison_exp
  orientationSystems: structure_orientation_system_bool_exp
  orientationSystems_aggregate: structure_orientation_system_aggregate_bool_exp
  phone: String_comparison_exp
  postalCode: String_comparison_exp
  professionals: professional_bool_exp
  professionals_aggregate: professional_aggregate_bool_exp
  sensitive: Boolean_comparison_exp
  shortDesc: String_comparison_exp
  siret: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  website: String_comparison_exp
}

"""
unique or primary key constraints on table "structure"
"""
enum structure_constraint {
  """
  unique or primary key constraint on columns "deployment_id", "name"
  """
  structure_name_deployment_id_key

  """
  unique or primary key constraint on columns "id"
  """
  structure_pkey
}

"""
input type for inserting data into table "structure"
"""
input structure_insert_input {
  address1: String
  address2: String
  admins: admin_structure_structure_arr_rel_insert_input
  beneficiaries: beneficiary_structure_arr_rel_insert_input
  city: String
  createdAt: timestamptz
  deployment: deployment_obj_rel_insert_input
  deploymentId: uuid
  email: String
  id: uuid
  name: citext
  orientationSystems: structure_orientation_system_arr_rel_insert_input
  phone: String
  postalCode: String
  professionals: professional_arr_rel_insert_input
  sensitive: Boolean
  shortDesc: String
  siret: String
  updatedAt: timestamptz
  website: String
}

"""aggregate max on columns"""
type structure_max_fields {
  address1: String
  address2: String
  city: String
  createdAt: timestamptz
  deploymentId: uuid
  email: String
  id: uuid
  name: citext
  phone: String
  postalCode: String
  shortDesc: String
  siret: String
  updatedAt: timestamptz
  website: String
}

"""
order by max() on columns of table "structure"
"""
input structure_max_order_by {
  address1: order_by
  address2: order_by
  city: order_by
  createdAt: order_by
  deploymentId: order_by
  email: order_by
  id: order_by
  name: order_by
  phone: order_by
  postalCode: order_by
  shortDesc: order_by
  siret: order_by
  updatedAt: order_by
  website: order_by
}

"""aggregate min on columns"""
type structure_min_fields {
  address1: String
  address2: String
  city: String
  createdAt: timestamptz
  deploymentId: uuid
  email: String
  id: uuid
  name: citext
  phone: String
  postalCode: String
  shortDesc: String
  siret: String
  updatedAt: timestamptz
  website: String
}

"""
order by min() on columns of table "structure"
"""
input structure_min_order_by {
  address1: order_by
  address2: order_by
  city: order_by
  createdAt: order_by
  deploymentId: order_by
  email: order_by
  id: order_by
  name: order_by
  phone: order_by
  postalCode: order_by
  shortDesc: order_by
  siret: order_by
  updatedAt: order_by
  website: order_by
}

"""
response of any mutation on the table "structure"
"""
type structure_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [structure!]!
}

"""
input type for inserting object relation for remote table "structure"
"""
input structure_obj_rel_insert_input {
  data: structure_insert_input!

  """upsert condition"""
  on_conflict: structure_on_conflict
}

"""
on_conflict condition type for table "structure"
"""
input structure_on_conflict {
  constraint: structure_constraint!
  update_columns: [structure_update_column!]! = []
  where: structure_bool_exp
}

"""Ordering options when selecting data from "structure"."""
input structure_order_by {
  address1: order_by
  address2: order_by
  admins_aggregate: admin_structure_structure_aggregate_order_by
  beneficiaries_aggregate: beneficiary_structure_aggregate_order_by
  city: order_by
  createdAt: order_by
  deployment: deployment_order_by
  deploymentId: order_by
  email: order_by
  id: order_by
  name: order_by
  orientationSystems_aggregate: structure_orientation_system_aggregate_order_by
  phone: order_by
  postalCode: order_by
  professionals_aggregate: professional_aggregate_order_by
  sensitive: order_by
  shortDesc: order_by
  siret: order_by
  updatedAt: order_by
  website: order_by
}

"""
columns and relationships of "structure_orientation_system"
"""
type structure_orientation_system {
  createdAt: timestamptz!
  id: uuid!

  """An object relationship"""
  orientationSystem: orientation_system!
  orientationSystemId: uuid!

  """An object relationship"""
  structure: structure!
  structureId: uuid!
}

"""
aggregated selection of "structure_orientation_system"
"""
type structure_orientation_system_aggregate {
  aggregate: structure_orientation_system_aggregate_fields
  nodes: [structure_orientation_system!]!
}

input structure_orientation_system_aggregate_bool_exp {
  count: structure_orientation_system_aggregate_bool_exp_count
}

input structure_orientation_system_aggregate_bool_exp_count {
  arguments: [structure_orientation_system_select_column!]
  distinct: Boolean
  filter: structure_orientation_system_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "structure_orientation_system"
"""
type structure_orientation_system_aggregate_fields {
  count(columns: [structure_orientation_system_select_column!], distinct: Boolean): Int!
  max: structure_orientation_system_max_fields
  min: structure_orientation_system_min_fields
}

"""
order by aggregate values of table "structure_orientation_system"
"""
input structure_orientation_system_aggregate_order_by {
  count: order_by
  max: structure_orientation_system_max_order_by
  min: structure_orientation_system_min_order_by
}

"""
input type for inserting array relation for remote table "structure_orientation_system"
"""
input structure_orientation_system_arr_rel_insert_input {
  data: [structure_orientation_system_insert_input!]!

  """upsert condition"""
  on_conflict: structure_orientation_system_on_conflict
}

"""
Boolean expression to filter rows from the table "structure_orientation_system". All fields are combined with a logical 'AND'.
"""
input structure_orientation_system_bool_exp {
  _and: [structure_orientation_system_bool_exp!]
  _not: structure_orientation_system_bool_exp
  _or: [structure_orientation_system_bool_exp!]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  orientationSystem: orientation_system_bool_exp
  orientationSystemId: uuid_comparison_exp
  structure: structure_bool_exp
  structureId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "structure_orientation_system"
"""
enum structure_orientation_system_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  structure_orientation_system_pkey

  """
  unique or primary key constraint on columns "structure_id", "orientation_system_id"
  """
  structure_orientation_system_structure_id_orientation_system_id
}

"""
input type for inserting data into table "structure_orientation_system"
"""
input structure_orientation_system_insert_input {
  createdAt: timestamptz
  id: uuid
  orientationSystem: orientation_system_obj_rel_insert_input
  orientationSystemId: uuid
  structure: structure_obj_rel_insert_input
  structureId: uuid
}

"""aggregate max on columns"""
type structure_orientation_system_max_fields {
  createdAt: timestamptz
  id: uuid
  orientationSystemId: uuid
  structureId: uuid
}

"""
order by max() on columns of table "structure_orientation_system"
"""
input structure_orientation_system_max_order_by {
  createdAt: order_by
  id: order_by
  orientationSystemId: order_by
  structureId: order_by
}

"""aggregate min on columns"""
type structure_orientation_system_min_fields {
  createdAt: timestamptz
  id: uuid
  orientationSystemId: uuid
  structureId: uuid
}

"""
order by min() on columns of table "structure_orientation_system"
"""
input structure_orientation_system_min_order_by {
  createdAt: order_by
  id: order_by
  orientationSystemId: order_by
  structureId: order_by
}

"""
response of any mutation on the table "structure_orientation_system"
"""
type structure_orientation_system_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [structure_orientation_system!]!
}

"""
on_conflict condition type for table "structure_orientation_system"
"""
input structure_orientation_system_on_conflict {
  constraint: structure_orientation_system_constraint!
  update_columns: [structure_orientation_system_update_column!]! = []
  where: structure_orientation_system_bool_exp
}

"""
Ordering options when selecting data from "structure_orientation_system".
"""
input structure_orientation_system_order_by {
  createdAt: order_by
  id: order_by
  orientationSystem: orientation_system_order_by
  orientationSystemId: order_by
  structure: structure_order_by
  structureId: order_by
}

"""primary key columns input for table: structure_orientation_system"""
input structure_orientation_system_pk_columns_input {
  id: uuid!
}

"""
select columns of table "structure_orientation_system"
"""
enum structure_orientation_system_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  orientationSystemId

  """column name"""
  structureId
}

"""
input type for updating data in table "structure_orientation_system"
"""
input structure_orientation_system_set_input {
  createdAt: timestamptz
  id: uuid
  orientationSystemId: uuid
  structureId: uuid
}

"""
Streaming cursor of the table "structure_orientation_system"
"""
input structure_orientation_system_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: structure_orientation_system_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input structure_orientation_system_stream_cursor_value_input {
  createdAt: timestamptz
  id: uuid
  orientationSystemId: uuid
  structureId: uuid
}

"""
update columns of table "structure_orientation_system"
"""
enum structure_orientation_system_update_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  orientationSystemId

  """column name"""
  structureId
}

input structure_orientation_system_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: structure_orientation_system_set_input

  """filter the rows which have to be updated"""
  where: structure_orientation_system_bool_exp!
}

"""primary key columns input for table: structure"""
input structure_pk_columns_input {
  id: uuid!
}

"""
select columns of table "structure"
"""
enum structure_select_column {
  """column name"""
  address1

  """column name"""
  address2

  """column name"""
  city

  """column name"""
  createdAt

  """column name"""
  deploymentId

  """column name"""
  email

  """column name"""
  id

  """column name"""
  name

  """column name"""
  phone

  """column name"""
  postalCode

  """column name"""
  sensitive

  """column name"""
  shortDesc

  """column name"""
  siret

  """column name"""
  updatedAt

  """column name"""
  website
}

"""
select "structure_aggregate_bool_exp_bool_and_arguments_columns" columns of table "structure"
"""
enum structure_select_column_structure_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  sensitive
}

"""
select "structure_aggregate_bool_exp_bool_or_arguments_columns" columns of table "structure"
"""
enum structure_select_column_structure_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  sensitive
}

"""
input type for updating data in table "structure"
"""
input structure_set_input {
  address1: String
  address2: String
  city: String
  createdAt: timestamptz
  deploymentId: uuid
  email: String
  id: uuid
  name: citext
  phone: String
  postalCode: String
  sensitive: Boolean
  shortDesc: String
  siret: String
  updatedAt: timestamptz
  website: String
}

"""
Streaming cursor of the table "structure"
"""
input structure_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: structure_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input structure_stream_cursor_value_input {
  address1: String
  address2: String
  city: String
  createdAt: timestamptz
  deploymentId: uuid
  email: String
  id: uuid
  name: citext
  phone: String
  postalCode: String
  sensitive: Boolean
  shortDesc: String
  siret: String
  updatedAt: timestamptz
  website: String
}

"""
update columns of table "structure"
"""
enum structure_update_column {
  """column name"""
  address1

  """column name"""
  address2

  """column name"""
  city

  """column name"""
  createdAt

  """column name"""
  deploymentId

  """column name"""
  email

  """column name"""
  id

  """column name"""
  name

  """column name"""
  phone

  """column name"""
  postalCode

  """column name"""
  sensitive

  """column name"""
  shortDesc

  """column name"""
  siret

  """column name"""
  updatedAt

  """column name"""
  website
}

input structure_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: structure_set_input

  """filter the rows which have to be updated"""
  where: structure_bool_exp!
}

type subscription_root {
  """
  fetch data from the table: "account"
  """
  account(
    """distinct select on columns"""
    distinct_on: [account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_order_by!]

    """filter the rows returned"""
    where: account_bool_exp
  ): [account!]!

  """
  fetch aggregated fields from the table: "account"
  """
  account_aggregate(
    """distinct select on columns"""
    distinct_on: [account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_order_by!]

    """filter the rows returned"""
    where: account_bool_exp
  ): account_aggregate!

  """fetch data from the table: "account" using primary key columns"""
  account_by_pk(id: uuid!): account

  """
  fetch data from the table: "account_info"
  """
  account_info(
    """distinct select on columns"""
    distinct_on: [account_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_info_order_by!]

    """filter the rows returned"""
    where: account_info_bool_exp
  ): [account_info!]!

  """
  fetch aggregated fields from the table: "account_info"
  """
  account_info_aggregate(
    """distinct select on columns"""
    distinct_on: [account_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_info_order_by!]

    """filter the rows returned"""
    where: account_info_bool_exp
  ): account_info_aggregate!

  """
  fetch data from the table in a streaming manner: "account_info"
  """
  account_info_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [account_info_stream_cursor_input]!

    """filter the rows returned"""
    where: account_info_bool_exp
  ): [account_info!]!

  """
  fetch data from the table in a streaming manner: "account"
  """
  account_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [account_stream_cursor_input]!

    """filter the rows returned"""
    where: account_bool_exp
  ): [account!]!

  """
  fetch data from the table: "action_status"
  """
  action_status(
    """distinct select on columns"""
    distinct_on: [action_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_status_order_by!]

    """filter the rows returned"""
    where: action_status_bool_exp
  ): [action_status!]!

  """
  fetch aggregated fields from the table: "action_status"
  """
  action_status_aggregate(
    """distinct select on columns"""
    distinct_on: [action_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_status_order_by!]

    """filter the rows returned"""
    where: action_status_bool_exp
  ): action_status_aggregate!

  """fetch data from the table: "action_status" using primary key columns"""
  action_status_by_pk(status: String!): action_status

  """
  fetch data from the table in a streaming manner: "action_status"
  """
  action_status_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [action_status_stream_cursor_input]!

    """filter the rows returned"""
    where: action_status_bool_exp
  ): [action_status!]!

  """
  fetch data from the table: "admin_cdb"
  """
  admin_cdb(
    """distinct select on columns"""
    distinct_on: [admin_cdb_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admin_cdb_order_by!]

    """filter the rows returned"""
    where: admin_cdb_bool_exp
  ): [admin_cdb!]!

  """
  fetch aggregated fields from the table: "admin_cdb"
  """
  admin_cdb_aggregate(
    """distinct select on columns"""
    distinct_on: [admin_cdb_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admin_cdb_order_by!]

    """filter the rows returned"""
    where: admin_cdb_bool_exp
  ): admin_cdb_aggregate!

  """fetch data from the table: "admin_cdb" using primary key columns"""
  admin_cdb_by_pk(id: uuid!): admin_cdb

  """
  fetch data from the table in a streaming manner: "admin_cdb"
  """
  admin_cdb_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [admin_cdb_stream_cursor_input]!

    """filter the rows returned"""
    where: admin_cdb_bool_exp
  ): [admin_cdb!]!

  """
  fetch data from the table: "admin_structure"
  """
  admin_structure(
    """distinct select on columns"""
    distinct_on: [admin_structure_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admin_structure_order_by!]

    """filter the rows returned"""
    where: admin_structure_bool_exp
  ): [admin_structure!]!

  """
  fetch aggregated fields from the table: "admin_structure"
  """
  admin_structure_aggregate(
    """distinct select on columns"""
    distinct_on: [admin_structure_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admin_structure_order_by!]

    """filter the rows returned"""
    where: admin_structure_bool_exp
  ): admin_structure_aggregate!

  """fetch data from the table: "admin_structure" using primary key columns"""
  admin_structure_by_pk(id: uuid!): admin_structure

  """
  fetch data from the table in a streaming manner: "admin_structure"
  """
  admin_structure_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [admin_structure_stream_cursor_input]!

    """filter the rows returned"""
    where: admin_structure_bool_exp
  ): [admin_structure!]!

  """
  fetch data from the table: "admin_structure_structure"
  """
  admin_structure_structure(
    """distinct select on columns"""
    distinct_on: [admin_structure_structure_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admin_structure_structure_order_by!]

    """filter the rows returned"""
    where: admin_structure_structure_bool_exp
  ): [admin_structure_structure!]!

  """
  fetch aggregated fields from the table: "admin_structure_structure"
  """
  admin_structure_structure_aggregate(
    """distinct select on columns"""
    distinct_on: [admin_structure_structure_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admin_structure_structure_order_by!]

    """filter the rows returned"""
    where: admin_structure_structure_bool_exp
  ): admin_structure_structure_aggregate!

  """
  fetch data from the table: "admin_structure_structure" using primary key columns
  """
  admin_structure_structure_by_pk(id: uuid!): admin_structure_structure

  """
  fetch data from the table in a streaming manner: "admin_structure_structure"
  """
  admin_structure_structure_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [admin_structure_structure_stream_cursor_input]!

    """filter the rows returned"""
    where: admin_structure_structure_bool_exp
  ): [admin_structure_structure!]!

  """
  fetch data from the table: "beneficiary"
  """
  beneficiary(
    """distinct select on columns"""
    distinct_on: [beneficiary_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [beneficiary_order_by!]

    """filter the rows returned"""
    where: beneficiary_bool_exp
  ): [beneficiary!]!

  """
  fetch aggregated fields from the table: "beneficiary"
  """
  beneficiary_aggregate(
    """distinct select on columns"""
    distinct_on: [beneficiary_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [beneficiary_order_by!]

    """filter the rows returned"""
    where: beneficiary_bool_exp
  ): beneficiary_aggregate!

  """fetch data from the table: "beneficiary" using primary key columns"""
  beneficiary_by_pk(id: uuid!): beneficiary

  """
  fetch data from the table in a streaming manner: "beneficiary"
  """
  beneficiary_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [beneficiary_stream_cursor_input]!

    """filter the rows returned"""
    where: beneficiary_bool_exp
  ): [beneficiary!]!

  """
  fetch data from the table: "beneficiary_structure"
  """
  beneficiary_structure(
    """distinct select on columns"""
    distinct_on: [beneficiary_structure_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [beneficiary_structure_order_by!]

    """filter the rows returned"""
    where: beneficiary_structure_bool_exp
  ): [beneficiary_structure!]!

  """
  fetch aggregated fields from the table: "beneficiary_structure"
  """
  beneficiary_structure_aggregate(
    """distinct select on columns"""
    distinct_on: [beneficiary_structure_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [beneficiary_structure_order_by!]

    """filter the rows returned"""
    where: beneficiary_structure_bool_exp
  ): beneficiary_structure_aggregate!

  """
  fetch data from the table: "beneficiary_structure" using primary key columns
  """
  beneficiary_structure_by_pk(id: uuid!): beneficiary_structure

  """
  fetch data from the table in a streaming manner: "beneficiary_structure"
  """
  beneficiary_structure_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [beneficiary_structure_stream_cursor_input]!

    """filter the rows returned"""
    where: beneficiary_structure_bool_exp
  ): [beneficiary_structure!]!

  """
  fetch data from the table: "contract_type"
  """
  contract_type(
    """distinct select on columns"""
    distinct_on: [contract_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [contract_type_order_by!]

    """filter the rows returned"""
    where: contract_type_bool_exp
  ): [contract_type!]!

  """
  fetch aggregated fields from the table: "contract_type"
  """
  contract_type_aggregate(
    """distinct select on columns"""
    distinct_on: [contract_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [contract_type_order_by!]

    """filter the rows returned"""
    where: contract_type_bool_exp
  ): contract_type_aggregate!

  """fetch data from the table: "contract_type" using primary key columns"""
  contract_type_by_pk(id: String!): contract_type

  """
  fetch data from the table in a streaming manner: "contract_type"
  """
  contract_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [contract_type_stream_cursor_input]!

    """filter the rows returned"""
    where: contract_type_bool_exp
  ): [contract_type!]!

  """
  fetch data from the table: "deployment"
  """
  deployment(
    """distinct select on columns"""
    distinct_on: [deployment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [deployment_order_by!]

    """filter the rows returned"""
    where: deployment_bool_exp
  ): [deployment!]!

  """
  fetch aggregated fields from the table: "deployment"
  """
  deployment_aggregate(
    """distinct select on columns"""
    distinct_on: [deployment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [deployment_order_by!]

    """filter the rows returned"""
    where: deployment_bool_exp
  ): deployment_aggregate!

  """fetch data from the table: "deployment" using primary key columns"""
  deployment_by_pk(id: uuid!): deployment

  """
  fetch data from the table in a streaming manner: "deployment"
  """
  deployment_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [deployment_stream_cursor_input]!

    """filter the rows returned"""
    where: deployment_bool_exp
  ): [deployment!]!

  """
  fetch data from the table: "employment_type"
  """
  employment_type(
    """distinct select on columns"""
    distinct_on: [employment_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employment_type_order_by!]

    """filter the rows returned"""
    where: employment_type_bool_exp
  ): [employment_type!]!

  """
  fetch aggregated fields from the table: "employment_type"
  """
  employment_type_aggregate(
    """distinct select on columns"""
    distinct_on: [employment_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employment_type_order_by!]

    """filter the rows returned"""
    where: employment_type_bool_exp
  ): employment_type_aggregate!

  """fetch data from the table: "employment_type" using primary key columns"""
  employment_type_by_pk(id: String!): employment_type

  """
  fetch data from the table in a streaming manner: "employment_type"
  """
  employment_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [employment_type_stream_cursor_input]!

    """filter the rows returned"""
    where: employment_type_bool_exp
  ): [employment_type!]!

  """An array relationship"""
  external_data(
    """distinct select on columns"""
    distinct_on: [external_data_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [external_data_order_by!]

    """filter the rows returned"""
    where: external_data_bool_exp
  ): [external_data!]!

  """An aggregate relationship"""
  external_data_aggregate(
    """distinct select on columns"""
    distinct_on: [external_data_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [external_data_order_by!]

    """filter the rows returned"""
    where: external_data_bool_exp
  ): external_data_aggregate!

  """fetch data from the table: "external_data" using primary key columns"""
  external_data_by_pk(id: uuid!): external_data

  """
  fetch data from the table: "external_data_info"
  """
  external_data_info(
    """distinct select on columns"""
    distinct_on: [external_data_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [external_data_info_order_by!]

    """filter the rows returned"""
    where: external_data_info_bool_exp
  ): [external_data_info!]!

  """
  fetch aggregated fields from the table: "external_data_info"
  """
  external_data_info_aggregate(
    """distinct select on columns"""
    distinct_on: [external_data_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [external_data_info_order_by!]

    """filter the rows returned"""
    where: external_data_info_bool_exp
  ): external_data_info_aggregate!

  """
  fetch data from the table: "external_data_info" using primary key columns
  """
  external_data_info_by_pk(external_data_id: uuid!): external_data_info

  """
  fetch data from the table in a streaming manner: "external_data_info"
  """
  external_data_info_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [external_data_info_stream_cursor_input]!

    """filter the rows returned"""
    where: external_data_info_bool_exp
  ): [external_data_info!]!

  """
  fetch data from the table in a streaming manner: "external_data"
  """
  external_data_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [external_data_stream_cursor_input]!

    """filter the rows returned"""
    where: external_data_bool_exp
  ): [external_data!]!

  """
  fetch data from the table: "external_source"
  """
  external_source(
    """distinct select on columns"""
    distinct_on: [external_source_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [external_source_order_by!]

    """filter the rows returned"""
    where: external_source_bool_exp
  ): [external_source!]!

  """
  fetch aggregated fields from the table: "external_source"
  """
  external_source_aggregate(
    """distinct select on columns"""
    distinct_on: [external_source_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [external_source_order_by!]

    """filter the rows returned"""
    where: external_source_bool_exp
  ): external_source_aggregate!

  """fetch data from the table: "external_source" using primary key columns"""
  external_source_by_pk(value: String!): external_source

  """
  fetch data from the table in a streaming manner: "external_source"
  """
  external_source_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [external_source_stream_cursor_input]!

    """filter the rows returned"""
    where: external_source_bool_exp
  ): [external_source!]!

  """
  execute function "get_beneficiaries_from_nir" which returns "beneficiary"
  """
  get_beneficiaries_from_nir(
    """
    input parameters for function "get_beneficiaries_from_nir"
    """
    args: get_beneficiaries_from_nir_args!

    """distinct select on columns"""
    distinct_on: [beneficiary_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [beneficiary_order_by!]

    """filter the rows returned"""
    where: beneficiary_bool_exp
  ): [beneficiary!]!

  """
  execute function "get_beneficiaries_from_nir" and query aggregates on result of table type "beneficiary"
  """
  get_beneficiaries_from_nir_aggregate(
    """
    input parameters for function "get_beneficiaries_from_nir_aggregate"
    """
    args: get_beneficiaries_from_nir_args!

    """distinct select on columns"""
    distinct_on: [beneficiary_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [beneficiary_order_by!]

    """filter the rows returned"""
    where: beneficiary_bool_exp
  ): beneficiary_aggregate!

  """
  fetch data from the table: "manager"
  """
  manager(
    """distinct select on columns"""
    distinct_on: [manager_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [manager_order_by!]

    """filter the rows returned"""
    where: manager_bool_exp
  ): [manager!]!

  """
  fetch aggregated fields from the table: "manager"
  """
  manager_aggregate(
    """distinct select on columns"""
    distinct_on: [manager_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [manager_order_by!]

    """filter the rows returned"""
    where: manager_bool_exp
  ): manager_aggregate!

  """fetch data from the table: "manager" using primary key columns"""
  manager_by_pk(id: uuid!): manager

  """
  fetch data from the table in a streaming manner: "manager"
  """
  manager_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [manager_stream_cursor_input]!

    """filter the rows returned"""
    where: manager_bool_exp
  ): [manager!]!

  """
  fetch data from the table: "notebook"
  """
  notebook(
    """distinct select on columns"""
    distinct_on: [notebook_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_order_by!]

    """filter the rows returned"""
    where: notebook_bool_exp
  ): [notebook!]!

  """
  fetch data from the table: "notebook_action"
  """
  notebook_action(
    """distinct select on columns"""
    distinct_on: [notebook_action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_action_order_by!]

    """filter the rows returned"""
    where: notebook_action_bool_exp
  ): [notebook_action!]!

  """
  fetch aggregated fields from the table: "notebook_action"
  """
  notebook_action_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_action_order_by!]

    """filter the rows returned"""
    where: notebook_action_bool_exp
  ): notebook_action_aggregate!

  """fetch data from the table: "notebook_action" using primary key columns"""
  notebook_action_by_pk(id: uuid!): notebook_action

  """
  fetch data from the table in a streaming manner: "notebook_action"
  """
  notebook_action_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notebook_action_stream_cursor_input]!

    """filter the rows returned"""
    where: notebook_action_bool_exp
  ): [notebook_action!]!

  """
  fetch aggregated fields from the table: "notebook"
  """
  notebook_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_order_by!]

    """filter the rows returned"""
    where: notebook_bool_exp
  ): notebook_aggregate!

  """
  fetch data from the table: "notebook_appointment"
  """
  notebook_appointment(
    """distinct select on columns"""
    distinct_on: [notebook_appointment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_appointment_order_by!]

    """filter the rows returned"""
    where: notebook_appointment_bool_exp
  ): [notebook_appointment!]!

  """
  fetch aggregated fields from the table: "notebook_appointment"
  """
  notebook_appointment_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_appointment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_appointment_order_by!]

    """filter the rows returned"""
    where: notebook_appointment_bool_exp
  ): notebook_appointment_aggregate!

  """
  fetch data from the table: "notebook_appointment" using primary key columns
  """
  notebook_appointment_by_pk(id: uuid!): notebook_appointment

  """
  fetch data from the table in a streaming manner: "notebook_appointment"
  """
  notebook_appointment_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notebook_appointment_stream_cursor_input]!

    """filter the rows returned"""
    where: notebook_appointment_bool_exp
  ): [notebook_appointment!]!

  """fetch data from the table: "notebook" using primary key columns"""
  notebook_by_pk(id: uuid!): notebook

  """
  fetch data from the table: "notebook_creation"
  """
  notebook_creation(
    """distinct select on columns"""
    distinct_on: [notebook_creation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_creation_order_by!]

    """filter the rows returned"""
    where: notebook_creation_bool_exp
  ): [notebook_creation!]!

  """
  fetch aggregated fields from the table: "notebook_creation"
  """
  notebook_creation_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_creation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_creation_order_by!]

    """filter the rows returned"""
    where: notebook_creation_bool_exp
  ): notebook_creation_aggregate!

  """
  fetch data from the table: "notebook_creation" using primary key columns
  """
  notebook_creation_by_pk(id: uuid!): notebook_creation

  """
  fetch data from the table: "notebook_creation_source_type"
  """
  notebook_creation_source_type(
    """distinct select on columns"""
    distinct_on: [notebook_creation_source_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_creation_source_type_order_by!]

    """filter the rows returned"""
    where: notebook_creation_source_type_bool_exp
  ): [notebook_creation_source_type!]!

  """
  fetch aggregated fields from the table: "notebook_creation_source_type"
  """
  notebook_creation_source_type_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_creation_source_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_creation_source_type_order_by!]

    """filter the rows returned"""
    where: notebook_creation_source_type_bool_exp
  ): notebook_creation_source_type_aggregate!

  """
  fetch data from the table: "notebook_creation_source_type" using primary key columns
  """
  notebook_creation_source_type_by_pk(id: String!): notebook_creation_source_type

  """
  fetch data from the table in a streaming manner: "notebook_creation_source_type"
  """
  notebook_creation_source_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notebook_creation_source_type_stream_cursor_input]!

    """filter the rows returned"""
    where: notebook_creation_source_type_bool_exp
  ): [notebook_creation_source_type!]!

  """
  fetch data from the table in a streaming manner: "notebook_creation"
  """
  notebook_creation_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notebook_creation_stream_cursor_input]!

    """filter the rows returned"""
    where: notebook_creation_bool_exp
  ): [notebook_creation!]!

  """
  fetch data from the table: "notebook_event"
  """
  notebook_event(
    """distinct select on columns"""
    distinct_on: [notebook_event_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_event_order_by!]

    """filter the rows returned"""
    where: notebook_event_bool_exp
  ): [notebook_event!]!

  """
  fetch aggregated fields from the table: "notebook_event"
  """
  notebook_event_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_event_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_event_order_by!]

    """filter the rows returned"""
    where: notebook_event_bool_exp
  ): notebook_event_aggregate!

  """fetch data from the table: "notebook_event" using primary key columns"""
  notebook_event_by_pk(id: uuid!): notebook_event

  """
  fetch data from the table in a streaming manner: "notebook_event"
  """
  notebook_event_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notebook_event_stream_cursor_input]!

    """filter the rows returned"""
    where: notebook_event_bool_exp
  ): [notebook_event!]!

  """
  fetch data from the table: "notebook_event_type"
  """
  notebook_event_type(
    """distinct select on columns"""
    distinct_on: [notebook_event_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_event_type_order_by!]

    """filter the rows returned"""
    where: notebook_event_type_bool_exp
  ): [notebook_event_type!]!

  """
  fetch aggregated fields from the table: "notebook_event_type"
  """
  notebook_event_type_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_event_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_event_type_order_by!]

    """filter the rows returned"""
    where: notebook_event_type_bool_exp
  ): notebook_event_type_aggregate!

  """
  fetch data from the table: "notebook_event_type" using primary key columns
  """
  notebook_event_type_by_pk(value: String!): notebook_event_type

  """
  fetch data from the table in a streaming manner: "notebook_event_type"
  """
  notebook_event_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notebook_event_type_stream_cursor_input]!

    """filter the rows returned"""
    where: notebook_event_type_bool_exp
  ): [notebook_event_type!]!

  """
  fetch data from the table: "notebook_focus"
  """
  notebook_focus(
    """distinct select on columns"""
    distinct_on: [notebook_focus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_focus_order_by!]

    """filter the rows returned"""
    where: notebook_focus_bool_exp
  ): [notebook_focus!]!

  """
  fetch aggregated fields from the table: "notebook_focus"
  """
  notebook_focus_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_focus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_focus_order_by!]

    """filter the rows returned"""
    where: notebook_focus_bool_exp
  ): notebook_focus_aggregate!

  """fetch data from the table: "notebook_focus" using primary key columns"""
  notebook_focus_by_pk(id: uuid!): notebook_focus

  """
  fetch data from the table in a streaming manner: "notebook_focus"
  """
  notebook_focus_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notebook_focus_stream_cursor_input]!

    """filter the rows returned"""
    where: notebook_focus_bool_exp
  ): [notebook_focus!]!

  """
  fetch data from the table: "notebook_info"
  """
  notebook_info(
    """distinct select on columns"""
    distinct_on: [notebook_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_info_order_by!]

    """filter the rows returned"""
    where: notebook_info_bool_exp
  ): [notebook_info!]!

  """
  fetch aggregated fields from the table: "notebook_info"
  """
  notebook_info_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_info_order_by!]

    """filter the rows returned"""
    where: notebook_info_bool_exp
  ): notebook_info_aggregate!

  """fetch data from the table: "notebook_info" using primary key columns"""
  notebook_info_by_pk(notebookId: uuid!): notebook_info

  """
  fetch data from the table in a streaming manner: "notebook_info"
  """
  notebook_info_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notebook_info_stream_cursor_input]!

    """filter the rows returned"""
    where: notebook_info_bool_exp
  ): [notebook_info!]!

  """
  fetch data from the table: "notebook_member"
  """
  notebook_member(
    """distinct select on columns"""
    distinct_on: [notebook_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_member_order_by!]

    """filter the rows returned"""
    where: notebook_member_bool_exp
  ): [notebook_member!]!

  """
  fetch aggregated fields from the table: "notebook_member"
  """
  notebook_member_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_member_order_by!]

    """filter the rows returned"""
    where: notebook_member_bool_exp
  ): notebook_member_aggregate!

  """fetch data from the table: "notebook_member" using primary key columns"""
  notebook_member_by_pk(id: uuid!): notebook_member

  """
  fetch data from the table in a streaming manner: "notebook_member"
  """
  notebook_member_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notebook_member_stream_cursor_input]!

    """filter the rows returned"""
    where: notebook_member_bool_exp
  ): [notebook_member!]!

  """
  fetch data from the table: "notebook_public_view"
  """
  notebook_public_view(
    """distinct select on columns"""
    distinct_on: [notebook_public_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_public_view_order_by!]

    """filter the rows returned"""
    where: notebook_public_view_bool_exp
  ): [notebook_public_view!]!

  """
  fetch aggregated fields from the table: "notebook_public_view"
  """
  notebook_public_view_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_public_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_public_view_order_by!]

    """filter the rows returned"""
    where: notebook_public_view_bool_exp
  ): notebook_public_view_aggregate!

  """
  fetch data from the table in a streaming manner: "notebook_public_view"
  """
  notebook_public_view_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notebook_public_view_stream_cursor_input]!

    """filter the rows returned"""
    where: notebook_public_view_bool_exp
  ): [notebook_public_view!]!

  """
  fetch data from the table: "notebook_situation"
  """
  notebook_situation(
    """distinct select on columns"""
    distinct_on: [notebook_situation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_situation_order_by!]

    """filter the rows returned"""
    where: notebook_situation_bool_exp
  ): [notebook_situation!]!

  """
  fetch aggregated fields from the table: "notebook_situation"
  """
  notebook_situation_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_situation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_situation_order_by!]

    """filter the rows returned"""
    where: notebook_situation_bool_exp
  ): notebook_situation_aggregate!

  """
  fetch data from the table: "notebook_situation" using primary key columns
  """
  notebook_situation_by_pk(id: uuid!): notebook_situation

  """
  fetch data from the table in a streaming manner: "notebook_situation"
  """
  notebook_situation_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notebook_situation_stream_cursor_input]!

    """filter the rows returned"""
    where: notebook_situation_bool_exp
  ): [notebook_situation!]!

  """
  fetch data from the table in a streaming manner: "notebook"
  """
  notebook_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notebook_stream_cursor_input]!

    """filter the rows returned"""
    where: notebook_bool_exp
  ): [notebook!]!

  """
  fetch data from the table: "notebook_target"
  """
  notebook_target(
    """distinct select on columns"""
    distinct_on: [notebook_target_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_target_order_by!]

    """filter the rows returned"""
    where: notebook_target_bool_exp
  ): [notebook_target!]!

  """
  fetch aggregated fields from the table: "notebook_target"
  """
  notebook_target_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_target_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_target_order_by!]

    """filter the rows returned"""
    where: notebook_target_bool_exp
  ): notebook_target_aggregate!

  """fetch data from the table: "notebook_target" using primary key columns"""
  notebook_target_by_pk(id: uuid!): notebook_target

  """
  fetch data from the table in a streaming manner: "notebook_target"
  """
  notebook_target_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notebook_target_stream_cursor_input]!

    """filter the rows returned"""
    where: notebook_target_bool_exp
  ): [notebook_target!]!

  """
  fetch data from the table: "notebook_update"
  """
  notebook_update(
    """distinct select on columns"""
    distinct_on: [notebook_update_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_update_order_by!]

    """filter the rows returned"""
    where: notebook_update_bool_exp
  ): [notebook_update!]!

  """
  fetch aggregated fields from the table: "notebook_update"
  """
  notebook_update_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_update_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_update_order_by!]

    """filter the rows returned"""
    where: notebook_update_bool_exp
  ): notebook_update_aggregate!

  """fetch data from the table: "notebook_update" using primary key columns"""
  notebook_update_by_pk(id: uuid!): notebook_update

  """
  fetch data from the table in a streaming manner: "notebook_update"
  """
  notebook_update_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notebook_update_stream_cursor_input]!

    """filter the rows returned"""
    where: notebook_update_bool_exp
  ): [notebook_update!]!

  """
  fetch data from the table: "notebook_visit"
  """
  notebook_visit(
    """distinct select on columns"""
    distinct_on: [notebook_visit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_visit_order_by!]

    """filter the rows returned"""
    where: notebook_visit_bool_exp
  ): [notebook_visit!]!

  """
  fetch aggregated fields from the table: "notebook_visit"
  """
  notebook_visit_aggregate(
    """distinct select on columns"""
    distinct_on: [notebook_visit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_visit_order_by!]

    """filter the rows returned"""
    where: notebook_visit_bool_exp
  ): notebook_visit_aggregate!

  """fetch data from the table: "notebook_visit" using primary key columns"""
  notebook_visit_by_pk(id: uuid!): notebook_visit

  """
  fetch data from the table in a streaming manner: "notebook_visit"
  """
  notebook_visit_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notebook_visit_stream_cursor_input]!

    """filter the rows returned"""
    where: notebook_visit_bool_exp
  ): [notebook_visit!]!

  """
  fetch data from the table: "nps_rating"
  """
  nps_rating(
    """distinct select on columns"""
    distinct_on: [nps_rating_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [nps_rating_order_by!]

    """filter the rows returned"""
    where: nps_rating_bool_exp
  ): [nps_rating!]!

  """
  fetch aggregated fields from the table: "nps_rating"
  """
  nps_rating_aggregate(
    """distinct select on columns"""
    distinct_on: [nps_rating_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [nps_rating_order_by!]

    """filter the rows returned"""
    where: nps_rating_bool_exp
  ): nps_rating_aggregate!

  """fetch data from the table: "nps_rating" using primary key columns"""
  nps_rating_by_pk(id: uuid!): nps_rating

  """
  fetch data from the table: "nps_rating_dismissal"
  """
  nps_rating_dismissal(
    """distinct select on columns"""
    distinct_on: [nps_rating_dismissal_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [nps_rating_dismissal_order_by!]

    """filter the rows returned"""
    where: nps_rating_dismissal_bool_exp
  ): [nps_rating_dismissal!]!

  """
  fetch aggregated fields from the table: "nps_rating_dismissal"
  """
  nps_rating_dismissal_aggregate(
    """distinct select on columns"""
    distinct_on: [nps_rating_dismissal_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [nps_rating_dismissal_order_by!]

    """filter the rows returned"""
    where: nps_rating_dismissal_bool_exp
  ): nps_rating_dismissal_aggregate!

  """
  fetch data from the table: "nps_rating_dismissal" using primary key columns
  """
  nps_rating_dismissal_by_pk(id: uuid!): nps_rating_dismissal

  """
  fetch data from the table in a streaming manner: "nps_rating_dismissal"
  """
  nps_rating_dismissal_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [nps_rating_dismissal_stream_cursor_input]!

    """filter the rows returned"""
    where: nps_rating_dismissal_bool_exp
  ): [nps_rating_dismissal!]!

  """
  fetch data from the table in a streaming manner: "nps_rating"
  """
  nps_rating_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [nps_rating_stream_cursor_input]!

    """filter the rows returned"""
    where: nps_rating_bool_exp
  ): [nps_rating!]!

  """
  fetch data from the table: "orientation_manager"
  """
  orientation_manager(
    """distinct select on columns"""
    distinct_on: [orientation_manager_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [orientation_manager_order_by!]

    """filter the rows returned"""
    where: orientation_manager_bool_exp
  ): [orientation_manager!]!

  """
  fetch aggregated fields from the table: "orientation_manager"
  """
  orientation_manager_aggregate(
    """distinct select on columns"""
    distinct_on: [orientation_manager_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [orientation_manager_order_by!]

    """filter the rows returned"""
    where: orientation_manager_bool_exp
  ): orientation_manager_aggregate!

  """
  fetch data from the table: "orientation_manager" using primary key columns
  """
  orientation_manager_by_pk(id: uuid!): orientation_manager

  """
  fetch data from the table in a streaming manner: "orientation_manager"
  """
  orientation_manager_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [orientation_manager_stream_cursor_input]!

    """filter the rows returned"""
    where: orientation_manager_bool_exp
  ): [orientation_manager!]!

  """
  fetch data from the table: "orientation_request"
  """
  orientation_request(
    """distinct select on columns"""
    distinct_on: [orientation_request_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [orientation_request_order_by!]

    """filter the rows returned"""
    where: orientation_request_bool_exp
  ): [orientation_request!]!

  """
  fetch aggregated fields from the table: "orientation_request"
  """
  orientation_request_aggregate(
    """distinct select on columns"""
    distinct_on: [orientation_request_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [orientation_request_order_by!]

    """filter the rows returned"""
    where: orientation_request_bool_exp
  ): orientation_request_aggregate!

  """
  fetch data from the table: "orientation_request" using primary key columns
  """
  orientation_request_by_pk(id: uuid!): orientation_request

  """
  fetch data from the table in a streaming manner: "orientation_request"
  """
  orientation_request_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [orientation_request_stream_cursor_input]!

    """filter the rows returned"""
    where: orientation_request_bool_exp
  ): [orientation_request!]!

  """
  fetch data from the table: "orientation_system"
  """
  orientation_system(
    """distinct select on columns"""
    distinct_on: [orientation_system_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [orientation_system_order_by!]

    """filter the rows returned"""
    where: orientation_system_bool_exp
  ): [orientation_system!]!

  """
  fetch aggregated fields from the table: "orientation_system"
  """
  orientation_system_aggregate(
    """distinct select on columns"""
    distinct_on: [orientation_system_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [orientation_system_order_by!]

    """filter the rows returned"""
    where: orientation_system_bool_exp
  ): orientation_system_aggregate!

  """
  fetch data from the table: "orientation_system" using primary key columns
  """
  orientation_system_by_pk(id: uuid!): orientation_system

  """
  fetch data from the table in a streaming manner: "orientation_system"
  """
  orientation_system_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [orientation_system_stream_cursor_input]!

    """filter the rows returned"""
    where: orientation_system_bool_exp
  ): [orientation_system!]!

  """
  fetch data from the table: "orientation_type"
  """
  orientation_type(
    """distinct select on columns"""
    distinct_on: [orientation_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [orientation_type_order_by!]

    """filter the rows returned"""
    where: orientation_type_bool_exp
  ): [orientation_type!]!

  """
  fetch aggregated fields from the table: "orientation_type"
  """
  orientation_type_aggregate(
    """distinct select on columns"""
    distinct_on: [orientation_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [orientation_type_order_by!]

    """filter the rows returned"""
    where: orientation_type_bool_exp
  ): orientation_type_aggregate!

  """
  fetch data from the table: "orientation_type" using primary key columns
  """
  orientation_type_by_pk(id: String!): orientation_type

  """
  fetch data from the table in a streaming manner: "orientation_type"
  """
  orientation_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [orientation_type_stream_cursor_input]!

    """filter the rows returned"""
    where: orientation_type_bool_exp
  ): [orientation_type!]!

  """
  fetch data from the table: "professional"
  """
  professional(
    """distinct select on columns"""
    distinct_on: [professional_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [professional_order_by!]

    """filter the rows returned"""
    where: professional_bool_exp
  ): [professional!]!

  """
  fetch aggregated fields from the table: "professional"
  """
  professional_aggregate(
    """distinct select on columns"""
    distinct_on: [professional_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [professional_order_by!]

    """filter the rows returned"""
    where: professional_bool_exp
  ): professional_aggregate!

  """fetch data from the table: "professional" using primary key columns"""
  professional_by_pk(id: uuid!): professional

  """
  fetch data from the table: "professional_orientation_system"
  """
  professional_orientation_system(
    """distinct select on columns"""
    distinct_on: [professional_orientation_system_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [professional_orientation_system_order_by!]

    """filter the rows returned"""
    where: professional_orientation_system_bool_exp
  ): [professional_orientation_system!]!

  """
  fetch aggregated fields from the table: "professional_orientation_system"
  """
  professional_orientation_system_aggregate(
    """distinct select on columns"""
    distinct_on: [professional_orientation_system_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [professional_orientation_system_order_by!]

    """filter the rows returned"""
    where: professional_orientation_system_bool_exp
  ): professional_orientation_system_aggregate!

  """
  fetch data from the table: "professional_orientation_system" using primary key columns
  """
  professional_orientation_system_by_pk(id: uuid!): professional_orientation_system

  """
  fetch data from the table in a streaming manner: "professional_orientation_system"
  """
  professional_orientation_system_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [professional_orientation_system_stream_cursor_input]!

    """filter the rows returned"""
    where: professional_orientation_system_bool_exp
  ): [professional_orientation_system!]!

  """
  fetch data from the table: "professional_project"
  """
  professional_project(
    """distinct select on columns"""
    distinct_on: [professional_project_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [professional_project_order_by!]

    """filter the rows returned"""
    where: professional_project_bool_exp
  ): [professional_project!]!

  """
  fetch aggregated fields from the table: "professional_project"
  """
  professional_project_aggregate(
    """distinct select on columns"""
    distinct_on: [professional_project_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [professional_project_order_by!]

    """filter the rows returned"""
    where: professional_project_bool_exp
  ): professional_project_aggregate!

  """
  fetch data from the table: "professional_project" using primary key columns
  """
  professional_project_by_pk(id: uuid!): professional_project

  """
  fetch data from the table in a streaming manner: "professional_project"
  """
  professional_project_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [professional_project_stream_cursor_input]!

    """filter the rows returned"""
    where: professional_project_bool_exp
  ): [professional_project!]!

  """
  fetch data from the table in a streaming manner: "professional"
  """
  professional_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [professional_stream_cursor_input]!

    """filter the rows returned"""
    where: professional_bool_exp
  ): [professional!]!

  """
  fetch data from the table: "ref_action"
  """
  ref_action(
    """distinct select on columns"""
    distinct_on: [ref_action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_action_order_by!]

    """filter the rows returned"""
    where: ref_action_bool_exp
  ): [ref_action!]!

  """
  fetch aggregated fields from the table: "ref_action"
  """
  ref_action_aggregate(
    """distinct select on columns"""
    distinct_on: [ref_action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_action_order_by!]

    """filter the rows returned"""
    where: ref_action_bool_exp
  ): ref_action_aggregate!

  """fetch data from the table: "ref_action" using primary key columns"""
  ref_action_by_pk(id: uuid!): ref_action

  """
  fetch data from the table in a streaming manner: "ref_action"
  """
  ref_action_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ref_action_stream_cursor_input]!

    """filter the rows returned"""
    where: ref_action_bool_exp
  ): [ref_action!]!

  """
  fetch data from the table: "ref_situation"
  """
  ref_situation(
    """distinct select on columns"""
    distinct_on: [ref_situation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_situation_order_by!]

    """filter the rows returned"""
    where: ref_situation_bool_exp
  ): [ref_situation!]!

  """
  fetch aggregated fields from the table: "ref_situation"
  """
  ref_situation_aggregate(
    """distinct select on columns"""
    distinct_on: [ref_situation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_situation_order_by!]

    """filter the rows returned"""
    where: ref_situation_bool_exp
  ): ref_situation_aggregate!

  """fetch data from the table: "ref_situation" using primary key columns"""
  ref_situation_by_pk(id: uuid!): ref_situation

  """
  fetch data from the table in a streaming manner: "ref_situation"
  """
  ref_situation_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ref_situation_stream_cursor_input]!

    """filter the rows returned"""
    where: ref_situation_bool_exp
  ): [ref_situation!]!

  """
  fetch data from the table: "ref_target"
  """
  ref_target(
    """distinct select on columns"""
    distinct_on: [ref_target_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_target_order_by!]

    """filter the rows returned"""
    where: ref_target_bool_exp
  ): [ref_target!]!

  """
  fetch aggregated fields from the table: "ref_target"
  """
  ref_target_aggregate(
    """distinct select on columns"""
    distinct_on: [ref_target_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_target_order_by!]

    """filter the rows returned"""
    where: ref_target_bool_exp
  ): ref_target_aggregate!

  """fetch data from the table: "ref_target" using primary key columns"""
  ref_target_by_pk(id: uuid!): ref_target

  """
  fetch data from the table in a streaming manner: "ref_target"
  """
  ref_target_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ref_target_stream_cursor_input]!

    """filter the rows returned"""
    where: ref_target_bool_exp
  ): [ref_target!]!

  """
  fetch data from the table: "ref_theme"
  """
  ref_theme(
    """distinct select on columns"""
    distinct_on: [ref_theme_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_theme_order_by!]

    """filter the rows returned"""
    where: ref_theme_bool_exp
  ): [ref_theme!]!

  """
  fetch aggregated fields from the table: "ref_theme"
  """
  ref_theme_aggregate(
    """distinct select on columns"""
    distinct_on: [ref_theme_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_theme_order_by!]

    """filter the rows returned"""
    where: ref_theme_bool_exp
  ): ref_theme_aggregate!

  """fetch data from the table: "ref_theme" using primary key columns"""
  ref_theme_by_pk(name: String!): ref_theme

  """
  fetch data from the table in a streaming manner: "ref_theme"
  """
  ref_theme_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ref_theme_stream_cursor_input]!

    """filter the rows returned"""
    where: ref_theme_bool_exp
  ): [ref_theme!]!

  """
  fetch data from the table: "role"
  """
  role(
    """distinct select on columns"""
    distinct_on: [role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_order_by!]

    """filter the rows returned"""
    where: role_bool_exp
  ): [role!]!

  """
  fetch aggregated fields from the table: "role"
  """
  role_aggregate(
    """distinct select on columns"""
    distinct_on: [role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_order_by!]

    """filter the rows returned"""
    where: role_bool_exp
  ): role_aggregate!

  """fetch data from the table: "role" using primary key columns"""
  role_by_pk(label: String!): role

  """
  fetch data from the table in a streaming manner: "role"
  """
  role_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [role_stream_cursor_input]!

    """filter the rows returned"""
    where: role_bool_exp
  ): [role!]!

  """
  fetch data from the table: "rome_code"
  """
  rome_code(
    """distinct select on columns"""
    distinct_on: [rome_code_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rome_code_order_by!]

    """filter the rows returned"""
    where: rome_code_bool_exp
  ): [rome_code!]!

  """
  fetch aggregated fields from the table: "rome_code"
  """
  rome_code_aggregate(
    """distinct select on columns"""
    distinct_on: [rome_code_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rome_code_order_by!]

    """filter the rows returned"""
    where: rome_code_bool_exp
  ): rome_code_aggregate!

  """fetch data from the table: "rome_code" using primary key columns"""
  rome_code_by_pk(id: uuid!): rome_code

  """
  fetch data from the table in a streaming manner: "rome_code"
  """
  rome_code_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rome_code_stream_cursor_input]!

    """filter the rows returned"""
    where: rome_code_bool_exp
  ): [rome_code!]!

  """
  fetch data from the table: "rsa_closure_reason"
  """
  rsa_closure_reason(
    """distinct select on columns"""
    distinct_on: [rsa_closure_reason_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rsa_closure_reason_order_by!]

    """filter the rows returned"""
    where: rsa_closure_reason_bool_exp
  ): [rsa_closure_reason!]!

  """
  fetch aggregated fields from the table: "rsa_closure_reason"
  """
  rsa_closure_reason_aggregate(
    """distinct select on columns"""
    distinct_on: [rsa_closure_reason_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rsa_closure_reason_order_by!]

    """filter the rows returned"""
    where: rsa_closure_reason_bool_exp
  ): rsa_closure_reason_aggregate!

  """
  fetch data from the table: "rsa_closure_reason" using primary key columns
  """
  rsa_closure_reason_by_pk(code: String!): rsa_closure_reason

  """
  fetch data from the table in a streaming manner: "rsa_closure_reason"
  """
  rsa_closure_reason_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rsa_closure_reason_stream_cursor_input]!

    """filter the rows returned"""
    where: rsa_closure_reason_bool_exp
  ): [rsa_closure_reason!]!

  """
  fetch data from the table: "rsa_suspension_reason"
  """
  rsa_suspension_reason(
    """distinct select on columns"""
    distinct_on: [rsa_suspension_reason_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rsa_suspension_reason_order_by!]

    """filter the rows returned"""
    where: rsa_suspension_reason_bool_exp
  ): [rsa_suspension_reason!]!

  """
  fetch aggregated fields from the table: "rsa_suspension_reason"
  """
  rsa_suspension_reason_aggregate(
    """distinct select on columns"""
    distinct_on: [rsa_suspension_reason_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rsa_suspension_reason_order_by!]

    """filter the rows returned"""
    where: rsa_suspension_reason_bool_exp
  ): rsa_suspension_reason_aggregate!

  """
  fetch data from the table: "rsa_suspension_reason" using primary key columns
  """
  rsa_suspension_reason_by_pk(code: String!): rsa_suspension_reason

  """
  fetch data from the table in a streaming manner: "rsa_suspension_reason"
  """
  rsa_suspension_reason_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rsa_suspension_reason_stream_cursor_input]!

    """filter the rows returned"""
    where: rsa_suspension_reason_bool_exp
  ): [rsa_suspension_reason!]!

  """
  execute function "search_beneficiaries" which returns "beneficiary"
  """
  search_beneficiaries(
    """
    input parameters for function "search_beneficiaries"
    """
    args: search_beneficiaries_args!

    """distinct select on columns"""
    distinct_on: [beneficiary_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [beneficiary_order_by!]

    """filter the rows returned"""
    where: beneficiary_bool_exp
  ): [beneficiary!]!

  """
  execute function "search_beneficiaries" and query aggregates on result of table type "beneficiary"
  """
  search_beneficiaries_aggregate(
    """
    input parameters for function "search_beneficiaries_aggregate"
    """
    args: search_beneficiaries_args!

    """distinct select on columns"""
    distinct_on: [beneficiary_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [beneficiary_order_by!]

    """filter the rows returned"""
    where: beneficiary_bool_exp
  ): beneficiary_aggregate!

  """
  execute function "search_notebook_members" which returns "notebook_member"
  """
  search_notebook_members(
    """
    input parameters for function "search_notebook_members"
    """
    args: search_notebook_members_args!

    """distinct select on columns"""
    distinct_on: [notebook_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_member_order_by!]

    """filter the rows returned"""
    where: notebook_member_bool_exp
  ): [notebook_member!]!

  """
  execute function "search_notebook_members" and query aggregates on result of table type "notebook_member"
  """
  search_notebook_members_aggregate(
    """
    input parameters for function "search_notebook_members_aggregate"
    """
    args: search_notebook_members_args!

    """distinct select on columns"""
    distinct_on: [notebook_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_member_order_by!]

    """filter the rows returned"""
    where: notebook_member_bool_exp
  ): notebook_member_aggregate!

  """
  execute function "search_public_notebooks" which returns "notebook_public_view"
  """
  search_public_notebooks(
    """
    input parameters for function "search_public_notebooks"
    """
    args: search_public_notebooks_args!

    """distinct select on columns"""
    distinct_on: [notebook_public_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_public_view_order_by!]

    """filter the rows returned"""
    where: notebook_public_view_bool_exp
  ): [notebook_public_view!]!

  """
  execute function "search_public_notebooks" and query aggregates on result of table type "notebook_public_view"
  """
  search_public_notebooks_aggregate(
    """
    input parameters for function "search_public_notebooks_aggregate"
    """
    args: search_public_notebooks_args!

    """distinct select on columns"""
    distinct_on: [notebook_public_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notebook_public_view_order_by!]

    """filter the rows returned"""
    where: notebook_public_view_bool_exp
  ): notebook_public_view_aggregate!

  """
  execute function "search_ref_action" which returns "ref_action"
  """
  search_ref_action(
    """
    input parameters for function "search_ref_action"
    """
    args: search_ref_action_args!

    """distinct select on columns"""
    distinct_on: [ref_action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_action_order_by!]

    """filter the rows returned"""
    where: ref_action_bool_exp
  ): [ref_action!]!

  """
  execute function "search_ref_action" and query aggregates on result of table type "ref_action"
  """
  search_ref_action_aggregate(
    """
    input parameters for function "search_ref_action_aggregate"
    """
    args: search_ref_action_args!

    """distinct select on columns"""
    distinct_on: [ref_action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_action_order_by!]

    """filter the rows returned"""
    where: ref_action_bool_exp
  ): ref_action_aggregate!

  """
  execute function "search_rome_codes" which returns "rome_code"
  """
  search_rome_codes(
    """
    input parameters for function "search_rome_codes"
    """
    args: search_rome_codes_args!

    """distinct select on columns"""
    distinct_on: [rome_code_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rome_code_order_by!]

    """filter the rows returned"""
    where: rome_code_bool_exp
  ): [rome_code!]!

  """
  execute function "search_rome_codes" and query aggregates on result of table type "rome_code"
  """
  search_rome_codes_aggregate(
    """
    input parameters for function "search_rome_codes_aggregate"
    """
    args: search_rome_codes_args!

    """distinct select on columns"""
    distinct_on: [rome_code_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rome_code_order_by!]

    """filter the rows returned"""
    where: rome_code_bool_exp
  ): rome_code_aggregate!

  """
  fetch data from the table: "structure"
  """
  structure(
    """distinct select on columns"""
    distinct_on: [structure_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [structure_order_by!]

    """filter the rows returned"""
    where: structure_bool_exp
  ): [structure!]!

  """
  fetch aggregated fields from the table: "structure"
  """
  structure_aggregate(
    """distinct select on columns"""
    distinct_on: [structure_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [structure_order_by!]

    """filter the rows returned"""
    where: structure_bool_exp
  ): structure_aggregate!

  """fetch data from the table: "structure" using primary key columns"""
  structure_by_pk(id: uuid!): structure

  """
  fetch data from the table: "structure_orientation_system"
  """
  structure_orientation_system(
    """distinct select on columns"""
    distinct_on: [structure_orientation_system_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [structure_orientation_system_order_by!]

    """filter the rows returned"""
    where: structure_orientation_system_bool_exp
  ): [structure_orientation_system!]!

  """
  fetch aggregated fields from the table: "structure_orientation_system"
  """
  structure_orientation_system_aggregate(
    """distinct select on columns"""
    distinct_on: [structure_orientation_system_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [structure_orientation_system_order_by!]

    """filter the rows returned"""
    where: structure_orientation_system_bool_exp
  ): structure_orientation_system_aggregate!

  """
  fetch data from the table: "structure_orientation_system" using primary key columns
  """
  structure_orientation_system_by_pk(id: uuid!): structure_orientation_system

  """
  fetch data from the table in a streaming manner: "structure_orientation_system"
  """
  structure_orientation_system_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [structure_orientation_system_stream_cursor_input]!

    """filter the rows returned"""
    where: structure_orientation_system_bool_exp
  ): [structure_orientation_system!]!

  """
  fetch data from the table in a streaming manner: "structure"
  """
  structure_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [structure_stream_cursor_input]!

    """filter the rows returned"""
    where: structure_bool_exp
  ): [structure!]!
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

