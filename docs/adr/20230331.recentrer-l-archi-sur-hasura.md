# Remettre Hasura au centre de l'architecture applicative de Carnet de bord 

## :memo: Ã‰tat

AcceptÃ©

## :stethoscope: Contexte

Historiquement, lâ€™archi de Carnet de bord sâ€™appuie sur Hasura, une brique open source qui permet de mettre en relation plusieurs systÃ¨mes (webapps, APIs, sources et bases de donnÃ©es).

Au fil du temps, une API mÃ©tier a vu le jour, pour gÃ©rer certaines tÃ¢ches Â« avancÃ©es Â» telles que : lâ€™import /export de donnÃ©es via des imports fichiers, certaines requÃªtes SQL et traitement mÃ©tiers complexes.

Cette brique back-end ajoute des endpoints REST Ã  un back-for-front intÃ©grÃ© Ã  la webapp principale (en Sveltekit). Dans le passÃ©, lâ€™Ã©quipe avait pris la dÃ©cision de migrer les endpoints Sveltekit vers lâ€™API Python.

Aujourdâ€™hui â€“ malgrÃ© l'ADR ["Quand utiliser GraphQL ou l'API backend ?"](./20220926.utilisation-graphql-ou-backend.md)  â€“ lâ€™Ã©quipe se sent perdue au moment dâ€™implÃ©menter des features. Est-ce quâ€™il faut les mettre dans lâ€™API Python ou les dÃ©clarer dans Hasura ? On sent une entropie des opposÃ©s qui nous fait craindre pour lâ€™Ã©volution et la capacitÃ© Ã  faire vivre et Ã©voluer lâ€™archi.

Le schÃ©ma ci-dessus permet de visualiser la multitude de types de flux (GraphQL, REST) ou d'interconnexions au sein du systÃ¨me.

![Architecture actuelle](./CDB_internal_architecture_current_202304.png)

## :bulb: Pistes

1. Miser sur Hasura et remettre la brique au centre de lâ€™archi (comme le veut la philosophie prÃ´nÃ©e par le produit), en suivant un maximum ses prÃ©ceptes / guidelines / contraintes
2. Sortir Hasura et miser sur lâ€™API Python
3. RÃ©Ã©crire le back-end from scratch, en Django (enfin, une techno un peu complÃ¨te, qui permette de refondre rapidement)

## :sparkles: DÃ©cision

Nous prenons la dÃ©cision de retenir la solution 1 et miser sur Hasura.

Les arguments qui nous ont dÃ©cidÃ©s (par rapport Ã  la solution 2, la 3 nous paraissent totalement irrÃ©aliste compte tenu de lâ€™historique et la situation actuelle de CDB) :
- il y aurait plus dâ€™une centaine de endpoints correspondant Ã  la centaine de fichiers GraphQL Ã  rÃ©Ã©crire
- il faudrait reprendre et recoder de 0 le mÃ©canisme de permission
- il faudrait coder tout plein dâ€™opÃ©rations CRUD (pas passionnant, pas si simple, pas rapide du tout)

Nous pensons que si elle est bien utilisÃ©e, en respectant scrupuleusement ses standards et guidelines, la brique Hasura peut permettre Ã  CDB de continuer de bien se dÃ©velopper, pour les usagers / utilisateurs ainsi que les devs / le projet. Comme un projet Ember.

## ConsÃ©quences

Nous pensons qu'un tel choix va sensiblement simplifier l'architecture et faciliter le dÃ©veloppement, l'Ã©volution et le passage Ã  l'Ã©chelle de la plateforme.

![Architecture cible](./CDB_internal_architecture_target.png)

Nous devons viser Ã  couper les liens webapp -> API et API -> BDD.

Au passage, nous devons planifier et mettre en Å“uvre la conversion des 9 derniers endpoints Sveltekit restant vers (des actions) Hasura.

Nous pouvons conserver en lâ€™Ã©tat lâ€™API Python / FastAPI (12 endpoints). Nous devons cependant veiller Ã  ce quâ€™elle respecte le format et les bonnes pratiques Hasura.

Nous devons modifier les requÃªtes SQL en requÃªtes GraphQL via Hasura (et dÃ©clarer les actions / endpoints qui vont bien).

Nous devons nous assurer que lâ€™API Python ne soit jamais accessible sur Internet, autre que par Hasura.

## Points de vigilance

Il sâ€™est posÃ© la question du passage Ã  lâ€™Ã©chelle.

Hasura est OSS mais propose un version payante pour des contextes de passage Ã  lâ€™Ã©chelle. Le pricing nâ€™est pas vraiment fourni par le site (autre que 1,50$/heure dâ€™utilisation).

Il y a la question du vendor lock-in. On a fermÃ© le point en se disant quelle jour oÃ¹ on a ce type de problÃ¨mes / questions, cela voudra dire quâ€™on ira les moyens de payer ou de migrer ðŸ˜Ž.

Nous avons tout de mÃªme regardÃ© les fonctionnalitÃ©s payantes. Nous pensons pouvoir vivre sans.

Nous avons aussi regardÃ© pour scaler horizontalement. Cela nous paraÃ®t possible.

Il semble aussi possible de gÃ©rer des imports de fichiers depuis une webapp vers Hasura.

Hasura est aussi parfaitement capable de consommer et dâ€™exposer des APIs (via un converter built-in GraphQL -> REST).
