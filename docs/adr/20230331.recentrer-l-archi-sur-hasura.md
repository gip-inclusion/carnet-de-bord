# Remettre Hasura au centre de l'architecture applicative de Carnet de bord 

## :memo: Ã‰tat

AcceptÃ©

## :stethoscope: Contexte

Historiquement, lâ€™archi de Carnet de bord sâ€™appuie sur Hasura, une brique open source qui permet de mettre en relation plusieurs systÃ¨mes (webapps, APIs, sources et bases de donnÃ©es).

Au fil du temps, une API mÃ©tier a vu le jour, pour gÃ©rer certaines tÃ¢ches Â« avancÃ©es Â» telles que : lâ€™import /export de donnÃ©es via des imports fichiers, certaines requÃªtes SQL et traitement mÃ©tiers complexes.

Cette brique back-end ajoute des endpoints REST Ã  un back-for-front intÃ©grÃ© Ã  la webapp principale (en Sveltekit). Dans le passÃ©, lâ€™Ã©quipe avait pris la dÃ©cision de migrer les endpoints Sveltekit vers lâ€™API Python.

Aujourdâ€™hui â€“ malgrÃ© l'ADR ["Quand utiliser GraphQL ou l'API backend ?"](./20220926.utilisation-graphql-ou-backend.md)  â€“ lâ€™Ã©quipe se sent perdue au moment dâ€™implÃ©menter des features. Est-ce quâ€™il faut les mettre dans lâ€™API Python ou les dÃ©clarer dans Hasura ? On sent une entropie des opposÃ©s qui nous fait craindre pour lâ€™Ã©volution et la capacitÃ© Ã  faire vivre et Ã©voluer lâ€™archi.

Le schÃ©ma ci-dessus permet de visualiser la multitude de types de flux (GraphQL, REST) ou d'interconnexions au sein du systÃ¨me.

![Architecture actuelle](./CDB_internal_architecture_current_202304.png)

## :bulb: Pistes

1. Miser sur Hasura et remettre la brique au centre de lâ€™archi (comme le veut la philosophie prÃ´nÃ©e par le produit), en suivant un maximum ses prÃ©ceptes / guidelines / contraintes
2. Sortir Hasura et miser sur lâ€™API Python
3. RÃ©Ã©crire le back-end from scratch, en Django (enfin, une techno un peu complÃ¨te, qui permette de refondre rapidement)

## :sparkles: DÃ©cision

Nous prenons la dÃ©cision de retenir la solution 1 et miser sur Hasura.

Les arguments qui nous ont dÃ©cidÃ©s (par rapport Ã  la solution 2, la 3 nous paraissent totalement irrÃ©aliste compte tenu de lâ€™historique et la situation actuelle de CDB) :
- il y aurait plus dâ€™une centaine de endpoints correspondant Ã  la centaine de fichiers GraphQL Ã  rÃ©Ã©crire
- il faudrait reprendre et recoder de 0 le mÃ©canisme de permission
- il faudrait coder tout plein dâ€™opÃ©rations CRUD (pas passionnant, pas si simple, pas rapide du tout)

Nous pensons que si elle est bien utilisÃ©e, en respectant scrupuleusement ses standards et guidelines, la brique Hasura peut permettre Ã  CDB de continuer de bien se dÃ©velopper, pour les usagers / utilisateurs ainsi que les devs / le projet.

## ConsÃ©quences

Nous pensons qu'un tel choix va sensiblement simplifier l'architecture et faciliter le dÃ©veloppement, l'Ã©volution et le passage Ã  l'Ã©chelle de la plateforme.

![Architecture cible](./CDB_internal_architecture_target.png)

Nous devons viser Ã  couper les liens webapp -> API et API -> BDD.

Au passage, nous devons planifier et mettre en Å“uvre la conversion des 9 derniers endpoints Sveltekit restant vers (des actions) Hasura.

Nous pouvons conserver en lâ€™Ã©tat lâ€™API Python / FastAPI (12 endpoints). Nous devons cependant veiller Ã  ce quâ€™elle respecte le format et les bonnes pratiques Hasura.

Nous devons modifier les requÃªtes SQL en requÃªtes GraphQL via Hasura (et dÃ©clarer les actions / endpoints qui vont bien).

La cible est que l'accÃ¨s direct du serveur Python Ã  la base de donnÃ©es PostgreSQL ne soit plus nÃ©cessaire. Si des opÃ©rations doivent Ãªtre effectuÃ©es qui seraient difficiles Ã  exprimer de faÃ§on efficace en GraphQL "pur", les possibilitÃ©s suivantes devraient permettre de les faire passer quand mÃªme par l'API Hasura :
- la dÃ©finition de fonctions et routines PL/SQL appelables via des mutations GraphQLÂ ;
- l'API Hasura "Run SQL" qui permet d'exÃ©cuter des commandes SQL arbitraires : https://hasura.io/docs/latest/api-reference/schema-api/run-sql/
Afin d'accÃ©lÃ©rer la migration vers ce mode d'accÃ¨s aux donnÃ©es passant entiÃ¨rement par Hasura, on peut envisager de remplacer dans un premier temps tous les accÃ¨s SQL faits dans le code Python par des appels Ã  cette API "Run SQL", sachant qu'il est possible que cela se heurte Ã  certaines contraintes notamment au niveau de la gestion des transactions.

Nous devons nous assurer que lâ€™API Python ne soit jamais accessible sur Internet, autre que par Hasura.

Pour les tÃ¢ches planifiÃ©es (_cron_), nous gÃ©nÃ©raliserons l'utilisation du _scheduler_ Hasura (https://hasura.io/docs/latest/scheduled-triggers/create-cron-trigger/), dÃ©jÃ  utilisÃ© pour l'envoi de rapports quotidiens Ã  Matomo, plutÃ´t que par exemple le _scheduler_ Scalingo tel qu'il a Ã©tÃ© mis en place pour l'envoi automatique d'emails de relance (https://github.com/gip-inclusion/carnet-de-bord/pull/1454/files#diff-0459a8f0d0cb8e5dc97c651a02c11ed3dcc6eceac13ca748ea20b89717b17cee).

## Points de vigilance

Il sâ€™est posÃ© la question du passage Ã  lâ€™Ã©chelle.

Hasura est OSS mais propose un version payante pour des contextes de passage Ã  lâ€™Ã©chelle. Le pricing nâ€™est pas vraiment fourni par le site (autre que 1,50$/heure dâ€™utilisation).

Il y a la question du vendor lock-in. On a fermÃ© le point en se disant que le jour oÃ¹ on a ce type de problÃ¨mes / questions, cela voudra dire quâ€™on aura les moyens de payer ou de migrer ğŸ˜.

Nous avons tout de mÃªme regardÃ© les fonctionnalitÃ©s payantes. Nous pensons pouvoir vivre sans.

Nous avons aussi regardÃ© pour scaler horizontalement. Cela nous paraÃ®t possible.

Il semble aussi possible de gÃ©rer des imports de fichiers depuis une webapp vers Hasura.

Hasura est aussi parfaitement capable de consommer et dâ€™exposer des APIs (via un converter built-in GraphQL -> REST).

Pour les mutations, il est possible qu'on se rende compte que dans la majoritÃ© des cas, il est nÃ©cessaire d'ajouter du comportement pour valider les entrÃ©es et/ou appliquer des rÃ¨gles mÃ©tiers (on ne peut en effet pas faire confiance au client GraphQL public pour enchaÃ®ner des opÃ©rations qui doivent Ãªtre faites conjointement pour respecter les rÃ¨gles mÃ©tiers). Ce cas de figure est prÃ©vu par Hasura et la procÃ©dure Ã  suivre pour remplacer les mutations par dÃ©faut de Hasura (ex. `insert_notebook_one`) par des actions implÃ©mentÃ©es par un _backend_ est documentÃ©e ici : https://hasura.io/docs/latest/actions/derive/ .

Pour les routes de l'API Python qui prennent des fichiers en entrÃ©e (pour les imports), il reste Ã  voir si ces transferts peuvent Ãªtre "embarquÃ©s" dans du GraphQL, ou si une autre solution doit Ãªtre trouvÃ©e (par exemple, voir si la spec https://github.com/jaydenseric/graphql-multipart-request-spec peut Ãªtre implÃ©mentÃ©e, ou mettre en Å“uvre un mÃ©canisme d'upload dans un _object store_ sÃ©parÃ© de l'action qui dÃ©clenche l'import, ou encore laisser ces routes ouvertes sans passer par Hasura).

