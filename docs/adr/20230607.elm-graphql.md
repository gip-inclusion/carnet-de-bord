---
statut: Brouillon
date: 2023-06-07
décideurs:
---

# Graphql en Elm

## Contexte et énoncé du problème

L'application est écrite en [Elm](https://elm-lang.org). Le backend est accessible via [Hasura](https://hasura.io) avec son API graphql.
Par conséquent, nous devons appeler graphql à partir du code Elm (au lieu de Svelte).

## Facteurs de décision

**TODO**

- Désir de diviser l'ensemble du système en parties gérables pour réduire la complexité
- Capacité à échanger des parties du système sans affecter les autres

## Résultat de la décision

**TODO**
Nous avons décidé d'appliquer le modèle de couches (Layers pattern) et de négliger d'autres modèles de décomposition tels que pipes-and-filters ou workflow, car le système en cours de construction et ses capacités ne suggèrent pas une organisation par flux de données ou flux de contrôle. La technologie devrait être le principal moteur du changement lors de l'évolution du système.

### Conséquences

**TODO**

- Bon, car le modèle de couches offre une grande flexibilité en ce qui concerne les sélections de technologie au sein des couches (possibilité de changement) et permet aux équipes de travailler sur les parties du système en parallèle.
- Mauvais, car il peut y avoir une pénalité de performance pour chaque niveau d'indirection et une certaine duplication indésirable des artefacts d'implémentation.

## Solutions envisagées

### Déléguer à Svelte

Lorsque nous devons effectuer un appel graphql, nous envoyons les données à Svelte via un port. Svelte traduit ensuite les données en une requête graphql. Lorsqu'il reçoit la réponse, il envoie les données à Elm via un autre port (et une souscription correspondante). Elm doit ensuite mapper les données sur son modèle interne.

#### Avantages

- Svelte peut garantir la sécurité des types de la requête lors de la compilation.
- Elm reste relativement simple et rapide.

#### Inconvénients

- Le flux des données est plus difficile à suivre car il passe de Elm à Svelte et vice versa.
- Beaucoup de code de mappage entre le modèle Elm et Svelte.

### Chaîne de caractères et Json.Decode

Nous écrivons le code graphql dans une chaîne de caractères multiligne en tant que corps de la requête HTTP. Ensuite, nous utilisons des décodeurs JSON pour analyser la réponse.

#### Avantages

- Léger
- Simple à lire et à suivre le flux des données

#### Inconvénients

- Nous n'avons pas d'autocomplétion pour le code graphql ni de coloration syntaxique.
- Si le schéma change, nous le savons uniquement à l'exécution. Nous devrions donc avoir des tests d'intégration pour vérifier que le code graphql est toujours valide avant de passer en production.

### [graphql-to-elm](https://package.elm-lang.org/packages/harmboschloo/graphql-to-elm/latest/)

Il s'agit d'un module Elm et d'un générateur de code. Il traduit un fichier graphql en un appel HTTP et un décodeur Json.Decode.

Il simplifie l'écriture du code mais ne fournit pas de garanties additionelles.

### elm-graphql

Il s'agit d'un package Elm et d'un générateur de code.
Il traduit le schéma graphql en code Elm. Ainsi, il rend les requêtes graphql invalides impossibles lors de la compilation.

#### Avantages

Graphql sûr au niveau des types. La boucle de rétroaction est aussi courte que possible.

Le schéma graphql est traduit en Elm sûr au niveau des types.

    Il est techniquement impossible d'écrire une requête qui ne serait pas valide par rapport au schéma.
    Toute modification structurelle du schéma empêcherait la compilation du code Elm.

#### Inconvénients

    Le code généré est très volumineux. Cela ralentit considérablement elm-review et elm-language-server.
        450 fichiers
        48 398 lignes de code Elm
    Une partie du code est assez difficile à travailler.

```graphql
query {
	notebook_situation(where: { notebookId: { _eq: "9b07a45e-2c7c-4f92-ae6b-bc2f5a3c9a7d" } }) {
		creator {
			orientation_manager {
				lastname
				firstname
			}
			professional {
				structure {
					name
				}
				lastname
				firstname
			}
		}
		createdAt
		refSituation {
			description
			theme
		}
	}
}
```

Se traduit en 100 lignes de Elm. En particulier, la clause where est difficile à écrire et lire.

```elm
findBy :
    String
    -> CdbGQL.Query.NotebookSituationOptionalArguments
    -> CdbGQL.Query.NotebookSituationOptionalArguments
findBy id args =
    { args | where_ = Present (notebookIdEq id) }


notebookIdEq : String -> CdbGQL.InputObject.Notebook_situation_bool_exp
notebookIdEq notebookId =
    buildNotebook_situation_bool_exp
        (\args ->
            { args | notebookId = Present (eq notebookId) }
        )


eq : String -> CdbGQL.InputObject.Uuid_comparison_exp
eq notebookId =
    buildUuid_comparison_exp
        (\comparison ->
            { comparison | eq_ = Present <| CdbGQL.Scalar.Uuid notebookId }
        )

```
