---
statut: Brouillon
date: 2023-06-07
décideurs:
---

# Graphql en Elm

## Contexte et énoncé du problème

L'application est écrite en [Elm](https://elm-lang.org). Le backend est accessible via [Hasura](https://hasura.io) avec son API graphql.
Par conséquent, nous devons appeler graphql à partir du code Elm (au lieu de Svelte).

## Facteurs de décision

**TODO**

- Désir de diviser l'ensemble du système en parties gérables pour réduire la complexité
- Capacité à échanger des parties du système sans affecter les autres

## Résultat de la décision

**TODO**
Nous avons décidé d'appliquer le modèle de couches (Layers pattern) et de négliger d'autres modèles de décomposition tels que pipes-and-filters ou workflow, car le système en cours de construction et ses capacités ne suggèrent pas une organisation par flux de données ou flux de contrôle. La technologie devrait être le principal moteur du changement lors de l'évolution du système.

### Conséquences

**TODO**

- Bon, car le modèle de couches offre une grande flexibilité en ce qui concerne les sélections de technologie au sein des couches (possibilité de changement) et permet aux équipes de travailler sur les parties du système en parallèle.
- Mauvais, car il peut y avoir une pénalité de performance pour chaque niveau d'indirection et une certaine duplication indésirable des artefacts d'implémentation.

## Solutions envisagées

### Déléguer à Svelte

Lorsque nous devons effectuer un appel graphql, nous envoyons les données à Svelte via un port. Svelte traduit ensuite les données en une requête graphql. Lorsqu'il reçoit la réponse, il envoie les données à Elm via un autre port (et une souscription correspondante). Elm doit ensuite mapper les données sur son modèle interne.

#### Avantages

- Svelte peut garantir la sécurité des types de la requête lors de la compilation.
- Elm reste relativement simple et rapide.

#### Inconvénients

- Le flux des données est plus difficile à suivre car il passe de Elm à Svelte et vice versa.
- Beaucoup de code de mappage entre le modèle Elm et Svelte.

### Chaîne de caractères et Json.Decode

Nous écrivons le code graphql dans une chaîne de caractères multiligne en tant que corps de la requête HTTP. Ensuite, nous utilisons des décodeurs JSON pour analyser la réponse.

#### Avantages

- Léger
- Simple à lire et à suivre le flux des données

#### Inconvénients

- Nous n'avons pas d'autocomplétion pour le code graphql ni de coloration syntaxique.
- Si le schéma change, nous le savons uniquement à l'exécution. Nous devrions donc avoir des tests d'intégration pour vérifier que le code graphql est toujours valide avant de passer en production.

### [graphql-to-elm](https://package.elm-lang.org/packages/harmboschloo/graphql-to-elm/latest/)

Il s'agit d'un module Elm et d'un générateur de code. Il traduit un fichier graphql en un appel HTTP et un décodeur Json.Decode.

Il simplifie l'écriture du code mais ne fournit pas de
