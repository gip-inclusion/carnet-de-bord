-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module CdbGQL.Query exposing (..)

import CdbGQL.Enum.Account_info_select_column
import CdbGQL.Enum.Account_select_column
import CdbGQL.Enum.Action_status_select_column
import CdbGQL.Enum.Admin_cdb_select_column
import CdbGQL.Enum.Admin_structure_select_column
import CdbGQL.Enum.Admin_structure_structure_select_column
import CdbGQL.Enum.Beneficiary_select_column
import CdbGQL.Enum.Beneficiary_structure_select_column
import CdbGQL.Enum.Contract_type_select_column
import CdbGQL.Enum.Deployment_select_column
import CdbGQL.Enum.Employment_type_select_column
import CdbGQL.Enum.External_data_info_select_column
import CdbGQL.Enum.External_data_select_column
import CdbGQL.Enum.External_source_select_column
import CdbGQL.Enum.Manager_select_column
import CdbGQL.Enum.Notebook_action_select_column
import CdbGQL.Enum.Notebook_appointment_select_column
import CdbGQL.Enum.Notebook_event_select_column
import CdbGQL.Enum.Notebook_event_type_select_column
import CdbGQL.Enum.Notebook_focus_select_column
import CdbGQL.Enum.Notebook_info_select_column
import CdbGQL.Enum.Notebook_member_select_column
import CdbGQL.Enum.Notebook_public_view_select_column
import CdbGQL.Enum.Notebook_select_column
import CdbGQL.Enum.Notebook_situation_select_column
import CdbGQL.Enum.Notebook_target_select_column
import CdbGQL.Enum.Nps_rating_dismissal_select_column
import CdbGQL.Enum.Nps_rating_select_column
import CdbGQL.Enum.Orientation_manager_select_column
import CdbGQL.Enum.Orientation_request_select_column
import CdbGQL.Enum.Orientation_system_select_column
import CdbGQL.Enum.Orientation_type_select_column
import CdbGQL.Enum.Professional_orientation_system_select_column
import CdbGQL.Enum.Professional_project_select_column
import CdbGQL.Enum.Professional_select_column
import CdbGQL.Enum.Ref_action_select_column
import CdbGQL.Enum.Ref_situation_select_column
import CdbGQL.Enum.Ref_target_select_column
import CdbGQL.Enum.Ref_theme_select_column
import CdbGQL.Enum.Role_select_column
import CdbGQL.Enum.Rome_code_select_column
import CdbGQL.Enum.Rsa_closure_reason_select_column
import CdbGQL.Enum.Rsa_suspension_reason_select_column
import CdbGQL.Enum.Structure_orientation_system_select_column
import CdbGQL.Enum.Structure_select_column
import CdbGQL.InputObject
import CdbGQL.Interface
import CdbGQL.Object
import CdbGQL.Scalar
import CdbGQL.ScalarCodecs
import CdbGQL.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)


type alias AccountOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Account_select_column.Account_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Account_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Account_bool_exp
    }


{-| fetch data from the table: "account"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
account :
    (AccountOptionalArguments -> AccountOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Account
    -> SelectionSet (List decodesTo) RootQuery
account fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Account_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeAccount_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeAccount_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "account" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias AccountAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Account_select_column.Account_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Account_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Account_bool_exp
    }


{-| fetch aggregated fields from the table: "account"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
account_aggregate :
    (AccountAggregateOptionalArguments -> AccountAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Account_aggregate
    -> SelectionSet decodesTo RootQuery
account_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Account_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeAccount_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeAccount_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "account_aggregate" optionalArgs____ object____ Basics.identity


type alias AccountByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "account" using primary key columns
-}
account_by_pk :
    AccountByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Account
    -> SelectionSet (Maybe decodesTo) RootQuery
account_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "account_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias AccountInfoOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Account_info_select_column.Account_info_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Account_info_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Account_info_bool_exp
    }


{-| fetch data from the table: "account\_info"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
account_info :
    (AccountInfoOptionalArguments -> AccountInfoOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Account_info
    -> SelectionSet (List decodesTo) RootQuery
account_info fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Account_info_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeAccount_info_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeAccount_info_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "account_info" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias AccountInfoAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Account_info_select_column.Account_info_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Account_info_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Account_info_bool_exp
    }


{-| fetch aggregated fields from the table: "account\_info"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
account_info_aggregate :
    (AccountInfoAggregateOptionalArguments -> AccountInfoAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Account_info_aggregate
    -> SelectionSet decodesTo RootQuery
account_info_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Account_info_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeAccount_info_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeAccount_info_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "account_info_aggregate" optionalArgs____ object____ Basics.identity


type alias ActionStatusOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Action_status_select_column.Action_status_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Action_status_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Action_status_bool_exp
    }


{-| fetch data from the table: "action\_status"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
action_status :
    (ActionStatusOptionalArguments -> ActionStatusOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Action_status
    -> SelectionSet (List decodesTo) RootQuery
action_status fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Action_status_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeAction_status_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeAction_status_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "action_status" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias ActionStatusAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Action_status_select_column.Action_status_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Action_status_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Action_status_bool_exp
    }


{-| fetch aggregated fields from the table: "action\_status"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
action_status_aggregate :
    (ActionStatusAggregateOptionalArguments -> ActionStatusAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Action_status_aggregate
    -> SelectionSet decodesTo RootQuery
action_status_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Action_status_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeAction_status_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeAction_status_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "action_status_aggregate" optionalArgs____ object____ Basics.identity


type alias ActionStatusByPkRequiredArguments =
    { status : String }


{-| fetch data from the table: "action\_status" using primary key columns
-}
action_status_by_pk :
    ActionStatusByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Action_status
    -> SelectionSet (Maybe decodesTo) RootQuery
action_status_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "action_status_by_pk" [ Argument.required "status" requiredArgs____.status Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias AdminCdbOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Admin_cdb_select_column.Admin_cdb_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Admin_cdb_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Admin_cdb_bool_exp
    }


{-| fetch data from the table: "admin\_cdb"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
admin_cdb :
    (AdminCdbOptionalArguments -> AdminCdbOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Admin_cdb
    -> SelectionSet (List decodesTo) RootQuery
admin_cdb fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Admin_cdb_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeAdmin_cdb_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeAdmin_cdb_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "admin_cdb" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias AdminCdbAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Admin_cdb_select_column.Admin_cdb_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Admin_cdb_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Admin_cdb_bool_exp
    }


{-| fetch aggregated fields from the table: "admin\_cdb"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
admin_cdb_aggregate :
    (AdminCdbAggregateOptionalArguments -> AdminCdbAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Admin_cdb_aggregate
    -> SelectionSet decodesTo RootQuery
admin_cdb_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Admin_cdb_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeAdmin_cdb_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeAdmin_cdb_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "admin_cdb_aggregate" optionalArgs____ object____ Basics.identity


type alias AdminCdbByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "admin\_cdb" using primary key columns
-}
admin_cdb_by_pk :
    AdminCdbByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Admin_cdb
    -> SelectionSet (Maybe decodesTo) RootQuery
admin_cdb_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "admin_cdb_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias AdminStructureOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Admin_structure_select_column.Admin_structure_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Admin_structure_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Admin_structure_bool_exp
    }


{-| fetch data from the table: "admin\_structure"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
admin_structure :
    (AdminStructureOptionalArguments -> AdminStructureOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Admin_structure
    -> SelectionSet (List decodesTo) RootQuery
admin_structure fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Admin_structure_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeAdmin_structure_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeAdmin_structure_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "admin_structure" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias AdminStructureAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Admin_structure_select_column.Admin_structure_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Admin_structure_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Admin_structure_bool_exp
    }


{-| fetch aggregated fields from the table: "admin\_structure"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
admin_structure_aggregate :
    (AdminStructureAggregateOptionalArguments -> AdminStructureAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Admin_structure_aggregate
    -> SelectionSet decodesTo RootQuery
admin_structure_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Admin_structure_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeAdmin_structure_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeAdmin_structure_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "admin_structure_aggregate" optionalArgs____ object____ Basics.identity


type alias AdminStructureByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "admin\_structure" using primary key columns
-}
admin_structure_by_pk :
    AdminStructureByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Admin_structure
    -> SelectionSet (Maybe decodesTo) RootQuery
admin_structure_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "admin_structure_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias AdminStructureStructureOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Admin_structure_structure_select_column.Admin_structure_structure_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Admin_structure_structure_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Admin_structure_structure_bool_exp
    }


{-| fetch data from the table: "admin\_structure\_structure"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
admin_structure_structure :
    (AdminStructureStructureOptionalArguments -> AdminStructureStructureOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Admin_structure_structure
    -> SelectionSet (List decodesTo) RootQuery
admin_structure_structure fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Admin_structure_structure_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeAdmin_structure_structure_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeAdmin_structure_structure_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "admin_structure_structure" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias AdminStructureStructureAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Admin_structure_structure_select_column.Admin_structure_structure_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Admin_structure_structure_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Admin_structure_structure_bool_exp
    }


{-| fetch aggregated fields from the table: "admin\_structure\_structure"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
admin_structure_structure_aggregate :
    (AdminStructureStructureAggregateOptionalArguments -> AdminStructureStructureAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Admin_structure_structure_aggregate
    -> SelectionSet decodesTo RootQuery
admin_structure_structure_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Admin_structure_structure_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeAdmin_structure_structure_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeAdmin_structure_structure_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "admin_structure_structure_aggregate" optionalArgs____ object____ Basics.identity


type alias AdminStructureStructureByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "admin\_structure\_structure" using primary key columns
-}
admin_structure_structure_by_pk :
    AdminStructureStructureByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Admin_structure_structure
    -> SelectionSet (Maybe decodesTo) RootQuery
admin_structure_structure_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "admin_structure_structure_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias BeneficiaryOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Beneficiary_select_column.Beneficiary_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Beneficiary_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Beneficiary_bool_exp
    }


{-| fetch data from the table: "beneficiary"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
beneficiary :
    (BeneficiaryOptionalArguments -> BeneficiaryOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary
    -> SelectionSet (List decodesTo) RootQuery
beneficiary fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Beneficiary_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeBeneficiary_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeBeneficiary_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "beneficiary" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias BeneficiaryAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Beneficiary_select_column.Beneficiary_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Beneficiary_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Beneficiary_bool_exp
    }


{-| fetch aggregated fields from the table: "beneficiary"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
beneficiary_aggregate :
    (BeneficiaryAggregateOptionalArguments -> BeneficiaryAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary_aggregate
    -> SelectionSet decodesTo RootQuery
beneficiary_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Beneficiary_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeBeneficiary_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeBeneficiary_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "beneficiary_aggregate" optionalArgs____ object____ Basics.identity


type alias BeneficiaryByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "beneficiary" using primary key columns
-}
beneficiary_by_pk :
    BeneficiaryByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary
    -> SelectionSet (Maybe decodesTo) RootQuery
beneficiary_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "beneficiary_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias BeneficiaryStructureOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Beneficiary_structure_select_column.Beneficiary_structure_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Beneficiary_structure_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Beneficiary_structure_bool_exp
    }


{-| fetch data from the table: "beneficiary\_structure"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
beneficiary_structure :
    (BeneficiaryStructureOptionalArguments -> BeneficiaryStructureOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary_structure
    -> SelectionSet (List decodesTo) RootQuery
beneficiary_structure fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Beneficiary_structure_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeBeneficiary_structure_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeBeneficiary_structure_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "beneficiary_structure" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias BeneficiaryStructureAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Beneficiary_structure_select_column.Beneficiary_structure_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Beneficiary_structure_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Beneficiary_structure_bool_exp
    }


{-| fetch aggregated fields from the table: "beneficiary\_structure"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
beneficiary_structure_aggregate :
    (BeneficiaryStructureAggregateOptionalArguments -> BeneficiaryStructureAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary_structure_aggregate
    -> SelectionSet decodesTo RootQuery
beneficiary_structure_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Beneficiary_structure_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeBeneficiary_structure_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeBeneficiary_structure_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "beneficiary_structure_aggregate" optionalArgs____ object____ Basics.identity


type alias BeneficiaryStructureByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "beneficiary\_structure" using primary key columns
-}
beneficiary_structure_by_pk :
    BeneficiaryStructureByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary_structure
    -> SelectionSet (Maybe decodesTo) RootQuery
beneficiary_structure_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "beneficiary_structure_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias ContractTypeOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Contract_type_select_column.Contract_type_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Contract_type_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Contract_type_bool_exp
    }


{-| fetch data from the table: "contract\_type"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
contract_type :
    (ContractTypeOptionalArguments -> ContractTypeOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Contract_type
    -> SelectionSet (List decodesTo) RootQuery
contract_type fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Contract_type_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeContract_type_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeContract_type_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "contract_type" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias ContractTypeAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Contract_type_select_column.Contract_type_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Contract_type_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Contract_type_bool_exp
    }


{-| fetch aggregated fields from the table: "contract\_type"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
contract_type_aggregate :
    (ContractTypeAggregateOptionalArguments -> ContractTypeAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Contract_type_aggregate
    -> SelectionSet decodesTo RootQuery
contract_type_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Contract_type_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeContract_type_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeContract_type_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "contract_type_aggregate" optionalArgs____ object____ Basics.identity


type alias ContractTypeByPkRequiredArguments =
    { id : String }


{-| fetch data from the table: "contract\_type" using primary key columns
-}
contract_type_by_pk :
    ContractTypeByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Contract_type
    -> SelectionSet (Maybe decodesTo) RootQuery
contract_type_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "contract_type_by_pk" [ Argument.required "id" requiredArgs____.id Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias DeploymentOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Deployment_select_column.Deployment_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Deployment_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Deployment_bool_exp
    }


{-| fetch data from the table: "deployment"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
deployment :
    (DeploymentOptionalArguments -> DeploymentOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Deployment
    -> SelectionSet (List decodesTo) RootQuery
deployment fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Deployment_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeDeployment_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeDeployment_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "deployment" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias DeploymentAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Deployment_select_column.Deployment_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Deployment_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Deployment_bool_exp
    }


{-| fetch aggregated fields from the table: "deployment"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
deployment_aggregate :
    (DeploymentAggregateOptionalArguments -> DeploymentAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Deployment_aggregate
    -> SelectionSet decodesTo RootQuery
deployment_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Deployment_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeDeployment_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeDeployment_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "deployment_aggregate" optionalArgs____ object____ Basics.identity


type alias DeploymentByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "deployment" using primary key columns
-}
deployment_by_pk :
    DeploymentByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Deployment
    -> SelectionSet (Maybe decodesTo) RootQuery
deployment_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "deployment_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias EmploymentTypeOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Employment_type_select_column.Employment_type_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Employment_type_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Employment_type_bool_exp
    }


{-| fetch data from the table: "employment\_type"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
employment_type :
    (EmploymentTypeOptionalArguments -> EmploymentTypeOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Employment_type
    -> SelectionSet (List decodesTo) RootQuery
employment_type fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Employment_type_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeEmployment_type_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeEmployment_type_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "employment_type" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias EmploymentTypeAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Employment_type_select_column.Employment_type_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Employment_type_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Employment_type_bool_exp
    }


{-| fetch aggregated fields from the table: "employment\_type"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
employment_type_aggregate :
    (EmploymentTypeAggregateOptionalArguments -> EmploymentTypeAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Employment_type_aggregate
    -> SelectionSet decodesTo RootQuery
employment_type_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Employment_type_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeEmployment_type_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeEmployment_type_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "employment_type_aggregate" optionalArgs____ object____ Basics.identity


type alias EmploymentTypeByPkRequiredArguments =
    { id : String }


{-| fetch data from the table: "employment\_type" using primary key columns
-}
employment_type_by_pk :
    EmploymentTypeByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Employment_type
    -> SelectionSet (Maybe decodesTo) RootQuery
employment_type_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "employment_type_by_pk" [ Argument.required "id" requiredArgs____.id Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias ExternalDataOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.External_data_select_column.External_data_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.External_data_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.External_data_bool_exp
    }


{-| An array relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
external_data :
    (ExternalDataOptionalArguments -> ExternalDataOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.External_data
    -> SelectionSet (List decodesTo) RootQuery
external_data fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.External_data_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeExternal_data_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeExternal_data_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "external_data" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias ExternalDataAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.External_data_select_column.External_data_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.External_data_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.External_data_bool_exp
    }


{-| An aggregate relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
external_data_aggregate :
    (ExternalDataAggregateOptionalArguments -> ExternalDataAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.External_data_aggregate
    -> SelectionSet decodesTo RootQuery
external_data_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.External_data_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeExternal_data_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeExternal_data_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "external_data_aggregate" optionalArgs____ object____ Basics.identity


type alias ExternalDataByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "external\_data" using primary key columns
-}
external_data_by_pk :
    ExternalDataByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.External_data
    -> SelectionSet (Maybe decodesTo) RootQuery
external_data_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "external_data_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias ExternalDataInfoOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.External_data_info_select_column.External_data_info_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.External_data_info_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.External_data_info_bool_exp
    }


{-| fetch data from the table: "external\_data\_info"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
external_data_info :
    (ExternalDataInfoOptionalArguments -> ExternalDataInfoOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.External_data_info
    -> SelectionSet (List decodesTo) RootQuery
external_data_info fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.External_data_info_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeExternal_data_info_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeExternal_data_info_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "external_data_info" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias ExternalDataInfoAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.External_data_info_select_column.External_data_info_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.External_data_info_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.External_data_info_bool_exp
    }


{-| fetch aggregated fields from the table: "external\_data\_info"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
external_data_info_aggregate :
    (ExternalDataInfoAggregateOptionalArguments -> ExternalDataInfoAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.External_data_info_aggregate
    -> SelectionSet decodesTo RootQuery
external_data_info_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.External_data_info_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeExternal_data_info_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeExternal_data_info_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "external_data_info_aggregate" optionalArgs____ object____ Basics.identity


type alias ExternalDataInfoByPkRequiredArguments =
    { external_data_id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "external\_data\_info" using primary key columns
-}
external_data_info_by_pk :
    ExternalDataInfoByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.External_data_info
    -> SelectionSet (Maybe decodesTo) RootQuery
external_data_info_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "external_data_info_by_pk" [ Argument.required "external_data_id" requiredArgs____.external_data_id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias ExternalSourceOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.External_source_select_column.External_source_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.External_source_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.External_source_bool_exp
    }


{-| fetch data from the table: "external\_source"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
external_source :
    (ExternalSourceOptionalArguments -> ExternalSourceOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.External_source
    -> SelectionSet (List decodesTo) RootQuery
external_source fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.External_source_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeExternal_source_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeExternal_source_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "external_source" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias ExternalSourceAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.External_source_select_column.External_source_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.External_source_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.External_source_bool_exp
    }


{-| fetch aggregated fields from the table: "external\_source"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
external_source_aggregate :
    (ExternalSourceAggregateOptionalArguments -> ExternalSourceAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.External_source_aggregate
    -> SelectionSet decodesTo RootQuery
external_source_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.External_source_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeExternal_source_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeExternal_source_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "external_source_aggregate" optionalArgs____ object____ Basics.identity


type alias ExternalSourceByPkRequiredArguments =
    { value : String }


{-| fetch data from the table: "external\_source" using primary key columns
-}
external_source_by_pk :
    ExternalSourceByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.External_source
    -> SelectionSet (Maybe decodesTo) RootQuery
external_source_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "external_source_by_pk" [ Argument.required "value" requiredArgs____.value Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias GetBeneficiariesFromNirOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Beneficiary_select_column.Beneficiary_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Beneficiary_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Beneficiary_bool_exp
    }


type alias GetBeneficiariesFromNirRequiredArguments =
    { args : CdbGQL.InputObject.Get_beneficiaries_from_nir_args }


{-| execute function "get\_beneficiaries\_from\_nir" which returns "beneficiary"

  - args - input parameters for function "get\_beneficiaries\_from\_nir"
  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
get_beneficiaries_from_nir :
    (GetBeneficiariesFromNirOptionalArguments -> GetBeneficiariesFromNirOptionalArguments)
    -> GetBeneficiariesFromNirRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary
    -> SelectionSet (List decodesTo) RootQuery
get_beneficiaries_from_nir fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Beneficiary_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeBeneficiary_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeBeneficiary_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "get_beneficiaries_from_nir" (optionalArgs____ ++ [ Argument.required "args" requiredArgs____.args CdbGQL.InputObject.encodeGet_beneficiaries_from_nir_args ]) object____ (Basics.identity >> Decode.list)


type alias GetBeneficiariesFromNirAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Beneficiary_select_column.Beneficiary_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Beneficiary_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Beneficiary_bool_exp
    }


type alias GetBeneficiariesFromNirAggregateRequiredArguments =
    { args : CdbGQL.InputObject.Get_beneficiaries_from_nir_args }


{-| execute function "get\_beneficiaries\_from\_nir" and query aggregates on result of table type "beneficiary"

  - args - input parameters for function "get\_beneficiaries\_from\_nir\_aggregate"
  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
get_beneficiaries_from_nir_aggregate :
    (GetBeneficiariesFromNirAggregateOptionalArguments -> GetBeneficiariesFromNirAggregateOptionalArguments)
    -> GetBeneficiariesFromNirAggregateRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary_aggregate
    -> SelectionSet decodesTo RootQuery
get_beneficiaries_from_nir_aggregate fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Beneficiary_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeBeneficiary_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeBeneficiary_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "get_beneficiaries_from_nir_aggregate" (optionalArgs____ ++ [ Argument.required "args" requiredArgs____.args CdbGQL.InputObject.encodeGet_beneficiaries_from_nir_args ]) object____ Basics.identity


type alias ManagerOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Manager_select_column.Manager_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Manager_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Manager_bool_exp
    }


{-| fetch data from the table: "manager"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
manager :
    (ManagerOptionalArguments -> ManagerOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Manager
    -> SelectionSet (List decodesTo) RootQuery
manager fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Manager_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeManager_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeManager_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "manager" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias ManagerAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Manager_select_column.Manager_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Manager_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Manager_bool_exp
    }


{-| fetch aggregated fields from the table: "manager"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
manager_aggregate :
    (ManagerAggregateOptionalArguments -> ManagerAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Manager_aggregate
    -> SelectionSet decodesTo RootQuery
manager_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Manager_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeManager_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeManager_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "manager_aggregate" optionalArgs____ object____ Basics.identity


type alias ManagerByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "manager" using primary key columns
-}
manager_by_pk :
    ManagerByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Manager
    -> SelectionSet (Maybe decodesTo) RootQuery
manager_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "manager_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias NotebookOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_select_column.Notebook_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_bool_exp
    }


{-| fetch data from the table: "notebook"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook :
    (NotebookOptionalArguments -> NotebookOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook
    -> SelectionSet (List decodesTo) RootQuery
notebook fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias NotebookActionOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_action_select_column.Notebook_action_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_action_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_action_bool_exp
    }


{-| fetch data from the table: "notebook\_action"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_action :
    (NotebookActionOptionalArguments -> NotebookActionOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_action
    -> SelectionSet (List decodesTo) RootQuery
notebook_action fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_action_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_action_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_action_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_action" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias NotebookActionAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_action_select_column.Notebook_action_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_action_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_action_bool_exp
    }


{-| fetch aggregated fields from the table: "notebook\_action"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_action_aggregate :
    (NotebookActionAggregateOptionalArguments -> NotebookActionAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_action_aggregate
    -> SelectionSet decodesTo RootQuery
notebook_action_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_action_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_action_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_action_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_action_aggregate" optionalArgs____ object____ Basics.identity


type alias NotebookActionByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "notebook\_action" using primary key columns
-}
notebook_action_by_pk :
    NotebookActionByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_action
    -> SelectionSet (Maybe decodesTo) RootQuery
notebook_action_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "notebook_action_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias NotebookAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_select_column.Notebook_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_bool_exp
    }


{-| fetch aggregated fields from the table: "notebook"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_aggregate :
    (NotebookAggregateOptionalArguments -> NotebookAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_aggregate
    -> SelectionSet decodesTo RootQuery
notebook_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_aggregate" optionalArgs____ object____ Basics.identity


type alias NotebookAppointmentOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_appointment_select_column.Notebook_appointment_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_appointment_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_appointment_bool_exp
    }


{-| fetch data from the table: "notebook\_appointment"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_appointment :
    (NotebookAppointmentOptionalArguments -> NotebookAppointmentOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_appointment
    -> SelectionSet (List decodesTo) RootQuery
notebook_appointment fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_appointment_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_appointment_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_appointment_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_appointment" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias NotebookAppointmentAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_appointment_select_column.Notebook_appointment_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_appointment_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_appointment_bool_exp
    }


{-| fetch aggregated fields from the table: "notebook\_appointment"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_appointment_aggregate :
    (NotebookAppointmentAggregateOptionalArguments -> NotebookAppointmentAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_appointment_aggregate
    -> SelectionSet decodesTo RootQuery
notebook_appointment_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_appointment_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_appointment_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_appointment_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_appointment_aggregate" optionalArgs____ object____ Basics.identity


type alias NotebookAppointmentByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "notebook\_appointment" using primary key columns
-}
notebook_appointment_by_pk :
    NotebookAppointmentByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_appointment
    -> SelectionSet (Maybe decodesTo) RootQuery
notebook_appointment_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "notebook_appointment_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias NotebookByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "notebook" using primary key columns
-}
notebook_by_pk :
    NotebookByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook
    -> SelectionSet (Maybe decodesTo) RootQuery
notebook_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "notebook_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias NotebookEventOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_event_select_column.Notebook_event_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_event_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_event_bool_exp
    }


{-| fetch data from the table: "notebook\_event"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_event :
    (NotebookEventOptionalArguments -> NotebookEventOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_event
    -> SelectionSet (List decodesTo) RootQuery
notebook_event fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_event_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_event_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_event_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_event" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias NotebookEventAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_event_select_column.Notebook_event_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_event_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_event_bool_exp
    }


{-| fetch aggregated fields from the table: "notebook\_event"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_event_aggregate :
    (NotebookEventAggregateOptionalArguments -> NotebookEventAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_event_aggregate
    -> SelectionSet decodesTo RootQuery
notebook_event_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_event_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_event_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_event_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_event_aggregate" optionalArgs____ object____ Basics.identity


type alias NotebookEventByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "notebook\_event" using primary key columns
-}
notebook_event_by_pk :
    NotebookEventByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_event
    -> SelectionSet (Maybe decodesTo) RootQuery
notebook_event_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "notebook_event_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias NotebookEventTypeOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_event_type_select_column.Notebook_event_type_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_event_type_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_event_type_bool_exp
    }


{-| fetch data from the table: "notebook\_event\_type"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_event_type :
    (NotebookEventTypeOptionalArguments -> NotebookEventTypeOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_event_type
    -> SelectionSet (List decodesTo) RootQuery
notebook_event_type fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_event_type_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_event_type_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_event_type_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_event_type" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias NotebookEventTypeAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_event_type_select_column.Notebook_event_type_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_event_type_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_event_type_bool_exp
    }


{-| fetch aggregated fields from the table: "notebook\_event\_type"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_event_type_aggregate :
    (NotebookEventTypeAggregateOptionalArguments -> NotebookEventTypeAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_event_type_aggregate
    -> SelectionSet decodesTo RootQuery
notebook_event_type_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_event_type_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_event_type_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_event_type_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_event_type_aggregate" optionalArgs____ object____ Basics.identity


type alias NotebookEventTypeByPkRequiredArguments =
    { value : String }


{-| fetch data from the table: "notebook\_event\_type" using primary key columns
-}
notebook_event_type_by_pk :
    NotebookEventTypeByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_event_type
    -> SelectionSet (Maybe decodesTo) RootQuery
notebook_event_type_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "notebook_event_type_by_pk" [ Argument.required "value" requiredArgs____.value Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias NotebookFocusOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_focus_select_column.Notebook_focus_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_focus_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_focus_bool_exp
    }


{-| fetch data from the table: "notebook\_focus"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_focus :
    (NotebookFocusOptionalArguments -> NotebookFocusOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_focus
    -> SelectionSet (List decodesTo) RootQuery
notebook_focus fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_focus_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_focus_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_focus_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_focus" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias NotebookFocusAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_focus_select_column.Notebook_focus_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_focus_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_focus_bool_exp
    }


{-| fetch aggregated fields from the table: "notebook\_focus"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_focus_aggregate :
    (NotebookFocusAggregateOptionalArguments -> NotebookFocusAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_focus_aggregate
    -> SelectionSet decodesTo RootQuery
notebook_focus_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_focus_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_focus_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_focus_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_focus_aggregate" optionalArgs____ object____ Basics.identity


type alias NotebookFocusByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "notebook\_focus" using primary key columns
-}
notebook_focus_by_pk :
    NotebookFocusByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_focus
    -> SelectionSet (Maybe decodesTo) RootQuery
notebook_focus_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "notebook_focus_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias NotebookInfoOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_info_select_column.Notebook_info_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_info_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_info_bool_exp
    }


{-| fetch data from the table: "notebook\_info"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_info :
    (NotebookInfoOptionalArguments -> NotebookInfoOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_info
    -> SelectionSet (List decodesTo) RootQuery
notebook_info fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_info_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_info_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_info_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_info" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias NotebookInfoAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_info_select_column.Notebook_info_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_info_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_info_bool_exp
    }


{-| fetch aggregated fields from the table: "notebook\_info"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_info_aggregate :
    (NotebookInfoAggregateOptionalArguments -> NotebookInfoAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_info_aggregate
    -> SelectionSet decodesTo RootQuery
notebook_info_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_info_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_info_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_info_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_info_aggregate" optionalArgs____ object____ Basics.identity


type alias NotebookInfoByPkRequiredArguments =
    { notebookId : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "notebook\_info" using primary key columns
-}
notebook_info_by_pk :
    NotebookInfoByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_info
    -> SelectionSet (Maybe decodesTo) RootQuery
notebook_info_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "notebook_info_by_pk" [ Argument.required "notebookId" requiredArgs____.notebookId (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias NotebookMemberOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_member_select_column.Notebook_member_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_member_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_member_bool_exp
    }


{-| fetch data from the table: "notebook\_member"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_member :
    (NotebookMemberOptionalArguments -> NotebookMemberOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_member
    -> SelectionSet (List decodesTo) RootQuery
notebook_member fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_member_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_member_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_member_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_member" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias NotebookMemberAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_member_select_column.Notebook_member_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_member_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_member_bool_exp
    }


{-| fetch aggregated fields from the table: "notebook\_member"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_member_aggregate :
    (NotebookMemberAggregateOptionalArguments -> NotebookMemberAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_member_aggregate
    -> SelectionSet decodesTo RootQuery
notebook_member_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_member_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_member_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_member_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_member_aggregate" optionalArgs____ object____ Basics.identity


type alias NotebookMemberByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "notebook\_member" using primary key columns
-}
notebook_member_by_pk :
    NotebookMemberByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_member
    -> SelectionSet (Maybe decodesTo) RootQuery
notebook_member_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "notebook_member_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias NotebookPublicViewOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_public_view_select_column.Notebook_public_view_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_public_view_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_public_view_bool_exp
    }


{-| fetch data from the table: "notebook\_public\_view"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_public_view :
    (NotebookPublicViewOptionalArguments -> NotebookPublicViewOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_public_view
    -> SelectionSet (List decodesTo) RootQuery
notebook_public_view fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_public_view_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_public_view_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_public_view_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_public_view" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias NotebookPublicViewAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_public_view_select_column.Notebook_public_view_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_public_view_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_public_view_bool_exp
    }


{-| fetch aggregated fields from the table: "notebook\_public\_view"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_public_view_aggregate :
    (NotebookPublicViewAggregateOptionalArguments -> NotebookPublicViewAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_public_view_aggregate
    -> SelectionSet decodesTo RootQuery
notebook_public_view_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_public_view_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_public_view_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_public_view_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_public_view_aggregate" optionalArgs____ object____ Basics.identity


type alias NotebookSituationOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_situation_select_column.Notebook_situation_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_situation_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_situation_bool_exp
    }


{-| fetch data from the table: "notebook\_situation"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_situation :
    (NotebookSituationOptionalArguments -> NotebookSituationOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_situation
    -> SelectionSet (List decodesTo) RootQuery
notebook_situation fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_situation_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_situation_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_situation_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_situation" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias NotebookSituationAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_situation_select_column.Notebook_situation_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_situation_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_situation_bool_exp
    }


{-| fetch aggregated fields from the table: "notebook\_situation"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_situation_aggregate :
    (NotebookSituationAggregateOptionalArguments -> NotebookSituationAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_situation_aggregate
    -> SelectionSet decodesTo RootQuery
notebook_situation_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_situation_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_situation_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_situation_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_situation_aggregate" optionalArgs____ object____ Basics.identity


type alias NotebookSituationByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "notebook\_situation" using primary key columns
-}
notebook_situation_by_pk :
    NotebookSituationByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_situation
    -> SelectionSet (Maybe decodesTo) RootQuery
notebook_situation_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "notebook_situation_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias NotebookTargetOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_target_select_column.Notebook_target_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_target_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_target_bool_exp
    }


{-| fetch data from the table: "notebook\_target"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_target :
    (NotebookTargetOptionalArguments -> NotebookTargetOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_target
    -> SelectionSet (List decodesTo) RootQuery
notebook_target fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_target_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_target_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_target_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_target" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias NotebookTargetAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_target_select_column.Notebook_target_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_target_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_target_bool_exp
    }


{-| fetch aggregated fields from the table: "notebook\_target"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_target_aggregate :
    (NotebookTargetAggregateOptionalArguments -> NotebookTargetAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_target_aggregate
    -> SelectionSet decodesTo RootQuery
notebook_target_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_target_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_target_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_target_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_target_aggregate" optionalArgs____ object____ Basics.identity


type alias NotebookTargetByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "notebook\_target" using primary key columns
-}
notebook_target_by_pk :
    NotebookTargetByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_target
    -> SelectionSet (Maybe decodesTo) RootQuery
notebook_target_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "notebook_target_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias NpsRatingOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Nps_rating_select_column.Nps_rating_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Nps_rating_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Nps_rating_bool_exp
    }


{-| fetch data from the table: "nps\_rating"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
nps_rating :
    (NpsRatingOptionalArguments -> NpsRatingOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Nps_rating
    -> SelectionSet (List decodesTo) RootQuery
nps_rating fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Nps_rating_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNps_rating_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNps_rating_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "nps_rating" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias NpsRatingAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Nps_rating_select_column.Nps_rating_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Nps_rating_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Nps_rating_bool_exp
    }


{-| fetch aggregated fields from the table: "nps\_rating"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
nps_rating_aggregate :
    (NpsRatingAggregateOptionalArguments -> NpsRatingAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Nps_rating_aggregate
    -> SelectionSet decodesTo RootQuery
nps_rating_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Nps_rating_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNps_rating_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNps_rating_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "nps_rating_aggregate" optionalArgs____ object____ Basics.identity


type alias NpsRatingByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "nps\_rating" using primary key columns
-}
nps_rating_by_pk :
    NpsRatingByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Nps_rating
    -> SelectionSet (Maybe decodesTo) RootQuery
nps_rating_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "nps_rating_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias NpsRatingDismissalOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Nps_rating_dismissal_select_column.Nps_rating_dismissal_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Nps_rating_dismissal_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Nps_rating_dismissal_bool_exp
    }


{-| fetch data from the table: "nps\_rating\_dismissal"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
nps_rating_dismissal :
    (NpsRatingDismissalOptionalArguments -> NpsRatingDismissalOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Nps_rating_dismissal
    -> SelectionSet (List decodesTo) RootQuery
nps_rating_dismissal fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Nps_rating_dismissal_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNps_rating_dismissal_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNps_rating_dismissal_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "nps_rating_dismissal" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias NpsRatingDismissalAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Nps_rating_dismissal_select_column.Nps_rating_dismissal_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Nps_rating_dismissal_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Nps_rating_dismissal_bool_exp
    }


{-| fetch aggregated fields from the table: "nps\_rating\_dismissal"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
nps_rating_dismissal_aggregate :
    (NpsRatingDismissalAggregateOptionalArguments -> NpsRatingDismissalAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Nps_rating_dismissal_aggregate
    -> SelectionSet decodesTo RootQuery
nps_rating_dismissal_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Nps_rating_dismissal_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNps_rating_dismissal_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNps_rating_dismissal_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "nps_rating_dismissal_aggregate" optionalArgs____ object____ Basics.identity


type alias NpsRatingDismissalByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "nps\_rating\_dismissal" using primary key columns
-}
nps_rating_dismissal_by_pk :
    NpsRatingDismissalByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Nps_rating_dismissal
    -> SelectionSet (Maybe decodesTo) RootQuery
nps_rating_dismissal_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "nps_rating_dismissal_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias OrientationManagerOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Orientation_manager_select_column.Orientation_manager_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Orientation_manager_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Orientation_manager_bool_exp
    }


{-| fetch data from the table: "orientation\_manager"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
orientation_manager :
    (OrientationManagerOptionalArguments -> OrientationManagerOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_manager
    -> SelectionSet (List decodesTo) RootQuery
orientation_manager fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Orientation_manager_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeOrientation_manager_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeOrientation_manager_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "orientation_manager" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias OrientationManagerAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Orientation_manager_select_column.Orientation_manager_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Orientation_manager_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Orientation_manager_bool_exp
    }


{-| fetch aggregated fields from the table: "orientation\_manager"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
orientation_manager_aggregate :
    (OrientationManagerAggregateOptionalArguments -> OrientationManagerAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_manager_aggregate
    -> SelectionSet decodesTo RootQuery
orientation_manager_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Orientation_manager_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeOrientation_manager_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeOrientation_manager_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "orientation_manager_aggregate" optionalArgs____ object____ Basics.identity


type alias OrientationManagerByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "orientation\_manager" using primary key columns
-}
orientation_manager_by_pk :
    OrientationManagerByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_manager
    -> SelectionSet (Maybe decodesTo) RootQuery
orientation_manager_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "orientation_manager_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias OrientationRequestOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Orientation_request_select_column.Orientation_request_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Orientation_request_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Orientation_request_bool_exp
    }


{-| fetch data from the table: "orientation\_request"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
orientation_request :
    (OrientationRequestOptionalArguments -> OrientationRequestOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_request
    -> SelectionSet (List decodesTo) RootQuery
orientation_request fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Orientation_request_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeOrientation_request_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeOrientation_request_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "orientation_request" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias OrientationRequestAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Orientation_request_select_column.Orientation_request_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Orientation_request_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Orientation_request_bool_exp
    }


{-| fetch aggregated fields from the table: "orientation\_request"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
orientation_request_aggregate :
    (OrientationRequestAggregateOptionalArguments -> OrientationRequestAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_request_aggregate
    -> SelectionSet decodesTo RootQuery
orientation_request_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Orientation_request_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeOrientation_request_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeOrientation_request_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "orientation_request_aggregate" optionalArgs____ object____ Basics.identity


type alias OrientationRequestByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "orientation\_request" using primary key columns
-}
orientation_request_by_pk :
    OrientationRequestByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_request
    -> SelectionSet (Maybe decodesTo) RootQuery
orientation_request_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "orientation_request_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias OrientationSystemOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Orientation_system_select_column.Orientation_system_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Orientation_system_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Orientation_system_bool_exp
    }


{-| fetch data from the table: "orientation\_system"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
orientation_system :
    (OrientationSystemOptionalArguments -> OrientationSystemOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_system
    -> SelectionSet (List decodesTo) RootQuery
orientation_system fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Orientation_system_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeOrientation_system_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeOrientation_system_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "orientation_system" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias OrientationSystemAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Orientation_system_select_column.Orientation_system_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Orientation_system_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Orientation_system_bool_exp
    }


{-| fetch aggregated fields from the table: "orientation\_system"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
orientation_system_aggregate :
    (OrientationSystemAggregateOptionalArguments -> OrientationSystemAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_system_aggregate
    -> SelectionSet decodesTo RootQuery
orientation_system_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Orientation_system_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeOrientation_system_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeOrientation_system_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "orientation_system_aggregate" optionalArgs____ object____ Basics.identity


type alias OrientationSystemByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "orientation\_system" using primary key columns
-}
orientation_system_by_pk :
    OrientationSystemByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_system
    -> SelectionSet (Maybe decodesTo) RootQuery
orientation_system_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "orientation_system_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias OrientationTypeOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Orientation_type_select_column.Orientation_type_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Orientation_type_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Orientation_type_bool_exp
    }


{-| fetch data from the table: "orientation\_type"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
orientation_type :
    (OrientationTypeOptionalArguments -> OrientationTypeOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_type
    -> SelectionSet (List decodesTo) RootQuery
orientation_type fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Orientation_type_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeOrientation_type_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeOrientation_type_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "orientation_type" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias OrientationTypeAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Orientation_type_select_column.Orientation_type_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Orientation_type_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Orientation_type_bool_exp
    }


{-| fetch aggregated fields from the table: "orientation\_type"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
orientation_type_aggregate :
    (OrientationTypeAggregateOptionalArguments -> OrientationTypeAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_type_aggregate
    -> SelectionSet decodesTo RootQuery
orientation_type_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Orientation_type_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeOrientation_type_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeOrientation_type_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "orientation_type_aggregate" optionalArgs____ object____ Basics.identity


type alias OrientationTypeByPkRequiredArguments =
    { id : String }


{-| fetch data from the table: "orientation\_type" using primary key columns
-}
orientation_type_by_pk :
    OrientationTypeByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_type
    -> SelectionSet (Maybe decodesTo) RootQuery
orientation_type_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "orientation_type_by_pk" [ Argument.required "id" requiredArgs____.id Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias ProfessionalOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Professional_select_column.Professional_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Professional_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Professional_bool_exp
    }


{-| fetch data from the table: "professional"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
professional :
    (ProfessionalOptionalArguments -> ProfessionalOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Professional
    -> SelectionSet (List decodesTo) RootQuery
professional fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Professional_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeProfessional_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeProfessional_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "professional" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias ProfessionalAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Professional_select_column.Professional_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Professional_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Professional_bool_exp
    }


{-| fetch aggregated fields from the table: "professional"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
professional_aggregate :
    (ProfessionalAggregateOptionalArguments -> ProfessionalAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Professional_aggregate
    -> SelectionSet decodesTo RootQuery
professional_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Professional_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeProfessional_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeProfessional_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "professional_aggregate" optionalArgs____ object____ Basics.identity


type alias ProfessionalByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "professional" using primary key columns
-}
professional_by_pk :
    ProfessionalByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Professional
    -> SelectionSet (Maybe decodesTo) RootQuery
professional_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "professional_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias ProfessionalOrientationSystemOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Professional_orientation_system_select_column.Professional_orientation_system_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Professional_orientation_system_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Professional_orientation_system_bool_exp
    }


{-| fetch data from the table: "professional\_orientation\_system"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
professional_orientation_system :
    (ProfessionalOrientationSystemOptionalArguments -> ProfessionalOrientationSystemOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Professional_orientation_system
    -> SelectionSet (List decodesTo) RootQuery
professional_orientation_system fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Professional_orientation_system_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeProfessional_orientation_system_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeProfessional_orientation_system_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "professional_orientation_system" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias ProfessionalOrientationSystemAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Professional_orientation_system_select_column.Professional_orientation_system_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Professional_orientation_system_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Professional_orientation_system_bool_exp
    }


{-| fetch aggregated fields from the table: "professional\_orientation\_system"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
professional_orientation_system_aggregate :
    (ProfessionalOrientationSystemAggregateOptionalArguments -> ProfessionalOrientationSystemAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Professional_orientation_system_aggregate
    -> SelectionSet decodesTo RootQuery
professional_orientation_system_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Professional_orientation_system_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeProfessional_orientation_system_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeProfessional_orientation_system_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "professional_orientation_system_aggregate" optionalArgs____ object____ Basics.identity


type alias ProfessionalOrientationSystemByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "professional\_orientation\_system" using primary key columns
-}
professional_orientation_system_by_pk :
    ProfessionalOrientationSystemByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Professional_orientation_system
    -> SelectionSet (Maybe decodesTo) RootQuery
professional_orientation_system_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "professional_orientation_system_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias ProfessionalProjectOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Professional_project_select_column.Professional_project_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Professional_project_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Professional_project_bool_exp
    }


{-| fetch data from the table: "professional\_project"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
professional_project :
    (ProfessionalProjectOptionalArguments -> ProfessionalProjectOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Professional_project
    -> SelectionSet (List decodesTo) RootQuery
professional_project fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Professional_project_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeProfessional_project_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeProfessional_project_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "professional_project" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias ProfessionalProjectAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Professional_project_select_column.Professional_project_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Professional_project_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Professional_project_bool_exp
    }


{-| fetch aggregated fields from the table: "professional\_project"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
professional_project_aggregate :
    (ProfessionalProjectAggregateOptionalArguments -> ProfessionalProjectAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Professional_project_aggregate
    -> SelectionSet decodesTo RootQuery
professional_project_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Professional_project_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeProfessional_project_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeProfessional_project_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "professional_project_aggregate" optionalArgs____ object____ Basics.identity


type alias ProfessionalProjectByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "professional\_project" using primary key columns
-}
professional_project_by_pk :
    ProfessionalProjectByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Professional_project
    -> SelectionSet (Maybe decodesTo) RootQuery
professional_project_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "professional_project_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias RefActionOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Ref_action_select_column.Ref_action_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Ref_action_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Ref_action_bool_exp
    }


{-| fetch data from the table: "ref\_action"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
ref_action :
    (RefActionOptionalArguments -> RefActionOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Ref_action
    -> SelectionSet (List decodesTo) RootQuery
ref_action fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Ref_action_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRef_action_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRef_action_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "ref_action" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias RefActionAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Ref_action_select_column.Ref_action_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Ref_action_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Ref_action_bool_exp
    }


{-| fetch aggregated fields from the table: "ref\_action"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
ref_action_aggregate :
    (RefActionAggregateOptionalArguments -> RefActionAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Ref_action_aggregate
    -> SelectionSet decodesTo RootQuery
ref_action_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Ref_action_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRef_action_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRef_action_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "ref_action_aggregate" optionalArgs____ object____ Basics.identity


type alias RefActionByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "ref\_action" using primary key columns
-}
ref_action_by_pk :
    RefActionByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_action
    -> SelectionSet (Maybe decodesTo) RootQuery
ref_action_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "ref_action_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias RefSituationOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Ref_situation_select_column.Ref_situation_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Ref_situation_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Ref_situation_bool_exp
    }


{-| fetch data from the table: "ref\_situation"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
ref_situation :
    (RefSituationOptionalArguments -> RefSituationOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Ref_situation
    -> SelectionSet (List decodesTo) RootQuery
ref_situation fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Ref_situation_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRef_situation_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRef_situation_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "ref_situation" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias RefSituationAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Ref_situation_select_column.Ref_situation_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Ref_situation_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Ref_situation_bool_exp
    }


{-| fetch aggregated fields from the table: "ref\_situation"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
ref_situation_aggregate :
    (RefSituationAggregateOptionalArguments -> RefSituationAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Ref_situation_aggregate
    -> SelectionSet decodesTo RootQuery
ref_situation_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Ref_situation_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRef_situation_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRef_situation_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "ref_situation_aggregate" optionalArgs____ object____ Basics.identity


type alias RefSituationByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "ref\_situation" using primary key columns
-}
ref_situation_by_pk :
    RefSituationByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_situation
    -> SelectionSet (Maybe decodesTo) RootQuery
ref_situation_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "ref_situation_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias RefTargetOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Ref_target_select_column.Ref_target_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Ref_target_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Ref_target_bool_exp
    }


{-| fetch data from the table: "ref\_target"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
ref_target :
    (RefTargetOptionalArguments -> RefTargetOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Ref_target
    -> SelectionSet (List decodesTo) RootQuery
ref_target fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Ref_target_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRef_target_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRef_target_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "ref_target" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias RefTargetAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Ref_target_select_column.Ref_target_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Ref_target_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Ref_target_bool_exp
    }


{-| fetch aggregated fields from the table: "ref\_target"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
ref_target_aggregate :
    (RefTargetAggregateOptionalArguments -> RefTargetAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Ref_target_aggregate
    -> SelectionSet decodesTo RootQuery
ref_target_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Ref_target_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRef_target_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRef_target_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "ref_target_aggregate" optionalArgs____ object____ Basics.identity


type alias RefTargetByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "ref\_target" using primary key columns
-}
ref_target_by_pk :
    RefTargetByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_target
    -> SelectionSet (Maybe decodesTo) RootQuery
ref_target_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "ref_target_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias RefThemeOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Ref_theme_select_column.Ref_theme_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Ref_theme_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Ref_theme_bool_exp
    }


{-| fetch data from the table: "ref\_theme"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
ref_theme :
    (RefThemeOptionalArguments -> RefThemeOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Ref_theme
    -> SelectionSet (List decodesTo) RootQuery
ref_theme fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Ref_theme_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRef_theme_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRef_theme_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "ref_theme" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias RefThemeAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Ref_theme_select_column.Ref_theme_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Ref_theme_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Ref_theme_bool_exp
    }


{-| fetch aggregated fields from the table: "ref\_theme"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
ref_theme_aggregate :
    (RefThemeAggregateOptionalArguments -> RefThemeAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Ref_theme_aggregate
    -> SelectionSet decodesTo RootQuery
ref_theme_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Ref_theme_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRef_theme_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRef_theme_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "ref_theme_aggregate" optionalArgs____ object____ Basics.identity


type alias RefThemeByPkRequiredArguments =
    { name : String }


{-| fetch data from the table: "ref\_theme" using primary key columns
-}
ref_theme_by_pk :
    RefThemeByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_theme
    -> SelectionSet (Maybe decodesTo) RootQuery
ref_theme_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "ref_theme_by_pk" [ Argument.required "name" requiredArgs____.name Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias RoleOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Role_select_column.Role_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Role_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Role_bool_exp
    }


{-| fetch data from the table: "role"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
role :
    (RoleOptionalArguments -> RoleOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Role
    -> SelectionSet (List decodesTo) RootQuery
role fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Role_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRole_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRole_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "role" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias RoleAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Role_select_column.Role_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Role_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Role_bool_exp
    }


{-| fetch aggregated fields from the table: "role"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
role_aggregate :
    (RoleAggregateOptionalArguments -> RoleAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Role_aggregate
    -> SelectionSet decodesTo RootQuery
role_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Role_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRole_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRole_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "role_aggregate" optionalArgs____ object____ Basics.identity


type alias RoleByPkRequiredArguments =
    { label : String }


{-| fetch data from the table: "role" using primary key columns
-}
role_by_pk :
    RoleByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Role
    -> SelectionSet (Maybe decodesTo) RootQuery
role_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "role_by_pk" [ Argument.required "label" requiredArgs____.label Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias RomeCodeOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Rome_code_select_column.Rome_code_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Rome_code_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Rome_code_bool_exp
    }


{-| fetch data from the table: "rome\_code"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
rome_code :
    (RomeCodeOptionalArguments -> RomeCodeOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Rome_code
    -> SelectionSet (List decodesTo) RootQuery
rome_code fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Rome_code_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRome_code_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRome_code_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "rome_code" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias RomeCodeAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Rome_code_select_column.Rome_code_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Rome_code_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Rome_code_bool_exp
    }


{-| fetch aggregated fields from the table: "rome\_code"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
rome_code_aggregate :
    (RomeCodeAggregateOptionalArguments -> RomeCodeAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Rome_code_aggregate
    -> SelectionSet decodesTo RootQuery
rome_code_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Rome_code_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRome_code_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRome_code_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "rome_code_aggregate" optionalArgs____ object____ Basics.identity


type alias RomeCodeByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "rome\_code" using primary key columns
-}
rome_code_by_pk :
    RomeCodeByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rome_code
    -> SelectionSet (Maybe decodesTo) RootQuery
rome_code_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "rome_code_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias RsaClosureReasonOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Rsa_closure_reason_select_column.Rsa_closure_reason_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Rsa_closure_reason_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Rsa_closure_reason_bool_exp
    }


{-| fetch data from the table: "rsa\_closure\_reason"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
rsa_closure_reason :
    (RsaClosureReasonOptionalArguments -> RsaClosureReasonOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Rsa_closure_reason
    -> SelectionSet (List decodesTo) RootQuery
rsa_closure_reason fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Rsa_closure_reason_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRsa_closure_reason_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRsa_closure_reason_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "rsa_closure_reason" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias RsaClosureReasonAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Rsa_closure_reason_select_column.Rsa_closure_reason_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Rsa_closure_reason_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Rsa_closure_reason_bool_exp
    }


{-| fetch aggregated fields from the table: "rsa\_closure\_reason"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
rsa_closure_reason_aggregate :
    (RsaClosureReasonAggregateOptionalArguments -> RsaClosureReasonAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Rsa_closure_reason_aggregate
    -> SelectionSet decodesTo RootQuery
rsa_closure_reason_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Rsa_closure_reason_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRsa_closure_reason_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRsa_closure_reason_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "rsa_closure_reason_aggregate" optionalArgs____ object____ Basics.identity


type alias RsaClosureReasonByPkRequiredArguments =
    { code : String }


{-| fetch data from the table: "rsa\_closure\_reason" using primary key columns
-}
rsa_closure_reason_by_pk :
    RsaClosureReasonByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rsa_closure_reason
    -> SelectionSet (Maybe decodesTo) RootQuery
rsa_closure_reason_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "rsa_closure_reason_by_pk" [ Argument.required "code" requiredArgs____.code Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias RsaSuspensionReasonOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Rsa_suspension_reason_select_column.Rsa_suspension_reason_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Rsa_suspension_reason_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Rsa_suspension_reason_bool_exp
    }


{-| fetch data from the table: "rsa\_suspension\_reason"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
rsa_suspension_reason :
    (RsaSuspensionReasonOptionalArguments -> RsaSuspensionReasonOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Rsa_suspension_reason
    -> SelectionSet (List decodesTo) RootQuery
rsa_suspension_reason fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Rsa_suspension_reason_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRsa_suspension_reason_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRsa_suspension_reason_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "rsa_suspension_reason" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias RsaSuspensionReasonAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Rsa_suspension_reason_select_column.Rsa_suspension_reason_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Rsa_suspension_reason_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Rsa_suspension_reason_bool_exp
    }


{-| fetch aggregated fields from the table: "rsa\_suspension\_reason"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
rsa_suspension_reason_aggregate :
    (RsaSuspensionReasonAggregateOptionalArguments -> RsaSuspensionReasonAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Rsa_suspension_reason_aggregate
    -> SelectionSet decodesTo RootQuery
rsa_suspension_reason_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Rsa_suspension_reason_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRsa_suspension_reason_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRsa_suspension_reason_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "rsa_suspension_reason_aggregate" optionalArgs____ object____ Basics.identity


type alias RsaSuspensionReasonByPkRequiredArguments =
    { code : String }


{-| fetch data from the table: "rsa\_suspension\_reason" using primary key columns
-}
rsa_suspension_reason_by_pk :
    RsaSuspensionReasonByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rsa_suspension_reason
    -> SelectionSet (Maybe decodesTo) RootQuery
rsa_suspension_reason_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "rsa_suspension_reason_by_pk" [ Argument.required "code" requiredArgs____.code Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias SearchBeneficiariesOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Beneficiary_select_column.Beneficiary_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Beneficiary_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Beneficiary_bool_exp
    }


type alias SearchBeneficiariesRequiredArguments =
    { args : CdbGQL.InputObject.Search_beneficiaries_args }


{-| execute function "search\_beneficiaries" which returns "beneficiary"

  - args - input parameters for function "search\_beneficiaries"
  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
search_beneficiaries :
    (SearchBeneficiariesOptionalArguments -> SearchBeneficiariesOptionalArguments)
    -> SearchBeneficiariesRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary
    -> SelectionSet (List decodesTo) RootQuery
search_beneficiaries fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Beneficiary_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeBeneficiary_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeBeneficiary_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "search_beneficiaries" (optionalArgs____ ++ [ Argument.required "args" requiredArgs____.args CdbGQL.InputObject.encodeSearch_beneficiaries_args ]) object____ (Basics.identity >> Decode.list)


type alias SearchBeneficiariesAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Beneficiary_select_column.Beneficiary_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Beneficiary_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Beneficiary_bool_exp
    }


type alias SearchBeneficiariesAggregateRequiredArguments =
    { args : CdbGQL.InputObject.Search_beneficiaries_args }


{-| execute function "search\_beneficiaries" and query aggregates on result of table type "beneficiary"

  - args - input parameters for function "search\_beneficiaries\_aggregate"
  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
search_beneficiaries_aggregate :
    (SearchBeneficiariesAggregateOptionalArguments -> SearchBeneficiariesAggregateOptionalArguments)
    -> SearchBeneficiariesAggregateRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary_aggregate
    -> SelectionSet decodesTo RootQuery
search_beneficiaries_aggregate fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Beneficiary_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeBeneficiary_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeBeneficiary_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "search_beneficiaries_aggregate" (optionalArgs____ ++ [ Argument.required "args" requiredArgs____.args CdbGQL.InputObject.encodeSearch_beneficiaries_args ]) object____ Basics.identity


type alias SearchNotebookMembersOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_member_select_column.Notebook_member_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_member_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_member_bool_exp
    }


type alias SearchNotebookMembersRequiredArguments =
    { args : CdbGQL.InputObject.Search_notebook_members_args }


{-| execute function "search\_notebook\_members" which returns "notebook\_member"

  - args - input parameters for function "search\_notebook\_members"
  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
search_notebook_members :
    (SearchNotebookMembersOptionalArguments -> SearchNotebookMembersOptionalArguments)
    -> SearchNotebookMembersRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_member
    -> SelectionSet (List decodesTo) RootQuery
search_notebook_members fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_member_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_member_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_member_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "search_notebook_members" (optionalArgs____ ++ [ Argument.required "args" requiredArgs____.args CdbGQL.InputObject.encodeSearch_notebook_members_args ]) object____ (Basics.identity >> Decode.list)


type alias SearchNotebookMembersAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_member_select_column.Notebook_member_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_member_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_member_bool_exp
    }


type alias SearchNotebookMembersAggregateRequiredArguments =
    { args : CdbGQL.InputObject.Search_notebook_members_args }


{-| execute function "search\_notebook\_members" and query aggregates on result of table type "notebook\_member"

  - args - input parameters for function "search\_notebook\_members\_aggregate"
  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
search_notebook_members_aggregate :
    (SearchNotebookMembersAggregateOptionalArguments -> SearchNotebookMembersAggregateOptionalArguments)
    -> SearchNotebookMembersAggregateRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_member_aggregate
    -> SelectionSet decodesTo RootQuery
search_notebook_members_aggregate fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_member_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_member_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_member_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "search_notebook_members_aggregate" (optionalArgs____ ++ [ Argument.required "args" requiredArgs____.args CdbGQL.InputObject.encodeSearch_notebook_members_args ]) object____ Basics.identity


type alias SearchPublicNotebooksOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_public_view_select_column.Notebook_public_view_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_public_view_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_public_view_bool_exp
    }


type alias SearchPublicNotebooksRequiredArguments =
    { args : CdbGQL.InputObject.Search_public_notebooks_args }


{-| execute function "search\_public\_notebooks" which returns "notebook\_public\_view"

  - args - input parameters for function "search\_public\_notebooks"
  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
search_public_notebooks :
    (SearchPublicNotebooksOptionalArguments -> SearchPublicNotebooksOptionalArguments)
    -> SearchPublicNotebooksRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_public_view
    -> SelectionSet (List decodesTo) RootQuery
search_public_notebooks fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_public_view_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_public_view_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_public_view_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "search_public_notebooks" (optionalArgs____ ++ [ Argument.required "args" requiredArgs____.args CdbGQL.InputObject.encodeSearch_public_notebooks_args ]) object____ (Basics.identity >> Decode.list)


type alias SearchPublicNotebooksAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_public_view_select_column.Notebook_public_view_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_public_view_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_public_view_bool_exp
    }


type alias SearchPublicNotebooksAggregateRequiredArguments =
    { args : CdbGQL.InputObject.Search_public_notebooks_args }


{-| execute function "search\_public\_notebooks" and query aggregates on result of table type "notebook\_public\_view"

  - args - input parameters for function "search\_public\_notebooks\_aggregate"
  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
search_public_notebooks_aggregate :
    (SearchPublicNotebooksAggregateOptionalArguments -> SearchPublicNotebooksAggregateOptionalArguments)
    -> SearchPublicNotebooksAggregateRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_public_view_aggregate
    -> SelectionSet decodesTo RootQuery
search_public_notebooks_aggregate fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_public_view_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_public_view_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_public_view_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "search_public_notebooks_aggregate" (optionalArgs____ ++ [ Argument.required "args" requiredArgs____.args CdbGQL.InputObject.encodeSearch_public_notebooks_args ]) object____ Basics.identity


type alias SearchRefActionOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Ref_action_select_column.Ref_action_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Ref_action_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Ref_action_bool_exp
    }


type alias SearchRefActionRequiredArguments =
    { args : CdbGQL.InputObject.Search_ref_action_args }


{-| execute function "search\_ref\_action" which returns "ref\_action"

  - args - input parameters for function "search\_ref\_action"
  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
search_ref_action :
    (SearchRefActionOptionalArguments -> SearchRefActionOptionalArguments)
    -> SearchRefActionRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_action
    -> SelectionSet (List decodesTo) RootQuery
search_ref_action fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Ref_action_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRef_action_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRef_action_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "search_ref_action" (optionalArgs____ ++ [ Argument.required "args" requiredArgs____.args CdbGQL.InputObject.encodeSearch_ref_action_args ]) object____ (Basics.identity >> Decode.list)


type alias SearchRefActionAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Ref_action_select_column.Ref_action_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Ref_action_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Ref_action_bool_exp
    }


type alias SearchRefActionAggregateRequiredArguments =
    { args : CdbGQL.InputObject.Search_ref_action_args }


{-| execute function "search\_ref\_action" and query aggregates on result of table type "ref\_action"

  - args - input parameters for function "search\_ref\_action\_aggregate"
  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
search_ref_action_aggregate :
    (SearchRefActionAggregateOptionalArguments -> SearchRefActionAggregateOptionalArguments)
    -> SearchRefActionAggregateRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_action_aggregate
    -> SelectionSet decodesTo RootQuery
search_ref_action_aggregate fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Ref_action_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRef_action_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRef_action_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "search_ref_action_aggregate" (optionalArgs____ ++ [ Argument.required "args" requiredArgs____.args CdbGQL.InputObject.encodeSearch_ref_action_args ]) object____ Basics.identity


type alias SearchRomeCodesOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Rome_code_select_column.Rome_code_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Rome_code_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Rome_code_bool_exp
    }


type alias SearchRomeCodesRequiredArguments =
    { args : CdbGQL.InputObject.Search_rome_codes_args }


{-| execute function "search\_rome\_codes" which returns "rome\_code"

  - args - input parameters for function "search\_rome\_codes"
  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
search_rome_codes :
    (SearchRomeCodesOptionalArguments -> SearchRomeCodesOptionalArguments)
    -> SearchRomeCodesRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rome_code
    -> SelectionSet (List decodesTo) RootQuery
search_rome_codes fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Rome_code_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRome_code_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRome_code_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "search_rome_codes" (optionalArgs____ ++ [ Argument.required "args" requiredArgs____.args CdbGQL.InputObject.encodeSearch_rome_codes_args ]) object____ (Basics.identity >> Decode.list)


type alias SearchRomeCodesAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Rome_code_select_column.Rome_code_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Rome_code_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Rome_code_bool_exp
    }


type alias SearchRomeCodesAggregateRequiredArguments =
    { args : CdbGQL.InputObject.Search_rome_codes_args }


{-| execute function "search\_rome\_codes" and query aggregates on result of table type "rome\_code"

  - args - input parameters for function "search\_rome\_codes\_aggregate"
  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
search_rome_codes_aggregate :
    (SearchRomeCodesAggregateOptionalArguments -> SearchRomeCodesAggregateOptionalArguments)
    -> SearchRomeCodesAggregateRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rome_code_aggregate
    -> SelectionSet decodesTo RootQuery
search_rome_codes_aggregate fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Rome_code_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRome_code_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRome_code_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "search_rome_codes_aggregate" (optionalArgs____ ++ [ Argument.required "args" requiredArgs____.args CdbGQL.InputObject.encodeSearch_rome_codes_args ]) object____ Basics.identity


type alias StructureOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Structure_select_column.Structure_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Structure_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Structure_bool_exp
    }


{-| fetch data from the table: "structure"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
structure :
    (StructureOptionalArguments -> StructureOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Structure
    -> SelectionSet (List decodesTo) RootQuery
structure fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Structure_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeStructure_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeStructure_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "structure" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias StructureAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Structure_select_column.Structure_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Structure_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Structure_bool_exp
    }


{-| fetch aggregated fields from the table: "structure"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
structure_aggregate :
    (StructureAggregateOptionalArguments -> StructureAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Structure_aggregate
    -> SelectionSet decodesTo RootQuery
structure_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Structure_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeStructure_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeStructure_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "structure_aggregate" optionalArgs____ object____ Basics.identity


type alias StructureByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "structure" using primary key columns
-}
structure_by_pk :
    StructureByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Structure
    -> SelectionSet (Maybe decodesTo) RootQuery
structure_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "structure_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias StructureOrientationSystemOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Structure_orientation_system_select_column.Structure_orientation_system_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Structure_orientation_system_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Structure_orientation_system_bool_exp
    }


{-| fetch data from the table: "structure\_orientation\_system"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
structure_orientation_system :
    (StructureOrientationSystemOptionalArguments -> StructureOrientationSystemOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Structure_orientation_system
    -> SelectionSet (List decodesTo) RootQuery
structure_orientation_system fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Structure_orientation_system_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeStructure_orientation_system_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeStructure_orientation_system_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "structure_orientation_system" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias StructureOrientationSystemAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Structure_orientation_system_select_column.Structure_orientation_system_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Structure_orientation_system_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Structure_orientation_system_bool_exp
    }


{-| fetch aggregated fields from the table: "structure\_orientation\_system"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
structure_orientation_system_aggregate :
    (StructureOrientationSystemAggregateOptionalArguments -> StructureOrientationSystemAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Structure_orientation_system_aggregate
    -> SelectionSet decodesTo RootQuery
structure_orientation_system_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Structure_orientation_system_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeStructure_orientation_system_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeStructure_orientation_system_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "structure_orientation_system_aggregate" optionalArgs____ object____ Basics.identity


type alias StructureOrientationSystemByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "structure\_orientation\_system" using primary key columns
-}
structure_orientation_system_by_pk :
    StructureOrientationSystemByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Structure_orientation_system
    -> SelectionSet (Maybe decodesTo) RootQuery
structure_orientation_system_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "structure_orientation_system_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)
