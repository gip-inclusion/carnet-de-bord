-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module CdbGQL.Object.Notebook exposing (..)

import CdbGQL.Enum.Notebook_appointment_select_column
import CdbGQL.Enum.Notebook_event_select_column
import CdbGQL.Enum.Notebook_focus_select_column
import CdbGQL.Enum.Notebook_member_select_column
import CdbGQL.Enum.Notebook_situation_select_column
import CdbGQL.Enum.Professional_project_select_column
import CdbGQL.InputObject
import CdbGQL.Interface
import CdbGQL.Object
import CdbGQL.Scalar
import CdbGQL.ScalarCodecs
import CdbGQL.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode


type alias AppointmentsOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_appointment_select_column.Notebook_appointment_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_appointment_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_appointment_bool_exp
    }


{-| An array relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
appointments :
    (AppointmentsOptionalArguments -> AppointmentsOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_appointment
    -> SelectionSet (List decodesTo) CdbGQL.Object.Notebook
appointments fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_appointment_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_appointment_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_appointment_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "appointments" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias AppointmentsAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_appointment_select_column.Notebook_appointment_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_appointment_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_appointment_bool_exp
    }


{-| An aggregate relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
appointments_aggregate :
    (AppointmentsAggregateOptionalArguments -> AppointmentsAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_appointment_aggregate
    -> SelectionSet decodesTo CdbGQL.Object.Notebook
appointments_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_appointment_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_appointment_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_appointment_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "appointments_aggregate" optionalArgs____ object____ Basics.identity


{-| An object relationship
-}
beneficiary :
    SelectionSet decodesTo CdbGQL.Object.Beneficiary
    -> SelectionSet decodesTo CdbGQL.Object.Notebook
beneficiary object____ =
    Object.selectionForCompositeField "beneficiary" [] object____ Basics.identity


beneficiaryId : SelectionSet CdbGQL.ScalarCodecs.Uuid CdbGQL.Object.Notebook
beneficiaryId =
    Object.selectionForField "ScalarCodecs.Uuid" "beneficiaryId" [] (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapCodecs |> .codecUuid |> .decoder)


contractEndDate : SelectionSet (Maybe CdbGQL.ScalarCodecs.Date) CdbGQL.Object.Notebook
contractEndDate =
    Object.selectionForField "(Maybe ScalarCodecs.Date)" "contractEndDate" [] (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapCodecs |> .codecDate |> .decoder |> Decode.nullable)


contractSignDate : SelectionSet (Maybe CdbGQL.ScalarCodecs.Date) CdbGQL.Object.Notebook
contractSignDate =
    Object.selectionForField "(Maybe ScalarCodecs.Date)" "contractSignDate" [] (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapCodecs |> .codecDate |> .decoder |> Decode.nullable)


contractStartDate : SelectionSet (Maybe CdbGQL.ScalarCodecs.Date) CdbGQL.Object.Notebook
contractStartDate =
    Object.selectionForField "(Maybe ScalarCodecs.Date)" "contractStartDate" [] (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapCodecs |> .codecDate |> .decoder |> Decode.nullable)


contractType : SelectionSet (Maybe String) CdbGQL.Object.Notebook
contractType =
    Object.selectionForField "(Maybe String)" "contractType" [] (Decode.string |> Decode.nullable)


createdAt : SelectionSet CdbGQL.ScalarCodecs.Timestamptz CdbGQL.Object.Notebook
createdAt =
    Object.selectionForField "ScalarCodecs.Timestamptz" "createdAt" [] (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapCodecs |> .codecTimestamptz |> .decoder)


educationLevel : SelectionSet (Maybe String) CdbGQL.Object.Notebook
educationLevel =
    Object.selectionForField "(Maybe String)" "educationLevel" [] (Decode.string |> Decode.nullable)


type alias EventsOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_event_select_column.Notebook_event_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_event_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_event_bool_exp
    }


{-| An array relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
events :
    (EventsOptionalArguments -> EventsOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_event
    -> SelectionSet (List decodesTo) CdbGQL.Object.Notebook
events fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_event_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_event_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_event_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "events" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias EventsAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_event_select_column.Notebook_event_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_event_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_event_bool_exp
    }


{-| An aggregate relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
events_aggregate :
    (EventsAggregateOptionalArguments -> EventsAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_event_aggregate
    -> SelectionSet decodesTo CdbGQL.Object.Notebook
events_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_event_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_event_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_event_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "events_aggregate" optionalArgs____ object____ Basics.identity


type alias FocusesOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_focus_select_column.Notebook_focus_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_focus_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_focus_bool_exp
    }


{-| An array relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
focuses :
    (FocusesOptionalArguments -> FocusesOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_focus
    -> SelectionSet (List decodesTo) CdbGQL.Object.Notebook
focuses fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_focus_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_focus_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_focus_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "focuses" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias FocusesAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_focus_select_column.Notebook_focus_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_focus_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_focus_bool_exp
    }


{-| An aggregate relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
focuses_aggregate :
    (FocusesAggregateOptionalArguments -> FocusesAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_focus_aggregate
    -> SelectionSet decodesTo CdbGQL.Object.Notebook
focuses_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_focus_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_focus_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_focus_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "focuses_aggregate" optionalArgs____ object____ Basics.identity


id : SelectionSet CdbGQL.ScalarCodecs.Uuid CdbGQL.Object.Notebook
id =
    Object.selectionForField "ScalarCodecs.Uuid" "id" [] (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapCodecs |> .codecUuid |> .decoder)


lastJobEndedAt : SelectionSet (Maybe CdbGQL.ScalarCodecs.Date) CdbGQL.Object.Notebook
lastJobEndedAt =
    Object.selectionForField "(Maybe ScalarCodecs.Date)" "lastJobEndedAt" [] (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapCodecs |> .codecDate |> .decoder |> Decode.nullable)


type alias MembersOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_member_select_column.Notebook_member_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_member_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_member_bool_exp
    }


{-| An array relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
members :
    (MembersOptionalArguments -> MembersOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_member
    -> SelectionSet (List decodesTo) CdbGQL.Object.Notebook
members fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_member_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_member_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_member_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "members" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias MembersAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_member_select_column.Notebook_member_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_member_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_member_bool_exp
    }


{-| An aggregate relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
members_aggregate :
    (MembersAggregateOptionalArguments -> MembersAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_member_aggregate
    -> SelectionSet decodesTo CdbGQL.Object.Notebook
members_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_member_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_member_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_member_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "members_aggregate" optionalArgs____ object____ Basics.identity


{-| An object relationship
-}
notebookInfo :
    SelectionSet decodesTo CdbGQL.Object.Notebook_info
    -> SelectionSet (Maybe decodesTo) CdbGQL.Object.Notebook
notebookInfo object____ =
    Object.selectionForCompositeField "notebookInfo" [] object____ (Basics.identity >> Decode.nullable)


type alias ProfessionalProjectsOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Professional_project_select_column.Professional_project_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Professional_project_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Professional_project_bool_exp
    }


{-| An array relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
professionalProjects :
    (ProfessionalProjectsOptionalArguments -> ProfessionalProjectsOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Professional_project
    -> SelectionSet (List decodesTo) CdbGQL.Object.Notebook
professionalProjects fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Professional_project_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeProfessional_project_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeProfessional_project_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "professionalProjects" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias ProfessionalProjectsAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Professional_project_select_column.Professional_project_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Professional_project_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Professional_project_bool_exp
    }


{-| An aggregate relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
professionalProjects_aggregate :
    (ProfessionalProjectsAggregateOptionalArguments -> ProfessionalProjectsAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Professional_project_aggregate
    -> SelectionSet decodesTo CdbGQL.Object.Notebook
professionalProjects_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Professional_project_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeProfessional_project_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeProfessional_project_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "professionalProjects_aggregate" optionalArgs____ object____ Basics.identity


rightRqth : SelectionSet Bool CdbGQL.Object.Notebook
rightRqth =
    Object.selectionForField "Bool" "rightRqth" [] Decode.bool


type alias SituationsOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_situation_select_column.Notebook_situation_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_situation_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_situation_bool_exp
    }


{-| An array relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
situations :
    (SituationsOptionalArguments -> SituationsOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_situation
    -> SelectionSet (List decodesTo) CdbGQL.Object.Notebook
situations fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_situation_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_situation_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_situation_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "situations" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias SituationsAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_situation_select_column.Notebook_situation_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_situation_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_situation_bool_exp
    }


{-| An aggregate relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
situations_aggregate :
    (SituationsAggregateOptionalArguments -> SituationsAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_situation_aggregate
    -> SelectionSet decodesTo CdbGQL.Object.Notebook
situations_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_situation_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_situation_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_situation_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "situations_aggregate" optionalArgs____ object____ Basics.identity


updatedAt : SelectionSet CdbGQL.ScalarCodecs.Timestamptz CdbGQL.Object.Notebook
updatedAt =
    Object.selectionForField "ScalarCodecs.Timestamptz" "updatedAt" [] (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapCodecs |> .codecTimestamptz |> .decoder)


workSituation : SelectionSet (Maybe String) CdbGQL.Object.Notebook
workSituation =
    Object.selectionForField "(Maybe String)" "workSituation" [] (Decode.string |> Decode.nullable)


workSituationDate : SelectionSet (Maybe CdbGQL.ScalarCodecs.Date) CdbGQL.Object.Notebook
workSituationDate =
    Object.selectionForField "(Maybe ScalarCodecs.Date)" "workSituationDate" [] (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapCodecs |> .codecDate |> .decoder |> Decode.nullable)


workSituationEndDate : SelectionSet (Maybe CdbGQL.ScalarCodecs.Date) CdbGQL.Object.Notebook
workSituationEndDate =
    Object.selectionForField "(Maybe ScalarCodecs.Date)" "workSituationEndDate" [] (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapCodecs |> .codecDate |> .decoder |> Decode.nullable)
