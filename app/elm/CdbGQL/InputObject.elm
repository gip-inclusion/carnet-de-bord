-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module CdbGQL.InputObject exposing (..)

import CdbGQL.Enum.Account_constraint
import CdbGQL.Enum.Account_select_column
import CdbGQL.Enum.Account_select_column_account_aggregate_bool_exp_bool_and_arguments_columns
import CdbGQL.Enum.Account_select_column_account_aggregate_bool_exp_bool_or_arguments_columns
import CdbGQL.Enum.Account_update_column
import CdbGQL.Enum.Action_status_constraint
import CdbGQL.Enum.Action_status_enum
import CdbGQL.Enum.Action_status_update_column
import CdbGQL.Enum.Admin_cdb_constraint
import CdbGQL.Enum.Admin_cdb_update_column
import CdbGQL.Enum.Admin_structure_constraint
import CdbGQL.Enum.Admin_structure_select_column
import CdbGQL.Enum.Admin_structure_structure_constraint
import CdbGQL.Enum.Admin_structure_structure_select_column
import CdbGQL.Enum.Admin_structure_structure_update_column
import CdbGQL.Enum.Admin_structure_update_column
import CdbGQL.Enum.Beneficiary_constraint
import CdbGQL.Enum.Beneficiary_select_column
import CdbGQL.Enum.Beneficiary_select_column_beneficiary_aggregate_bool_exp_bool_and_arguments_columns
import CdbGQL.Enum.Beneficiary_select_column_beneficiary_aggregate_bool_exp_bool_or_arguments_columns
import CdbGQL.Enum.Beneficiary_structure_constraint
import CdbGQL.Enum.Beneficiary_structure_select_column
import CdbGQL.Enum.Beneficiary_structure_update_column
import CdbGQL.Enum.Beneficiary_update_column
import CdbGQL.Enum.Contract_type_constraint
import CdbGQL.Enum.Contract_type_enum
import CdbGQL.Enum.Contract_type_update_column
import CdbGQL.Enum.Cursor_ordering
import CdbGQL.Enum.Deployment_constraint
import CdbGQL.Enum.Deployment_update_column
import CdbGQL.Enum.Employment_type_constraint
import CdbGQL.Enum.Employment_type_enum
import CdbGQL.Enum.Employment_type_update_column
import CdbGQL.Enum.External_data_constraint
import CdbGQL.Enum.External_data_info_constraint
import CdbGQL.Enum.External_data_info_select_column
import CdbGQL.Enum.External_data_info_update_column
import CdbGQL.Enum.External_data_select_column
import CdbGQL.Enum.External_data_update_column
import CdbGQL.Enum.External_source_constraint
import CdbGQL.Enum.External_source_enum
import CdbGQL.Enum.External_source_update_column
import CdbGQL.Enum.Manager_constraint
import CdbGQL.Enum.Manager_select_column
import CdbGQL.Enum.Manager_update_column
import CdbGQL.Enum.Notebook_action_constraint
import CdbGQL.Enum.Notebook_action_select_column
import CdbGQL.Enum.Notebook_action_update_column
import CdbGQL.Enum.Notebook_appointment_constraint
import CdbGQL.Enum.Notebook_appointment_select_column
import CdbGQL.Enum.Notebook_appointment_update_column
import CdbGQL.Enum.Notebook_constraint
import CdbGQL.Enum.Notebook_event_constraint
import CdbGQL.Enum.Notebook_event_select_column
import CdbGQL.Enum.Notebook_event_type_constraint
import CdbGQL.Enum.Notebook_event_type_enum
import CdbGQL.Enum.Notebook_event_type_update_column
import CdbGQL.Enum.Notebook_event_update_column
import CdbGQL.Enum.Notebook_focus_constraint
import CdbGQL.Enum.Notebook_focus_select_column
import CdbGQL.Enum.Notebook_focus_update_column
import CdbGQL.Enum.Notebook_info_constraint
import CdbGQL.Enum.Notebook_info_update_column
import CdbGQL.Enum.Notebook_member_constraint
import CdbGQL.Enum.Notebook_member_select_column
import CdbGQL.Enum.Notebook_member_select_column_notebook_member_aggregate_bool_exp_bool_and_arguments_columns
import CdbGQL.Enum.Notebook_member_select_column_notebook_member_aggregate_bool_exp_bool_or_arguments_columns
import CdbGQL.Enum.Notebook_member_update_column
import CdbGQL.Enum.Notebook_situation_constraint
import CdbGQL.Enum.Notebook_situation_select_column
import CdbGQL.Enum.Notebook_situation_update_column
import CdbGQL.Enum.Notebook_target_constraint
import CdbGQL.Enum.Notebook_target_select_column
import CdbGQL.Enum.Notebook_target_update_column
import CdbGQL.Enum.Notebook_update_column
import CdbGQL.Enum.Nps_rating_constraint
import CdbGQL.Enum.Nps_rating_dismissal_constraint
import CdbGQL.Enum.Nps_rating_dismissal_update_column
import CdbGQL.Enum.Nps_rating_update_column
import CdbGQL.Enum.Order_by
import CdbGQL.Enum.Orientation_manager_constraint
import CdbGQL.Enum.Orientation_manager_select_column
import CdbGQL.Enum.Orientation_manager_update_column
import CdbGQL.Enum.Orientation_request_constraint
import CdbGQL.Enum.Orientation_request_select_column
import CdbGQL.Enum.Orientation_request_update_column
import CdbGQL.Enum.Orientation_system_constraint
import CdbGQL.Enum.Orientation_system_select_column
import CdbGQL.Enum.Orientation_system_update_column
import CdbGQL.Enum.Orientation_type_constraint
import CdbGQL.Enum.Orientation_type_enum
import CdbGQL.Enum.Orientation_type_update_column
import CdbGQL.Enum.Professional_constraint
import CdbGQL.Enum.Professional_orientation_system_constraint
import CdbGQL.Enum.Professional_orientation_system_select_column
import CdbGQL.Enum.Professional_orientation_system_update_column
import CdbGQL.Enum.Professional_project_constraint
import CdbGQL.Enum.Professional_project_select_column
import CdbGQL.Enum.Professional_project_update_column
import CdbGQL.Enum.Professional_select_column
import CdbGQL.Enum.Professional_update_column
import CdbGQL.Enum.Ref_action_constraint
import CdbGQL.Enum.Ref_action_update_column
import CdbGQL.Enum.Ref_situation_constraint
import CdbGQL.Enum.Ref_situation_update_column
import CdbGQL.Enum.Ref_target_constraint
import CdbGQL.Enum.Ref_target_update_column
import CdbGQL.Enum.Ref_theme_constraint
import CdbGQL.Enum.Ref_theme_update_column
import CdbGQL.Enum.Role_constraint
import CdbGQL.Enum.Role_enum
import CdbGQL.Enum.Role_update_column
import CdbGQL.Enum.Rome_code_constraint
import CdbGQL.Enum.Rome_code_update_column
import CdbGQL.Enum.Rsa_closure_reason_constraint
import CdbGQL.Enum.Rsa_closure_reason_enum
import CdbGQL.Enum.Rsa_closure_reason_update_column
import CdbGQL.Enum.Rsa_suspension_reason_constraint
import CdbGQL.Enum.Rsa_suspension_reason_enum
import CdbGQL.Enum.Rsa_suspension_reason_update_column
import CdbGQL.Enum.Structure_constraint
import CdbGQL.Enum.Structure_orientation_system_constraint
import CdbGQL.Enum.Structure_orientation_system_select_column
import CdbGQL.Enum.Structure_orientation_system_update_column
import CdbGQL.Enum.Structure_select_column
import CdbGQL.Enum.Structure_update_column
import CdbGQL.Enum.UpdateSocioProContractTypeEnum
import CdbGQL.Enum.UpdateSocioProEmploymentTypeEnum
import CdbGQL.Interface
import CdbGQL.Object
import CdbGQL.Scalar
import CdbGQL.ScalarCodecs
import CdbGQL.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode


buildAccount_aggregate_bool_exp :
    (Account_aggregate_bool_expOptionalFields -> Account_aggregate_bool_expOptionalFields)
    -> Account_aggregate_bool_exp
buildAccount_aggregate_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { bool_and = Absent, bool_or = Absent, count = Absent }
    in
    Account_aggregate_bool_exp { bool_and = optionals____.bool_and, bool_or = optionals____.bool_or, count = optionals____.count }


type alias Account_aggregate_bool_expOptionalFields =
    { bool_and : OptionalArgument Account_aggregate_bool_exp_bool_and
    , bool_or : OptionalArgument Account_aggregate_bool_exp_bool_or
    , count : OptionalArgument Account_aggregate_bool_exp_count
    }


{-| Type alias for the `Account_aggregate_bool_exp` attributes. Note that this type
needs to use the `Account_aggregate_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Account_aggregate_bool_expRaw =
    { bool_and : OptionalArgument Account_aggregate_bool_exp_bool_and
    , bool_or : OptionalArgument Account_aggregate_bool_exp_bool_or
    , count : OptionalArgument Account_aggregate_bool_exp_count
    }


{-| Type for the Account\_aggregate\_bool\_exp input object.
-}
type Account_aggregate_bool_exp
    = Account_aggregate_bool_exp Account_aggregate_bool_expRaw


{-| Encode a Account\_aggregate\_bool\_exp into a value that can be used as an argument.
-}
encodeAccount_aggregate_bool_exp : Account_aggregate_bool_exp -> Value
encodeAccount_aggregate_bool_exp (Account_aggregate_bool_exp input____) =
    Encode.maybeObject
        [ ( "bool_and", encodeAccount_aggregate_bool_exp_bool_and |> Encode.optional input____.bool_and ), ( "bool_or", encodeAccount_aggregate_bool_exp_bool_or |> Encode.optional input____.bool_or ), ( "count", encodeAccount_aggregate_bool_exp_count |> Encode.optional input____.count ) ]


buildAccount_aggregate_bool_exp_bool_and :
    Account_aggregate_bool_exp_bool_andRequiredFields
    -> (Account_aggregate_bool_exp_bool_andOptionalFields -> Account_aggregate_bool_exp_bool_andOptionalFields)
    -> Account_aggregate_bool_exp_bool_and
buildAccount_aggregate_bool_exp_bool_and required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { distinct = Absent, filter = Absent }
    in
    Account_aggregate_bool_exp_bool_and { arguments = required____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Account_aggregate_bool_exp_bool_andRequiredFields =
    { arguments : CdbGQL.Enum.Account_select_column_account_aggregate_bool_exp_bool_and_arguments_columns.Account_select_column_account_aggregate_bool_exp_bool_and_arguments_columns
    , predicate : Boolean_comparison_exp
    }


type alias Account_aggregate_bool_exp_bool_andOptionalFields =
    { distinct : OptionalArgument Bool
    , filter : OptionalArgument Account_bool_exp
    }


{-| Type alias for the `Account_aggregate_bool_exp_bool_and` attributes. Note that this type
needs to use the `Account_aggregate_bool_exp_bool_and` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Account_aggregate_bool_exp_bool_andRaw =
    { arguments : CdbGQL.Enum.Account_select_column_account_aggregate_bool_exp_bool_and_arguments_columns.Account_select_column_account_aggregate_bool_exp_bool_and_arguments_columns
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Account_bool_exp
    , predicate : Boolean_comparison_exp
    }


{-| Type for the Account\_aggregate\_bool\_exp\_bool\_and input object.
-}
type Account_aggregate_bool_exp_bool_and
    = Account_aggregate_bool_exp_bool_and Account_aggregate_bool_exp_bool_andRaw


{-| Encode a Account\_aggregate\_bool\_exp\_bool\_and into a value that can be used as an argument.
-}
encodeAccount_aggregate_bool_exp_bool_and : Account_aggregate_bool_exp_bool_and -> Value
encodeAccount_aggregate_bool_exp_bool_and (Account_aggregate_bool_exp_bool_and input____) =
    Encode.maybeObject
        [ ( "arguments", Encode.enum CdbGQL.Enum.Account_select_column_account_aggregate_bool_exp_bool_and_arguments_columns.toString input____.arguments |> Just ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeAccount_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeBoolean_comparison_exp input____.predicate |> Just ) ]


buildAccount_aggregate_bool_exp_bool_or :
    Account_aggregate_bool_exp_bool_orRequiredFields
    -> (Account_aggregate_bool_exp_bool_orOptionalFields -> Account_aggregate_bool_exp_bool_orOptionalFields)
    -> Account_aggregate_bool_exp_bool_or
buildAccount_aggregate_bool_exp_bool_or required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { distinct = Absent, filter = Absent }
    in
    Account_aggregate_bool_exp_bool_or { arguments = required____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Account_aggregate_bool_exp_bool_orRequiredFields =
    { arguments : CdbGQL.Enum.Account_select_column_account_aggregate_bool_exp_bool_or_arguments_columns.Account_select_column_account_aggregate_bool_exp_bool_or_arguments_columns
    , predicate : Boolean_comparison_exp
    }


type alias Account_aggregate_bool_exp_bool_orOptionalFields =
    { distinct : OptionalArgument Bool
    , filter : OptionalArgument Account_bool_exp
    }


{-| Type alias for the `Account_aggregate_bool_exp_bool_or` attributes. Note that this type
needs to use the `Account_aggregate_bool_exp_bool_or` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Account_aggregate_bool_exp_bool_orRaw =
    { arguments : CdbGQL.Enum.Account_select_column_account_aggregate_bool_exp_bool_or_arguments_columns.Account_select_column_account_aggregate_bool_exp_bool_or_arguments_columns
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Account_bool_exp
    , predicate : Boolean_comparison_exp
    }


{-| Type for the Account\_aggregate\_bool\_exp\_bool\_or input object.
-}
type Account_aggregate_bool_exp_bool_or
    = Account_aggregate_bool_exp_bool_or Account_aggregate_bool_exp_bool_orRaw


{-| Encode a Account\_aggregate\_bool\_exp\_bool\_or into a value that can be used as an argument.
-}
encodeAccount_aggregate_bool_exp_bool_or : Account_aggregate_bool_exp_bool_or -> Value
encodeAccount_aggregate_bool_exp_bool_or (Account_aggregate_bool_exp_bool_or input____) =
    Encode.maybeObject
        [ ( "arguments", Encode.enum CdbGQL.Enum.Account_select_column_account_aggregate_bool_exp_bool_or_arguments_columns.toString input____.arguments |> Just ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeAccount_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeBoolean_comparison_exp input____.predicate |> Just ) ]


buildAccount_aggregate_bool_exp_count :
    Account_aggregate_bool_exp_countRequiredFields
    -> (Account_aggregate_bool_exp_countOptionalFields -> Account_aggregate_bool_exp_countOptionalFields)
    -> Account_aggregate_bool_exp_count
buildAccount_aggregate_bool_exp_count required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { arguments = Absent, distinct = Absent, filter = Absent }
    in
    Account_aggregate_bool_exp_count { arguments = optionals____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Account_aggregate_bool_exp_countRequiredFields =
    { predicate : Int_comparison_exp }


type alias Account_aggregate_bool_exp_countOptionalFields =
    { arguments : OptionalArgument (List CdbGQL.Enum.Account_select_column.Account_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Account_bool_exp
    }


{-| Type alias for the `Account_aggregate_bool_exp_count` attributes. Note that this type
needs to use the `Account_aggregate_bool_exp_count` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Account_aggregate_bool_exp_countRaw =
    { arguments : OptionalArgument (List CdbGQL.Enum.Account_select_column.Account_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Account_bool_exp
    , predicate : Int_comparison_exp
    }


{-| Type for the Account\_aggregate\_bool\_exp\_count input object.
-}
type Account_aggregate_bool_exp_count
    = Account_aggregate_bool_exp_count Account_aggregate_bool_exp_countRaw


{-| Encode a Account\_aggregate\_bool\_exp\_count into a value that can be used as an argument.
-}
encodeAccount_aggregate_bool_exp_count : Account_aggregate_bool_exp_count -> Value
encodeAccount_aggregate_bool_exp_count (Account_aggregate_bool_exp_count input____) =
    Encode.maybeObject
        [ ( "arguments", (Encode.enum CdbGQL.Enum.Account_select_column.toString |> Encode.list) |> Encode.optional input____.arguments ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeAccount_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeInt_comparison_exp input____.predicate |> Just ) ]


buildAccount_aggregate_order_by :
    (Account_aggregate_order_byOptionalFields -> Account_aggregate_order_byOptionalFields)
    -> Account_aggregate_order_by
buildAccount_aggregate_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals____.count, max = optionals____.max, min = optionals____.min }


type alias Account_aggregate_order_byOptionalFields =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Account_max_order_by
    , min : OptionalArgument Account_min_order_by
    }


{-| Type for the Account\_aggregate\_order\_by input object.
-}
type alias Account_aggregate_order_by =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Account_max_order_by
    , min : OptionalArgument Account_min_order_by
    }


{-| Encode a Account\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeAccount_aggregate_order_by : Account_aggregate_order_by -> Value
encodeAccount_aggregate_order_by input____ =
    Encode.maybeObject
        [ ( "count", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.count ), ( "max", encodeAccount_max_order_by |> Encode.optional input____.max ), ( "min", encodeAccount_min_order_by |> Encode.optional input____.min ) ]


buildAccount_arr_rel_insert_input :
    Account_arr_rel_insert_inputRequiredFields
    -> (Account_arr_rel_insert_inputOptionalFields -> Account_arr_rel_insert_inputOptionalFields)
    -> Account_arr_rel_insert_input
buildAccount_arr_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Account_arr_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Account_arr_rel_insert_inputRequiredFields =
    { data : List Account_insert_input }


type alias Account_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Account_on_conflict }


{-| Type alias for the `Account_arr_rel_insert_input` attributes. Note that this type
needs to use the `Account_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Account_arr_rel_insert_inputRaw =
    { data : List Account_insert_input
    , on_conflict : OptionalArgument Account_on_conflict
    }


{-| Type for the Account\_arr\_rel\_insert\_input input object.
-}
type Account_arr_rel_insert_input
    = Account_arr_rel_insert_input Account_arr_rel_insert_inputRaw


{-| Encode a Account\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeAccount_arr_rel_insert_input : Account_arr_rel_insert_input -> Value
encodeAccount_arr_rel_insert_input (Account_arr_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", (encodeAccount_insert_input |> Encode.list) input____.data |> Just ), ( "on_conflict", encodeAccount_on_conflict |> Encode.optional input____.on_conflict ) ]


buildAccount_bool_exp :
    (Account_bool_expOptionalFields -> Account_bool_expOptionalFields)
    -> Account_bool_exp
buildAccount_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, accessKey = Absent, accessKeyDate = Absent, admin = Absent, adminId = Absent, adminStructureId = Absent, admin_structure = Absent, beneficiary = Absent, beneficiaryId = Absent, confirmed = Absent, createdAt = Absent, deletedAt = Absent, id = Absent, lastLogin = Absent, manager = Absent, managerId = Absent, notebookActionsCreated = Absent, notebookActionsCreated_aggregate = Absent, notebookEventsCreated = Absent, notebookEventsCreated_aggregate = Absent, notebookFocusesCreated = Absent, notebookFocusesCreated_aggregate = Absent, notebookTargetsCreated = Absent, notebookTargetsCreated_aggregate = Absent, notebooksCreated = Absent, notebooksCreated_aggregate = Absent, notebooksWhereMember = Absent, notebooksWhereMember_aggregate = Absent, onboardingDone = Absent, orientationManagerId = Absent, orientation_manager = Absent, professional = Absent, professionalId = Absent, role = Absent, type_ = Absent, updatedAt = Absent, username = Absent }
    in
    Account_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, accessKey = optionals____.accessKey, accessKeyDate = optionals____.accessKeyDate, admin = optionals____.admin, adminId = optionals____.adminId, adminStructureId = optionals____.adminStructureId, admin_structure = optionals____.admin_structure, beneficiary = optionals____.beneficiary, beneficiaryId = optionals____.beneficiaryId, confirmed = optionals____.confirmed, createdAt = optionals____.createdAt, deletedAt = optionals____.deletedAt, id = optionals____.id, lastLogin = optionals____.lastLogin, manager = optionals____.manager, managerId = optionals____.managerId, notebookActionsCreated = optionals____.notebookActionsCreated, notebookActionsCreated_aggregate = optionals____.notebookActionsCreated_aggregate, notebookEventsCreated = optionals____.notebookEventsCreated, notebookEventsCreated_aggregate = optionals____.notebookEventsCreated_aggregate, notebookFocusesCreated = optionals____.notebookFocusesCreated, notebookFocusesCreated_aggregate = optionals____.notebookFocusesCreated_aggregate, notebookTargetsCreated = optionals____.notebookTargetsCreated, notebookTargetsCreated_aggregate = optionals____.notebookTargetsCreated_aggregate, notebooksCreated = optionals____.notebooksCreated, notebooksCreated_aggregate = optionals____.notebooksCreated_aggregate, notebooksWhereMember = optionals____.notebooksWhereMember, notebooksWhereMember_aggregate = optionals____.notebooksWhereMember_aggregate, onboardingDone = optionals____.onboardingDone, orientationManagerId = optionals____.orientationManagerId, orientation_manager = optionals____.orientation_manager, professional = optionals____.professional, professionalId = optionals____.professionalId, role = optionals____.role, type_ = optionals____.type_, updatedAt = optionals____.updatedAt, username = optionals____.username }


type alias Account_bool_expOptionalFields =
    { and_ : OptionalArgument (List Account_bool_exp)
    , not_ : OptionalArgument Account_bool_exp
    , or_ : OptionalArgument (List Account_bool_exp)
    , accessKey : OptionalArgument String_comparison_exp
    , accessKeyDate : OptionalArgument Timestamptz_comparison_exp
    , admin : OptionalArgument Admin_cdb_bool_exp
    , adminId : OptionalArgument Uuid_comparison_exp
    , adminStructureId : OptionalArgument Uuid_comparison_exp
    , admin_structure : OptionalArgument Admin_structure_bool_exp
    , beneficiary : OptionalArgument Beneficiary_bool_exp
    , beneficiaryId : OptionalArgument Uuid_comparison_exp
    , confirmed : OptionalArgument Boolean_comparison_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , deletedAt : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , lastLogin : OptionalArgument Timestamptz_comparison_exp
    , manager : OptionalArgument Manager_bool_exp
    , managerId : OptionalArgument Uuid_comparison_exp
    , notebookActionsCreated : OptionalArgument Notebook_action_bool_exp
    , notebookActionsCreated_aggregate : OptionalArgument Notebook_action_aggregate_bool_exp
    , notebookEventsCreated : OptionalArgument Notebook_event_bool_exp
    , notebookEventsCreated_aggregate : OptionalArgument Notebook_event_aggregate_bool_exp
    , notebookFocusesCreated : OptionalArgument Notebook_focus_bool_exp
    , notebookFocusesCreated_aggregate : OptionalArgument Notebook_focus_aggregate_bool_exp
    , notebookTargetsCreated : OptionalArgument Notebook_target_bool_exp
    , notebookTargetsCreated_aggregate : OptionalArgument Notebook_target_aggregate_bool_exp
    , notebooksCreated : OptionalArgument Notebook_member_bool_exp
    , notebooksCreated_aggregate : OptionalArgument Notebook_member_aggregate_bool_exp
    , notebooksWhereMember : OptionalArgument Notebook_member_bool_exp
    , notebooksWhereMember_aggregate : OptionalArgument Notebook_member_aggregate_bool_exp
    , onboardingDone : OptionalArgument Boolean_comparison_exp
    , orientationManagerId : OptionalArgument Uuid_comparison_exp
    , orientation_manager : OptionalArgument Orientation_manager_bool_exp
    , professional : OptionalArgument Professional_bool_exp
    , professionalId : OptionalArgument Uuid_comparison_exp
    , role : OptionalArgument Role_bool_exp
    , type_ : OptionalArgument Role_enum_comparison_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    , username : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Account_bool_exp` attributes. Note that this type
needs to use the `Account_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Account_bool_expRaw =
    { and_ : OptionalArgument (List Account_bool_exp)
    , not_ : OptionalArgument Account_bool_exp
    , or_ : OptionalArgument (List Account_bool_exp)
    , accessKey : OptionalArgument String_comparison_exp
    , accessKeyDate : OptionalArgument Timestamptz_comparison_exp
    , admin : OptionalArgument Admin_cdb_bool_exp
    , adminId : OptionalArgument Uuid_comparison_exp
    , adminStructureId : OptionalArgument Uuid_comparison_exp
    , admin_structure : OptionalArgument Admin_structure_bool_exp
    , beneficiary : OptionalArgument Beneficiary_bool_exp
    , beneficiaryId : OptionalArgument Uuid_comparison_exp
    , confirmed : OptionalArgument Boolean_comparison_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , deletedAt : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , lastLogin : OptionalArgument Timestamptz_comparison_exp
    , manager : OptionalArgument Manager_bool_exp
    , managerId : OptionalArgument Uuid_comparison_exp
    , notebookActionsCreated : OptionalArgument Notebook_action_bool_exp
    , notebookActionsCreated_aggregate : OptionalArgument Notebook_action_aggregate_bool_exp
    , notebookEventsCreated : OptionalArgument Notebook_event_bool_exp
    , notebookEventsCreated_aggregate : OptionalArgument Notebook_event_aggregate_bool_exp
    , notebookFocusesCreated : OptionalArgument Notebook_focus_bool_exp
    , notebookFocusesCreated_aggregate : OptionalArgument Notebook_focus_aggregate_bool_exp
    , notebookTargetsCreated : OptionalArgument Notebook_target_bool_exp
    , notebookTargetsCreated_aggregate : OptionalArgument Notebook_target_aggregate_bool_exp
    , notebooksCreated : OptionalArgument Notebook_member_bool_exp
    , notebooksCreated_aggregate : OptionalArgument Notebook_member_aggregate_bool_exp
    , notebooksWhereMember : OptionalArgument Notebook_member_bool_exp
    , notebooksWhereMember_aggregate : OptionalArgument Notebook_member_aggregate_bool_exp
    , onboardingDone : OptionalArgument Boolean_comparison_exp
    , orientationManagerId : OptionalArgument Uuid_comparison_exp
    , orientation_manager : OptionalArgument Orientation_manager_bool_exp
    , professional : OptionalArgument Professional_bool_exp
    , professionalId : OptionalArgument Uuid_comparison_exp
    , role : OptionalArgument Role_bool_exp
    , type_ : OptionalArgument Role_enum_comparison_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    , username : OptionalArgument String_comparison_exp
    }


{-| Type for the Account\_bool\_exp input object.
-}
type Account_bool_exp
    = Account_bool_exp Account_bool_expRaw


{-| Encode a Account\_bool\_exp into a value that can be used as an argument.
-}
encodeAccount_bool_exp : Account_bool_exp -> Value
encodeAccount_bool_exp (Account_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeAccount_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeAccount_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeAccount_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "accessKey", encodeString_comparison_exp |> Encode.optional input____.accessKey ), ( "accessKeyDate", encodeTimestamptz_comparison_exp |> Encode.optional input____.accessKeyDate ), ( "admin", encodeAdmin_cdb_bool_exp |> Encode.optional input____.admin ), ( "adminId", encodeUuid_comparison_exp |> Encode.optional input____.adminId ), ( "adminStructureId", encodeUuid_comparison_exp |> Encode.optional input____.adminStructureId ), ( "admin_structure", encodeAdmin_structure_bool_exp |> Encode.optional input____.admin_structure ), ( "beneficiary", encodeBeneficiary_bool_exp |> Encode.optional input____.beneficiary ), ( "beneficiaryId", encodeUuid_comparison_exp |> Encode.optional input____.beneficiaryId ), ( "confirmed", encodeBoolean_comparison_exp |> Encode.optional input____.confirmed ), ( "createdAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.createdAt ), ( "deletedAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.deletedAt ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "lastLogin", encodeTimestamptz_comparison_exp |> Encode.optional input____.lastLogin ), ( "manager", encodeManager_bool_exp |> Encode.optional input____.manager ), ( "managerId", encodeUuid_comparison_exp |> Encode.optional input____.managerId ), ( "notebookActionsCreated", encodeNotebook_action_bool_exp |> Encode.optional input____.notebookActionsCreated ), ( "notebookActionsCreated_aggregate", encodeNotebook_action_aggregate_bool_exp |> Encode.optional input____.notebookActionsCreated_aggregate ), ( "notebookEventsCreated", encodeNotebook_event_bool_exp |> Encode.optional input____.notebookEventsCreated ), ( "notebookEventsCreated_aggregate", encodeNotebook_event_aggregate_bool_exp |> Encode.optional input____.notebookEventsCreated_aggregate ), ( "notebookFocusesCreated", encodeNotebook_focus_bool_exp |> Encode.optional input____.notebookFocusesCreated ), ( "notebookFocusesCreated_aggregate", encodeNotebook_focus_aggregate_bool_exp |> Encode.optional input____.notebookFocusesCreated_aggregate ), ( "notebookTargetsCreated", encodeNotebook_target_bool_exp |> Encode.optional input____.notebookTargetsCreated ), ( "notebookTargetsCreated_aggregate", encodeNotebook_target_aggregate_bool_exp |> Encode.optional input____.notebookTargetsCreated_aggregate ), ( "notebooksCreated", encodeNotebook_member_bool_exp |> Encode.optional input____.notebooksCreated ), ( "notebooksCreated_aggregate", encodeNotebook_member_aggregate_bool_exp |> Encode.optional input____.notebooksCreated_aggregate ), ( "notebooksWhereMember", encodeNotebook_member_bool_exp |> Encode.optional input____.notebooksWhereMember ), ( "notebooksWhereMember_aggregate", encodeNotebook_member_aggregate_bool_exp |> Encode.optional input____.notebooksWhereMember_aggregate ), ( "onboardingDone", encodeBoolean_comparison_exp |> Encode.optional input____.onboardingDone ), ( "orientationManagerId", encodeUuid_comparison_exp |> Encode.optional input____.orientationManagerId ), ( "orientation_manager", encodeOrientation_manager_bool_exp |> Encode.optional input____.orientation_manager ), ( "professional", encodeProfessional_bool_exp |> Encode.optional input____.professional ), ( "professionalId", encodeUuid_comparison_exp |> Encode.optional input____.professionalId ), ( "role", encodeRole_bool_exp |> Encode.optional input____.role ), ( "type", encodeRole_enum_comparison_exp |> Encode.optional input____.type_ ), ( "updatedAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.updatedAt ), ( "username", encodeString_comparison_exp |> Encode.optional input____.username ) ]


buildAccount_info_bool_exp :
    (Account_info_bool_expOptionalFields -> Account_info_bool_expOptionalFields)
    -> Account_info_bool_exp
buildAccount_info_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, account_id = Absent, email = Absent, firstname = Absent, lastname = Absent }
    in
    Account_info_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, account_id = optionals____.account_id, email = optionals____.email, firstname = optionals____.firstname, lastname = optionals____.lastname }


type alias Account_info_bool_expOptionalFields =
    { and_ : OptionalArgument (List Account_info_bool_exp)
    , not_ : OptionalArgument Account_info_bool_exp
    , or_ : OptionalArgument (List Account_info_bool_exp)
    , account_id : OptionalArgument Uuid_comparison_exp
    , email : OptionalArgument Citext_comparison_exp
    , firstname : OptionalArgument String_comparison_exp
    , lastname : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Account_info_bool_exp` attributes. Note that this type
needs to use the `Account_info_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Account_info_bool_expRaw =
    { and_ : OptionalArgument (List Account_info_bool_exp)
    , not_ : OptionalArgument Account_info_bool_exp
    , or_ : OptionalArgument (List Account_info_bool_exp)
    , account_id : OptionalArgument Uuid_comparison_exp
    , email : OptionalArgument Citext_comparison_exp
    , firstname : OptionalArgument String_comparison_exp
    , lastname : OptionalArgument String_comparison_exp
    }


{-| Type for the Account\_info\_bool\_exp input object.
-}
type Account_info_bool_exp
    = Account_info_bool_exp Account_info_bool_expRaw


{-| Encode a Account\_info\_bool\_exp into a value that can be used as an argument.
-}
encodeAccount_info_bool_exp : Account_info_bool_exp -> Value
encodeAccount_info_bool_exp (Account_info_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeAccount_info_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeAccount_info_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeAccount_info_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "account_id", encodeUuid_comparison_exp |> Encode.optional input____.account_id ), ( "email", encodeCitext_comparison_exp |> Encode.optional input____.email ), ( "firstname", encodeString_comparison_exp |> Encode.optional input____.firstname ), ( "lastname", encodeString_comparison_exp |> Encode.optional input____.lastname ) ]


buildAccount_info_order_by :
    (Account_info_order_byOptionalFields -> Account_info_order_byOptionalFields)
    -> Account_info_order_by
buildAccount_info_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { account_id = Absent, email = Absent, firstname = Absent, lastname = Absent }
    in
    { account_id = optionals____.account_id, email = optionals____.email, firstname = optionals____.firstname, lastname = optionals____.lastname }


type alias Account_info_order_byOptionalFields =
    { account_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Account\_info\_order\_by input object.
-}
type alias Account_info_order_by =
    { account_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Account\_info\_order\_by into a value that can be used as an argument.
-}
encodeAccount_info_order_by : Account_info_order_by -> Value
encodeAccount_info_order_by input____ =
    Encode.maybeObject
        [ ( "account_id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.account_id ), ( "email", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.email ), ( "firstname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.firstname ), ( "lastname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.lastname ) ]


buildAccount_info_stream_cursor_input :
    Account_info_stream_cursor_inputRequiredFields
    -> (Account_info_stream_cursor_inputOptionalFields -> Account_info_stream_cursor_inputOptionalFields)
    -> Account_info_stream_cursor_input
buildAccount_info_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Account_info_stream_cursor_inputRequiredFields =
    { initial_value : Account_info_stream_cursor_value_input }


type alias Account_info_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Account\_info\_stream\_cursor\_input input object.
-}
type alias Account_info_stream_cursor_input =
    { initial_value : Account_info_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Account\_info\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeAccount_info_stream_cursor_input : Account_info_stream_cursor_input -> Value
encodeAccount_info_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeAccount_info_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildAccount_info_stream_cursor_value_input :
    (Account_info_stream_cursor_value_inputOptionalFields -> Account_info_stream_cursor_value_inputOptionalFields)
    -> Account_info_stream_cursor_value_input
buildAccount_info_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { account_id = Absent, email = Absent, firstname = Absent, lastname = Absent }
    in
    { account_id = optionals____.account_id, email = optionals____.email, firstname = optionals____.firstname, lastname = optionals____.lastname }


type alias Account_info_stream_cursor_value_inputOptionalFields =
    { account_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , lastname : OptionalArgument String
    }


{-| Type for the Account\_info\_stream\_cursor\_value\_input input object.
-}
type alias Account_info_stream_cursor_value_input =
    { account_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , lastname : OptionalArgument String
    }


{-| Encode a Account\_info\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeAccount_info_stream_cursor_value_input : Account_info_stream_cursor_value_input -> Value
encodeAccount_info_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "account_id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.account_id ), ( "email", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.email ), ( "firstname", Encode.string |> Encode.optional input____.firstname ), ( "lastname", Encode.string |> Encode.optional input____.lastname ) ]


buildAccount_insert_input :
    (Account_insert_inputOptionalFields -> Account_insert_inputOptionalFields)
    -> Account_insert_input
buildAccount_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { accessKey = Absent, accessKeyDate = Absent, admin = Absent, adminId = Absent, adminStructureId = Absent, admin_structure = Absent, beneficiary = Absent, beneficiaryId = Absent, confirmed = Absent, createdAt = Absent, deletedAt = Absent, id = Absent, lastLogin = Absent, manager = Absent, managerId = Absent, notebookActionsCreated = Absent, notebookEventsCreated = Absent, notebookFocusesCreated = Absent, notebookTargetsCreated = Absent, notebooksCreated = Absent, notebooksWhereMember = Absent, onboardingDone = Absent, orientationManagerId = Absent, orientation_manager = Absent, professional = Absent, professionalId = Absent, role = Absent, type_ = Absent, updatedAt = Absent, username = Absent }
    in
    Account_insert_input { accessKey = optionals____.accessKey, accessKeyDate = optionals____.accessKeyDate, admin = optionals____.admin, adminId = optionals____.adminId, adminStructureId = optionals____.adminStructureId, admin_structure = optionals____.admin_structure, beneficiary = optionals____.beneficiary, beneficiaryId = optionals____.beneficiaryId, confirmed = optionals____.confirmed, createdAt = optionals____.createdAt, deletedAt = optionals____.deletedAt, id = optionals____.id, lastLogin = optionals____.lastLogin, manager = optionals____.manager, managerId = optionals____.managerId, notebookActionsCreated = optionals____.notebookActionsCreated, notebookEventsCreated = optionals____.notebookEventsCreated, notebookFocusesCreated = optionals____.notebookFocusesCreated, notebookTargetsCreated = optionals____.notebookTargetsCreated, notebooksCreated = optionals____.notebooksCreated, notebooksWhereMember = optionals____.notebooksWhereMember, onboardingDone = optionals____.onboardingDone, orientationManagerId = optionals____.orientationManagerId, orientation_manager = optionals____.orientation_manager, professional = optionals____.professional, professionalId = optionals____.professionalId, role = optionals____.role, type_ = optionals____.type_, updatedAt = optionals____.updatedAt, username = optionals____.username }


type alias Account_insert_inputOptionalFields =
    { accessKey : OptionalArgument String
    , accessKeyDate : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , admin : OptionalArgument Admin_cdb_obj_rel_insert_input
    , adminId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , adminStructureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , admin_structure : OptionalArgument Admin_structure_obj_rel_insert_input
    , beneficiary : OptionalArgument Beneficiary_obj_rel_insert_input
    , beneficiaryId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , confirmed : OptionalArgument Bool
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deletedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastLogin : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , manager : OptionalArgument Manager_obj_rel_insert_input
    , managerId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , notebookActionsCreated : OptionalArgument Notebook_action_arr_rel_insert_input
    , notebookEventsCreated : OptionalArgument Notebook_event_arr_rel_insert_input
    , notebookFocusesCreated : OptionalArgument Notebook_focus_arr_rel_insert_input
    , notebookTargetsCreated : OptionalArgument Notebook_target_arr_rel_insert_input
    , notebooksCreated : OptionalArgument Notebook_member_arr_rel_insert_input
    , notebooksWhereMember : OptionalArgument Notebook_member_arr_rel_insert_input
    , onboardingDone : OptionalArgument Bool
    , orientationManagerId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , orientation_manager : OptionalArgument Orientation_manager_obj_rel_insert_input
    , professional : OptionalArgument Professional_obj_rel_insert_input
    , professionalId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , role : OptionalArgument Role_obj_rel_insert_input
    , type_ : OptionalArgument CdbGQL.Enum.Role_enum.Role_enum
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , username : OptionalArgument String
    }


{-| Type alias for the `Account_insert_input` attributes. Note that this type
needs to use the `Account_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Account_insert_inputRaw =
    { accessKey : OptionalArgument String
    , accessKeyDate : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , admin : OptionalArgument Admin_cdb_obj_rel_insert_input
    , adminId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , adminStructureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , admin_structure : OptionalArgument Admin_structure_obj_rel_insert_input
    , beneficiary : OptionalArgument Beneficiary_obj_rel_insert_input
    , beneficiaryId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , confirmed : OptionalArgument Bool
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deletedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastLogin : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , manager : OptionalArgument Manager_obj_rel_insert_input
    , managerId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , notebookActionsCreated : OptionalArgument Notebook_action_arr_rel_insert_input
    , notebookEventsCreated : OptionalArgument Notebook_event_arr_rel_insert_input
    , notebookFocusesCreated : OptionalArgument Notebook_focus_arr_rel_insert_input
    , notebookTargetsCreated : OptionalArgument Notebook_target_arr_rel_insert_input
    , notebooksCreated : OptionalArgument Notebook_member_arr_rel_insert_input
    , notebooksWhereMember : OptionalArgument Notebook_member_arr_rel_insert_input
    , onboardingDone : OptionalArgument Bool
    , orientationManagerId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , orientation_manager : OptionalArgument Orientation_manager_obj_rel_insert_input
    , professional : OptionalArgument Professional_obj_rel_insert_input
    , professionalId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , role : OptionalArgument Role_obj_rel_insert_input
    , type_ : OptionalArgument CdbGQL.Enum.Role_enum.Role_enum
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , username : OptionalArgument String
    }


{-| Type for the Account\_insert\_input input object.
-}
type Account_insert_input
    = Account_insert_input Account_insert_inputRaw


{-| Encode a Account\_insert\_input into a value that can be used as an argument.
-}
encodeAccount_insert_input : Account_insert_input -> Value
encodeAccount_insert_input (Account_insert_input input____) =
    Encode.maybeObject
        [ ( "accessKey", Encode.string |> Encode.optional input____.accessKey ), ( "accessKeyDate", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.accessKeyDate ), ( "admin", encodeAdmin_cdb_obj_rel_insert_input |> Encode.optional input____.admin ), ( "adminId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.adminId ), ( "adminStructureId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.adminStructureId ), ( "admin_structure", encodeAdmin_structure_obj_rel_insert_input |> Encode.optional input____.admin_structure ), ( "beneficiary", encodeBeneficiary_obj_rel_insert_input |> Encode.optional input____.beneficiary ), ( "beneficiaryId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.beneficiaryId ), ( "confirmed", Encode.bool |> Encode.optional input____.confirmed ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "deletedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.deletedAt ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "lastLogin", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.lastLogin ), ( "manager", encodeManager_obj_rel_insert_input |> Encode.optional input____.manager ), ( "managerId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.managerId ), ( "notebookActionsCreated", encodeNotebook_action_arr_rel_insert_input |> Encode.optional input____.notebookActionsCreated ), ( "notebookEventsCreated", encodeNotebook_event_arr_rel_insert_input |> Encode.optional input____.notebookEventsCreated ), ( "notebookFocusesCreated", encodeNotebook_focus_arr_rel_insert_input |> Encode.optional input____.notebookFocusesCreated ), ( "notebookTargetsCreated", encodeNotebook_target_arr_rel_insert_input |> Encode.optional input____.notebookTargetsCreated ), ( "notebooksCreated", encodeNotebook_member_arr_rel_insert_input |> Encode.optional input____.notebooksCreated ), ( "notebooksWhereMember", encodeNotebook_member_arr_rel_insert_input |> Encode.optional input____.notebooksWhereMember ), ( "onboardingDone", Encode.bool |> Encode.optional input____.onboardingDone ), ( "orientationManagerId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.orientationManagerId ), ( "orientation_manager", encodeOrientation_manager_obj_rel_insert_input |> Encode.optional input____.orientation_manager ), ( "professional", encodeProfessional_obj_rel_insert_input |> Encode.optional input____.professional ), ( "professionalId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.professionalId ), ( "role", encodeRole_obj_rel_insert_input |> Encode.optional input____.role ), ( "type", Encode.enum CdbGQL.Enum.Role_enum.toString |> Encode.optional input____.type_ ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ), ( "username", Encode.string |> Encode.optional input____.username ) ]


buildAccount_max_order_by :
    (Account_max_order_byOptionalFields -> Account_max_order_byOptionalFields)
    -> Account_max_order_by
buildAccount_max_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { accessKey = Absent, accessKeyDate = Absent, adminId = Absent, adminStructureId = Absent, beneficiaryId = Absent, createdAt = Absent, deletedAt = Absent, id = Absent, lastLogin = Absent, managerId = Absent, orientationManagerId = Absent, professionalId = Absent, updatedAt = Absent, username = Absent }
    in
    { accessKey = optionals____.accessKey, accessKeyDate = optionals____.accessKeyDate, adminId = optionals____.adminId, adminStructureId = optionals____.adminStructureId, beneficiaryId = optionals____.beneficiaryId, createdAt = optionals____.createdAt, deletedAt = optionals____.deletedAt, id = optionals____.id, lastLogin = optionals____.lastLogin, managerId = optionals____.managerId, orientationManagerId = optionals____.orientationManagerId, professionalId = optionals____.professionalId, updatedAt = optionals____.updatedAt, username = optionals____.username }


type alias Account_max_order_byOptionalFields =
    { accessKey : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , accessKeyDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , adminId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , adminStructureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , beneficiaryId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deletedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastLogin : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , managerId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationManagerId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , professionalId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , username : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Account\_max\_order\_by input object.
-}
type alias Account_max_order_by =
    { accessKey : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , accessKeyDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , adminId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , adminStructureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , beneficiaryId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deletedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastLogin : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , managerId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationManagerId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , professionalId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , username : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Account\_max\_order\_by into a value that can be used as an argument.
-}
encodeAccount_max_order_by : Account_max_order_by -> Value
encodeAccount_max_order_by input____ =
    Encode.maybeObject
        [ ( "accessKey", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.accessKey ), ( "accessKeyDate", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.accessKeyDate ), ( "adminId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.adminId ), ( "adminStructureId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.adminStructureId ), ( "beneficiaryId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.beneficiaryId ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "deletedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deletedAt ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "lastLogin", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.lastLogin ), ( "managerId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.managerId ), ( "orientationManagerId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.orientationManagerId ), ( "professionalId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.professionalId ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ), ( "username", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.username ) ]


buildAccount_min_order_by :
    (Account_min_order_byOptionalFields -> Account_min_order_byOptionalFields)
    -> Account_min_order_by
buildAccount_min_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { accessKey = Absent, accessKeyDate = Absent, adminId = Absent, adminStructureId = Absent, beneficiaryId = Absent, createdAt = Absent, deletedAt = Absent, id = Absent, lastLogin = Absent, managerId = Absent, orientationManagerId = Absent, professionalId = Absent, updatedAt = Absent, username = Absent }
    in
    { accessKey = optionals____.accessKey, accessKeyDate = optionals____.accessKeyDate, adminId = optionals____.adminId, adminStructureId = optionals____.adminStructureId, beneficiaryId = optionals____.beneficiaryId, createdAt = optionals____.createdAt, deletedAt = optionals____.deletedAt, id = optionals____.id, lastLogin = optionals____.lastLogin, managerId = optionals____.managerId, orientationManagerId = optionals____.orientationManagerId, professionalId = optionals____.professionalId, updatedAt = optionals____.updatedAt, username = optionals____.username }


type alias Account_min_order_byOptionalFields =
    { accessKey : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , accessKeyDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , adminId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , adminStructureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , beneficiaryId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deletedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastLogin : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , managerId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationManagerId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , professionalId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , username : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Account\_min\_order\_by input object.
-}
type alias Account_min_order_by =
    { accessKey : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , accessKeyDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , adminId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , adminStructureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , beneficiaryId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deletedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastLogin : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , managerId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationManagerId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , professionalId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , username : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Account\_min\_order\_by into a value that can be used as an argument.
-}
encodeAccount_min_order_by : Account_min_order_by -> Value
encodeAccount_min_order_by input____ =
    Encode.maybeObject
        [ ( "accessKey", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.accessKey ), ( "accessKeyDate", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.accessKeyDate ), ( "adminId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.adminId ), ( "adminStructureId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.adminStructureId ), ( "beneficiaryId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.beneficiaryId ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "deletedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deletedAt ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "lastLogin", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.lastLogin ), ( "managerId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.managerId ), ( "orientationManagerId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.orientationManagerId ), ( "professionalId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.professionalId ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ), ( "username", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.username ) ]


buildAccount_obj_rel_insert_input :
    Account_obj_rel_insert_inputRequiredFields
    -> (Account_obj_rel_insert_inputOptionalFields -> Account_obj_rel_insert_inputOptionalFields)
    -> Account_obj_rel_insert_input
buildAccount_obj_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Account_obj_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Account_obj_rel_insert_inputRequiredFields =
    { data : Account_insert_input }


type alias Account_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Account_on_conflict }


{-| Type alias for the `Account_obj_rel_insert_input` attributes. Note that this type
needs to use the `Account_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Account_obj_rel_insert_inputRaw =
    { data : Account_insert_input
    , on_conflict : OptionalArgument Account_on_conflict
    }


{-| Type for the Account\_obj\_rel\_insert\_input input object.
-}
type Account_obj_rel_insert_input
    = Account_obj_rel_insert_input Account_obj_rel_insert_inputRaw


{-| Encode a Account\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeAccount_obj_rel_insert_input : Account_obj_rel_insert_input -> Value
encodeAccount_obj_rel_insert_input (Account_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeAccount_insert_input input____.data |> Just ), ( "on_conflict", encodeAccount_on_conflict |> Encode.optional input____.on_conflict ) ]


buildAccount_on_conflict :
    Account_on_conflictRequiredFields
    -> (Account_on_conflictOptionalFields -> Account_on_conflictOptionalFields)
    -> Account_on_conflict
buildAccount_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Account_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Account_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Account_constraint.Account_constraint
    , update_columns : List CdbGQL.Enum.Account_update_column.Account_update_column
    }


type alias Account_on_conflictOptionalFields =
    { where_ : OptionalArgument Account_bool_exp }


{-| Type alias for the `Account_on_conflict` attributes. Note that this type
needs to use the `Account_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Account_on_conflictRaw =
    { constraint : CdbGQL.Enum.Account_constraint.Account_constraint
    , update_columns : List CdbGQL.Enum.Account_update_column.Account_update_column
    , where_ : OptionalArgument Account_bool_exp
    }


{-| Type for the Account\_on\_conflict input object.
-}
type Account_on_conflict
    = Account_on_conflict Account_on_conflictRaw


{-| Encode a Account\_on\_conflict into a value that can be used as an argument.
-}
encodeAccount_on_conflict : Account_on_conflict -> Value
encodeAccount_on_conflict (Account_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Account_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Account_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeAccount_bool_exp |> Encode.optional input____.where_ ) ]


buildAccount_order_by :
    (Account_order_byOptionalFields -> Account_order_byOptionalFields)
    -> Account_order_by
buildAccount_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { accessKey = Absent, accessKeyDate = Absent, admin = Absent, adminId = Absent, adminStructureId = Absent, admin_structure = Absent, beneficiary = Absent, beneficiaryId = Absent, confirmed = Absent, createdAt = Absent, deletedAt = Absent, id = Absent, lastLogin = Absent, manager = Absent, managerId = Absent, notebookActionsCreated_aggregate = Absent, notebookEventsCreated_aggregate = Absent, notebookFocusesCreated_aggregate = Absent, notebookTargetsCreated_aggregate = Absent, notebooksCreated_aggregate = Absent, notebooksWhereMember_aggregate = Absent, onboardingDone = Absent, orientationManagerId = Absent, orientation_manager = Absent, professional = Absent, professionalId = Absent, role = Absent, type_ = Absent, updatedAt = Absent, username = Absent }
    in
    Account_order_by { accessKey = optionals____.accessKey, accessKeyDate = optionals____.accessKeyDate, admin = optionals____.admin, adminId = optionals____.adminId, adminStructureId = optionals____.adminStructureId, admin_structure = optionals____.admin_structure, beneficiary = optionals____.beneficiary, beneficiaryId = optionals____.beneficiaryId, confirmed = optionals____.confirmed, createdAt = optionals____.createdAt, deletedAt = optionals____.deletedAt, id = optionals____.id, lastLogin = optionals____.lastLogin, manager = optionals____.manager, managerId = optionals____.managerId, notebookActionsCreated_aggregate = optionals____.notebookActionsCreated_aggregate, notebookEventsCreated_aggregate = optionals____.notebookEventsCreated_aggregate, notebookFocusesCreated_aggregate = optionals____.notebookFocusesCreated_aggregate, notebookTargetsCreated_aggregate = optionals____.notebookTargetsCreated_aggregate, notebooksCreated_aggregate = optionals____.notebooksCreated_aggregate, notebooksWhereMember_aggregate = optionals____.notebooksWhereMember_aggregate, onboardingDone = optionals____.onboardingDone, orientationManagerId = optionals____.orientationManagerId, orientation_manager = optionals____.orientation_manager, professional = optionals____.professional, professionalId = optionals____.professionalId, role = optionals____.role, type_ = optionals____.type_, updatedAt = optionals____.updatedAt, username = optionals____.username }


type alias Account_order_byOptionalFields =
    { accessKey : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , accessKeyDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , admin : OptionalArgument Admin_cdb_order_by
    , adminId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , adminStructureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , admin_structure : OptionalArgument Admin_structure_order_by
    , beneficiary : OptionalArgument Beneficiary_order_by
    , beneficiaryId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , confirmed : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deletedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastLogin : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , manager : OptionalArgument Manager_order_by
    , managerId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebookActionsCreated_aggregate : OptionalArgument Notebook_action_aggregate_order_by
    , notebookEventsCreated_aggregate : OptionalArgument Notebook_event_aggregate_order_by
    , notebookFocusesCreated_aggregate : OptionalArgument Notebook_focus_aggregate_order_by
    , notebookTargetsCreated_aggregate : OptionalArgument Notebook_target_aggregate_order_by
    , notebooksCreated_aggregate : OptionalArgument Notebook_member_aggregate_order_by
    , notebooksWhereMember_aggregate : OptionalArgument Notebook_member_aggregate_order_by
    , onboardingDone : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationManagerId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientation_manager : OptionalArgument Orientation_manager_order_by
    , professional : OptionalArgument Professional_order_by
    , professionalId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , role : OptionalArgument Role_order_by
    , type_ : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , username : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type alias for the `Account_order_by` attributes. Note that this type
needs to use the `Account_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Account_order_byRaw =
    { accessKey : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , accessKeyDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , admin : OptionalArgument Admin_cdb_order_by
    , adminId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , adminStructureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , admin_structure : OptionalArgument Admin_structure_order_by
    , beneficiary : OptionalArgument Beneficiary_order_by
    , beneficiaryId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , confirmed : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deletedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastLogin : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , manager : OptionalArgument Manager_order_by
    , managerId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebookActionsCreated_aggregate : OptionalArgument Notebook_action_aggregate_order_by
    , notebookEventsCreated_aggregate : OptionalArgument Notebook_event_aggregate_order_by
    , notebookFocusesCreated_aggregate : OptionalArgument Notebook_focus_aggregate_order_by
    , notebookTargetsCreated_aggregate : OptionalArgument Notebook_target_aggregate_order_by
    , notebooksCreated_aggregate : OptionalArgument Notebook_member_aggregate_order_by
    , notebooksWhereMember_aggregate : OptionalArgument Notebook_member_aggregate_order_by
    , onboardingDone : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationManagerId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientation_manager : OptionalArgument Orientation_manager_order_by
    , professional : OptionalArgument Professional_order_by
    , professionalId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , role : OptionalArgument Role_order_by
    , type_ : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , username : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Account\_order\_by input object.
-}
type Account_order_by
    = Account_order_by Account_order_byRaw


{-| Encode a Account\_order\_by into a value that can be used as an argument.
-}
encodeAccount_order_by : Account_order_by -> Value
encodeAccount_order_by (Account_order_by input____) =
    Encode.maybeObject
        [ ( "accessKey", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.accessKey ), ( "accessKeyDate", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.accessKeyDate ), ( "admin", encodeAdmin_cdb_order_by |> Encode.optional input____.admin ), ( "adminId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.adminId ), ( "adminStructureId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.adminStructureId ), ( "admin_structure", encodeAdmin_structure_order_by |> Encode.optional input____.admin_structure ), ( "beneficiary", encodeBeneficiary_order_by |> Encode.optional input____.beneficiary ), ( "beneficiaryId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.beneficiaryId ), ( "confirmed", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.confirmed ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "deletedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deletedAt ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "lastLogin", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.lastLogin ), ( "manager", encodeManager_order_by |> Encode.optional input____.manager ), ( "managerId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.managerId ), ( "notebookActionsCreated_aggregate", encodeNotebook_action_aggregate_order_by |> Encode.optional input____.notebookActionsCreated_aggregate ), ( "notebookEventsCreated_aggregate", encodeNotebook_event_aggregate_order_by |> Encode.optional input____.notebookEventsCreated_aggregate ), ( "notebookFocusesCreated_aggregate", encodeNotebook_focus_aggregate_order_by |> Encode.optional input____.notebookFocusesCreated_aggregate ), ( "notebookTargetsCreated_aggregate", encodeNotebook_target_aggregate_order_by |> Encode.optional input____.notebookTargetsCreated_aggregate ), ( "notebooksCreated_aggregate", encodeNotebook_member_aggregate_order_by |> Encode.optional input____.notebooksCreated_aggregate ), ( "notebooksWhereMember_aggregate", encodeNotebook_member_aggregate_order_by |> Encode.optional input____.notebooksWhereMember_aggregate ), ( "onboardingDone", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.onboardingDone ), ( "orientationManagerId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.orientationManagerId ), ( "orientation_manager", encodeOrientation_manager_order_by |> Encode.optional input____.orientation_manager ), ( "professional", encodeProfessional_order_by |> Encode.optional input____.professional ), ( "professionalId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.professionalId ), ( "role", encodeRole_order_by |> Encode.optional input____.role ), ( "type", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.type_ ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ), ( "username", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.username ) ]


buildAccount_pk_columns_input :
    Account_pk_columns_inputRequiredFields
    -> Account_pk_columns_input
buildAccount_pk_columns_input required____ =
    { id = required____.id }


type alias Account_pk_columns_inputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the Account\_pk\_columns\_input input object.
-}
type alias Account_pk_columns_input =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a Account\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeAccount_pk_columns_input : Account_pk_columns_input -> Value
encodeAccount_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildAccount_set_input :
    (Account_set_inputOptionalFields -> Account_set_inputOptionalFields)
    -> Account_set_input
buildAccount_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { accessKey = Absent, accessKeyDate = Absent, adminId = Absent, adminStructureId = Absent, beneficiaryId = Absent, confirmed = Absent, createdAt = Absent, deletedAt = Absent, id = Absent, lastLogin = Absent, managerId = Absent, onboardingDone = Absent, orientationManagerId = Absent, professionalId = Absent, type_ = Absent, updatedAt = Absent, username = Absent }
    in
    { accessKey = optionals____.accessKey, accessKeyDate = optionals____.accessKeyDate, adminId = optionals____.adminId, adminStructureId = optionals____.adminStructureId, beneficiaryId = optionals____.beneficiaryId, confirmed = optionals____.confirmed, createdAt = optionals____.createdAt, deletedAt = optionals____.deletedAt, id = optionals____.id, lastLogin = optionals____.lastLogin, managerId = optionals____.managerId, onboardingDone = optionals____.onboardingDone, orientationManagerId = optionals____.orientationManagerId, professionalId = optionals____.professionalId, type_ = optionals____.type_, updatedAt = optionals____.updatedAt, username = optionals____.username }


type alias Account_set_inputOptionalFields =
    { accessKey : OptionalArgument String
    , accessKeyDate : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , adminId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , adminStructureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , beneficiaryId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , confirmed : OptionalArgument Bool
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deletedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastLogin : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , managerId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , onboardingDone : OptionalArgument Bool
    , orientationManagerId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , professionalId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , type_ : OptionalArgument CdbGQL.Enum.Role_enum.Role_enum
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , username : OptionalArgument String
    }


{-| Type for the Account\_set\_input input object.
-}
type alias Account_set_input =
    { accessKey : OptionalArgument String
    , accessKeyDate : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , adminId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , adminStructureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , beneficiaryId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , confirmed : OptionalArgument Bool
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deletedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastLogin : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , managerId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , onboardingDone : OptionalArgument Bool
    , orientationManagerId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , professionalId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , type_ : OptionalArgument CdbGQL.Enum.Role_enum.Role_enum
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , username : OptionalArgument String
    }


{-| Encode a Account\_set\_input into a value that can be used as an argument.
-}
encodeAccount_set_input : Account_set_input -> Value
encodeAccount_set_input input____ =
    Encode.maybeObject
        [ ( "accessKey", Encode.string |> Encode.optional input____.accessKey ), ( "accessKeyDate", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.accessKeyDate ), ( "adminId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.adminId ), ( "adminStructureId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.adminStructureId ), ( "beneficiaryId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.beneficiaryId ), ( "confirmed", Encode.bool |> Encode.optional input____.confirmed ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "deletedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.deletedAt ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "lastLogin", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.lastLogin ), ( "managerId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.managerId ), ( "onboardingDone", Encode.bool |> Encode.optional input____.onboardingDone ), ( "orientationManagerId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.orientationManagerId ), ( "professionalId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.professionalId ), ( "type", Encode.enum CdbGQL.Enum.Role_enum.toString |> Encode.optional input____.type_ ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ), ( "username", Encode.string |> Encode.optional input____.username ) ]


buildAccount_stream_cursor_input :
    Account_stream_cursor_inputRequiredFields
    -> (Account_stream_cursor_inputOptionalFields -> Account_stream_cursor_inputOptionalFields)
    -> Account_stream_cursor_input
buildAccount_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Account_stream_cursor_inputRequiredFields =
    { initial_value : Account_stream_cursor_value_input }


type alias Account_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Account\_stream\_cursor\_input input object.
-}
type alias Account_stream_cursor_input =
    { initial_value : Account_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Account\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeAccount_stream_cursor_input : Account_stream_cursor_input -> Value
encodeAccount_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeAccount_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildAccount_stream_cursor_value_input :
    (Account_stream_cursor_value_inputOptionalFields -> Account_stream_cursor_value_inputOptionalFields)
    -> Account_stream_cursor_value_input
buildAccount_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { accessKey = Absent, accessKeyDate = Absent, adminId = Absent, adminStructureId = Absent, beneficiaryId = Absent, confirmed = Absent, createdAt = Absent, deletedAt = Absent, id = Absent, lastLogin = Absent, managerId = Absent, onboardingDone = Absent, orientationManagerId = Absent, professionalId = Absent, type_ = Absent, updatedAt = Absent, username = Absent }
    in
    { accessKey = optionals____.accessKey, accessKeyDate = optionals____.accessKeyDate, adminId = optionals____.adminId, adminStructureId = optionals____.adminStructureId, beneficiaryId = optionals____.beneficiaryId, confirmed = optionals____.confirmed, createdAt = optionals____.createdAt, deletedAt = optionals____.deletedAt, id = optionals____.id, lastLogin = optionals____.lastLogin, managerId = optionals____.managerId, onboardingDone = optionals____.onboardingDone, orientationManagerId = optionals____.orientationManagerId, professionalId = optionals____.professionalId, type_ = optionals____.type_, updatedAt = optionals____.updatedAt, username = optionals____.username }


type alias Account_stream_cursor_value_inputOptionalFields =
    { accessKey : OptionalArgument String
    , accessKeyDate : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , adminId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , adminStructureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , beneficiaryId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , confirmed : OptionalArgument Bool
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deletedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastLogin : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , managerId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , onboardingDone : OptionalArgument Bool
    , orientationManagerId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , professionalId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , type_ : OptionalArgument CdbGQL.Enum.Role_enum.Role_enum
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , username : OptionalArgument String
    }


{-| Type for the Account\_stream\_cursor\_value\_input input object.
-}
type alias Account_stream_cursor_value_input =
    { accessKey : OptionalArgument String
    , accessKeyDate : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , adminId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , adminStructureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , beneficiaryId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , confirmed : OptionalArgument Bool
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deletedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastLogin : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , managerId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , onboardingDone : OptionalArgument Bool
    , orientationManagerId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , professionalId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , type_ : OptionalArgument CdbGQL.Enum.Role_enum.Role_enum
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , username : OptionalArgument String
    }


{-| Encode a Account\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeAccount_stream_cursor_value_input : Account_stream_cursor_value_input -> Value
encodeAccount_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "accessKey", Encode.string |> Encode.optional input____.accessKey ), ( "accessKeyDate", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.accessKeyDate ), ( "adminId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.adminId ), ( "adminStructureId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.adminStructureId ), ( "beneficiaryId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.beneficiaryId ), ( "confirmed", Encode.bool |> Encode.optional input____.confirmed ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "deletedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.deletedAt ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "lastLogin", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.lastLogin ), ( "managerId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.managerId ), ( "onboardingDone", Encode.bool |> Encode.optional input____.onboardingDone ), ( "orientationManagerId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.orientationManagerId ), ( "professionalId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.professionalId ), ( "type", Encode.enum CdbGQL.Enum.Role_enum.toString |> Encode.optional input____.type_ ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ), ( "username", Encode.string |> Encode.optional input____.username ) ]


buildAccount_updates :
    Account_updatesRequiredFields
    -> (Account_updatesOptionalFields -> Account_updatesOptionalFields)
    -> Account_updates
buildAccount_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Account_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Account_updatesRequiredFields =
    { where_ : Account_bool_exp }


type alias Account_updatesOptionalFields =
    { set_ : OptionalArgument Account_set_input }


{-| Type alias for the `Account_updates` attributes. Note that this type
needs to use the `Account_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Account_updatesRaw =
    { set_ : OptionalArgument Account_set_input
    , where_ : Account_bool_exp
    }


{-| Type for the Account\_updates input object.
-}
type Account_updates
    = Account_updates Account_updatesRaw


{-| Encode a Account\_updates into a value that can be used as an argument.
-}
encodeAccount_updates : Account_updates -> Value
encodeAccount_updates (Account_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeAccount_set_input |> Encode.optional input____.set_ ), ( "where", encodeAccount_bool_exp input____.where_ |> Just ) ]


buildAction_status_bool_exp :
    (Action_status_bool_expOptionalFields -> Action_status_bool_expOptionalFields)
    -> Action_status_bool_exp
buildAction_status_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, notebook_actions = Absent, notebook_actions_aggregate = Absent, status = Absent }
    in
    Action_status_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, notebook_actions = optionals____.notebook_actions, notebook_actions_aggregate = optionals____.notebook_actions_aggregate, status = optionals____.status }


type alias Action_status_bool_expOptionalFields =
    { and_ : OptionalArgument (List Action_status_bool_exp)
    , not_ : OptionalArgument Action_status_bool_exp
    , or_ : OptionalArgument (List Action_status_bool_exp)
    , notebook_actions : OptionalArgument Notebook_action_bool_exp
    , notebook_actions_aggregate : OptionalArgument Notebook_action_aggregate_bool_exp
    , status : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Action_status_bool_exp` attributes. Note that this type
needs to use the `Action_status_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Action_status_bool_expRaw =
    { and_ : OptionalArgument (List Action_status_bool_exp)
    , not_ : OptionalArgument Action_status_bool_exp
    , or_ : OptionalArgument (List Action_status_bool_exp)
    , notebook_actions : OptionalArgument Notebook_action_bool_exp
    , notebook_actions_aggregate : OptionalArgument Notebook_action_aggregate_bool_exp
    , status : OptionalArgument String_comparison_exp
    }


{-| Type for the Action\_status\_bool\_exp input object.
-}
type Action_status_bool_exp
    = Action_status_bool_exp Action_status_bool_expRaw


{-| Encode a Action\_status\_bool\_exp into a value that can be used as an argument.
-}
encodeAction_status_bool_exp : Action_status_bool_exp -> Value
encodeAction_status_bool_exp (Action_status_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeAction_status_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeAction_status_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeAction_status_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "notebook_actions", encodeNotebook_action_bool_exp |> Encode.optional input____.notebook_actions ), ( "notebook_actions_aggregate", encodeNotebook_action_aggregate_bool_exp |> Encode.optional input____.notebook_actions_aggregate ), ( "status", encodeString_comparison_exp |> Encode.optional input____.status ) ]


buildAction_status_enum_comparison_exp :
    (Action_status_enum_comparison_expOptionalFields -> Action_status_enum_comparison_expOptionalFields)
    -> Action_status_enum_comparison_exp
buildAction_status_enum_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, in_ = Absent, is_null_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals____.eq_, in_ = optionals____.in_, is_null_ = optionals____.is_null_, neq_ = optionals____.neq_, nin_ = optionals____.nin_ }


type alias Action_status_enum_comparison_expOptionalFields =
    { eq_ : OptionalArgument CdbGQL.Enum.Action_status_enum.Action_status_enum
    , in_ : OptionalArgument (List CdbGQL.Enum.Action_status_enum.Action_status_enum)
    , is_null_ : OptionalArgument Bool
    , neq_ : OptionalArgument CdbGQL.Enum.Action_status_enum.Action_status_enum
    , nin_ : OptionalArgument (List CdbGQL.Enum.Action_status_enum.Action_status_enum)
    }


{-| Type for the Action\_status\_enum\_comparison\_exp input object.
-}
type alias Action_status_enum_comparison_exp =
    { eq_ : OptionalArgument CdbGQL.Enum.Action_status_enum.Action_status_enum
    , in_ : OptionalArgument (List CdbGQL.Enum.Action_status_enum.Action_status_enum)
    , is_null_ : OptionalArgument Bool
    , neq_ : OptionalArgument CdbGQL.Enum.Action_status_enum.Action_status_enum
    , nin_ : OptionalArgument (List CdbGQL.Enum.Action_status_enum.Action_status_enum)
    }


{-| Encode a Action\_status\_enum\_comparison\_exp into a value that can be used as an argument.
-}
encodeAction_status_enum_comparison_exp : Action_status_enum_comparison_exp -> Value
encodeAction_status_enum_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", Encode.enum CdbGQL.Enum.Action_status_enum.toString |> Encode.optional input____.eq_ ), ( "_in", (Encode.enum CdbGQL.Enum.Action_status_enum.toString |> Encode.list) |> Encode.optional input____.in_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_neq", Encode.enum CdbGQL.Enum.Action_status_enum.toString |> Encode.optional input____.neq_ ), ( "_nin", (Encode.enum CdbGQL.Enum.Action_status_enum.toString |> Encode.list) |> Encode.optional input____.nin_ ) ]


buildAction_status_insert_input :
    (Action_status_insert_inputOptionalFields -> Action_status_insert_inputOptionalFields)
    -> Action_status_insert_input
buildAction_status_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { notebook_actions = Absent, status = Absent }
    in
    Action_status_insert_input { notebook_actions = optionals____.notebook_actions, status = optionals____.status }


type alias Action_status_insert_inputOptionalFields =
    { notebook_actions : OptionalArgument Notebook_action_arr_rel_insert_input
    , status : OptionalArgument String
    }


{-| Type alias for the `Action_status_insert_input` attributes. Note that this type
needs to use the `Action_status_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Action_status_insert_inputRaw =
    { notebook_actions : OptionalArgument Notebook_action_arr_rel_insert_input
    , status : OptionalArgument String
    }


{-| Type for the Action\_status\_insert\_input input object.
-}
type Action_status_insert_input
    = Action_status_insert_input Action_status_insert_inputRaw


{-| Encode a Action\_status\_insert\_input into a value that can be used as an argument.
-}
encodeAction_status_insert_input : Action_status_insert_input -> Value
encodeAction_status_insert_input (Action_status_insert_input input____) =
    Encode.maybeObject
        [ ( "notebook_actions", encodeNotebook_action_arr_rel_insert_input |> Encode.optional input____.notebook_actions ), ( "status", Encode.string |> Encode.optional input____.status ) ]


buildAction_status_on_conflict :
    Action_status_on_conflictRequiredFields
    -> (Action_status_on_conflictOptionalFields -> Action_status_on_conflictOptionalFields)
    -> Action_status_on_conflict
buildAction_status_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Action_status_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Action_status_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Action_status_constraint.Action_status_constraint
    , update_columns : List CdbGQL.Enum.Action_status_update_column.Action_status_update_column
    }


type alias Action_status_on_conflictOptionalFields =
    { where_ : OptionalArgument Action_status_bool_exp }


{-| Type alias for the `Action_status_on_conflict` attributes. Note that this type
needs to use the `Action_status_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Action_status_on_conflictRaw =
    { constraint : CdbGQL.Enum.Action_status_constraint.Action_status_constraint
    , update_columns : List CdbGQL.Enum.Action_status_update_column.Action_status_update_column
    , where_ : OptionalArgument Action_status_bool_exp
    }


{-| Type for the Action\_status\_on\_conflict input object.
-}
type Action_status_on_conflict
    = Action_status_on_conflict Action_status_on_conflictRaw


{-| Encode a Action\_status\_on\_conflict into a value that can be used as an argument.
-}
encodeAction_status_on_conflict : Action_status_on_conflict -> Value
encodeAction_status_on_conflict (Action_status_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Action_status_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Action_status_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeAction_status_bool_exp |> Encode.optional input____.where_ ) ]


buildAction_status_order_by :
    (Action_status_order_byOptionalFields -> Action_status_order_byOptionalFields)
    -> Action_status_order_by
buildAction_status_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { notebook_actions_aggregate = Absent, status = Absent }
    in
    { notebook_actions_aggregate = optionals____.notebook_actions_aggregate, status = optionals____.status }


type alias Action_status_order_byOptionalFields =
    { notebook_actions_aggregate : OptionalArgument Notebook_action_aggregate_order_by
    , status : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Action\_status\_order\_by input object.
-}
type alias Action_status_order_by =
    { notebook_actions_aggregate : OptionalArgument Notebook_action_aggregate_order_by
    , status : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Action\_status\_order\_by into a value that can be used as an argument.
-}
encodeAction_status_order_by : Action_status_order_by -> Value
encodeAction_status_order_by input____ =
    Encode.maybeObject
        [ ( "notebook_actions_aggregate", encodeNotebook_action_aggregate_order_by |> Encode.optional input____.notebook_actions_aggregate ), ( "status", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.status ) ]


buildAction_status_pk_columns_input :
    Action_status_pk_columns_inputRequiredFields
    -> Action_status_pk_columns_input
buildAction_status_pk_columns_input required____ =
    { status = required____.status }


type alias Action_status_pk_columns_inputRequiredFields =
    { status : String }


{-| Type for the Action\_status\_pk\_columns\_input input object.
-}
type alias Action_status_pk_columns_input =
    { status : String }


{-| Encode a Action\_status\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeAction_status_pk_columns_input : Action_status_pk_columns_input -> Value
encodeAction_status_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "status", Encode.string input____.status |> Just ) ]


buildAction_status_set_input :
    (Action_status_set_inputOptionalFields -> Action_status_set_inputOptionalFields)
    -> Action_status_set_input
buildAction_status_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { status = Absent }
    in
    { status = optionals____.status }


type alias Action_status_set_inputOptionalFields =
    { status : OptionalArgument String }


{-| Type for the Action\_status\_set\_input input object.
-}
type alias Action_status_set_input =
    { status : OptionalArgument String }


{-| Encode a Action\_status\_set\_input into a value that can be used as an argument.
-}
encodeAction_status_set_input : Action_status_set_input -> Value
encodeAction_status_set_input input____ =
    Encode.maybeObject
        [ ( "status", Encode.string |> Encode.optional input____.status ) ]


buildAction_status_stream_cursor_input :
    Action_status_stream_cursor_inputRequiredFields
    -> (Action_status_stream_cursor_inputOptionalFields -> Action_status_stream_cursor_inputOptionalFields)
    -> Action_status_stream_cursor_input
buildAction_status_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Action_status_stream_cursor_inputRequiredFields =
    { initial_value : Action_status_stream_cursor_value_input }


type alias Action_status_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Action\_status\_stream\_cursor\_input input object.
-}
type alias Action_status_stream_cursor_input =
    { initial_value : Action_status_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Action\_status\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeAction_status_stream_cursor_input : Action_status_stream_cursor_input -> Value
encodeAction_status_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeAction_status_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildAction_status_stream_cursor_value_input :
    (Action_status_stream_cursor_value_inputOptionalFields -> Action_status_stream_cursor_value_inputOptionalFields)
    -> Action_status_stream_cursor_value_input
buildAction_status_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { status = Absent }
    in
    { status = optionals____.status }


type alias Action_status_stream_cursor_value_inputOptionalFields =
    { status : OptionalArgument String }


{-| Type for the Action\_status\_stream\_cursor\_value\_input input object.
-}
type alias Action_status_stream_cursor_value_input =
    { status : OptionalArgument String }


{-| Encode a Action\_status\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeAction_status_stream_cursor_value_input : Action_status_stream_cursor_value_input -> Value
encodeAction_status_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "status", Encode.string |> Encode.optional input____.status ) ]


buildAction_status_updates :
    Action_status_updatesRequiredFields
    -> (Action_status_updatesOptionalFields -> Action_status_updatesOptionalFields)
    -> Action_status_updates
buildAction_status_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Action_status_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Action_status_updatesRequiredFields =
    { where_ : Action_status_bool_exp }


type alias Action_status_updatesOptionalFields =
    { set_ : OptionalArgument Action_status_set_input }


{-| Type alias for the `Action_status_updates` attributes. Note that this type
needs to use the `Action_status_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Action_status_updatesRaw =
    { set_ : OptionalArgument Action_status_set_input
    , where_ : Action_status_bool_exp
    }


{-| Type for the Action\_status\_updates input object.
-}
type Action_status_updates
    = Action_status_updates Action_status_updatesRaw


{-| Encode a Action\_status\_updates into a value that can be used as an argument.
-}
encodeAction_status_updates : Action_status_updates -> Value
encodeAction_status_updates (Action_status_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeAction_status_set_input |> Encode.optional input____.set_ ), ( "where", encodeAction_status_bool_exp input____.where_ |> Just ) ]


buildAdmin_cdb_bool_exp :
    (Admin_cdb_bool_expOptionalFields -> Admin_cdb_bool_expOptionalFields)
    -> Admin_cdb_bool_exp
buildAdmin_cdb_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, account = Absent, createdAt = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, updatedAt = Absent }
    in
    Admin_cdb_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, account = optionals____.account, createdAt = optionals____.createdAt, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, updatedAt = optionals____.updatedAt }


type alias Admin_cdb_bool_expOptionalFields =
    { and_ : OptionalArgument (List Admin_cdb_bool_exp)
    , not_ : OptionalArgument Admin_cdb_bool_exp
    , or_ : OptionalArgument (List Admin_cdb_bool_exp)
    , account : OptionalArgument Account_bool_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , email : OptionalArgument Citext_comparison_exp
    , firstname : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , lastname : OptionalArgument String_comparison_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type alias for the `Admin_cdb_bool_exp` attributes. Note that this type
needs to use the `Admin_cdb_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Admin_cdb_bool_expRaw =
    { and_ : OptionalArgument (List Admin_cdb_bool_exp)
    , not_ : OptionalArgument Admin_cdb_bool_exp
    , or_ : OptionalArgument (List Admin_cdb_bool_exp)
    , account : OptionalArgument Account_bool_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , email : OptionalArgument Citext_comparison_exp
    , firstname : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , lastname : OptionalArgument String_comparison_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type for the Admin\_cdb\_bool\_exp input object.
-}
type Admin_cdb_bool_exp
    = Admin_cdb_bool_exp Admin_cdb_bool_expRaw


{-| Encode a Admin\_cdb\_bool\_exp into a value that can be used as an argument.
-}
encodeAdmin_cdb_bool_exp : Admin_cdb_bool_exp -> Value
encodeAdmin_cdb_bool_exp (Admin_cdb_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeAdmin_cdb_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeAdmin_cdb_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeAdmin_cdb_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "account", encodeAccount_bool_exp |> Encode.optional input____.account ), ( "createdAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.createdAt ), ( "email", encodeCitext_comparison_exp |> Encode.optional input____.email ), ( "firstname", encodeString_comparison_exp |> Encode.optional input____.firstname ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "lastname", encodeString_comparison_exp |> Encode.optional input____.lastname ), ( "updatedAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.updatedAt ) ]


buildAdmin_cdb_insert_input :
    (Admin_cdb_insert_inputOptionalFields -> Admin_cdb_insert_inputOptionalFields)
    -> Admin_cdb_insert_input
buildAdmin_cdb_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { account = Absent, createdAt = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, updatedAt = Absent }
    in
    Admin_cdb_insert_input { account = optionals____.account, createdAt = optionals____.createdAt, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, updatedAt = optionals____.updatedAt }


type alias Admin_cdb_insert_inputOptionalFields =
    { account : OptionalArgument Account_obj_rel_insert_input
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastname : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type alias for the `Admin_cdb_insert_input` attributes. Note that this type
needs to use the `Admin_cdb_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Admin_cdb_insert_inputRaw =
    { account : OptionalArgument Account_obj_rel_insert_input
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastname : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Admin\_cdb\_insert\_input input object.
-}
type Admin_cdb_insert_input
    = Admin_cdb_insert_input Admin_cdb_insert_inputRaw


{-| Encode a Admin\_cdb\_insert\_input into a value that can be used as an argument.
-}
encodeAdmin_cdb_insert_input : Admin_cdb_insert_input -> Value
encodeAdmin_cdb_insert_input (Admin_cdb_insert_input input____) =
    Encode.maybeObject
        [ ( "account", encodeAccount_obj_rel_insert_input |> Encode.optional input____.account ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "email", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.email ), ( "firstname", Encode.string |> Encode.optional input____.firstname ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "lastname", Encode.string |> Encode.optional input____.lastname ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildAdmin_cdb_obj_rel_insert_input :
    Admin_cdb_obj_rel_insert_inputRequiredFields
    -> (Admin_cdb_obj_rel_insert_inputOptionalFields -> Admin_cdb_obj_rel_insert_inputOptionalFields)
    -> Admin_cdb_obj_rel_insert_input
buildAdmin_cdb_obj_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Admin_cdb_obj_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Admin_cdb_obj_rel_insert_inputRequiredFields =
    { data : Admin_cdb_insert_input }


type alias Admin_cdb_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Admin_cdb_on_conflict }


{-| Type alias for the `Admin_cdb_obj_rel_insert_input` attributes. Note that this type
needs to use the `Admin_cdb_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Admin_cdb_obj_rel_insert_inputRaw =
    { data : Admin_cdb_insert_input
    , on_conflict : OptionalArgument Admin_cdb_on_conflict
    }


{-| Type for the Admin\_cdb\_obj\_rel\_insert\_input input object.
-}
type Admin_cdb_obj_rel_insert_input
    = Admin_cdb_obj_rel_insert_input Admin_cdb_obj_rel_insert_inputRaw


{-| Encode a Admin\_cdb\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeAdmin_cdb_obj_rel_insert_input : Admin_cdb_obj_rel_insert_input -> Value
encodeAdmin_cdb_obj_rel_insert_input (Admin_cdb_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeAdmin_cdb_insert_input input____.data |> Just ), ( "on_conflict", encodeAdmin_cdb_on_conflict |> Encode.optional input____.on_conflict ) ]


buildAdmin_cdb_on_conflict :
    Admin_cdb_on_conflictRequiredFields
    -> (Admin_cdb_on_conflictOptionalFields -> Admin_cdb_on_conflictOptionalFields)
    -> Admin_cdb_on_conflict
buildAdmin_cdb_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Admin_cdb_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Admin_cdb_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Admin_cdb_constraint.Admin_cdb_constraint
    , update_columns : List CdbGQL.Enum.Admin_cdb_update_column.Admin_cdb_update_column
    }


type alias Admin_cdb_on_conflictOptionalFields =
    { where_ : OptionalArgument Admin_cdb_bool_exp }


{-| Type alias for the `Admin_cdb_on_conflict` attributes. Note that this type
needs to use the `Admin_cdb_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Admin_cdb_on_conflictRaw =
    { constraint : CdbGQL.Enum.Admin_cdb_constraint.Admin_cdb_constraint
    , update_columns : List CdbGQL.Enum.Admin_cdb_update_column.Admin_cdb_update_column
    , where_ : OptionalArgument Admin_cdb_bool_exp
    }


{-| Type for the Admin\_cdb\_on\_conflict input object.
-}
type Admin_cdb_on_conflict
    = Admin_cdb_on_conflict Admin_cdb_on_conflictRaw


{-| Encode a Admin\_cdb\_on\_conflict into a value that can be used as an argument.
-}
encodeAdmin_cdb_on_conflict : Admin_cdb_on_conflict -> Value
encodeAdmin_cdb_on_conflict (Admin_cdb_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Admin_cdb_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Admin_cdb_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeAdmin_cdb_bool_exp |> Encode.optional input____.where_ ) ]


buildAdmin_cdb_order_by :
    (Admin_cdb_order_byOptionalFields -> Admin_cdb_order_byOptionalFields)
    -> Admin_cdb_order_by
buildAdmin_cdb_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { account = Absent, createdAt = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, updatedAt = Absent }
    in
    Admin_cdb_order_by { account = optionals____.account, createdAt = optionals____.createdAt, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, updatedAt = optionals____.updatedAt }


type alias Admin_cdb_order_byOptionalFields =
    { account : OptionalArgument Account_order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type alias for the `Admin_cdb_order_by` attributes. Note that this type
needs to use the `Admin_cdb_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Admin_cdb_order_byRaw =
    { account : OptionalArgument Account_order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Admin\_cdb\_order\_by input object.
-}
type Admin_cdb_order_by
    = Admin_cdb_order_by Admin_cdb_order_byRaw


{-| Encode a Admin\_cdb\_order\_by into a value that can be used as an argument.
-}
encodeAdmin_cdb_order_by : Admin_cdb_order_by -> Value
encodeAdmin_cdb_order_by (Admin_cdb_order_by input____) =
    Encode.maybeObject
        [ ( "account", encodeAccount_order_by |> Encode.optional input____.account ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "email", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.email ), ( "firstname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.firstname ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "lastname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.lastname ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildAdmin_cdb_pk_columns_input :
    Admin_cdb_pk_columns_inputRequiredFields
    -> Admin_cdb_pk_columns_input
buildAdmin_cdb_pk_columns_input required____ =
    { id = required____.id }


type alias Admin_cdb_pk_columns_inputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the Admin\_cdb\_pk\_columns\_input input object.
-}
type alias Admin_cdb_pk_columns_input =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a Admin\_cdb\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeAdmin_cdb_pk_columns_input : Admin_cdb_pk_columns_input -> Value
encodeAdmin_cdb_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildAdmin_cdb_set_input :
    (Admin_cdb_set_inputOptionalFields -> Admin_cdb_set_inputOptionalFields)
    -> Admin_cdb_set_input
buildAdmin_cdb_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, updatedAt = optionals____.updatedAt }


type alias Admin_cdb_set_inputOptionalFields =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastname : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Admin\_cdb\_set\_input input object.
-}
type alias Admin_cdb_set_input =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastname : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Admin\_cdb\_set\_input into a value that can be used as an argument.
-}
encodeAdmin_cdb_set_input : Admin_cdb_set_input -> Value
encodeAdmin_cdb_set_input input____ =
    Encode.maybeObject
        [ ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "email", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.email ), ( "firstname", Encode.string |> Encode.optional input____.firstname ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "lastname", Encode.string |> Encode.optional input____.lastname ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildAdmin_cdb_stream_cursor_input :
    Admin_cdb_stream_cursor_inputRequiredFields
    -> (Admin_cdb_stream_cursor_inputOptionalFields -> Admin_cdb_stream_cursor_inputOptionalFields)
    -> Admin_cdb_stream_cursor_input
buildAdmin_cdb_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Admin_cdb_stream_cursor_inputRequiredFields =
    { initial_value : Admin_cdb_stream_cursor_value_input }


type alias Admin_cdb_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Admin\_cdb\_stream\_cursor\_input input object.
-}
type alias Admin_cdb_stream_cursor_input =
    { initial_value : Admin_cdb_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Admin\_cdb\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeAdmin_cdb_stream_cursor_input : Admin_cdb_stream_cursor_input -> Value
encodeAdmin_cdb_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeAdmin_cdb_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildAdmin_cdb_stream_cursor_value_input :
    (Admin_cdb_stream_cursor_value_inputOptionalFields -> Admin_cdb_stream_cursor_value_inputOptionalFields)
    -> Admin_cdb_stream_cursor_value_input
buildAdmin_cdb_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, updatedAt = optionals____.updatedAt }


type alias Admin_cdb_stream_cursor_value_inputOptionalFields =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastname : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Admin\_cdb\_stream\_cursor\_value\_input input object.
-}
type alias Admin_cdb_stream_cursor_value_input =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastname : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Admin\_cdb\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeAdmin_cdb_stream_cursor_value_input : Admin_cdb_stream_cursor_value_input -> Value
encodeAdmin_cdb_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "email", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.email ), ( "firstname", Encode.string |> Encode.optional input____.firstname ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "lastname", Encode.string |> Encode.optional input____.lastname ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildAdmin_cdb_updates :
    Admin_cdb_updatesRequiredFields
    -> (Admin_cdb_updatesOptionalFields -> Admin_cdb_updatesOptionalFields)
    -> Admin_cdb_updates
buildAdmin_cdb_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Admin_cdb_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Admin_cdb_updatesRequiredFields =
    { where_ : Admin_cdb_bool_exp }


type alias Admin_cdb_updatesOptionalFields =
    { set_ : OptionalArgument Admin_cdb_set_input }


{-| Type alias for the `Admin_cdb_updates` attributes. Note that this type
needs to use the `Admin_cdb_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Admin_cdb_updatesRaw =
    { set_ : OptionalArgument Admin_cdb_set_input
    , where_ : Admin_cdb_bool_exp
    }


{-| Type for the Admin\_cdb\_updates input object.
-}
type Admin_cdb_updates
    = Admin_cdb_updates Admin_cdb_updatesRaw


{-| Encode a Admin\_cdb\_updates into a value that can be used as an argument.
-}
encodeAdmin_cdb_updates : Admin_cdb_updates -> Value
encodeAdmin_cdb_updates (Admin_cdb_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeAdmin_cdb_set_input |> Encode.optional input____.set_ ), ( "where", encodeAdmin_cdb_bool_exp input____.where_ |> Just ) ]


buildAdmin_structure_aggregate_bool_exp :
    (Admin_structure_aggregate_bool_expOptionalFields -> Admin_structure_aggregate_bool_expOptionalFields)
    -> Admin_structure_aggregate_bool_exp
buildAdmin_structure_aggregate_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent }
    in
    Admin_structure_aggregate_bool_exp { count = optionals____.count }


type alias Admin_structure_aggregate_bool_expOptionalFields =
    { count : OptionalArgument Admin_structure_aggregate_bool_exp_count }


{-| Type alias for the `Admin_structure_aggregate_bool_exp` attributes. Note that this type
needs to use the `Admin_structure_aggregate_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Admin_structure_aggregate_bool_expRaw =
    { count : OptionalArgument Admin_structure_aggregate_bool_exp_count }


{-| Type for the Admin\_structure\_aggregate\_bool\_exp input object.
-}
type Admin_structure_aggregate_bool_exp
    = Admin_structure_aggregate_bool_exp Admin_structure_aggregate_bool_expRaw


{-| Encode a Admin\_structure\_aggregate\_bool\_exp into a value that can be used as an argument.
-}
encodeAdmin_structure_aggregate_bool_exp : Admin_structure_aggregate_bool_exp -> Value
encodeAdmin_structure_aggregate_bool_exp (Admin_structure_aggregate_bool_exp input____) =
    Encode.maybeObject
        [ ( "count", encodeAdmin_structure_aggregate_bool_exp_count |> Encode.optional input____.count ) ]


buildAdmin_structure_aggregate_bool_exp_count :
    Admin_structure_aggregate_bool_exp_countRequiredFields
    -> (Admin_structure_aggregate_bool_exp_countOptionalFields -> Admin_structure_aggregate_bool_exp_countOptionalFields)
    -> Admin_structure_aggregate_bool_exp_count
buildAdmin_structure_aggregate_bool_exp_count required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { arguments = Absent, distinct = Absent, filter = Absent }
    in
    Admin_structure_aggregate_bool_exp_count { arguments = optionals____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Admin_structure_aggregate_bool_exp_countRequiredFields =
    { predicate : Int_comparison_exp }


type alias Admin_structure_aggregate_bool_exp_countOptionalFields =
    { arguments : OptionalArgument (List CdbGQL.Enum.Admin_structure_select_column.Admin_structure_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Admin_structure_bool_exp
    }


{-| Type alias for the `Admin_structure_aggregate_bool_exp_count` attributes. Note that this type
needs to use the `Admin_structure_aggregate_bool_exp_count` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Admin_structure_aggregate_bool_exp_countRaw =
    { arguments : OptionalArgument (List CdbGQL.Enum.Admin_structure_select_column.Admin_structure_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Admin_structure_bool_exp
    , predicate : Int_comparison_exp
    }


{-| Type for the Admin\_structure\_aggregate\_bool\_exp\_count input object.
-}
type Admin_structure_aggregate_bool_exp_count
    = Admin_structure_aggregate_bool_exp_count Admin_structure_aggregate_bool_exp_countRaw


{-| Encode a Admin\_structure\_aggregate\_bool\_exp\_count into a value that can be used as an argument.
-}
encodeAdmin_structure_aggregate_bool_exp_count : Admin_structure_aggregate_bool_exp_count -> Value
encodeAdmin_structure_aggregate_bool_exp_count (Admin_structure_aggregate_bool_exp_count input____) =
    Encode.maybeObject
        [ ( "arguments", (Encode.enum CdbGQL.Enum.Admin_structure_select_column.toString |> Encode.list) |> Encode.optional input____.arguments ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeAdmin_structure_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeInt_comparison_exp input____.predicate |> Just ) ]


buildAdmin_structure_aggregate_order_by :
    (Admin_structure_aggregate_order_byOptionalFields -> Admin_structure_aggregate_order_byOptionalFields)
    -> Admin_structure_aggregate_order_by
buildAdmin_structure_aggregate_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals____.count, max = optionals____.max, min = optionals____.min }


type alias Admin_structure_aggregate_order_byOptionalFields =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Admin_structure_max_order_by
    , min : OptionalArgument Admin_structure_min_order_by
    }


{-| Type for the Admin\_structure\_aggregate\_order\_by input object.
-}
type alias Admin_structure_aggregate_order_by =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Admin_structure_max_order_by
    , min : OptionalArgument Admin_structure_min_order_by
    }


{-| Encode a Admin\_structure\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeAdmin_structure_aggregate_order_by : Admin_structure_aggregate_order_by -> Value
encodeAdmin_structure_aggregate_order_by input____ =
    Encode.maybeObject
        [ ( "count", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.count ), ( "max", encodeAdmin_structure_max_order_by |> Encode.optional input____.max ), ( "min", encodeAdmin_structure_min_order_by |> Encode.optional input____.min ) ]


buildAdmin_structure_arr_rel_insert_input :
    Admin_structure_arr_rel_insert_inputRequiredFields
    -> (Admin_structure_arr_rel_insert_inputOptionalFields -> Admin_structure_arr_rel_insert_inputOptionalFields)
    -> Admin_structure_arr_rel_insert_input
buildAdmin_structure_arr_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Admin_structure_arr_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Admin_structure_arr_rel_insert_inputRequiredFields =
    { data : List Admin_structure_insert_input }


type alias Admin_structure_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Admin_structure_on_conflict }


{-| Type alias for the `Admin_structure_arr_rel_insert_input` attributes. Note that this type
needs to use the `Admin_structure_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Admin_structure_arr_rel_insert_inputRaw =
    { data : List Admin_structure_insert_input
    , on_conflict : OptionalArgument Admin_structure_on_conflict
    }


{-| Type for the Admin\_structure\_arr\_rel\_insert\_input input object.
-}
type Admin_structure_arr_rel_insert_input
    = Admin_structure_arr_rel_insert_input Admin_structure_arr_rel_insert_inputRaw


{-| Encode a Admin\_structure\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeAdmin_structure_arr_rel_insert_input : Admin_structure_arr_rel_insert_input -> Value
encodeAdmin_structure_arr_rel_insert_input (Admin_structure_arr_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", (encodeAdmin_structure_insert_input |> Encode.list) input____.data |> Just ), ( "on_conflict", encodeAdmin_structure_on_conflict |> Encode.optional input____.on_conflict ) ]


buildAdmin_structure_bool_exp :
    (Admin_structure_bool_expOptionalFields -> Admin_structure_bool_expOptionalFields)
    -> Admin_structure_bool_exp
buildAdmin_structure_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, account = Absent, createdAt = Absent, deployment = Absent, deploymentId = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, phoneNumbers = Absent, position = Absent, structures = Absent, structures_aggregate = Absent, updatedAt = Absent }
    in
    Admin_structure_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, account = optionals____.account, createdAt = optionals____.createdAt, deployment = optionals____.deployment, deploymentId = optionals____.deploymentId, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, phoneNumbers = optionals____.phoneNumbers, position = optionals____.position, structures = optionals____.structures, structures_aggregate = optionals____.structures_aggregate, updatedAt = optionals____.updatedAt }


type alias Admin_structure_bool_expOptionalFields =
    { and_ : OptionalArgument (List Admin_structure_bool_exp)
    , not_ : OptionalArgument Admin_structure_bool_exp
    , or_ : OptionalArgument (List Admin_structure_bool_exp)
    , account : OptionalArgument Account_bool_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , deployment : OptionalArgument Deployment_bool_exp
    , deploymentId : OptionalArgument Uuid_comparison_exp
    , email : OptionalArgument Citext_comparison_exp
    , firstname : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , lastname : OptionalArgument String_comparison_exp
    , phoneNumbers : OptionalArgument String_comparison_exp
    , position : OptionalArgument String_comparison_exp
    , structures : OptionalArgument Admin_structure_structure_bool_exp
    , structures_aggregate : OptionalArgument Admin_structure_structure_aggregate_bool_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type alias for the `Admin_structure_bool_exp` attributes. Note that this type
needs to use the `Admin_structure_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Admin_structure_bool_expRaw =
    { and_ : OptionalArgument (List Admin_structure_bool_exp)
    , not_ : OptionalArgument Admin_structure_bool_exp
    , or_ : OptionalArgument (List Admin_structure_bool_exp)
    , account : OptionalArgument Account_bool_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , deployment : OptionalArgument Deployment_bool_exp
    , deploymentId : OptionalArgument Uuid_comparison_exp
    , email : OptionalArgument Citext_comparison_exp
    , firstname : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , lastname : OptionalArgument String_comparison_exp
    , phoneNumbers : OptionalArgument String_comparison_exp
    , position : OptionalArgument String_comparison_exp
    , structures : OptionalArgument Admin_structure_structure_bool_exp
    , structures_aggregate : OptionalArgument Admin_structure_structure_aggregate_bool_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type for the Admin\_structure\_bool\_exp input object.
-}
type Admin_structure_bool_exp
    = Admin_structure_bool_exp Admin_structure_bool_expRaw


{-| Encode a Admin\_structure\_bool\_exp into a value that can be used as an argument.
-}
encodeAdmin_structure_bool_exp : Admin_structure_bool_exp -> Value
encodeAdmin_structure_bool_exp (Admin_structure_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeAdmin_structure_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeAdmin_structure_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeAdmin_structure_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "account", encodeAccount_bool_exp |> Encode.optional input____.account ), ( "createdAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.createdAt ), ( "deployment", encodeDeployment_bool_exp |> Encode.optional input____.deployment ), ( "deploymentId", encodeUuid_comparison_exp |> Encode.optional input____.deploymentId ), ( "email", encodeCitext_comparison_exp |> Encode.optional input____.email ), ( "firstname", encodeString_comparison_exp |> Encode.optional input____.firstname ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "lastname", encodeString_comparison_exp |> Encode.optional input____.lastname ), ( "phoneNumbers", encodeString_comparison_exp |> Encode.optional input____.phoneNumbers ), ( "position", encodeString_comparison_exp |> Encode.optional input____.position ), ( "structures", encodeAdmin_structure_structure_bool_exp |> Encode.optional input____.structures ), ( "structures_aggregate", encodeAdmin_structure_structure_aggregate_bool_exp |> Encode.optional input____.structures_aggregate ), ( "updatedAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.updatedAt ) ]


buildAdmin_structure_insert_input :
    (Admin_structure_insert_inputOptionalFields -> Admin_structure_insert_inputOptionalFields)
    -> Admin_structure_insert_input
buildAdmin_structure_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { account = Absent, createdAt = Absent, deployment = Absent, deploymentId = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, phoneNumbers = Absent, position = Absent, structures = Absent, updatedAt = Absent }
    in
    Admin_structure_insert_input { account = optionals____.account, createdAt = optionals____.createdAt, deployment = optionals____.deployment, deploymentId = optionals____.deploymentId, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, phoneNumbers = optionals____.phoneNumbers, position = optionals____.position, structures = optionals____.structures, updatedAt = optionals____.updatedAt }


type alias Admin_structure_insert_inputOptionalFields =
    { account : OptionalArgument Account_obj_rel_insert_input
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deployment : OptionalArgument Deployment_obj_rel_insert_input
    , deploymentId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastname : OptionalArgument String
    , phoneNumbers : OptionalArgument String
    , position : OptionalArgument String
    , structures : OptionalArgument Admin_structure_structure_arr_rel_insert_input
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type alias for the `Admin_structure_insert_input` attributes. Note that this type
needs to use the `Admin_structure_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Admin_structure_insert_inputRaw =
    { account : OptionalArgument Account_obj_rel_insert_input
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deployment : OptionalArgument Deployment_obj_rel_insert_input
    , deploymentId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastname : OptionalArgument String
    , phoneNumbers : OptionalArgument String
    , position : OptionalArgument String
    , structures : OptionalArgument Admin_structure_structure_arr_rel_insert_input
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Admin\_structure\_insert\_input input object.
-}
type Admin_structure_insert_input
    = Admin_structure_insert_input Admin_structure_insert_inputRaw


{-| Encode a Admin\_structure\_insert\_input into a value that can be used as an argument.
-}
encodeAdmin_structure_insert_input : Admin_structure_insert_input -> Value
encodeAdmin_structure_insert_input (Admin_structure_insert_input input____) =
    Encode.maybeObject
        [ ( "account", encodeAccount_obj_rel_insert_input |> Encode.optional input____.account ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "deployment", encodeDeployment_obj_rel_insert_input |> Encode.optional input____.deployment ), ( "deploymentId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.deploymentId ), ( "email", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.email ), ( "firstname", Encode.string |> Encode.optional input____.firstname ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "lastname", Encode.string |> Encode.optional input____.lastname ), ( "phoneNumbers", Encode.string |> Encode.optional input____.phoneNumbers ), ( "position", Encode.string |> Encode.optional input____.position ), ( "structures", encodeAdmin_structure_structure_arr_rel_insert_input |> Encode.optional input____.structures ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildAdmin_structure_max_order_by :
    (Admin_structure_max_order_byOptionalFields -> Admin_structure_max_order_byOptionalFields)
    -> Admin_structure_max_order_by
buildAdmin_structure_max_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, deploymentId = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, phoneNumbers = Absent, position = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, deploymentId = optionals____.deploymentId, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, phoneNumbers = optionals____.phoneNumbers, position = optionals____.position, updatedAt = optionals____.updatedAt }


type alias Admin_structure_max_order_byOptionalFields =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deploymentId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , phoneNumbers : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , position : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Admin\_structure\_max\_order\_by input object.
-}
type alias Admin_structure_max_order_by =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deploymentId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , phoneNumbers : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , position : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Admin\_structure\_max\_order\_by into a value that can be used as an argument.
-}
encodeAdmin_structure_max_order_by : Admin_structure_max_order_by -> Value
encodeAdmin_structure_max_order_by input____ =
    Encode.maybeObject
        [ ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "deploymentId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deploymentId ), ( "email", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.email ), ( "firstname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.firstname ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "lastname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.lastname ), ( "phoneNumbers", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.phoneNumbers ), ( "position", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.position ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildAdmin_structure_min_order_by :
    (Admin_structure_min_order_byOptionalFields -> Admin_structure_min_order_byOptionalFields)
    -> Admin_structure_min_order_by
buildAdmin_structure_min_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, deploymentId = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, phoneNumbers = Absent, position = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, deploymentId = optionals____.deploymentId, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, phoneNumbers = optionals____.phoneNumbers, position = optionals____.position, updatedAt = optionals____.updatedAt }


type alias Admin_structure_min_order_byOptionalFields =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deploymentId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , phoneNumbers : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , position : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Admin\_structure\_min\_order\_by input object.
-}
type alias Admin_structure_min_order_by =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deploymentId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , phoneNumbers : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , position : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Admin\_structure\_min\_order\_by into a value that can be used as an argument.
-}
encodeAdmin_structure_min_order_by : Admin_structure_min_order_by -> Value
encodeAdmin_structure_min_order_by input____ =
    Encode.maybeObject
        [ ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "deploymentId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deploymentId ), ( "email", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.email ), ( "firstname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.firstname ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "lastname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.lastname ), ( "phoneNumbers", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.phoneNumbers ), ( "position", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.position ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildAdmin_structure_obj_rel_insert_input :
    Admin_structure_obj_rel_insert_inputRequiredFields
    -> (Admin_structure_obj_rel_insert_inputOptionalFields -> Admin_structure_obj_rel_insert_inputOptionalFields)
    -> Admin_structure_obj_rel_insert_input
buildAdmin_structure_obj_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Admin_structure_obj_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Admin_structure_obj_rel_insert_inputRequiredFields =
    { data : Admin_structure_insert_input }


type alias Admin_structure_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Admin_structure_on_conflict }


{-| Type alias for the `Admin_structure_obj_rel_insert_input` attributes. Note that this type
needs to use the `Admin_structure_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Admin_structure_obj_rel_insert_inputRaw =
    { data : Admin_structure_insert_input
    , on_conflict : OptionalArgument Admin_structure_on_conflict
    }


{-| Type for the Admin\_structure\_obj\_rel\_insert\_input input object.
-}
type Admin_structure_obj_rel_insert_input
    = Admin_structure_obj_rel_insert_input Admin_structure_obj_rel_insert_inputRaw


{-| Encode a Admin\_structure\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeAdmin_structure_obj_rel_insert_input : Admin_structure_obj_rel_insert_input -> Value
encodeAdmin_structure_obj_rel_insert_input (Admin_structure_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeAdmin_structure_insert_input input____.data |> Just ), ( "on_conflict", encodeAdmin_structure_on_conflict |> Encode.optional input____.on_conflict ) ]


buildAdmin_structure_on_conflict :
    Admin_structure_on_conflictRequiredFields
    -> (Admin_structure_on_conflictOptionalFields -> Admin_structure_on_conflictOptionalFields)
    -> Admin_structure_on_conflict
buildAdmin_structure_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Admin_structure_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Admin_structure_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Admin_structure_constraint.Admin_structure_constraint
    , update_columns : List CdbGQL.Enum.Admin_structure_update_column.Admin_structure_update_column
    }


type alias Admin_structure_on_conflictOptionalFields =
    { where_ : OptionalArgument Admin_structure_bool_exp }


{-| Type alias for the `Admin_structure_on_conflict` attributes. Note that this type
needs to use the `Admin_structure_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Admin_structure_on_conflictRaw =
    { constraint : CdbGQL.Enum.Admin_structure_constraint.Admin_structure_constraint
    , update_columns : List CdbGQL.Enum.Admin_structure_update_column.Admin_structure_update_column
    , where_ : OptionalArgument Admin_structure_bool_exp
    }


{-| Type for the Admin\_structure\_on\_conflict input object.
-}
type Admin_structure_on_conflict
    = Admin_structure_on_conflict Admin_structure_on_conflictRaw


{-| Encode a Admin\_structure\_on\_conflict into a value that can be used as an argument.
-}
encodeAdmin_structure_on_conflict : Admin_structure_on_conflict -> Value
encodeAdmin_structure_on_conflict (Admin_structure_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Admin_structure_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Admin_structure_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeAdmin_structure_bool_exp |> Encode.optional input____.where_ ) ]


buildAdmin_structure_order_by :
    (Admin_structure_order_byOptionalFields -> Admin_structure_order_byOptionalFields)
    -> Admin_structure_order_by
buildAdmin_structure_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { account = Absent, createdAt = Absent, deployment = Absent, deploymentId = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, phoneNumbers = Absent, position = Absent, structures_aggregate = Absent, updatedAt = Absent }
    in
    Admin_structure_order_by { account = optionals____.account, createdAt = optionals____.createdAt, deployment = optionals____.deployment, deploymentId = optionals____.deploymentId, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, phoneNumbers = optionals____.phoneNumbers, position = optionals____.position, structures_aggregate = optionals____.structures_aggregate, updatedAt = optionals____.updatedAt }


type alias Admin_structure_order_byOptionalFields =
    { account : OptionalArgument Account_order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deployment : OptionalArgument Deployment_order_by
    , deploymentId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , phoneNumbers : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , position : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , structures_aggregate : OptionalArgument Admin_structure_structure_aggregate_order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type alias for the `Admin_structure_order_by` attributes. Note that this type
needs to use the `Admin_structure_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Admin_structure_order_byRaw =
    { account : OptionalArgument Account_order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deployment : OptionalArgument Deployment_order_by
    , deploymentId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , phoneNumbers : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , position : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , structures_aggregate : OptionalArgument Admin_structure_structure_aggregate_order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Admin\_structure\_order\_by input object.
-}
type Admin_structure_order_by
    = Admin_structure_order_by Admin_structure_order_byRaw


{-| Encode a Admin\_structure\_order\_by into a value that can be used as an argument.
-}
encodeAdmin_structure_order_by : Admin_structure_order_by -> Value
encodeAdmin_structure_order_by (Admin_structure_order_by input____) =
    Encode.maybeObject
        [ ( "account", encodeAccount_order_by |> Encode.optional input____.account ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "deployment", encodeDeployment_order_by |> Encode.optional input____.deployment ), ( "deploymentId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deploymentId ), ( "email", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.email ), ( "firstname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.firstname ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "lastname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.lastname ), ( "phoneNumbers", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.phoneNumbers ), ( "position", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.position ), ( "structures_aggregate", encodeAdmin_structure_structure_aggregate_order_by |> Encode.optional input____.structures_aggregate ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildAdmin_structure_pk_columns_input :
    Admin_structure_pk_columns_inputRequiredFields
    -> Admin_structure_pk_columns_input
buildAdmin_structure_pk_columns_input required____ =
    { id = required____.id }


type alias Admin_structure_pk_columns_inputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the Admin\_structure\_pk\_columns\_input input object.
-}
type alias Admin_structure_pk_columns_input =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a Admin\_structure\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeAdmin_structure_pk_columns_input : Admin_structure_pk_columns_input -> Value
encodeAdmin_structure_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildAdmin_structure_set_input :
    (Admin_structure_set_inputOptionalFields -> Admin_structure_set_inputOptionalFields)
    -> Admin_structure_set_input
buildAdmin_structure_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, deploymentId = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, phoneNumbers = Absent, position = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, deploymentId = optionals____.deploymentId, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, phoneNumbers = optionals____.phoneNumbers, position = optionals____.position, updatedAt = optionals____.updatedAt }


type alias Admin_structure_set_inputOptionalFields =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deploymentId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastname : OptionalArgument String
    , phoneNumbers : OptionalArgument String
    , position : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Admin\_structure\_set\_input input object.
-}
type alias Admin_structure_set_input =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deploymentId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastname : OptionalArgument String
    , phoneNumbers : OptionalArgument String
    , position : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Admin\_structure\_set\_input into a value that can be used as an argument.
-}
encodeAdmin_structure_set_input : Admin_structure_set_input -> Value
encodeAdmin_structure_set_input input____ =
    Encode.maybeObject
        [ ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "deploymentId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.deploymentId ), ( "email", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.email ), ( "firstname", Encode.string |> Encode.optional input____.firstname ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "lastname", Encode.string |> Encode.optional input____.lastname ), ( "phoneNumbers", Encode.string |> Encode.optional input____.phoneNumbers ), ( "position", Encode.string |> Encode.optional input____.position ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildAdmin_structure_stream_cursor_input :
    Admin_structure_stream_cursor_inputRequiredFields
    -> (Admin_structure_stream_cursor_inputOptionalFields -> Admin_structure_stream_cursor_inputOptionalFields)
    -> Admin_structure_stream_cursor_input
buildAdmin_structure_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Admin_structure_stream_cursor_inputRequiredFields =
    { initial_value : Admin_structure_stream_cursor_value_input }


type alias Admin_structure_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Admin\_structure\_stream\_cursor\_input input object.
-}
type alias Admin_structure_stream_cursor_input =
    { initial_value : Admin_structure_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Admin\_structure\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeAdmin_structure_stream_cursor_input : Admin_structure_stream_cursor_input -> Value
encodeAdmin_structure_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeAdmin_structure_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildAdmin_structure_stream_cursor_value_input :
    (Admin_structure_stream_cursor_value_inputOptionalFields -> Admin_structure_stream_cursor_value_inputOptionalFields)
    -> Admin_structure_stream_cursor_value_input
buildAdmin_structure_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, deploymentId = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, phoneNumbers = Absent, position = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, deploymentId = optionals____.deploymentId, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, phoneNumbers = optionals____.phoneNumbers, position = optionals____.position, updatedAt = optionals____.updatedAt }


type alias Admin_structure_stream_cursor_value_inputOptionalFields =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deploymentId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastname : OptionalArgument String
    , phoneNumbers : OptionalArgument String
    , position : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Admin\_structure\_stream\_cursor\_value\_input input object.
-}
type alias Admin_structure_stream_cursor_value_input =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deploymentId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastname : OptionalArgument String
    , phoneNumbers : OptionalArgument String
    , position : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Admin\_structure\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeAdmin_structure_stream_cursor_value_input : Admin_structure_stream_cursor_value_input -> Value
encodeAdmin_structure_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "deploymentId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.deploymentId ), ( "email", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.email ), ( "firstname", Encode.string |> Encode.optional input____.firstname ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "lastname", Encode.string |> Encode.optional input____.lastname ), ( "phoneNumbers", Encode.string |> Encode.optional input____.phoneNumbers ), ( "position", Encode.string |> Encode.optional input____.position ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildAdmin_structure_structure_aggregate_bool_exp :
    (Admin_structure_structure_aggregate_bool_expOptionalFields -> Admin_structure_structure_aggregate_bool_expOptionalFields)
    -> Admin_structure_structure_aggregate_bool_exp
buildAdmin_structure_structure_aggregate_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent }
    in
    Admin_structure_structure_aggregate_bool_exp { count = optionals____.count }


type alias Admin_structure_structure_aggregate_bool_expOptionalFields =
    { count : OptionalArgument Admin_structure_structure_aggregate_bool_exp_count }


{-| Type alias for the `Admin_structure_structure_aggregate_bool_exp` attributes. Note that this type
needs to use the `Admin_structure_structure_aggregate_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Admin_structure_structure_aggregate_bool_expRaw =
    { count : OptionalArgument Admin_structure_structure_aggregate_bool_exp_count }


{-| Type for the Admin\_structure\_structure\_aggregate\_bool\_exp input object.
-}
type Admin_structure_structure_aggregate_bool_exp
    = Admin_structure_structure_aggregate_bool_exp Admin_structure_structure_aggregate_bool_expRaw


{-| Encode a Admin\_structure\_structure\_aggregate\_bool\_exp into a value that can be used as an argument.
-}
encodeAdmin_structure_structure_aggregate_bool_exp : Admin_structure_structure_aggregate_bool_exp -> Value
encodeAdmin_structure_structure_aggregate_bool_exp (Admin_structure_structure_aggregate_bool_exp input____) =
    Encode.maybeObject
        [ ( "count", encodeAdmin_structure_structure_aggregate_bool_exp_count |> Encode.optional input____.count ) ]


buildAdmin_structure_structure_aggregate_bool_exp_count :
    Admin_structure_structure_aggregate_bool_exp_countRequiredFields
    -> (Admin_structure_structure_aggregate_bool_exp_countOptionalFields -> Admin_structure_structure_aggregate_bool_exp_countOptionalFields)
    -> Admin_structure_structure_aggregate_bool_exp_count
buildAdmin_structure_structure_aggregate_bool_exp_count required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { arguments = Absent, distinct = Absent, filter = Absent }
    in
    Admin_structure_structure_aggregate_bool_exp_count { arguments = optionals____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Admin_structure_structure_aggregate_bool_exp_countRequiredFields =
    { predicate : Int_comparison_exp }


type alias Admin_structure_structure_aggregate_bool_exp_countOptionalFields =
    { arguments : OptionalArgument (List CdbGQL.Enum.Admin_structure_structure_select_column.Admin_structure_structure_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Admin_structure_structure_bool_exp
    }


{-| Type alias for the `Admin_structure_structure_aggregate_bool_exp_count` attributes. Note that this type
needs to use the `Admin_structure_structure_aggregate_bool_exp_count` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Admin_structure_structure_aggregate_bool_exp_countRaw =
    { arguments : OptionalArgument (List CdbGQL.Enum.Admin_structure_structure_select_column.Admin_structure_structure_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Admin_structure_structure_bool_exp
    , predicate : Int_comparison_exp
    }


{-| Type for the Admin\_structure\_structure\_aggregate\_bool\_exp\_count input object.
-}
type Admin_structure_structure_aggregate_bool_exp_count
    = Admin_structure_structure_aggregate_bool_exp_count Admin_structure_structure_aggregate_bool_exp_countRaw


{-| Encode a Admin\_structure\_structure\_aggregate\_bool\_exp\_count into a value that can be used as an argument.
-}
encodeAdmin_structure_structure_aggregate_bool_exp_count : Admin_structure_structure_aggregate_bool_exp_count -> Value
encodeAdmin_structure_structure_aggregate_bool_exp_count (Admin_structure_structure_aggregate_bool_exp_count input____) =
    Encode.maybeObject
        [ ( "arguments", (Encode.enum CdbGQL.Enum.Admin_structure_structure_select_column.toString |> Encode.list) |> Encode.optional input____.arguments ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeAdmin_structure_structure_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeInt_comparison_exp input____.predicate |> Just ) ]


buildAdmin_structure_structure_aggregate_order_by :
    (Admin_structure_structure_aggregate_order_byOptionalFields -> Admin_structure_structure_aggregate_order_byOptionalFields)
    -> Admin_structure_structure_aggregate_order_by
buildAdmin_structure_structure_aggregate_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals____.count, max = optionals____.max, min = optionals____.min }


type alias Admin_structure_structure_aggregate_order_byOptionalFields =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Admin_structure_structure_max_order_by
    , min : OptionalArgument Admin_structure_structure_min_order_by
    }


{-| Type for the Admin\_structure\_structure\_aggregate\_order\_by input object.
-}
type alias Admin_structure_structure_aggregate_order_by =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Admin_structure_structure_max_order_by
    , min : OptionalArgument Admin_structure_structure_min_order_by
    }


{-| Encode a Admin\_structure\_structure\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeAdmin_structure_structure_aggregate_order_by : Admin_structure_structure_aggregate_order_by -> Value
encodeAdmin_structure_structure_aggregate_order_by input____ =
    Encode.maybeObject
        [ ( "count", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.count ), ( "max", encodeAdmin_structure_structure_max_order_by |> Encode.optional input____.max ), ( "min", encodeAdmin_structure_structure_min_order_by |> Encode.optional input____.min ) ]


buildAdmin_structure_structure_arr_rel_insert_input :
    Admin_structure_structure_arr_rel_insert_inputRequiredFields
    -> (Admin_structure_structure_arr_rel_insert_inputOptionalFields -> Admin_structure_structure_arr_rel_insert_inputOptionalFields)
    -> Admin_structure_structure_arr_rel_insert_input
buildAdmin_structure_structure_arr_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Admin_structure_structure_arr_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Admin_structure_structure_arr_rel_insert_inputRequiredFields =
    { data : List Admin_structure_structure_insert_input }


type alias Admin_structure_structure_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Admin_structure_structure_on_conflict }


{-| Type alias for the `Admin_structure_structure_arr_rel_insert_input` attributes. Note that this type
needs to use the `Admin_structure_structure_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Admin_structure_structure_arr_rel_insert_inputRaw =
    { data : List Admin_structure_structure_insert_input
    , on_conflict : OptionalArgument Admin_structure_structure_on_conflict
    }


{-| Type for the Admin\_structure\_structure\_arr\_rel\_insert\_input input object.
-}
type Admin_structure_structure_arr_rel_insert_input
    = Admin_structure_structure_arr_rel_insert_input Admin_structure_structure_arr_rel_insert_inputRaw


{-| Encode a Admin\_structure\_structure\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeAdmin_structure_structure_arr_rel_insert_input : Admin_structure_structure_arr_rel_insert_input -> Value
encodeAdmin_structure_structure_arr_rel_insert_input (Admin_structure_structure_arr_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", (encodeAdmin_structure_structure_insert_input |> Encode.list) input____.data |> Just ), ( "on_conflict", encodeAdmin_structure_structure_on_conflict |> Encode.optional input____.on_conflict ) ]


buildAdmin_structure_structure_bool_exp :
    (Admin_structure_structure_bool_expOptionalFields -> Admin_structure_structure_bool_expOptionalFields)
    -> Admin_structure_structure_bool_exp
buildAdmin_structure_structure_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, adminStructureId = Absent, admin_structure = Absent, createdAt = Absent, deletedAt = Absent, id = Absent, structure = Absent, structureId = Absent }
    in
    Admin_structure_structure_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, adminStructureId = optionals____.adminStructureId, admin_structure = optionals____.admin_structure, createdAt = optionals____.createdAt, deletedAt = optionals____.deletedAt, id = optionals____.id, structure = optionals____.structure, structureId = optionals____.structureId }


type alias Admin_structure_structure_bool_expOptionalFields =
    { and_ : OptionalArgument (List Admin_structure_structure_bool_exp)
    , not_ : OptionalArgument Admin_structure_structure_bool_exp
    , or_ : OptionalArgument (List Admin_structure_structure_bool_exp)
    , adminStructureId : OptionalArgument Uuid_comparison_exp
    , admin_structure : OptionalArgument Admin_structure_bool_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , deletedAt : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , structure : OptionalArgument Structure_bool_exp
    , structureId : OptionalArgument Uuid_comparison_exp
    }


{-| Type alias for the `Admin_structure_structure_bool_exp` attributes. Note that this type
needs to use the `Admin_structure_structure_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Admin_structure_structure_bool_expRaw =
    { and_ : OptionalArgument (List Admin_structure_structure_bool_exp)
    , not_ : OptionalArgument Admin_structure_structure_bool_exp
    , or_ : OptionalArgument (List Admin_structure_structure_bool_exp)
    , adminStructureId : OptionalArgument Uuid_comparison_exp
    , admin_structure : OptionalArgument Admin_structure_bool_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , deletedAt : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , structure : OptionalArgument Structure_bool_exp
    , structureId : OptionalArgument Uuid_comparison_exp
    }


{-| Type for the Admin\_structure\_structure\_bool\_exp input object.
-}
type Admin_structure_structure_bool_exp
    = Admin_structure_structure_bool_exp Admin_structure_structure_bool_expRaw


{-| Encode a Admin\_structure\_structure\_bool\_exp into a value that can be used as an argument.
-}
encodeAdmin_structure_structure_bool_exp : Admin_structure_structure_bool_exp -> Value
encodeAdmin_structure_structure_bool_exp (Admin_structure_structure_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeAdmin_structure_structure_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeAdmin_structure_structure_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeAdmin_structure_structure_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "adminStructureId", encodeUuid_comparison_exp |> Encode.optional input____.adminStructureId ), ( "admin_structure", encodeAdmin_structure_bool_exp |> Encode.optional input____.admin_structure ), ( "createdAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.createdAt ), ( "deletedAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.deletedAt ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "structure", encodeStructure_bool_exp |> Encode.optional input____.structure ), ( "structureId", encodeUuid_comparison_exp |> Encode.optional input____.structureId ) ]


buildAdmin_structure_structure_insert_input :
    (Admin_structure_structure_insert_inputOptionalFields -> Admin_structure_structure_insert_inputOptionalFields)
    -> Admin_structure_structure_insert_input
buildAdmin_structure_structure_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { adminStructureId = Absent, admin_structure = Absent, createdAt = Absent, deletedAt = Absent, id = Absent, structure = Absent, structureId = Absent }
    in
    Admin_structure_structure_insert_input { adminStructureId = optionals____.adminStructureId, admin_structure = optionals____.admin_structure, createdAt = optionals____.createdAt, deletedAt = optionals____.deletedAt, id = optionals____.id, structure = optionals____.structure, structureId = optionals____.structureId }


type alias Admin_structure_structure_insert_inputOptionalFields =
    { adminStructureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , admin_structure : OptionalArgument Admin_structure_obj_rel_insert_input
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deletedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , structure : OptionalArgument Structure_obj_rel_insert_input
    , structureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Type alias for the `Admin_structure_structure_insert_input` attributes. Note that this type
needs to use the `Admin_structure_structure_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Admin_structure_structure_insert_inputRaw =
    { adminStructureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , admin_structure : OptionalArgument Admin_structure_obj_rel_insert_input
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deletedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , structure : OptionalArgument Structure_obj_rel_insert_input
    , structureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Type for the Admin\_structure\_structure\_insert\_input input object.
-}
type Admin_structure_structure_insert_input
    = Admin_structure_structure_insert_input Admin_structure_structure_insert_inputRaw


{-| Encode a Admin\_structure\_structure\_insert\_input into a value that can be used as an argument.
-}
encodeAdmin_structure_structure_insert_input : Admin_structure_structure_insert_input -> Value
encodeAdmin_structure_structure_insert_input (Admin_structure_structure_insert_input input____) =
    Encode.maybeObject
        [ ( "adminStructureId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.adminStructureId ), ( "admin_structure", encodeAdmin_structure_obj_rel_insert_input |> Encode.optional input____.admin_structure ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "deletedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.deletedAt ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "structure", encodeStructure_obj_rel_insert_input |> Encode.optional input____.structure ), ( "structureId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.structureId ) ]


buildAdmin_structure_structure_max_order_by :
    (Admin_structure_structure_max_order_byOptionalFields -> Admin_structure_structure_max_order_byOptionalFields)
    -> Admin_structure_structure_max_order_by
buildAdmin_structure_structure_max_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { adminStructureId = Absent, createdAt = Absent, deletedAt = Absent, id = Absent, structureId = Absent }
    in
    { adminStructureId = optionals____.adminStructureId, createdAt = optionals____.createdAt, deletedAt = optionals____.deletedAt, id = optionals____.id, structureId = optionals____.structureId }


type alias Admin_structure_structure_max_order_byOptionalFields =
    { adminStructureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deletedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , structureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Admin\_structure\_structure\_max\_order\_by input object.
-}
type alias Admin_structure_structure_max_order_by =
    { adminStructureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deletedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , structureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Admin\_structure\_structure\_max\_order\_by into a value that can be used as an argument.
-}
encodeAdmin_structure_structure_max_order_by : Admin_structure_structure_max_order_by -> Value
encodeAdmin_structure_structure_max_order_by input____ =
    Encode.maybeObject
        [ ( "adminStructureId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.adminStructureId ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "deletedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deletedAt ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "structureId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.structureId ) ]


buildAdmin_structure_structure_min_order_by :
    (Admin_structure_structure_min_order_byOptionalFields -> Admin_structure_structure_min_order_byOptionalFields)
    -> Admin_structure_structure_min_order_by
buildAdmin_structure_structure_min_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { adminStructureId = Absent, createdAt = Absent, deletedAt = Absent, id = Absent, structureId = Absent }
    in
    { adminStructureId = optionals____.adminStructureId, createdAt = optionals____.createdAt, deletedAt = optionals____.deletedAt, id = optionals____.id, structureId = optionals____.structureId }


type alias Admin_structure_structure_min_order_byOptionalFields =
    { adminStructureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deletedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , structureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Admin\_structure\_structure\_min\_order\_by input object.
-}
type alias Admin_structure_structure_min_order_by =
    { adminStructureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deletedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , structureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Admin\_structure\_structure\_min\_order\_by into a value that can be used as an argument.
-}
encodeAdmin_structure_structure_min_order_by : Admin_structure_structure_min_order_by -> Value
encodeAdmin_structure_structure_min_order_by input____ =
    Encode.maybeObject
        [ ( "adminStructureId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.adminStructureId ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "deletedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deletedAt ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "structureId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.structureId ) ]


buildAdmin_structure_structure_on_conflict :
    Admin_structure_structure_on_conflictRequiredFields
    -> (Admin_structure_structure_on_conflictOptionalFields -> Admin_structure_structure_on_conflictOptionalFields)
    -> Admin_structure_structure_on_conflict
buildAdmin_structure_structure_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Admin_structure_structure_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Admin_structure_structure_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Admin_structure_structure_constraint.Admin_structure_structure_constraint
    , update_columns : List CdbGQL.Enum.Admin_structure_structure_update_column.Admin_structure_structure_update_column
    }


type alias Admin_structure_structure_on_conflictOptionalFields =
    { where_ : OptionalArgument Admin_structure_structure_bool_exp }


{-| Type alias for the `Admin_structure_structure_on_conflict` attributes. Note that this type
needs to use the `Admin_structure_structure_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Admin_structure_structure_on_conflictRaw =
    { constraint : CdbGQL.Enum.Admin_structure_structure_constraint.Admin_structure_structure_constraint
    , update_columns : List CdbGQL.Enum.Admin_structure_structure_update_column.Admin_structure_structure_update_column
    , where_ : OptionalArgument Admin_structure_structure_bool_exp
    }


{-| Type for the Admin\_structure\_structure\_on\_conflict input object.
-}
type Admin_structure_structure_on_conflict
    = Admin_structure_structure_on_conflict Admin_structure_structure_on_conflictRaw


{-| Encode a Admin\_structure\_structure\_on\_conflict into a value that can be used as an argument.
-}
encodeAdmin_structure_structure_on_conflict : Admin_structure_structure_on_conflict -> Value
encodeAdmin_structure_structure_on_conflict (Admin_structure_structure_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Admin_structure_structure_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Admin_structure_structure_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeAdmin_structure_structure_bool_exp |> Encode.optional input____.where_ ) ]


buildAdmin_structure_structure_order_by :
    (Admin_structure_structure_order_byOptionalFields -> Admin_structure_structure_order_byOptionalFields)
    -> Admin_structure_structure_order_by
buildAdmin_structure_structure_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { adminStructureId = Absent, admin_structure = Absent, createdAt = Absent, deletedAt = Absent, id = Absent, structure = Absent, structureId = Absent }
    in
    Admin_structure_structure_order_by { adminStructureId = optionals____.adminStructureId, admin_structure = optionals____.admin_structure, createdAt = optionals____.createdAt, deletedAt = optionals____.deletedAt, id = optionals____.id, structure = optionals____.structure, structureId = optionals____.structureId }


type alias Admin_structure_structure_order_byOptionalFields =
    { adminStructureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , admin_structure : OptionalArgument Admin_structure_order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deletedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , structure : OptionalArgument Structure_order_by
    , structureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type alias for the `Admin_structure_structure_order_by` attributes. Note that this type
needs to use the `Admin_structure_structure_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Admin_structure_structure_order_byRaw =
    { adminStructureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , admin_structure : OptionalArgument Admin_structure_order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deletedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , structure : OptionalArgument Structure_order_by
    , structureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Admin\_structure\_structure\_order\_by input object.
-}
type Admin_structure_structure_order_by
    = Admin_structure_structure_order_by Admin_structure_structure_order_byRaw


{-| Encode a Admin\_structure\_structure\_order\_by into a value that can be used as an argument.
-}
encodeAdmin_structure_structure_order_by : Admin_structure_structure_order_by -> Value
encodeAdmin_structure_structure_order_by (Admin_structure_structure_order_by input____) =
    Encode.maybeObject
        [ ( "adminStructureId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.adminStructureId ), ( "admin_structure", encodeAdmin_structure_order_by |> Encode.optional input____.admin_structure ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "deletedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deletedAt ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "structure", encodeStructure_order_by |> Encode.optional input____.structure ), ( "structureId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.structureId ) ]


buildAdmin_structure_structure_pk_columns_input :
    Admin_structure_structure_pk_columns_inputRequiredFields
    -> Admin_structure_structure_pk_columns_input
buildAdmin_structure_structure_pk_columns_input required____ =
    { id = required____.id }


type alias Admin_structure_structure_pk_columns_inputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the Admin\_structure\_structure\_pk\_columns\_input input object.
-}
type alias Admin_structure_structure_pk_columns_input =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a Admin\_structure\_structure\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeAdmin_structure_structure_pk_columns_input : Admin_structure_structure_pk_columns_input -> Value
encodeAdmin_structure_structure_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildAdmin_structure_structure_set_input :
    (Admin_structure_structure_set_inputOptionalFields -> Admin_structure_structure_set_inputOptionalFields)
    -> Admin_structure_structure_set_input
buildAdmin_structure_structure_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { adminStructureId = Absent, createdAt = Absent, deletedAt = Absent, id = Absent, structureId = Absent }
    in
    { adminStructureId = optionals____.adminStructureId, createdAt = optionals____.createdAt, deletedAt = optionals____.deletedAt, id = optionals____.id, structureId = optionals____.structureId }


type alias Admin_structure_structure_set_inputOptionalFields =
    { adminStructureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deletedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , structureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Type for the Admin\_structure\_structure\_set\_input input object.
-}
type alias Admin_structure_structure_set_input =
    { adminStructureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deletedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , structureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Encode a Admin\_structure\_structure\_set\_input into a value that can be used as an argument.
-}
encodeAdmin_structure_structure_set_input : Admin_structure_structure_set_input -> Value
encodeAdmin_structure_structure_set_input input____ =
    Encode.maybeObject
        [ ( "adminStructureId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.adminStructureId ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "deletedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.deletedAt ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "structureId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.structureId ) ]


buildAdmin_structure_structure_stream_cursor_input :
    Admin_structure_structure_stream_cursor_inputRequiredFields
    -> (Admin_structure_structure_stream_cursor_inputOptionalFields -> Admin_structure_structure_stream_cursor_inputOptionalFields)
    -> Admin_structure_structure_stream_cursor_input
buildAdmin_structure_structure_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Admin_structure_structure_stream_cursor_inputRequiredFields =
    { initial_value : Admin_structure_structure_stream_cursor_value_input }


type alias Admin_structure_structure_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Admin\_structure\_structure\_stream\_cursor\_input input object.
-}
type alias Admin_structure_structure_stream_cursor_input =
    { initial_value : Admin_structure_structure_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Admin\_structure\_structure\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeAdmin_structure_structure_stream_cursor_input : Admin_structure_structure_stream_cursor_input -> Value
encodeAdmin_structure_structure_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeAdmin_structure_structure_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildAdmin_structure_structure_stream_cursor_value_input :
    (Admin_structure_structure_stream_cursor_value_inputOptionalFields -> Admin_structure_structure_stream_cursor_value_inputOptionalFields)
    -> Admin_structure_structure_stream_cursor_value_input
buildAdmin_structure_structure_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { adminStructureId = Absent, createdAt = Absent, deletedAt = Absent, id = Absent, structureId = Absent }
    in
    { adminStructureId = optionals____.adminStructureId, createdAt = optionals____.createdAt, deletedAt = optionals____.deletedAt, id = optionals____.id, structureId = optionals____.structureId }


type alias Admin_structure_structure_stream_cursor_value_inputOptionalFields =
    { adminStructureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deletedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , structureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Type for the Admin\_structure\_structure\_stream\_cursor\_value\_input input object.
-}
type alias Admin_structure_structure_stream_cursor_value_input =
    { adminStructureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deletedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , structureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Encode a Admin\_structure\_structure\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeAdmin_structure_structure_stream_cursor_value_input : Admin_structure_structure_stream_cursor_value_input -> Value
encodeAdmin_structure_structure_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "adminStructureId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.adminStructureId ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "deletedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.deletedAt ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "structureId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.structureId ) ]


buildAdmin_structure_structure_updates :
    Admin_structure_structure_updatesRequiredFields
    -> (Admin_structure_structure_updatesOptionalFields -> Admin_structure_structure_updatesOptionalFields)
    -> Admin_structure_structure_updates
buildAdmin_structure_structure_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Admin_structure_structure_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Admin_structure_structure_updatesRequiredFields =
    { where_ : Admin_structure_structure_bool_exp }


type alias Admin_structure_structure_updatesOptionalFields =
    { set_ : OptionalArgument Admin_structure_structure_set_input }


{-| Type alias for the `Admin_structure_structure_updates` attributes. Note that this type
needs to use the `Admin_structure_structure_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Admin_structure_structure_updatesRaw =
    { set_ : OptionalArgument Admin_structure_structure_set_input
    , where_ : Admin_structure_structure_bool_exp
    }


{-| Type for the Admin\_structure\_structure\_updates input object.
-}
type Admin_structure_structure_updates
    = Admin_structure_structure_updates Admin_structure_structure_updatesRaw


{-| Encode a Admin\_structure\_structure\_updates into a value that can be used as an argument.
-}
encodeAdmin_structure_structure_updates : Admin_structure_structure_updates -> Value
encodeAdmin_structure_structure_updates (Admin_structure_structure_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeAdmin_structure_structure_set_input |> Encode.optional input____.set_ ), ( "where", encodeAdmin_structure_structure_bool_exp input____.where_ |> Just ) ]


buildAdmin_structure_updates :
    Admin_structure_updatesRequiredFields
    -> (Admin_structure_updatesOptionalFields -> Admin_structure_updatesOptionalFields)
    -> Admin_structure_updates
buildAdmin_structure_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Admin_structure_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Admin_structure_updatesRequiredFields =
    { where_ : Admin_structure_bool_exp }


type alias Admin_structure_updatesOptionalFields =
    { set_ : OptionalArgument Admin_structure_set_input }


{-| Type alias for the `Admin_structure_updates` attributes. Note that this type
needs to use the `Admin_structure_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Admin_structure_updatesRaw =
    { set_ : OptionalArgument Admin_structure_set_input
    , where_ : Admin_structure_bool_exp
    }


{-| Type for the Admin\_structure\_updates input object.
-}
type Admin_structure_updates
    = Admin_structure_updates Admin_structure_updatesRaw


{-| Encode a Admin\_structure\_updates into a value that can be used as an argument.
-}
encodeAdmin_structure_updates : Admin_structure_updates -> Value
encodeAdmin_structure_updates (Admin_structure_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeAdmin_structure_set_input |> Encode.optional input____.set_ ), ( "where", encodeAdmin_structure_bool_exp input____.where_ |> Just ) ]


buildBeneficiary_aggregate_bool_exp :
    (Beneficiary_aggregate_bool_expOptionalFields -> Beneficiary_aggregate_bool_expOptionalFields)
    -> Beneficiary_aggregate_bool_exp
buildBeneficiary_aggregate_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { bool_and = Absent, bool_or = Absent, count = Absent }
    in
    Beneficiary_aggregate_bool_exp { bool_and = optionals____.bool_and, bool_or = optionals____.bool_or, count = optionals____.count }


type alias Beneficiary_aggregate_bool_expOptionalFields =
    { bool_and : OptionalArgument Beneficiary_aggregate_bool_exp_bool_and
    , bool_or : OptionalArgument Beneficiary_aggregate_bool_exp_bool_or
    , count : OptionalArgument Beneficiary_aggregate_bool_exp_count
    }


{-| Type alias for the `Beneficiary_aggregate_bool_exp` attributes. Note that this type
needs to use the `Beneficiary_aggregate_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Beneficiary_aggregate_bool_expRaw =
    { bool_and : OptionalArgument Beneficiary_aggregate_bool_exp_bool_and
    , bool_or : OptionalArgument Beneficiary_aggregate_bool_exp_bool_or
    , count : OptionalArgument Beneficiary_aggregate_bool_exp_count
    }


{-| Type for the Beneficiary\_aggregate\_bool\_exp input object.
-}
type Beneficiary_aggregate_bool_exp
    = Beneficiary_aggregate_bool_exp Beneficiary_aggregate_bool_expRaw


{-| Encode a Beneficiary\_aggregate\_bool\_exp into a value that can be used as an argument.
-}
encodeBeneficiary_aggregate_bool_exp : Beneficiary_aggregate_bool_exp -> Value
encodeBeneficiary_aggregate_bool_exp (Beneficiary_aggregate_bool_exp input____) =
    Encode.maybeObject
        [ ( "bool_and", encodeBeneficiary_aggregate_bool_exp_bool_and |> Encode.optional input____.bool_and ), ( "bool_or", encodeBeneficiary_aggregate_bool_exp_bool_or |> Encode.optional input____.bool_or ), ( "count", encodeBeneficiary_aggregate_bool_exp_count |> Encode.optional input____.count ) ]


buildBeneficiary_aggregate_bool_exp_bool_and :
    Beneficiary_aggregate_bool_exp_bool_andRequiredFields
    -> (Beneficiary_aggregate_bool_exp_bool_andOptionalFields -> Beneficiary_aggregate_bool_exp_bool_andOptionalFields)
    -> Beneficiary_aggregate_bool_exp_bool_and
buildBeneficiary_aggregate_bool_exp_bool_and required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { distinct = Absent, filter = Absent }
    in
    Beneficiary_aggregate_bool_exp_bool_and { arguments = required____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Beneficiary_aggregate_bool_exp_bool_andRequiredFields =
    { arguments : CdbGQL.Enum.Beneficiary_select_column_beneficiary_aggregate_bool_exp_bool_and_arguments_columns.Beneficiary_select_column_beneficiary_aggregate_bool_exp_bool_and_arguments_columns
    , predicate : Boolean_comparison_exp
    }


type alias Beneficiary_aggregate_bool_exp_bool_andOptionalFields =
    { distinct : OptionalArgument Bool
    , filter : OptionalArgument Beneficiary_bool_exp
    }


{-| Type alias for the `Beneficiary_aggregate_bool_exp_bool_and` attributes. Note that this type
needs to use the `Beneficiary_aggregate_bool_exp_bool_and` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Beneficiary_aggregate_bool_exp_bool_andRaw =
    { arguments : CdbGQL.Enum.Beneficiary_select_column_beneficiary_aggregate_bool_exp_bool_and_arguments_columns.Beneficiary_select_column_beneficiary_aggregate_bool_exp_bool_and_arguments_columns
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Beneficiary_bool_exp
    , predicate : Boolean_comparison_exp
    }


{-| Type for the Beneficiary\_aggregate\_bool\_exp\_bool\_and input object.
-}
type Beneficiary_aggregate_bool_exp_bool_and
    = Beneficiary_aggregate_bool_exp_bool_and Beneficiary_aggregate_bool_exp_bool_andRaw


{-| Encode a Beneficiary\_aggregate\_bool\_exp\_bool\_and into a value that can be used as an argument.
-}
encodeBeneficiary_aggregate_bool_exp_bool_and : Beneficiary_aggregate_bool_exp_bool_and -> Value
encodeBeneficiary_aggregate_bool_exp_bool_and (Beneficiary_aggregate_bool_exp_bool_and input____) =
    Encode.maybeObject
        [ ( "arguments", Encode.enum CdbGQL.Enum.Beneficiary_select_column_beneficiary_aggregate_bool_exp_bool_and_arguments_columns.toString input____.arguments |> Just ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeBeneficiary_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeBoolean_comparison_exp input____.predicate |> Just ) ]


buildBeneficiary_aggregate_bool_exp_bool_or :
    Beneficiary_aggregate_bool_exp_bool_orRequiredFields
    -> (Beneficiary_aggregate_bool_exp_bool_orOptionalFields -> Beneficiary_aggregate_bool_exp_bool_orOptionalFields)
    -> Beneficiary_aggregate_bool_exp_bool_or
buildBeneficiary_aggregate_bool_exp_bool_or required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { distinct = Absent, filter = Absent }
    in
    Beneficiary_aggregate_bool_exp_bool_or { arguments = required____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Beneficiary_aggregate_bool_exp_bool_orRequiredFields =
    { arguments : CdbGQL.Enum.Beneficiary_select_column_beneficiary_aggregate_bool_exp_bool_or_arguments_columns.Beneficiary_select_column_beneficiary_aggregate_bool_exp_bool_or_arguments_columns
    , predicate : Boolean_comparison_exp
    }


type alias Beneficiary_aggregate_bool_exp_bool_orOptionalFields =
    { distinct : OptionalArgument Bool
    , filter : OptionalArgument Beneficiary_bool_exp
    }


{-| Type alias for the `Beneficiary_aggregate_bool_exp_bool_or` attributes. Note that this type
needs to use the `Beneficiary_aggregate_bool_exp_bool_or` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Beneficiary_aggregate_bool_exp_bool_orRaw =
    { arguments : CdbGQL.Enum.Beneficiary_select_column_beneficiary_aggregate_bool_exp_bool_or_arguments_columns.Beneficiary_select_column_beneficiary_aggregate_bool_exp_bool_or_arguments_columns
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Beneficiary_bool_exp
    , predicate : Boolean_comparison_exp
    }


{-| Type for the Beneficiary\_aggregate\_bool\_exp\_bool\_or input object.
-}
type Beneficiary_aggregate_bool_exp_bool_or
    = Beneficiary_aggregate_bool_exp_bool_or Beneficiary_aggregate_bool_exp_bool_orRaw


{-| Encode a Beneficiary\_aggregate\_bool\_exp\_bool\_or into a value that can be used as an argument.
-}
encodeBeneficiary_aggregate_bool_exp_bool_or : Beneficiary_aggregate_bool_exp_bool_or -> Value
encodeBeneficiary_aggregate_bool_exp_bool_or (Beneficiary_aggregate_bool_exp_bool_or input____) =
    Encode.maybeObject
        [ ( "arguments", Encode.enum CdbGQL.Enum.Beneficiary_select_column_beneficiary_aggregate_bool_exp_bool_or_arguments_columns.toString input____.arguments |> Just ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeBeneficiary_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeBoolean_comparison_exp input____.predicate |> Just ) ]


buildBeneficiary_aggregate_bool_exp_count :
    Beneficiary_aggregate_bool_exp_countRequiredFields
    -> (Beneficiary_aggregate_bool_exp_countOptionalFields -> Beneficiary_aggregate_bool_exp_countOptionalFields)
    -> Beneficiary_aggregate_bool_exp_count
buildBeneficiary_aggregate_bool_exp_count required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { arguments = Absent, distinct = Absent, filter = Absent }
    in
    Beneficiary_aggregate_bool_exp_count { arguments = optionals____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Beneficiary_aggregate_bool_exp_countRequiredFields =
    { predicate : Int_comparison_exp }


type alias Beneficiary_aggregate_bool_exp_countOptionalFields =
    { arguments : OptionalArgument (List CdbGQL.Enum.Beneficiary_select_column.Beneficiary_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Beneficiary_bool_exp
    }


{-| Type alias for the `Beneficiary_aggregate_bool_exp_count` attributes. Note that this type
needs to use the `Beneficiary_aggregate_bool_exp_count` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Beneficiary_aggregate_bool_exp_countRaw =
    { arguments : OptionalArgument (List CdbGQL.Enum.Beneficiary_select_column.Beneficiary_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Beneficiary_bool_exp
    , predicate : Int_comparison_exp
    }


{-| Type for the Beneficiary\_aggregate\_bool\_exp\_count input object.
-}
type Beneficiary_aggregate_bool_exp_count
    = Beneficiary_aggregate_bool_exp_count Beneficiary_aggregate_bool_exp_countRaw


{-| Encode a Beneficiary\_aggregate\_bool\_exp\_count into a value that can be used as an argument.
-}
encodeBeneficiary_aggregate_bool_exp_count : Beneficiary_aggregate_bool_exp_count -> Value
encodeBeneficiary_aggregate_bool_exp_count (Beneficiary_aggregate_bool_exp_count input____) =
    Encode.maybeObject
        [ ( "arguments", (Encode.enum CdbGQL.Enum.Beneficiary_select_column.toString |> Encode.list) |> Encode.optional input____.arguments ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeBeneficiary_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeInt_comparison_exp input____.predicate |> Just ) ]


buildBeneficiary_aggregate_order_by :
    (Beneficiary_aggregate_order_byOptionalFields -> Beneficiary_aggregate_order_byOptionalFields)
    -> Beneficiary_aggregate_order_by
buildBeneficiary_aggregate_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals____.count, max = optionals____.max, min = optionals____.min }


type alias Beneficiary_aggregate_order_byOptionalFields =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Beneficiary_max_order_by
    , min : OptionalArgument Beneficiary_min_order_by
    }


{-| Type for the Beneficiary\_aggregate\_order\_by input object.
-}
type alias Beneficiary_aggregate_order_by =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Beneficiary_max_order_by
    , min : OptionalArgument Beneficiary_min_order_by
    }


{-| Encode a Beneficiary\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeBeneficiary_aggregate_order_by : Beneficiary_aggregate_order_by -> Value
encodeBeneficiary_aggregate_order_by input____ =
    Encode.maybeObject
        [ ( "count", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.count ), ( "max", encodeBeneficiary_max_order_by |> Encode.optional input____.max ), ( "min", encodeBeneficiary_min_order_by |> Encode.optional input____.min ) ]


buildBeneficiary_arr_rel_insert_input :
    Beneficiary_arr_rel_insert_inputRequiredFields
    -> (Beneficiary_arr_rel_insert_inputOptionalFields -> Beneficiary_arr_rel_insert_inputOptionalFields)
    -> Beneficiary_arr_rel_insert_input
buildBeneficiary_arr_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Beneficiary_arr_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Beneficiary_arr_rel_insert_inputRequiredFields =
    { data : List Beneficiary_insert_input }


type alias Beneficiary_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Beneficiary_on_conflict }


{-| Type alias for the `Beneficiary_arr_rel_insert_input` attributes. Note that this type
needs to use the `Beneficiary_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Beneficiary_arr_rel_insert_inputRaw =
    { data : List Beneficiary_insert_input
    , on_conflict : OptionalArgument Beneficiary_on_conflict
    }


{-| Type for the Beneficiary\_arr\_rel\_insert\_input input object.
-}
type Beneficiary_arr_rel_insert_input
    = Beneficiary_arr_rel_insert_input Beneficiary_arr_rel_insert_inputRaw


{-| Encode a Beneficiary\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeBeneficiary_arr_rel_insert_input : Beneficiary_arr_rel_insert_input -> Value
encodeBeneficiary_arr_rel_insert_input (Beneficiary_arr_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", (encodeBeneficiary_insert_input |> Encode.list) input____.data |> Just ), ( "on_conflict", encodeBeneficiary_on_conflict |> Encode.optional input____.on_conflict ) ]


buildBeneficiary_bool_exp :
    (Beneficiary_bool_expOptionalFields -> Beneficiary_bool_expOptionalFields)
    -> Beneficiary_bool_exp
buildBeneficiary_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, account = Absent, address1 = Absent, address2 = Absent, cafNumber = Absent, city = Absent, createdAt = Absent, dateOfBirth = Absent, deployment = Absent, deploymentId = Absent, email = Absent, externalDataInfos = Absent, externalDataInfos_aggregate = Absent, firstname = Absent, id = Absent, internalId = Absent, isHomeless = Absent, lastname = Absent, mobileNumber = Absent, nir = Absent, notebook = Absent, notebook_public_view = Absent, orientationRequest = Absent, orientationRequest_aggregate = Absent, peNumber = Absent, peUniqueId = Absent, placeOfBirth = Absent, postalCode = Absent, rightAre = Absent, rightAss = Absent, rightBonus = Absent, rightRsa = Absent, rsaClosureDate = Absent, rsaClosureReason = Absent, rsaSuspensionReason = Absent, structures = Absent, structures_aggregate = Absent, subjectToRightAndDuty = Absent, updatedAt = Absent }
    in
    Beneficiary_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, account = optionals____.account, address1 = optionals____.address1, address2 = optionals____.address2, cafNumber = optionals____.cafNumber, city = optionals____.city, createdAt = optionals____.createdAt, dateOfBirth = optionals____.dateOfBirth, deployment = optionals____.deployment, deploymentId = optionals____.deploymentId, email = optionals____.email, externalDataInfos = optionals____.externalDataInfos, externalDataInfos_aggregate = optionals____.externalDataInfos_aggregate, firstname = optionals____.firstname, id = optionals____.id, internalId = optionals____.internalId, isHomeless = optionals____.isHomeless, lastname = optionals____.lastname, mobileNumber = optionals____.mobileNumber, nir = optionals____.nir, notebook = optionals____.notebook, notebook_public_view = optionals____.notebook_public_view, orientationRequest = optionals____.orientationRequest, orientationRequest_aggregate = optionals____.orientationRequest_aggregate, peNumber = optionals____.peNumber, peUniqueId = optionals____.peUniqueId, placeOfBirth = optionals____.placeOfBirth, postalCode = optionals____.postalCode, rightAre = optionals____.rightAre, rightAss = optionals____.rightAss, rightBonus = optionals____.rightBonus, rightRsa = optionals____.rightRsa, rsaClosureDate = optionals____.rsaClosureDate, rsaClosureReason = optionals____.rsaClosureReason, rsaSuspensionReason = optionals____.rsaSuspensionReason, structures = optionals____.structures, structures_aggregate = optionals____.structures_aggregate, subjectToRightAndDuty = optionals____.subjectToRightAndDuty, updatedAt = optionals____.updatedAt }


type alias Beneficiary_bool_expOptionalFields =
    { and_ : OptionalArgument (List Beneficiary_bool_exp)
    , not_ : OptionalArgument Beneficiary_bool_exp
    , or_ : OptionalArgument (List Beneficiary_bool_exp)
    , account : OptionalArgument Account_bool_exp
    , address1 : OptionalArgument String_comparison_exp
    , address2 : OptionalArgument String_comparison_exp
    , cafNumber : OptionalArgument String_comparison_exp
    , city : OptionalArgument String_comparison_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , dateOfBirth : OptionalArgument Date_comparison_exp
    , deployment : OptionalArgument Deployment_bool_exp
    , deploymentId : OptionalArgument Uuid_comparison_exp
    , email : OptionalArgument Citext_comparison_exp
    , externalDataInfos : OptionalArgument External_data_info_bool_exp
    , externalDataInfos_aggregate : OptionalArgument External_data_info_aggregate_bool_exp
    , firstname : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , internalId : OptionalArgument String_comparison_exp
    , isHomeless : OptionalArgument Boolean_comparison_exp
    , lastname : OptionalArgument String_comparison_exp
    , mobileNumber : OptionalArgument String_comparison_exp
    , nir : OptionalArgument String_comparison_exp
    , notebook : OptionalArgument Notebook_bool_exp
    , notebook_public_view : OptionalArgument Notebook_public_view_bool_exp
    , orientationRequest : OptionalArgument Orientation_request_bool_exp
    , orientationRequest_aggregate : OptionalArgument Orientation_request_aggregate_bool_exp
    , peNumber : OptionalArgument String_comparison_exp
    , peUniqueId : OptionalArgument String_comparison_exp
    , placeOfBirth : OptionalArgument String_comparison_exp
    , postalCode : OptionalArgument String_comparison_exp
    , rightAre : OptionalArgument Boolean_comparison_exp
    , rightAss : OptionalArgument Boolean_comparison_exp
    , rightBonus : OptionalArgument Boolean_comparison_exp
    , rightRsa : OptionalArgument String_comparison_exp
    , rsaClosureDate : OptionalArgument Date_comparison_exp
    , rsaClosureReason : OptionalArgument Rsa_closure_reason_enum_comparison_exp
    , rsaSuspensionReason : OptionalArgument Rsa_suspension_reason_enum_comparison_exp
    , structures : OptionalArgument Beneficiary_structure_bool_exp
    , structures_aggregate : OptionalArgument Beneficiary_structure_aggregate_bool_exp
    , subjectToRightAndDuty : OptionalArgument Boolean_comparison_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type alias for the `Beneficiary_bool_exp` attributes. Note that this type
needs to use the `Beneficiary_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Beneficiary_bool_expRaw =
    { and_ : OptionalArgument (List Beneficiary_bool_exp)
    , not_ : OptionalArgument Beneficiary_bool_exp
    , or_ : OptionalArgument (List Beneficiary_bool_exp)
    , account : OptionalArgument Account_bool_exp
    , address1 : OptionalArgument String_comparison_exp
    , address2 : OptionalArgument String_comparison_exp
    , cafNumber : OptionalArgument String_comparison_exp
    , city : OptionalArgument String_comparison_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , dateOfBirth : OptionalArgument Date_comparison_exp
    , deployment : OptionalArgument Deployment_bool_exp
    , deploymentId : OptionalArgument Uuid_comparison_exp
    , email : OptionalArgument Citext_comparison_exp
    , externalDataInfos : OptionalArgument External_data_info_bool_exp
    , externalDataInfos_aggregate : OptionalArgument External_data_info_aggregate_bool_exp
    , firstname : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , internalId : OptionalArgument String_comparison_exp
    , isHomeless : OptionalArgument Boolean_comparison_exp
    , lastname : OptionalArgument String_comparison_exp
    , mobileNumber : OptionalArgument String_comparison_exp
    , nir : OptionalArgument String_comparison_exp
    , notebook : OptionalArgument Notebook_bool_exp
    , notebook_public_view : OptionalArgument Notebook_public_view_bool_exp
    , orientationRequest : OptionalArgument Orientation_request_bool_exp
    , orientationRequest_aggregate : OptionalArgument Orientation_request_aggregate_bool_exp
    , peNumber : OptionalArgument String_comparison_exp
    , peUniqueId : OptionalArgument String_comparison_exp
    , placeOfBirth : OptionalArgument String_comparison_exp
    , postalCode : OptionalArgument String_comparison_exp
    , rightAre : OptionalArgument Boolean_comparison_exp
    , rightAss : OptionalArgument Boolean_comparison_exp
    , rightBonus : OptionalArgument Boolean_comparison_exp
    , rightRsa : OptionalArgument String_comparison_exp
    , rsaClosureDate : OptionalArgument Date_comparison_exp
    , rsaClosureReason : OptionalArgument Rsa_closure_reason_enum_comparison_exp
    , rsaSuspensionReason : OptionalArgument Rsa_suspension_reason_enum_comparison_exp
    , structures : OptionalArgument Beneficiary_structure_bool_exp
    , structures_aggregate : OptionalArgument Beneficiary_structure_aggregate_bool_exp
    , subjectToRightAndDuty : OptionalArgument Boolean_comparison_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type for the Beneficiary\_bool\_exp input object.
-}
type Beneficiary_bool_exp
    = Beneficiary_bool_exp Beneficiary_bool_expRaw


{-| Encode a Beneficiary\_bool\_exp into a value that can be used as an argument.
-}
encodeBeneficiary_bool_exp : Beneficiary_bool_exp -> Value
encodeBeneficiary_bool_exp (Beneficiary_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeBeneficiary_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeBeneficiary_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeBeneficiary_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "account", encodeAccount_bool_exp |> Encode.optional input____.account ), ( "address1", encodeString_comparison_exp |> Encode.optional input____.address1 ), ( "address2", encodeString_comparison_exp |> Encode.optional input____.address2 ), ( "cafNumber", encodeString_comparison_exp |> Encode.optional input____.cafNumber ), ( "city", encodeString_comparison_exp |> Encode.optional input____.city ), ( "createdAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.createdAt ), ( "dateOfBirth", encodeDate_comparison_exp |> Encode.optional input____.dateOfBirth ), ( "deployment", encodeDeployment_bool_exp |> Encode.optional input____.deployment ), ( "deploymentId", encodeUuid_comparison_exp |> Encode.optional input____.deploymentId ), ( "email", encodeCitext_comparison_exp |> Encode.optional input____.email ), ( "externalDataInfos", encodeExternal_data_info_bool_exp |> Encode.optional input____.externalDataInfos ), ( "externalDataInfos_aggregate", encodeExternal_data_info_aggregate_bool_exp |> Encode.optional input____.externalDataInfos_aggregate ), ( "firstname", encodeString_comparison_exp |> Encode.optional input____.firstname ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "internalId", encodeString_comparison_exp |> Encode.optional input____.internalId ), ( "isHomeless", encodeBoolean_comparison_exp |> Encode.optional input____.isHomeless ), ( "lastname", encodeString_comparison_exp |> Encode.optional input____.lastname ), ( "mobileNumber", encodeString_comparison_exp |> Encode.optional input____.mobileNumber ), ( "nir", encodeString_comparison_exp |> Encode.optional input____.nir ), ( "notebook", encodeNotebook_bool_exp |> Encode.optional input____.notebook ), ( "notebook_public_view", encodeNotebook_public_view_bool_exp |> Encode.optional input____.notebook_public_view ), ( "orientationRequest", encodeOrientation_request_bool_exp |> Encode.optional input____.orientationRequest ), ( "orientationRequest_aggregate", encodeOrientation_request_aggregate_bool_exp |> Encode.optional input____.orientationRequest_aggregate ), ( "peNumber", encodeString_comparison_exp |> Encode.optional input____.peNumber ), ( "peUniqueId", encodeString_comparison_exp |> Encode.optional input____.peUniqueId ), ( "placeOfBirth", encodeString_comparison_exp |> Encode.optional input____.placeOfBirth ), ( "postalCode", encodeString_comparison_exp |> Encode.optional input____.postalCode ), ( "rightAre", encodeBoolean_comparison_exp |> Encode.optional input____.rightAre ), ( "rightAss", encodeBoolean_comparison_exp |> Encode.optional input____.rightAss ), ( "rightBonus", encodeBoolean_comparison_exp |> Encode.optional input____.rightBonus ), ( "rightRsa", encodeString_comparison_exp |> Encode.optional input____.rightRsa ), ( "rsaClosureDate", encodeDate_comparison_exp |> Encode.optional input____.rsaClosureDate ), ( "rsaClosureReason", encodeRsa_closure_reason_enum_comparison_exp |> Encode.optional input____.rsaClosureReason ), ( "rsaSuspensionReason", encodeRsa_suspension_reason_enum_comparison_exp |> Encode.optional input____.rsaSuspensionReason ), ( "structures", encodeBeneficiary_structure_bool_exp |> Encode.optional input____.structures ), ( "structures_aggregate", encodeBeneficiary_structure_aggregate_bool_exp |> Encode.optional input____.structures_aggregate ), ( "subjectToRightAndDuty", encodeBoolean_comparison_exp |> Encode.optional input____.subjectToRightAndDuty ), ( "updatedAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.updatedAt ) ]


buildBeneficiary_insert_input :
    (Beneficiary_insert_inputOptionalFields -> Beneficiary_insert_inputOptionalFields)
    -> Beneficiary_insert_input
buildBeneficiary_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { account = Absent, address1 = Absent, address2 = Absent, cafNumber = Absent, city = Absent, createdAt = Absent, dateOfBirth = Absent, deployment = Absent, deploymentId = Absent, email = Absent, externalDataInfos = Absent, firstname = Absent, id = Absent, internalId = Absent, isHomeless = Absent, lastname = Absent, mobileNumber = Absent, nir = Absent, notebook = Absent, notebook_public_view = Absent, orientationRequest = Absent, peNumber = Absent, peUniqueId = Absent, placeOfBirth = Absent, postalCode = Absent, rightAre = Absent, rightAss = Absent, rightBonus = Absent, rightRsa = Absent, rsaClosureDate = Absent, rsaClosureReason = Absent, rsaSuspensionReason = Absent, structures = Absent, subjectToRightAndDuty = Absent, updatedAt = Absent }
    in
    Beneficiary_insert_input { account = optionals____.account, address1 = optionals____.address1, address2 = optionals____.address2, cafNumber = optionals____.cafNumber, city = optionals____.city, createdAt = optionals____.createdAt, dateOfBirth = optionals____.dateOfBirth, deployment = optionals____.deployment, deploymentId = optionals____.deploymentId, email = optionals____.email, externalDataInfos = optionals____.externalDataInfos, firstname = optionals____.firstname, id = optionals____.id, internalId = optionals____.internalId, isHomeless = optionals____.isHomeless, lastname = optionals____.lastname, mobileNumber = optionals____.mobileNumber, nir = optionals____.nir, notebook = optionals____.notebook, notebook_public_view = optionals____.notebook_public_view, orientationRequest = optionals____.orientationRequest, peNumber = optionals____.peNumber, peUniqueId = optionals____.peUniqueId, placeOfBirth = optionals____.placeOfBirth, postalCode = optionals____.postalCode, rightAre = optionals____.rightAre, rightAss = optionals____.rightAss, rightBonus = optionals____.rightBonus, rightRsa = optionals____.rightRsa, rsaClosureDate = optionals____.rsaClosureDate, rsaClosureReason = optionals____.rsaClosureReason, rsaSuspensionReason = optionals____.rsaSuspensionReason, structures = optionals____.structures, subjectToRightAndDuty = optionals____.subjectToRightAndDuty, updatedAt = optionals____.updatedAt }


type alias Beneficiary_insert_inputOptionalFields =
    { account : OptionalArgument Account_obj_rel_insert_input
    , address1 : OptionalArgument String
    , address2 : OptionalArgument String
    , cafNumber : OptionalArgument String
    , city : OptionalArgument String
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , dateOfBirth : OptionalArgument CdbGQL.ScalarCodecs.Date
    , deployment : OptionalArgument Deployment_obj_rel_insert_input
    , deploymentId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , externalDataInfos : OptionalArgument External_data_info_arr_rel_insert_input
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , internalId : OptionalArgument String
    , isHomeless : OptionalArgument Bool
    , lastname : OptionalArgument String
    , mobileNumber : OptionalArgument String
    , nir : OptionalArgument String
    , notebook : OptionalArgument Notebook_obj_rel_insert_input
    , notebook_public_view : OptionalArgument Notebook_public_view_obj_rel_insert_input
    , orientationRequest : OptionalArgument Orientation_request_arr_rel_insert_input
    , peNumber : OptionalArgument String
    , peUniqueId : OptionalArgument String
    , placeOfBirth : OptionalArgument String
    , postalCode : OptionalArgument String
    , rightAre : OptionalArgument Bool
    , rightAss : OptionalArgument Bool
    , rightBonus : OptionalArgument Bool
    , rightRsa : OptionalArgument String
    , rsaClosureDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    , rsaClosureReason : OptionalArgument CdbGQL.Enum.Rsa_closure_reason_enum.Rsa_closure_reason_enum
    , rsaSuspensionReason : OptionalArgument CdbGQL.Enum.Rsa_suspension_reason_enum.Rsa_suspension_reason_enum
    , structures : OptionalArgument Beneficiary_structure_arr_rel_insert_input
    , subjectToRightAndDuty : OptionalArgument Bool
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type alias for the `Beneficiary_insert_input` attributes. Note that this type
needs to use the `Beneficiary_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Beneficiary_insert_inputRaw =
    { account : OptionalArgument Account_obj_rel_insert_input
    , address1 : OptionalArgument String
    , address2 : OptionalArgument String
    , cafNumber : OptionalArgument String
    , city : OptionalArgument String
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , dateOfBirth : OptionalArgument CdbGQL.ScalarCodecs.Date
    , deployment : OptionalArgument Deployment_obj_rel_insert_input
    , deploymentId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , externalDataInfos : OptionalArgument External_data_info_arr_rel_insert_input
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , internalId : OptionalArgument String
    , isHomeless : OptionalArgument Bool
    , lastname : OptionalArgument String
    , mobileNumber : OptionalArgument String
    , nir : OptionalArgument String
    , notebook : OptionalArgument Notebook_obj_rel_insert_input
    , notebook_public_view : OptionalArgument Notebook_public_view_obj_rel_insert_input
    , orientationRequest : OptionalArgument Orientation_request_arr_rel_insert_input
    , peNumber : OptionalArgument String
    , peUniqueId : OptionalArgument String
    , placeOfBirth : OptionalArgument String
    , postalCode : OptionalArgument String
    , rightAre : OptionalArgument Bool
    , rightAss : OptionalArgument Bool
    , rightBonus : OptionalArgument Bool
    , rightRsa : OptionalArgument String
    , rsaClosureDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    , rsaClosureReason : OptionalArgument CdbGQL.Enum.Rsa_closure_reason_enum.Rsa_closure_reason_enum
    , rsaSuspensionReason : OptionalArgument CdbGQL.Enum.Rsa_suspension_reason_enum.Rsa_suspension_reason_enum
    , structures : OptionalArgument Beneficiary_structure_arr_rel_insert_input
    , subjectToRightAndDuty : OptionalArgument Bool
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Beneficiary\_insert\_input input object.
-}
type Beneficiary_insert_input
    = Beneficiary_insert_input Beneficiary_insert_inputRaw


{-| Encode a Beneficiary\_insert\_input into a value that can be used as an argument.
-}
encodeBeneficiary_insert_input : Beneficiary_insert_input -> Value
encodeBeneficiary_insert_input (Beneficiary_insert_input input____) =
    Encode.maybeObject
        [ ( "account", encodeAccount_obj_rel_insert_input |> Encode.optional input____.account ), ( "address1", Encode.string |> Encode.optional input____.address1 ), ( "address2", Encode.string |> Encode.optional input____.address2 ), ( "cafNumber", Encode.string |> Encode.optional input____.cafNumber ), ( "city", Encode.string |> Encode.optional input____.city ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "dateOfBirth", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.dateOfBirth ), ( "deployment", encodeDeployment_obj_rel_insert_input |> Encode.optional input____.deployment ), ( "deploymentId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.deploymentId ), ( "email", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.email ), ( "externalDataInfos", encodeExternal_data_info_arr_rel_insert_input |> Encode.optional input____.externalDataInfos ), ( "firstname", Encode.string |> Encode.optional input____.firstname ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "internalId", Encode.string |> Encode.optional input____.internalId ), ( "isHomeless", Encode.bool |> Encode.optional input____.isHomeless ), ( "lastname", Encode.string |> Encode.optional input____.lastname ), ( "mobileNumber", Encode.string |> Encode.optional input____.mobileNumber ), ( "nir", Encode.string |> Encode.optional input____.nir ), ( "notebook", encodeNotebook_obj_rel_insert_input |> Encode.optional input____.notebook ), ( "notebook_public_view", encodeNotebook_public_view_obj_rel_insert_input |> Encode.optional input____.notebook_public_view ), ( "orientationRequest", encodeOrientation_request_arr_rel_insert_input |> Encode.optional input____.orientationRequest ), ( "peNumber", Encode.string |> Encode.optional input____.peNumber ), ( "peUniqueId", Encode.string |> Encode.optional input____.peUniqueId ), ( "placeOfBirth", Encode.string |> Encode.optional input____.placeOfBirth ), ( "postalCode", Encode.string |> Encode.optional input____.postalCode ), ( "rightAre", Encode.bool |> Encode.optional input____.rightAre ), ( "rightAss", Encode.bool |> Encode.optional input____.rightAss ), ( "rightBonus", Encode.bool |> Encode.optional input____.rightBonus ), ( "rightRsa", Encode.string |> Encode.optional input____.rightRsa ), ( "rsaClosureDate", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.rsaClosureDate ), ( "rsaClosureReason", Encode.enum CdbGQL.Enum.Rsa_closure_reason_enum.toString |> Encode.optional input____.rsaClosureReason ), ( "rsaSuspensionReason", Encode.enum CdbGQL.Enum.Rsa_suspension_reason_enum.toString |> Encode.optional input____.rsaSuspensionReason ), ( "structures", encodeBeneficiary_structure_arr_rel_insert_input |> Encode.optional input____.structures ), ( "subjectToRightAndDuty", Encode.bool |> Encode.optional input____.subjectToRightAndDuty ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildBeneficiary_max_order_by :
    (Beneficiary_max_order_byOptionalFields -> Beneficiary_max_order_byOptionalFields)
    -> Beneficiary_max_order_by
buildBeneficiary_max_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { address1 = Absent, address2 = Absent, cafNumber = Absent, city = Absent, createdAt = Absent, dateOfBirth = Absent, deploymentId = Absent, email = Absent, firstname = Absent, id = Absent, internalId = Absent, lastname = Absent, mobileNumber = Absent, nir = Absent, peNumber = Absent, peUniqueId = Absent, placeOfBirth = Absent, postalCode = Absent, rightRsa = Absent, rsaClosureDate = Absent, updatedAt = Absent }
    in
    { address1 = optionals____.address1, address2 = optionals____.address2, cafNumber = optionals____.cafNumber, city = optionals____.city, createdAt = optionals____.createdAt, dateOfBirth = optionals____.dateOfBirth, deploymentId = optionals____.deploymentId, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, internalId = optionals____.internalId, lastname = optionals____.lastname, mobileNumber = optionals____.mobileNumber, nir = optionals____.nir, peNumber = optionals____.peNumber, peUniqueId = optionals____.peUniqueId, placeOfBirth = optionals____.placeOfBirth, postalCode = optionals____.postalCode, rightRsa = optionals____.rightRsa, rsaClosureDate = optionals____.rsaClosureDate, updatedAt = optionals____.updatedAt }


type alias Beneficiary_max_order_byOptionalFields =
    { address1 : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , address2 : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , cafNumber : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , city : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , dateOfBirth : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deploymentId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , internalId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobileNumber : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , nir : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , peNumber : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , peUniqueId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , placeOfBirth : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , postalCode : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , rightRsa : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , rsaClosureDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Beneficiary\_max\_order\_by input object.
-}
type alias Beneficiary_max_order_by =
    { address1 : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , address2 : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , cafNumber : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , city : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , dateOfBirth : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deploymentId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , internalId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobileNumber : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , nir : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , peNumber : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , peUniqueId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , placeOfBirth : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , postalCode : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , rightRsa : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , rsaClosureDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Beneficiary\_max\_order\_by into a value that can be used as an argument.
-}
encodeBeneficiary_max_order_by : Beneficiary_max_order_by -> Value
encodeBeneficiary_max_order_by input____ =
    Encode.maybeObject
        [ ( "address1", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.address1 ), ( "address2", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.address2 ), ( "cafNumber", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.cafNumber ), ( "city", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.city ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "dateOfBirth", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.dateOfBirth ), ( "deploymentId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deploymentId ), ( "email", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.email ), ( "firstname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.firstname ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "internalId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.internalId ), ( "lastname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.lastname ), ( "mobileNumber", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.mobileNumber ), ( "nir", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.nir ), ( "peNumber", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.peNumber ), ( "peUniqueId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.peUniqueId ), ( "placeOfBirth", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.placeOfBirth ), ( "postalCode", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.postalCode ), ( "rightRsa", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.rightRsa ), ( "rsaClosureDate", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.rsaClosureDate ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildBeneficiary_min_order_by :
    (Beneficiary_min_order_byOptionalFields -> Beneficiary_min_order_byOptionalFields)
    -> Beneficiary_min_order_by
buildBeneficiary_min_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { address1 = Absent, address2 = Absent, cafNumber = Absent, city = Absent, createdAt = Absent, dateOfBirth = Absent, deploymentId = Absent, email = Absent, firstname = Absent, id = Absent, internalId = Absent, lastname = Absent, mobileNumber = Absent, nir = Absent, peNumber = Absent, peUniqueId = Absent, placeOfBirth = Absent, postalCode = Absent, rightRsa = Absent, rsaClosureDate = Absent, updatedAt = Absent }
    in
    { address1 = optionals____.address1, address2 = optionals____.address2, cafNumber = optionals____.cafNumber, city = optionals____.city, createdAt = optionals____.createdAt, dateOfBirth = optionals____.dateOfBirth, deploymentId = optionals____.deploymentId, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, internalId = optionals____.internalId, lastname = optionals____.lastname, mobileNumber = optionals____.mobileNumber, nir = optionals____.nir, peNumber = optionals____.peNumber, peUniqueId = optionals____.peUniqueId, placeOfBirth = optionals____.placeOfBirth, postalCode = optionals____.postalCode, rightRsa = optionals____.rightRsa, rsaClosureDate = optionals____.rsaClosureDate, updatedAt = optionals____.updatedAt }


type alias Beneficiary_min_order_byOptionalFields =
    { address1 : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , address2 : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , cafNumber : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , city : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , dateOfBirth : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deploymentId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , internalId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobileNumber : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , nir : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , peNumber : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , peUniqueId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , placeOfBirth : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , postalCode : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , rightRsa : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , rsaClosureDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Beneficiary\_min\_order\_by input object.
-}
type alias Beneficiary_min_order_by =
    { address1 : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , address2 : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , cafNumber : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , city : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , dateOfBirth : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deploymentId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , internalId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobileNumber : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , nir : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , peNumber : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , peUniqueId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , placeOfBirth : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , postalCode : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , rightRsa : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , rsaClosureDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Beneficiary\_min\_order\_by into a value that can be used as an argument.
-}
encodeBeneficiary_min_order_by : Beneficiary_min_order_by -> Value
encodeBeneficiary_min_order_by input____ =
    Encode.maybeObject
        [ ( "address1", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.address1 ), ( "address2", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.address2 ), ( "cafNumber", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.cafNumber ), ( "city", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.city ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "dateOfBirth", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.dateOfBirth ), ( "deploymentId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deploymentId ), ( "email", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.email ), ( "firstname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.firstname ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "internalId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.internalId ), ( "lastname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.lastname ), ( "mobileNumber", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.mobileNumber ), ( "nir", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.nir ), ( "peNumber", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.peNumber ), ( "peUniqueId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.peUniqueId ), ( "placeOfBirth", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.placeOfBirth ), ( "postalCode", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.postalCode ), ( "rightRsa", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.rightRsa ), ( "rsaClosureDate", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.rsaClosureDate ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildBeneficiary_obj_rel_insert_input :
    Beneficiary_obj_rel_insert_inputRequiredFields
    -> (Beneficiary_obj_rel_insert_inputOptionalFields -> Beneficiary_obj_rel_insert_inputOptionalFields)
    -> Beneficiary_obj_rel_insert_input
buildBeneficiary_obj_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Beneficiary_obj_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Beneficiary_obj_rel_insert_inputRequiredFields =
    { data : Beneficiary_insert_input }


type alias Beneficiary_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Beneficiary_on_conflict }


{-| Type alias for the `Beneficiary_obj_rel_insert_input` attributes. Note that this type
needs to use the `Beneficiary_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Beneficiary_obj_rel_insert_inputRaw =
    { data : Beneficiary_insert_input
    , on_conflict : OptionalArgument Beneficiary_on_conflict
    }


{-| Type for the Beneficiary\_obj\_rel\_insert\_input input object.
-}
type Beneficiary_obj_rel_insert_input
    = Beneficiary_obj_rel_insert_input Beneficiary_obj_rel_insert_inputRaw


{-| Encode a Beneficiary\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeBeneficiary_obj_rel_insert_input : Beneficiary_obj_rel_insert_input -> Value
encodeBeneficiary_obj_rel_insert_input (Beneficiary_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeBeneficiary_insert_input input____.data |> Just ), ( "on_conflict", encodeBeneficiary_on_conflict |> Encode.optional input____.on_conflict ) ]


buildBeneficiary_on_conflict :
    Beneficiary_on_conflictRequiredFields
    -> (Beneficiary_on_conflictOptionalFields -> Beneficiary_on_conflictOptionalFields)
    -> Beneficiary_on_conflict
buildBeneficiary_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Beneficiary_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Beneficiary_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Beneficiary_constraint.Beneficiary_constraint
    , update_columns : List CdbGQL.Enum.Beneficiary_update_column.Beneficiary_update_column
    }


type alias Beneficiary_on_conflictOptionalFields =
    { where_ : OptionalArgument Beneficiary_bool_exp }


{-| Type alias for the `Beneficiary_on_conflict` attributes. Note that this type
needs to use the `Beneficiary_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Beneficiary_on_conflictRaw =
    { constraint : CdbGQL.Enum.Beneficiary_constraint.Beneficiary_constraint
    , update_columns : List CdbGQL.Enum.Beneficiary_update_column.Beneficiary_update_column
    , where_ : OptionalArgument Beneficiary_bool_exp
    }


{-| Type for the Beneficiary\_on\_conflict input object.
-}
type Beneficiary_on_conflict
    = Beneficiary_on_conflict Beneficiary_on_conflictRaw


{-| Encode a Beneficiary\_on\_conflict into a value that can be used as an argument.
-}
encodeBeneficiary_on_conflict : Beneficiary_on_conflict -> Value
encodeBeneficiary_on_conflict (Beneficiary_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Beneficiary_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Beneficiary_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeBeneficiary_bool_exp |> Encode.optional input____.where_ ) ]


buildBeneficiary_order_by :
    (Beneficiary_order_byOptionalFields -> Beneficiary_order_byOptionalFields)
    -> Beneficiary_order_by
buildBeneficiary_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { account = Absent, address1 = Absent, address2 = Absent, cafNumber = Absent, city = Absent, createdAt = Absent, dateOfBirth = Absent, deployment = Absent, deploymentId = Absent, email = Absent, externalDataInfos_aggregate = Absent, firstname = Absent, id = Absent, internalId = Absent, isHomeless = Absent, lastname = Absent, mobileNumber = Absent, nir = Absent, notebook = Absent, notebook_public_view = Absent, orientationRequest_aggregate = Absent, peNumber = Absent, peUniqueId = Absent, placeOfBirth = Absent, postalCode = Absent, rightAre = Absent, rightAss = Absent, rightBonus = Absent, rightRsa = Absent, rsaClosureDate = Absent, rsaClosureReason = Absent, rsaSuspensionReason = Absent, structures_aggregate = Absent, subjectToRightAndDuty = Absent, updatedAt = Absent }
    in
    Beneficiary_order_by { account = optionals____.account, address1 = optionals____.address1, address2 = optionals____.address2, cafNumber = optionals____.cafNumber, city = optionals____.city, createdAt = optionals____.createdAt, dateOfBirth = optionals____.dateOfBirth, deployment = optionals____.deployment, deploymentId = optionals____.deploymentId, email = optionals____.email, externalDataInfos_aggregate = optionals____.externalDataInfos_aggregate, firstname = optionals____.firstname, id = optionals____.id, internalId = optionals____.internalId, isHomeless = optionals____.isHomeless, lastname = optionals____.lastname, mobileNumber = optionals____.mobileNumber, nir = optionals____.nir, notebook = optionals____.notebook, notebook_public_view = optionals____.notebook_public_view, orientationRequest_aggregate = optionals____.orientationRequest_aggregate, peNumber = optionals____.peNumber, peUniqueId = optionals____.peUniqueId, placeOfBirth = optionals____.placeOfBirth, postalCode = optionals____.postalCode, rightAre = optionals____.rightAre, rightAss = optionals____.rightAss, rightBonus = optionals____.rightBonus, rightRsa = optionals____.rightRsa, rsaClosureDate = optionals____.rsaClosureDate, rsaClosureReason = optionals____.rsaClosureReason, rsaSuspensionReason = optionals____.rsaSuspensionReason, structures_aggregate = optionals____.structures_aggregate, subjectToRightAndDuty = optionals____.subjectToRightAndDuty, updatedAt = optionals____.updatedAt }


type alias Beneficiary_order_byOptionalFields =
    { account : OptionalArgument Account_order_by
    , address1 : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , address2 : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , cafNumber : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , city : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , dateOfBirth : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deployment : OptionalArgument Deployment_order_by
    , deploymentId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , externalDataInfos_aggregate : OptionalArgument External_data_info_aggregate_order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , internalId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , isHomeless : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobileNumber : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , nir : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebook : OptionalArgument Notebook_order_by
    , notebook_public_view : OptionalArgument Notebook_public_view_order_by
    , orientationRequest_aggregate : OptionalArgument Orientation_request_aggregate_order_by
    , peNumber : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , peUniqueId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , placeOfBirth : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , postalCode : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , rightAre : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , rightAss : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , rightBonus : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , rightRsa : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , rsaClosureDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , rsaClosureReason : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , rsaSuspensionReason : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , structures_aggregate : OptionalArgument Beneficiary_structure_aggregate_order_by
    , subjectToRightAndDuty : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type alias for the `Beneficiary_order_by` attributes. Note that this type
needs to use the `Beneficiary_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Beneficiary_order_byRaw =
    { account : OptionalArgument Account_order_by
    , address1 : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , address2 : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , cafNumber : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , city : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , dateOfBirth : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deployment : OptionalArgument Deployment_order_by
    , deploymentId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , externalDataInfos_aggregate : OptionalArgument External_data_info_aggregate_order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , internalId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , isHomeless : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobileNumber : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , nir : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebook : OptionalArgument Notebook_order_by
    , notebook_public_view : OptionalArgument Notebook_public_view_order_by
    , orientationRequest_aggregate : OptionalArgument Orientation_request_aggregate_order_by
    , peNumber : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , peUniqueId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , placeOfBirth : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , postalCode : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , rightAre : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , rightAss : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , rightBonus : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , rightRsa : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , rsaClosureDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , rsaClosureReason : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , rsaSuspensionReason : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , structures_aggregate : OptionalArgument Beneficiary_structure_aggregate_order_by
    , subjectToRightAndDuty : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Beneficiary\_order\_by input object.
-}
type Beneficiary_order_by
    = Beneficiary_order_by Beneficiary_order_byRaw


{-| Encode a Beneficiary\_order\_by into a value that can be used as an argument.
-}
encodeBeneficiary_order_by : Beneficiary_order_by -> Value
encodeBeneficiary_order_by (Beneficiary_order_by input____) =
    Encode.maybeObject
        [ ( "account", encodeAccount_order_by |> Encode.optional input____.account ), ( "address1", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.address1 ), ( "address2", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.address2 ), ( "cafNumber", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.cafNumber ), ( "city", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.city ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "dateOfBirth", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.dateOfBirth ), ( "deployment", encodeDeployment_order_by |> Encode.optional input____.deployment ), ( "deploymentId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deploymentId ), ( "email", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.email ), ( "externalDataInfos_aggregate", encodeExternal_data_info_aggregate_order_by |> Encode.optional input____.externalDataInfos_aggregate ), ( "firstname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.firstname ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "internalId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.internalId ), ( "isHomeless", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.isHomeless ), ( "lastname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.lastname ), ( "mobileNumber", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.mobileNumber ), ( "nir", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.nir ), ( "notebook", encodeNotebook_order_by |> Encode.optional input____.notebook ), ( "notebook_public_view", encodeNotebook_public_view_order_by |> Encode.optional input____.notebook_public_view ), ( "orientationRequest_aggregate", encodeOrientation_request_aggregate_order_by |> Encode.optional input____.orientationRequest_aggregate ), ( "peNumber", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.peNumber ), ( "peUniqueId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.peUniqueId ), ( "placeOfBirth", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.placeOfBirth ), ( "postalCode", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.postalCode ), ( "rightAre", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.rightAre ), ( "rightAss", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.rightAss ), ( "rightBonus", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.rightBonus ), ( "rightRsa", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.rightRsa ), ( "rsaClosureDate", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.rsaClosureDate ), ( "rsaClosureReason", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.rsaClosureReason ), ( "rsaSuspensionReason", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.rsaSuspensionReason ), ( "structures_aggregate", encodeBeneficiary_structure_aggregate_order_by |> Encode.optional input____.structures_aggregate ), ( "subjectToRightAndDuty", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.subjectToRightAndDuty ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildBeneficiary_pk_columns_input :
    Beneficiary_pk_columns_inputRequiredFields
    -> Beneficiary_pk_columns_input
buildBeneficiary_pk_columns_input required____ =
    { id = required____.id }


type alias Beneficiary_pk_columns_inputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the Beneficiary\_pk\_columns\_input input object.
-}
type alias Beneficiary_pk_columns_input =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a Beneficiary\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeBeneficiary_pk_columns_input : Beneficiary_pk_columns_input -> Value
encodeBeneficiary_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildBeneficiary_set_input :
    (Beneficiary_set_inputOptionalFields -> Beneficiary_set_inputOptionalFields)
    -> Beneficiary_set_input
buildBeneficiary_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { address1 = Absent, address2 = Absent, cafNumber = Absent, city = Absent, createdAt = Absent, dateOfBirth = Absent, deploymentId = Absent, email = Absent, firstname = Absent, id = Absent, internalId = Absent, isHomeless = Absent, lastname = Absent, mobileNumber = Absent, nir = Absent, peNumber = Absent, peUniqueId = Absent, placeOfBirth = Absent, postalCode = Absent, rightAre = Absent, rightAss = Absent, rightBonus = Absent, rightRsa = Absent, rsaClosureDate = Absent, rsaClosureReason = Absent, rsaSuspensionReason = Absent, subjectToRightAndDuty = Absent, updatedAt = Absent }
    in
    { address1 = optionals____.address1, address2 = optionals____.address2, cafNumber = optionals____.cafNumber, city = optionals____.city, createdAt = optionals____.createdAt, dateOfBirth = optionals____.dateOfBirth, deploymentId = optionals____.deploymentId, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, internalId = optionals____.internalId, isHomeless = optionals____.isHomeless, lastname = optionals____.lastname, mobileNumber = optionals____.mobileNumber, nir = optionals____.nir, peNumber = optionals____.peNumber, peUniqueId = optionals____.peUniqueId, placeOfBirth = optionals____.placeOfBirth, postalCode = optionals____.postalCode, rightAre = optionals____.rightAre, rightAss = optionals____.rightAss, rightBonus = optionals____.rightBonus, rightRsa = optionals____.rightRsa, rsaClosureDate = optionals____.rsaClosureDate, rsaClosureReason = optionals____.rsaClosureReason, rsaSuspensionReason = optionals____.rsaSuspensionReason, subjectToRightAndDuty = optionals____.subjectToRightAndDuty, updatedAt = optionals____.updatedAt }


type alias Beneficiary_set_inputOptionalFields =
    { address1 : OptionalArgument String
    , address2 : OptionalArgument String
    , cafNumber : OptionalArgument String
    , city : OptionalArgument String
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , dateOfBirth : OptionalArgument CdbGQL.ScalarCodecs.Date
    , deploymentId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , internalId : OptionalArgument String
    , isHomeless : OptionalArgument Bool
    , lastname : OptionalArgument String
    , mobileNumber : OptionalArgument String
    , nir : OptionalArgument String
    , peNumber : OptionalArgument String
    , peUniqueId : OptionalArgument String
    , placeOfBirth : OptionalArgument String
    , postalCode : OptionalArgument String
    , rightAre : OptionalArgument Bool
    , rightAss : OptionalArgument Bool
    , rightBonus : OptionalArgument Bool
    , rightRsa : OptionalArgument String
    , rsaClosureDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    , rsaClosureReason : OptionalArgument CdbGQL.Enum.Rsa_closure_reason_enum.Rsa_closure_reason_enum
    , rsaSuspensionReason : OptionalArgument CdbGQL.Enum.Rsa_suspension_reason_enum.Rsa_suspension_reason_enum
    , subjectToRightAndDuty : OptionalArgument Bool
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Beneficiary\_set\_input input object.
-}
type alias Beneficiary_set_input =
    { address1 : OptionalArgument String
    , address2 : OptionalArgument String
    , cafNumber : OptionalArgument String
    , city : OptionalArgument String
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , dateOfBirth : OptionalArgument CdbGQL.ScalarCodecs.Date
    , deploymentId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , internalId : OptionalArgument String
    , isHomeless : OptionalArgument Bool
    , lastname : OptionalArgument String
    , mobileNumber : OptionalArgument String
    , nir : OptionalArgument String
    , peNumber : OptionalArgument String
    , peUniqueId : OptionalArgument String
    , placeOfBirth : OptionalArgument String
    , postalCode : OptionalArgument String
    , rightAre : OptionalArgument Bool
    , rightAss : OptionalArgument Bool
    , rightBonus : OptionalArgument Bool
    , rightRsa : OptionalArgument String
    , rsaClosureDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    , rsaClosureReason : OptionalArgument CdbGQL.Enum.Rsa_closure_reason_enum.Rsa_closure_reason_enum
    , rsaSuspensionReason : OptionalArgument CdbGQL.Enum.Rsa_suspension_reason_enum.Rsa_suspension_reason_enum
    , subjectToRightAndDuty : OptionalArgument Bool
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Beneficiary\_set\_input into a value that can be used as an argument.
-}
encodeBeneficiary_set_input : Beneficiary_set_input -> Value
encodeBeneficiary_set_input input____ =
    Encode.maybeObject
        [ ( "address1", Encode.string |> Encode.optional input____.address1 ), ( "address2", Encode.string |> Encode.optional input____.address2 ), ( "cafNumber", Encode.string |> Encode.optional input____.cafNumber ), ( "city", Encode.string |> Encode.optional input____.city ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "dateOfBirth", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.dateOfBirth ), ( "deploymentId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.deploymentId ), ( "email", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.email ), ( "firstname", Encode.string |> Encode.optional input____.firstname ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "internalId", Encode.string |> Encode.optional input____.internalId ), ( "isHomeless", Encode.bool |> Encode.optional input____.isHomeless ), ( "lastname", Encode.string |> Encode.optional input____.lastname ), ( "mobileNumber", Encode.string |> Encode.optional input____.mobileNumber ), ( "nir", Encode.string |> Encode.optional input____.nir ), ( "peNumber", Encode.string |> Encode.optional input____.peNumber ), ( "peUniqueId", Encode.string |> Encode.optional input____.peUniqueId ), ( "placeOfBirth", Encode.string |> Encode.optional input____.placeOfBirth ), ( "postalCode", Encode.string |> Encode.optional input____.postalCode ), ( "rightAre", Encode.bool |> Encode.optional input____.rightAre ), ( "rightAss", Encode.bool |> Encode.optional input____.rightAss ), ( "rightBonus", Encode.bool |> Encode.optional input____.rightBonus ), ( "rightRsa", Encode.string |> Encode.optional input____.rightRsa ), ( "rsaClosureDate", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.rsaClosureDate ), ( "rsaClosureReason", Encode.enum CdbGQL.Enum.Rsa_closure_reason_enum.toString |> Encode.optional input____.rsaClosureReason ), ( "rsaSuspensionReason", Encode.enum CdbGQL.Enum.Rsa_suspension_reason_enum.toString |> Encode.optional input____.rsaSuspensionReason ), ( "subjectToRightAndDuty", Encode.bool |> Encode.optional input____.subjectToRightAndDuty ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildBeneficiary_stream_cursor_input :
    Beneficiary_stream_cursor_inputRequiredFields
    -> (Beneficiary_stream_cursor_inputOptionalFields -> Beneficiary_stream_cursor_inputOptionalFields)
    -> Beneficiary_stream_cursor_input
buildBeneficiary_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Beneficiary_stream_cursor_inputRequiredFields =
    { initial_value : Beneficiary_stream_cursor_value_input }


type alias Beneficiary_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Beneficiary\_stream\_cursor\_input input object.
-}
type alias Beneficiary_stream_cursor_input =
    { initial_value : Beneficiary_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Beneficiary\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeBeneficiary_stream_cursor_input : Beneficiary_stream_cursor_input -> Value
encodeBeneficiary_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeBeneficiary_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildBeneficiary_stream_cursor_value_input :
    (Beneficiary_stream_cursor_value_inputOptionalFields -> Beneficiary_stream_cursor_value_inputOptionalFields)
    -> Beneficiary_stream_cursor_value_input
buildBeneficiary_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { address1 = Absent, address2 = Absent, cafNumber = Absent, city = Absent, createdAt = Absent, dateOfBirth = Absent, deploymentId = Absent, email = Absent, firstname = Absent, id = Absent, internalId = Absent, isHomeless = Absent, lastname = Absent, mobileNumber = Absent, nir = Absent, peNumber = Absent, peUniqueId = Absent, placeOfBirth = Absent, postalCode = Absent, rightAre = Absent, rightAss = Absent, rightBonus = Absent, rightRsa = Absent, rsaClosureDate = Absent, rsaClosureReason = Absent, rsaSuspensionReason = Absent, subjectToRightAndDuty = Absent, updatedAt = Absent }
    in
    { address1 = optionals____.address1, address2 = optionals____.address2, cafNumber = optionals____.cafNumber, city = optionals____.city, createdAt = optionals____.createdAt, dateOfBirth = optionals____.dateOfBirth, deploymentId = optionals____.deploymentId, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, internalId = optionals____.internalId, isHomeless = optionals____.isHomeless, lastname = optionals____.lastname, mobileNumber = optionals____.mobileNumber, nir = optionals____.nir, peNumber = optionals____.peNumber, peUniqueId = optionals____.peUniqueId, placeOfBirth = optionals____.placeOfBirth, postalCode = optionals____.postalCode, rightAre = optionals____.rightAre, rightAss = optionals____.rightAss, rightBonus = optionals____.rightBonus, rightRsa = optionals____.rightRsa, rsaClosureDate = optionals____.rsaClosureDate, rsaClosureReason = optionals____.rsaClosureReason, rsaSuspensionReason = optionals____.rsaSuspensionReason, subjectToRightAndDuty = optionals____.subjectToRightAndDuty, updatedAt = optionals____.updatedAt }


type alias Beneficiary_stream_cursor_value_inputOptionalFields =
    { address1 : OptionalArgument String
    , address2 : OptionalArgument String
    , cafNumber : OptionalArgument String
    , city : OptionalArgument String
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , dateOfBirth : OptionalArgument CdbGQL.ScalarCodecs.Date
    , deploymentId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , internalId : OptionalArgument String
    , isHomeless : OptionalArgument Bool
    , lastname : OptionalArgument String
    , mobileNumber : OptionalArgument String
    , nir : OptionalArgument String
    , peNumber : OptionalArgument String
    , peUniqueId : OptionalArgument String
    , placeOfBirth : OptionalArgument String
    , postalCode : OptionalArgument String
    , rightAre : OptionalArgument Bool
    , rightAss : OptionalArgument Bool
    , rightBonus : OptionalArgument Bool
    , rightRsa : OptionalArgument String
    , rsaClosureDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    , rsaClosureReason : OptionalArgument CdbGQL.Enum.Rsa_closure_reason_enum.Rsa_closure_reason_enum
    , rsaSuspensionReason : OptionalArgument CdbGQL.Enum.Rsa_suspension_reason_enum.Rsa_suspension_reason_enum
    , subjectToRightAndDuty : OptionalArgument Bool
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Beneficiary\_stream\_cursor\_value\_input input object.
-}
type alias Beneficiary_stream_cursor_value_input =
    { address1 : OptionalArgument String
    , address2 : OptionalArgument String
    , cafNumber : OptionalArgument String
    , city : OptionalArgument String
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , dateOfBirth : OptionalArgument CdbGQL.ScalarCodecs.Date
    , deploymentId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , internalId : OptionalArgument String
    , isHomeless : OptionalArgument Bool
    , lastname : OptionalArgument String
    , mobileNumber : OptionalArgument String
    , nir : OptionalArgument String
    , peNumber : OptionalArgument String
    , peUniqueId : OptionalArgument String
    , placeOfBirth : OptionalArgument String
    , postalCode : OptionalArgument String
    , rightAre : OptionalArgument Bool
    , rightAss : OptionalArgument Bool
    , rightBonus : OptionalArgument Bool
    , rightRsa : OptionalArgument String
    , rsaClosureDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    , rsaClosureReason : OptionalArgument CdbGQL.Enum.Rsa_closure_reason_enum.Rsa_closure_reason_enum
    , rsaSuspensionReason : OptionalArgument CdbGQL.Enum.Rsa_suspension_reason_enum.Rsa_suspension_reason_enum
    , subjectToRightAndDuty : OptionalArgument Bool
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Beneficiary\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeBeneficiary_stream_cursor_value_input : Beneficiary_stream_cursor_value_input -> Value
encodeBeneficiary_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "address1", Encode.string |> Encode.optional input____.address1 ), ( "address2", Encode.string |> Encode.optional input____.address2 ), ( "cafNumber", Encode.string |> Encode.optional input____.cafNumber ), ( "city", Encode.string |> Encode.optional input____.city ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "dateOfBirth", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.dateOfBirth ), ( "deploymentId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.deploymentId ), ( "email", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.email ), ( "firstname", Encode.string |> Encode.optional input____.firstname ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "internalId", Encode.string |> Encode.optional input____.internalId ), ( "isHomeless", Encode.bool |> Encode.optional input____.isHomeless ), ( "lastname", Encode.string |> Encode.optional input____.lastname ), ( "mobileNumber", Encode.string |> Encode.optional input____.mobileNumber ), ( "nir", Encode.string |> Encode.optional input____.nir ), ( "peNumber", Encode.string |> Encode.optional input____.peNumber ), ( "peUniqueId", Encode.string |> Encode.optional input____.peUniqueId ), ( "placeOfBirth", Encode.string |> Encode.optional input____.placeOfBirth ), ( "postalCode", Encode.string |> Encode.optional input____.postalCode ), ( "rightAre", Encode.bool |> Encode.optional input____.rightAre ), ( "rightAss", Encode.bool |> Encode.optional input____.rightAss ), ( "rightBonus", Encode.bool |> Encode.optional input____.rightBonus ), ( "rightRsa", Encode.string |> Encode.optional input____.rightRsa ), ( "rsaClosureDate", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.rsaClosureDate ), ( "rsaClosureReason", Encode.enum CdbGQL.Enum.Rsa_closure_reason_enum.toString |> Encode.optional input____.rsaClosureReason ), ( "rsaSuspensionReason", Encode.enum CdbGQL.Enum.Rsa_suspension_reason_enum.toString |> Encode.optional input____.rsaSuspensionReason ), ( "subjectToRightAndDuty", Encode.bool |> Encode.optional input____.subjectToRightAndDuty ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildBeneficiary_structure_aggregate_bool_exp :
    (Beneficiary_structure_aggregate_bool_expOptionalFields -> Beneficiary_structure_aggregate_bool_expOptionalFields)
    -> Beneficiary_structure_aggregate_bool_exp
buildBeneficiary_structure_aggregate_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent }
    in
    Beneficiary_structure_aggregate_bool_exp { count = optionals____.count }


type alias Beneficiary_structure_aggregate_bool_expOptionalFields =
    { count : OptionalArgument Beneficiary_structure_aggregate_bool_exp_count }


{-| Type alias for the `Beneficiary_structure_aggregate_bool_exp` attributes. Note that this type
needs to use the `Beneficiary_structure_aggregate_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Beneficiary_structure_aggregate_bool_expRaw =
    { count : OptionalArgument Beneficiary_structure_aggregate_bool_exp_count }


{-| Type for the Beneficiary\_structure\_aggregate\_bool\_exp input object.
-}
type Beneficiary_structure_aggregate_bool_exp
    = Beneficiary_structure_aggregate_bool_exp Beneficiary_structure_aggregate_bool_expRaw


{-| Encode a Beneficiary\_structure\_aggregate\_bool\_exp into a value that can be used as an argument.
-}
encodeBeneficiary_structure_aggregate_bool_exp : Beneficiary_structure_aggregate_bool_exp -> Value
encodeBeneficiary_structure_aggregate_bool_exp (Beneficiary_structure_aggregate_bool_exp input____) =
    Encode.maybeObject
        [ ( "count", encodeBeneficiary_structure_aggregate_bool_exp_count |> Encode.optional input____.count ) ]


buildBeneficiary_structure_aggregate_bool_exp_count :
    Beneficiary_structure_aggregate_bool_exp_countRequiredFields
    -> (Beneficiary_structure_aggregate_bool_exp_countOptionalFields -> Beneficiary_structure_aggregate_bool_exp_countOptionalFields)
    -> Beneficiary_structure_aggregate_bool_exp_count
buildBeneficiary_structure_aggregate_bool_exp_count required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { arguments = Absent, distinct = Absent, filter = Absent }
    in
    Beneficiary_structure_aggregate_bool_exp_count { arguments = optionals____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Beneficiary_structure_aggregate_bool_exp_countRequiredFields =
    { predicate : Int_comparison_exp }


type alias Beneficiary_structure_aggregate_bool_exp_countOptionalFields =
    { arguments : OptionalArgument (List CdbGQL.Enum.Beneficiary_structure_select_column.Beneficiary_structure_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Beneficiary_structure_bool_exp
    }


{-| Type alias for the `Beneficiary_structure_aggregate_bool_exp_count` attributes. Note that this type
needs to use the `Beneficiary_structure_aggregate_bool_exp_count` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Beneficiary_structure_aggregate_bool_exp_countRaw =
    { arguments : OptionalArgument (List CdbGQL.Enum.Beneficiary_structure_select_column.Beneficiary_structure_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Beneficiary_structure_bool_exp
    , predicate : Int_comparison_exp
    }


{-| Type for the Beneficiary\_structure\_aggregate\_bool\_exp\_count input object.
-}
type Beneficiary_structure_aggregate_bool_exp_count
    = Beneficiary_structure_aggregate_bool_exp_count Beneficiary_structure_aggregate_bool_exp_countRaw


{-| Encode a Beneficiary\_structure\_aggregate\_bool\_exp\_count into a value that can be used as an argument.
-}
encodeBeneficiary_structure_aggregate_bool_exp_count : Beneficiary_structure_aggregate_bool_exp_count -> Value
encodeBeneficiary_structure_aggregate_bool_exp_count (Beneficiary_structure_aggregate_bool_exp_count input____) =
    Encode.maybeObject
        [ ( "arguments", (Encode.enum CdbGQL.Enum.Beneficiary_structure_select_column.toString |> Encode.list) |> Encode.optional input____.arguments ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeBeneficiary_structure_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeInt_comparison_exp input____.predicate |> Just ) ]


buildBeneficiary_structure_aggregate_order_by :
    (Beneficiary_structure_aggregate_order_byOptionalFields -> Beneficiary_structure_aggregate_order_byOptionalFields)
    -> Beneficiary_structure_aggregate_order_by
buildBeneficiary_structure_aggregate_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals____.count, max = optionals____.max, min = optionals____.min }


type alias Beneficiary_structure_aggregate_order_byOptionalFields =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Beneficiary_structure_max_order_by
    , min : OptionalArgument Beneficiary_structure_min_order_by
    }


{-| Type for the Beneficiary\_structure\_aggregate\_order\_by input object.
-}
type alias Beneficiary_structure_aggregate_order_by =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Beneficiary_structure_max_order_by
    , min : OptionalArgument Beneficiary_structure_min_order_by
    }


{-| Encode a Beneficiary\_structure\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeBeneficiary_structure_aggregate_order_by : Beneficiary_structure_aggregate_order_by -> Value
encodeBeneficiary_structure_aggregate_order_by input____ =
    Encode.maybeObject
        [ ( "count", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.count ), ( "max", encodeBeneficiary_structure_max_order_by |> Encode.optional input____.max ), ( "min", encodeBeneficiary_structure_min_order_by |> Encode.optional input____.min ) ]


buildBeneficiary_structure_append_input :
    (Beneficiary_structure_append_inputOptionalFields -> Beneficiary_structure_append_inputOptionalFields)
    -> Beneficiary_structure_append_input
buildBeneficiary_structure_append_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { data = Absent }
    in
    { data = optionals____.data }


type alias Beneficiary_structure_append_inputOptionalFields =
    { data : OptionalArgument CdbGQL.ScalarCodecs.Jsonb }


{-| Type for the Beneficiary\_structure\_append\_input input object.
-}
type alias Beneficiary_structure_append_input =
    { data : OptionalArgument CdbGQL.ScalarCodecs.Jsonb }


{-| Encode a Beneficiary\_structure\_append\_input into a value that can be used as an argument.
-}
encodeBeneficiary_structure_append_input : Beneficiary_structure_append_input -> Value
encodeBeneficiary_structure_append_input input____ =
    Encode.maybeObject
        [ ( "data", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input____.data ) ]


buildBeneficiary_structure_arr_rel_insert_input :
    Beneficiary_structure_arr_rel_insert_inputRequiredFields
    -> (Beneficiary_structure_arr_rel_insert_inputOptionalFields -> Beneficiary_structure_arr_rel_insert_inputOptionalFields)
    -> Beneficiary_structure_arr_rel_insert_input
buildBeneficiary_structure_arr_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Beneficiary_structure_arr_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Beneficiary_structure_arr_rel_insert_inputRequiredFields =
    { data : List Beneficiary_structure_insert_input }


type alias Beneficiary_structure_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Beneficiary_structure_on_conflict }


{-| Type alias for the `Beneficiary_structure_arr_rel_insert_input` attributes. Note that this type
needs to use the `Beneficiary_structure_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Beneficiary_structure_arr_rel_insert_inputRaw =
    { data : List Beneficiary_structure_insert_input
    , on_conflict : OptionalArgument Beneficiary_structure_on_conflict
    }


{-| Type for the Beneficiary\_structure\_arr\_rel\_insert\_input input object.
-}
type Beneficiary_structure_arr_rel_insert_input
    = Beneficiary_structure_arr_rel_insert_input Beneficiary_structure_arr_rel_insert_inputRaw


{-| Encode a Beneficiary\_structure\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeBeneficiary_structure_arr_rel_insert_input : Beneficiary_structure_arr_rel_insert_input -> Value
encodeBeneficiary_structure_arr_rel_insert_input (Beneficiary_structure_arr_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", (encodeBeneficiary_structure_insert_input |> Encode.list) input____.data |> Just ), ( "on_conflict", encodeBeneficiary_structure_on_conflict |> Encode.optional input____.on_conflict ) ]


buildBeneficiary_structure_bool_exp :
    (Beneficiary_structure_bool_expOptionalFields -> Beneficiary_structure_bool_expOptionalFields)
    -> Beneficiary_structure_bool_exp
buildBeneficiary_structure_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, beneficiary = Absent, beneficiaryId = Absent, createdAt = Absent, data = Absent, id = Absent, status = Absent, structure = Absent, structureId = Absent, updatedAt = Absent }
    in
    Beneficiary_structure_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, beneficiary = optionals____.beneficiary, beneficiaryId = optionals____.beneficiaryId, createdAt = optionals____.createdAt, data = optionals____.data, id = optionals____.id, status = optionals____.status, structure = optionals____.structure, structureId = optionals____.structureId, updatedAt = optionals____.updatedAt }


type alias Beneficiary_structure_bool_expOptionalFields =
    { and_ : OptionalArgument (List Beneficiary_structure_bool_exp)
    , not_ : OptionalArgument Beneficiary_structure_bool_exp
    , or_ : OptionalArgument (List Beneficiary_structure_bool_exp)
    , beneficiary : OptionalArgument Beneficiary_bool_exp
    , beneficiaryId : OptionalArgument Uuid_comparison_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , data : OptionalArgument Jsonb_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , status : OptionalArgument String_comparison_exp
    , structure : OptionalArgument Structure_bool_exp
    , structureId : OptionalArgument Uuid_comparison_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type alias for the `Beneficiary_structure_bool_exp` attributes. Note that this type
needs to use the `Beneficiary_structure_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Beneficiary_structure_bool_expRaw =
    { and_ : OptionalArgument (List Beneficiary_structure_bool_exp)
    , not_ : OptionalArgument Beneficiary_structure_bool_exp
    , or_ : OptionalArgument (List Beneficiary_structure_bool_exp)
    , beneficiary : OptionalArgument Beneficiary_bool_exp
    , beneficiaryId : OptionalArgument Uuid_comparison_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , data : OptionalArgument Jsonb_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , status : OptionalArgument String_comparison_exp
    , structure : OptionalArgument Structure_bool_exp
    , structureId : OptionalArgument Uuid_comparison_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type for the Beneficiary\_structure\_bool\_exp input object.
-}
type Beneficiary_structure_bool_exp
    = Beneficiary_structure_bool_exp Beneficiary_structure_bool_expRaw


{-| Encode a Beneficiary\_structure\_bool\_exp into a value that can be used as an argument.
-}
encodeBeneficiary_structure_bool_exp : Beneficiary_structure_bool_exp -> Value
encodeBeneficiary_structure_bool_exp (Beneficiary_structure_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeBeneficiary_structure_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeBeneficiary_structure_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeBeneficiary_structure_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "beneficiary", encodeBeneficiary_bool_exp |> Encode.optional input____.beneficiary ), ( "beneficiaryId", encodeUuid_comparison_exp |> Encode.optional input____.beneficiaryId ), ( "createdAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.createdAt ), ( "data", encodeJsonb_comparison_exp |> Encode.optional input____.data ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "status", encodeString_comparison_exp |> Encode.optional input____.status ), ( "structure", encodeStructure_bool_exp |> Encode.optional input____.structure ), ( "structureId", encodeUuid_comparison_exp |> Encode.optional input____.structureId ), ( "updatedAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.updatedAt ) ]


buildBeneficiary_structure_delete_at_path_input :
    (Beneficiary_structure_delete_at_path_inputOptionalFields -> Beneficiary_structure_delete_at_path_inputOptionalFields)
    -> Beneficiary_structure_delete_at_path_input
buildBeneficiary_structure_delete_at_path_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { data = Absent }
    in
    { data = optionals____.data }


type alias Beneficiary_structure_delete_at_path_inputOptionalFields =
    { data : OptionalArgument (List String) }


{-| Type for the Beneficiary\_structure\_delete\_at\_path\_input input object.
-}
type alias Beneficiary_structure_delete_at_path_input =
    { data : OptionalArgument (List String) }


{-| Encode a Beneficiary\_structure\_delete\_at\_path\_input into a value that can be used as an argument.
-}
encodeBeneficiary_structure_delete_at_path_input : Beneficiary_structure_delete_at_path_input -> Value
encodeBeneficiary_structure_delete_at_path_input input____ =
    Encode.maybeObject
        [ ( "data", (Encode.string |> Encode.list) |> Encode.optional input____.data ) ]


buildBeneficiary_structure_delete_elem_input :
    (Beneficiary_structure_delete_elem_inputOptionalFields -> Beneficiary_structure_delete_elem_inputOptionalFields)
    -> Beneficiary_structure_delete_elem_input
buildBeneficiary_structure_delete_elem_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { data = Absent }
    in
    { data = optionals____.data }


type alias Beneficiary_structure_delete_elem_inputOptionalFields =
    { data : OptionalArgument Int }


{-| Type for the Beneficiary\_structure\_delete\_elem\_input input object.
-}
type alias Beneficiary_structure_delete_elem_input =
    { data : OptionalArgument Int }


{-| Encode a Beneficiary\_structure\_delete\_elem\_input into a value that can be used as an argument.
-}
encodeBeneficiary_structure_delete_elem_input : Beneficiary_structure_delete_elem_input -> Value
encodeBeneficiary_structure_delete_elem_input input____ =
    Encode.maybeObject
        [ ( "data", Encode.int |> Encode.optional input____.data ) ]


buildBeneficiary_structure_delete_key_input :
    (Beneficiary_structure_delete_key_inputOptionalFields -> Beneficiary_structure_delete_key_inputOptionalFields)
    -> Beneficiary_structure_delete_key_input
buildBeneficiary_structure_delete_key_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { data = Absent }
    in
    { data = optionals____.data }


type alias Beneficiary_structure_delete_key_inputOptionalFields =
    { data : OptionalArgument String }


{-| Type for the Beneficiary\_structure\_delete\_key\_input input object.
-}
type alias Beneficiary_structure_delete_key_input =
    { data : OptionalArgument String }


{-| Encode a Beneficiary\_structure\_delete\_key\_input into a value that can be used as an argument.
-}
encodeBeneficiary_structure_delete_key_input : Beneficiary_structure_delete_key_input -> Value
encodeBeneficiary_structure_delete_key_input input____ =
    Encode.maybeObject
        [ ( "data", Encode.string |> Encode.optional input____.data ) ]


buildBeneficiary_structure_insert_input :
    (Beneficiary_structure_insert_inputOptionalFields -> Beneficiary_structure_insert_inputOptionalFields)
    -> Beneficiary_structure_insert_input
buildBeneficiary_structure_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { beneficiary = Absent, beneficiaryId = Absent, createdAt = Absent, data = Absent, id = Absent, status = Absent, structure = Absent, structureId = Absent, updatedAt = Absent }
    in
    Beneficiary_structure_insert_input { beneficiary = optionals____.beneficiary, beneficiaryId = optionals____.beneficiaryId, createdAt = optionals____.createdAt, data = optionals____.data, id = optionals____.id, status = optionals____.status, structure = optionals____.structure, structureId = optionals____.structureId, updatedAt = optionals____.updatedAt }


type alias Beneficiary_structure_insert_inputOptionalFields =
    { beneficiary : OptionalArgument Beneficiary_obj_rel_insert_input
    , beneficiaryId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , data : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , status : OptionalArgument String
    , structure : OptionalArgument Structure_obj_rel_insert_input
    , structureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type alias for the `Beneficiary_structure_insert_input` attributes. Note that this type
needs to use the `Beneficiary_structure_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Beneficiary_structure_insert_inputRaw =
    { beneficiary : OptionalArgument Beneficiary_obj_rel_insert_input
    , beneficiaryId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , data : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , status : OptionalArgument String
    , structure : OptionalArgument Structure_obj_rel_insert_input
    , structureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Beneficiary\_structure\_insert\_input input object.
-}
type Beneficiary_structure_insert_input
    = Beneficiary_structure_insert_input Beneficiary_structure_insert_inputRaw


{-| Encode a Beneficiary\_structure\_insert\_input into a value that can be used as an argument.
-}
encodeBeneficiary_structure_insert_input : Beneficiary_structure_insert_input -> Value
encodeBeneficiary_structure_insert_input (Beneficiary_structure_insert_input input____) =
    Encode.maybeObject
        [ ( "beneficiary", encodeBeneficiary_obj_rel_insert_input |> Encode.optional input____.beneficiary ), ( "beneficiaryId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.beneficiaryId ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "data", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input____.data ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "status", Encode.string |> Encode.optional input____.status ), ( "structure", encodeStructure_obj_rel_insert_input |> Encode.optional input____.structure ), ( "structureId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.structureId ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildBeneficiary_structure_max_order_by :
    (Beneficiary_structure_max_order_byOptionalFields -> Beneficiary_structure_max_order_byOptionalFields)
    -> Beneficiary_structure_max_order_by
buildBeneficiary_structure_max_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { beneficiaryId = Absent, createdAt = Absent, id = Absent, status = Absent, structureId = Absent, updatedAt = Absent }
    in
    { beneficiaryId = optionals____.beneficiaryId, createdAt = optionals____.createdAt, id = optionals____.id, status = optionals____.status, structureId = optionals____.structureId, updatedAt = optionals____.updatedAt }


type alias Beneficiary_structure_max_order_byOptionalFields =
    { beneficiaryId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , status : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , structureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Beneficiary\_structure\_max\_order\_by input object.
-}
type alias Beneficiary_structure_max_order_by =
    { beneficiaryId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , status : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , structureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Beneficiary\_structure\_max\_order\_by into a value that can be used as an argument.
-}
encodeBeneficiary_structure_max_order_by : Beneficiary_structure_max_order_by -> Value
encodeBeneficiary_structure_max_order_by input____ =
    Encode.maybeObject
        [ ( "beneficiaryId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.beneficiaryId ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "status", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.status ), ( "structureId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.structureId ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildBeneficiary_structure_min_order_by :
    (Beneficiary_structure_min_order_byOptionalFields -> Beneficiary_structure_min_order_byOptionalFields)
    -> Beneficiary_structure_min_order_by
buildBeneficiary_structure_min_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { beneficiaryId = Absent, createdAt = Absent, id = Absent, status = Absent, structureId = Absent, updatedAt = Absent }
    in
    { beneficiaryId = optionals____.beneficiaryId, createdAt = optionals____.createdAt, id = optionals____.id, status = optionals____.status, structureId = optionals____.structureId, updatedAt = optionals____.updatedAt }


type alias Beneficiary_structure_min_order_byOptionalFields =
    { beneficiaryId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , status : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , structureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Beneficiary\_structure\_min\_order\_by input object.
-}
type alias Beneficiary_structure_min_order_by =
    { beneficiaryId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , status : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , structureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Beneficiary\_structure\_min\_order\_by into a value that can be used as an argument.
-}
encodeBeneficiary_structure_min_order_by : Beneficiary_structure_min_order_by -> Value
encodeBeneficiary_structure_min_order_by input____ =
    Encode.maybeObject
        [ ( "beneficiaryId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.beneficiaryId ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "status", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.status ), ( "structureId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.structureId ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildBeneficiary_structure_on_conflict :
    Beneficiary_structure_on_conflictRequiredFields
    -> (Beneficiary_structure_on_conflictOptionalFields -> Beneficiary_structure_on_conflictOptionalFields)
    -> Beneficiary_structure_on_conflict
buildBeneficiary_structure_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Beneficiary_structure_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Beneficiary_structure_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Beneficiary_structure_constraint.Beneficiary_structure_constraint
    , update_columns : List CdbGQL.Enum.Beneficiary_structure_update_column.Beneficiary_structure_update_column
    }


type alias Beneficiary_structure_on_conflictOptionalFields =
    { where_ : OptionalArgument Beneficiary_structure_bool_exp }


{-| Type alias for the `Beneficiary_structure_on_conflict` attributes. Note that this type
needs to use the `Beneficiary_structure_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Beneficiary_structure_on_conflictRaw =
    { constraint : CdbGQL.Enum.Beneficiary_structure_constraint.Beneficiary_structure_constraint
    , update_columns : List CdbGQL.Enum.Beneficiary_structure_update_column.Beneficiary_structure_update_column
    , where_ : OptionalArgument Beneficiary_structure_bool_exp
    }


{-| Type for the Beneficiary\_structure\_on\_conflict input object.
-}
type Beneficiary_structure_on_conflict
    = Beneficiary_structure_on_conflict Beneficiary_structure_on_conflictRaw


{-| Encode a Beneficiary\_structure\_on\_conflict into a value that can be used as an argument.
-}
encodeBeneficiary_structure_on_conflict : Beneficiary_structure_on_conflict -> Value
encodeBeneficiary_structure_on_conflict (Beneficiary_structure_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Beneficiary_structure_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Beneficiary_structure_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeBeneficiary_structure_bool_exp |> Encode.optional input____.where_ ) ]


buildBeneficiary_structure_order_by :
    (Beneficiary_structure_order_byOptionalFields -> Beneficiary_structure_order_byOptionalFields)
    -> Beneficiary_structure_order_by
buildBeneficiary_structure_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { beneficiary = Absent, beneficiaryId = Absent, createdAt = Absent, data = Absent, id = Absent, status = Absent, structure = Absent, structureId = Absent, updatedAt = Absent }
    in
    Beneficiary_structure_order_by { beneficiary = optionals____.beneficiary, beneficiaryId = optionals____.beneficiaryId, createdAt = optionals____.createdAt, data = optionals____.data, id = optionals____.id, status = optionals____.status, structure = optionals____.structure, structureId = optionals____.structureId, updatedAt = optionals____.updatedAt }


type alias Beneficiary_structure_order_byOptionalFields =
    { beneficiary : OptionalArgument Beneficiary_order_by
    , beneficiaryId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , data : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , status : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , structure : OptionalArgument Structure_order_by
    , structureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type alias for the `Beneficiary_structure_order_by` attributes. Note that this type
needs to use the `Beneficiary_structure_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Beneficiary_structure_order_byRaw =
    { beneficiary : OptionalArgument Beneficiary_order_by
    , beneficiaryId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , data : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , status : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , structure : OptionalArgument Structure_order_by
    , structureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Beneficiary\_structure\_order\_by input object.
-}
type Beneficiary_structure_order_by
    = Beneficiary_structure_order_by Beneficiary_structure_order_byRaw


{-| Encode a Beneficiary\_structure\_order\_by into a value that can be used as an argument.
-}
encodeBeneficiary_structure_order_by : Beneficiary_structure_order_by -> Value
encodeBeneficiary_structure_order_by (Beneficiary_structure_order_by input____) =
    Encode.maybeObject
        [ ( "beneficiary", encodeBeneficiary_order_by |> Encode.optional input____.beneficiary ), ( "beneficiaryId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.beneficiaryId ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "data", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.data ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "status", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.status ), ( "structure", encodeStructure_order_by |> Encode.optional input____.structure ), ( "structureId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.structureId ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildBeneficiary_structure_pk_columns_input :
    Beneficiary_structure_pk_columns_inputRequiredFields
    -> Beneficiary_structure_pk_columns_input
buildBeneficiary_structure_pk_columns_input required____ =
    { id = required____.id }


type alias Beneficiary_structure_pk_columns_inputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the Beneficiary\_structure\_pk\_columns\_input input object.
-}
type alias Beneficiary_structure_pk_columns_input =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a Beneficiary\_structure\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeBeneficiary_structure_pk_columns_input : Beneficiary_structure_pk_columns_input -> Value
encodeBeneficiary_structure_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildBeneficiary_structure_prepend_input :
    (Beneficiary_structure_prepend_inputOptionalFields -> Beneficiary_structure_prepend_inputOptionalFields)
    -> Beneficiary_structure_prepend_input
buildBeneficiary_structure_prepend_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { data = Absent }
    in
    { data = optionals____.data }


type alias Beneficiary_structure_prepend_inputOptionalFields =
    { data : OptionalArgument CdbGQL.ScalarCodecs.Jsonb }


{-| Type for the Beneficiary\_structure\_prepend\_input input object.
-}
type alias Beneficiary_structure_prepend_input =
    { data : OptionalArgument CdbGQL.ScalarCodecs.Jsonb }


{-| Encode a Beneficiary\_structure\_prepend\_input into a value that can be used as an argument.
-}
encodeBeneficiary_structure_prepend_input : Beneficiary_structure_prepend_input -> Value
encodeBeneficiary_structure_prepend_input input____ =
    Encode.maybeObject
        [ ( "data", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input____.data ) ]


buildBeneficiary_structure_set_input :
    (Beneficiary_structure_set_inputOptionalFields -> Beneficiary_structure_set_inputOptionalFields)
    -> Beneficiary_structure_set_input
buildBeneficiary_structure_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { beneficiaryId = Absent, createdAt = Absent, data = Absent, id = Absent, status = Absent, structureId = Absent, updatedAt = Absent }
    in
    { beneficiaryId = optionals____.beneficiaryId, createdAt = optionals____.createdAt, data = optionals____.data, id = optionals____.id, status = optionals____.status, structureId = optionals____.structureId, updatedAt = optionals____.updatedAt }


type alias Beneficiary_structure_set_inputOptionalFields =
    { beneficiaryId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , data : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , status : OptionalArgument String
    , structureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Beneficiary\_structure\_set\_input input object.
-}
type alias Beneficiary_structure_set_input =
    { beneficiaryId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , data : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , status : OptionalArgument String
    , structureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Beneficiary\_structure\_set\_input into a value that can be used as an argument.
-}
encodeBeneficiary_structure_set_input : Beneficiary_structure_set_input -> Value
encodeBeneficiary_structure_set_input input____ =
    Encode.maybeObject
        [ ( "beneficiaryId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.beneficiaryId ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "data", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input____.data ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "status", Encode.string |> Encode.optional input____.status ), ( "structureId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.structureId ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildBeneficiary_structure_stream_cursor_input :
    Beneficiary_structure_stream_cursor_inputRequiredFields
    -> (Beneficiary_structure_stream_cursor_inputOptionalFields -> Beneficiary_structure_stream_cursor_inputOptionalFields)
    -> Beneficiary_structure_stream_cursor_input
buildBeneficiary_structure_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Beneficiary_structure_stream_cursor_inputRequiredFields =
    { initial_value : Beneficiary_structure_stream_cursor_value_input }


type alias Beneficiary_structure_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Beneficiary\_structure\_stream\_cursor\_input input object.
-}
type alias Beneficiary_structure_stream_cursor_input =
    { initial_value : Beneficiary_structure_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Beneficiary\_structure\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeBeneficiary_structure_stream_cursor_input : Beneficiary_structure_stream_cursor_input -> Value
encodeBeneficiary_structure_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeBeneficiary_structure_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildBeneficiary_structure_stream_cursor_value_input :
    (Beneficiary_structure_stream_cursor_value_inputOptionalFields -> Beneficiary_structure_stream_cursor_value_inputOptionalFields)
    -> Beneficiary_structure_stream_cursor_value_input
buildBeneficiary_structure_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { beneficiaryId = Absent, createdAt = Absent, data = Absent, id = Absent, status = Absent, structureId = Absent, updatedAt = Absent }
    in
    { beneficiaryId = optionals____.beneficiaryId, createdAt = optionals____.createdAt, data = optionals____.data, id = optionals____.id, status = optionals____.status, structureId = optionals____.structureId, updatedAt = optionals____.updatedAt }


type alias Beneficiary_structure_stream_cursor_value_inputOptionalFields =
    { beneficiaryId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , data : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , status : OptionalArgument String
    , structureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Beneficiary\_structure\_stream\_cursor\_value\_input input object.
-}
type alias Beneficiary_structure_stream_cursor_value_input =
    { beneficiaryId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , data : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , status : OptionalArgument String
    , structureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Beneficiary\_structure\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeBeneficiary_structure_stream_cursor_value_input : Beneficiary_structure_stream_cursor_value_input -> Value
encodeBeneficiary_structure_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "beneficiaryId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.beneficiaryId ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "data", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input____.data ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "status", Encode.string |> Encode.optional input____.status ), ( "structureId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.structureId ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildBeneficiary_structure_updates :
    Beneficiary_structure_updatesRequiredFields
    -> (Beneficiary_structure_updatesOptionalFields -> Beneficiary_structure_updatesOptionalFields)
    -> Beneficiary_structure_updates
buildBeneficiary_structure_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { append_ = Absent, delete_at_path_ = Absent, delete_elem_ = Absent, delete_key_ = Absent, prepend_ = Absent, set_ = Absent }
    in
    Beneficiary_structure_updates { append_ = optionals____.append_, delete_at_path_ = optionals____.delete_at_path_, delete_elem_ = optionals____.delete_elem_, delete_key_ = optionals____.delete_key_, prepend_ = optionals____.prepend_, set_ = optionals____.set_, where_ = required____.where_ }


type alias Beneficiary_structure_updatesRequiredFields =
    { where_ : Beneficiary_structure_bool_exp }


type alias Beneficiary_structure_updatesOptionalFields =
    { append_ : OptionalArgument Beneficiary_structure_append_input
    , delete_at_path_ : OptionalArgument Beneficiary_structure_delete_at_path_input
    , delete_elem_ : OptionalArgument Beneficiary_structure_delete_elem_input
    , delete_key_ : OptionalArgument Beneficiary_structure_delete_key_input
    , prepend_ : OptionalArgument Beneficiary_structure_prepend_input
    , set_ : OptionalArgument Beneficiary_structure_set_input
    }


{-| Type alias for the `Beneficiary_structure_updates` attributes. Note that this type
needs to use the `Beneficiary_structure_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Beneficiary_structure_updatesRaw =
    { append_ : OptionalArgument Beneficiary_structure_append_input
    , delete_at_path_ : OptionalArgument Beneficiary_structure_delete_at_path_input
    , delete_elem_ : OptionalArgument Beneficiary_structure_delete_elem_input
    , delete_key_ : OptionalArgument Beneficiary_structure_delete_key_input
    , prepend_ : OptionalArgument Beneficiary_structure_prepend_input
    , set_ : OptionalArgument Beneficiary_structure_set_input
    , where_ : Beneficiary_structure_bool_exp
    }


{-| Type for the Beneficiary\_structure\_updates input object.
-}
type Beneficiary_structure_updates
    = Beneficiary_structure_updates Beneficiary_structure_updatesRaw


{-| Encode a Beneficiary\_structure\_updates into a value that can be used as an argument.
-}
encodeBeneficiary_structure_updates : Beneficiary_structure_updates -> Value
encodeBeneficiary_structure_updates (Beneficiary_structure_updates input____) =
    Encode.maybeObject
        [ ( "_append", encodeBeneficiary_structure_append_input |> Encode.optional input____.append_ ), ( "_delete_at_path", encodeBeneficiary_structure_delete_at_path_input |> Encode.optional input____.delete_at_path_ ), ( "_delete_elem", encodeBeneficiary_structure_delete_elem_input |> Encode.optional input____.delete_elem_ ), ( "_delete_key", encodeBeneficiary_structure_delete_key_input |> Encode.optional input____.delete_key_ ), ( "_prepend", encodeBeneficiary_structure_prepend_input |> Encode.optional input____.prepend_ ), ( "_set", encodeBeneficiary_structure_set_input |> Encode.optional input____.set_ ), ( "where", encodeBeneficiary_structure_bool_exp input____.where_ |> Just ) ]


buildBeneficiary_updates :
    Beneficiary_updatesRequiredFields
    -> (Beneficiary_updatesOptionalFields -> Beneficiary_updatesOptionalFields)
    -> Beneficiary_updates
buildBeneficiary_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Beneficiary_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Beneficiary_updatesRequiredFields =
    { where_ : Beneficiary_bool_exp }


type alias Beneficiary_updatesOptionalFields =
    { set_ : OptionalArgument Beneficiary_set_input }


{-| Type alias for the `Beneficiary_updates` attributes. Note that this type
needs to use the `Beneficiary_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Beneficiary_updatesRaw =
    { set_ : OptionalArgument Beneficiary_set_input
    , where_ : Beneficiary_bool_exp
    }


{-| Type for the Beneficiary\_updates input object.
-}
type Beneficiary_updates
    = Beneficiary_updates Beneficiary_updatesRaw


{-| Encode a Beneficiary\_updates into a value that can be used as an argument.
-}
encodeBeneficiary_updates : Beneficiary_updates -> Value
encodeBeneficiary_updates (Beneficiary_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeBeneficiary_set_input |> Encode.optional input____.set_ ), ( "where", encodeBeneficiary_bool_exp input____.where_ |> Just ) ]


buildBoolean_comparison_exp :
    (Boolean_comparison_expOptionalFields -> Boolean_comparison_expOptionalFields)
    -> Boolean_comparison_exp
buildBoolean_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals____.eq_, gt_ = optionals____.gt_, gte_ = optionals____.gte_, in_ = optionals____.in_, is_null_ = optionals____.is_null_, lt_ = optionals____.lt_, lte_ = optionals____.lte_, neq_ = optionals____.neq_, nin_ = optionals____.nin_ }


type alias Boolean_comparison_expOptionalFields =
    { eq_ : OptionalArgument Bool
    , gt_ : OptionalArgument Bool
    , gte_ : OptionalArgument Bool
    , in_ : OptionalArgument (List Bool)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Bool
    , lte_ : OptionalArgument Bool
    , neq_ : OptionalArgument Bool
    , nin_ : OptionalArgument (List Bool)
    }


{-| Type for the Boolean\_comparison\_exp input object.
-}
type alias Boolean_comparison_exp =
    { eq_ : OptionalArgument Bool
    , gt_ : OptionalArgument Bool
    , gte_ : OptionalArgument Bool
    , in_ : OptionalArgument (List Bool)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Bool
    , lte_ : OptionalArgument Bool
    , neq_ : OptionalArgument Bool
    , nin_ : OptionalArgument (List Bool)
    }


{-| Encode a Boolean\_comparison\_exp into a value that can be used as an argument.
-}
encodeBoolean_comparison_exp : Boolean_comparison_exp -> Value
encodeBoolean_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", Encode.bool |> Encode.optional input____.eq_ ), ( "_gt", Encode.bool |> Encode.optional input____.gt_ ), ( "_gte", Encode.bool |> Encode.optional input____.gte_ ), ( "_in", (Encode.bool |> Encode.list) |> Encode.optional input____.in_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_lt", Encode.bool |> Encode.optional input____.lt_ ), ( "_lte", Encode.bool |> Encode.optional input____.lte_ ), ( "_neq", Encode.bool |> Encode.optional input____.neq_ ), ( "_nin", (Encode.bool |> Encode.list) |> Encode.optional input____.nin_ ) ]


buildCitext_comparison_exp :
    (Citext_comparison_expOptionalFields -> Citext_comparison_expOptionalFields)
    -> Citext_comparison_exp
buildCitext_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, ilike_ = Absent, in_ = Absent, iregex_ = Absent, is_null_ = Absent, like_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nilike_ = Absent, nin_ = Absent, niregex_ = Absent, nlike_ = Absent, nregex_ = Absent, nsimilar_ = Absent, regex_ = Absent, similar_ = Absent }
    in
    { eq_ = optionals____.eq_, gt_ = optionals____.gt_, gte_ = optionals____.gte_, ilike_ = optionals____.ilike_, in_ = optionals____.in_, iregex_ = optionals____.iregex_, is_null_ = optionals____.is_null_, like_ = optionals____.like_, lt_ = optionals____.lt_, lte_ = optionals____.lte_, neq_ = optionals____.neq_, nilike_ = optionals____.nilike_, nin_ = optionals____.nin_, niregex_ = optionals____.niregex_, nlike_ = optionals____.nlike_, nregex_ = optionals____.nregex_, nsimilar_ = optionals____.nsimilar_, regex_ = optionals____.regex_, similar_ = optionals____.similar_ }


type alias Citext_comparison_expOptionalFields =
    { eq_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , gt_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , gte_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , ilike_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , in_ : OptionalArgument (List CdbGQL.ScalarCodecs.Citext)
    , iregex_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , lt_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , lte_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , neq_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , nilike_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , nin_ : OptionalArgument (List CdbGQL.ScalarCodecs.Citext)
    , niregex_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , nlike_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , nregex_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , nsimilar_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , regex_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , similar_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    }


{-| Type for the Citext\_comparison\_exp input object.
-}
type alias Citext_comparison_exp =
    { eq_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , gt_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , gte_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , ilike_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , in_ : OptionalArgument (List CdbGQL.ScalarCodecs.Citext)
    , iregex_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , lt_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , lte_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , neq_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , nilike_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , nin_ : OptionalArgument (List CdbGQL.ScalarCodecs.Citext)
    , niregex_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , nlike_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , nregex_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , nsimilar_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , regex_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , similar_ : OptionalArgument CdbGQL.ScalarCodecs.Citext
    }


{-| Encode a Citext\_comparison\_exp into a value that can be used as an argument.
-}
encodeCitext_comparison_exp : Citext_comparison_exp -> Value
encodeCitext_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.eq_ ), ( "_gt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.gt_ ), ( "_gte", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.gte_ ), ( "_ilike", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.ilike_ ), ( "_in", ((CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.list) |> Encode.optional input____.in_ ), ( "_iregex", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.iregex_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_like", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.like_ ), ( "_lt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.lt_ ), ( "_lte", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.lte_ ), ( "_neq", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.neq_ ), ( "_nilike", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.nilike_ ), ( "_nin", ((CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.list) |> Encode.optional input____.nin_ ), ( "_niregex", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.niregex_ ), ( "_nlike", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.nlike_ ), ( "_nregex", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.nregex_ ), ( "_nsimilar", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.nsimilar_ ), ( "_regex", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.regex_ ), ( "_similar", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.similar_ ) ]


buildContract_type_bool_exp :
    (Contract_type_bool_expOptionalFields -> Contract_type_bool_expOptionalFields)
    -> Contract_type_bool_exp
buildContract_type_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, id = Absent, label = Absent }
    in
    Contract_type_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, id = optionals____.id, label = optionals____.label }


type alias Contract_type_bool_expOptionalFields =
    { and_ : OptionalArgument (List Contract_type_bool_exp)
    , not_ : OptionalArgument Contract_type_bool_exp
    , or_ : OptionalArgument (List Contract_type_bool_exp)
    , id : OptionalArgument String_comparison_exp
    , label : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Contract_type_bool_exp` attributes. Note that this type
needs to use the `Contract_type_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Contract_type_bool_expRaw =
    { and_ : OptionalArgument (List Contract_type_bool_exp)
    , not_ : OptionalArgument Contract_type_bool_exp
    , or_ : OptionalArgument (List Contract_type_bool_exp)
    , id : OptionalArgument String_comparison_exp
    , label : OptionalArgument String_comparison_exp
    }


{-| Type for the Contract\_type\_bool\_exp input object.
-}
type Contract_type_bool_exp
    = Contract_type_bool_exp Contract_type_bool_expRaw


{-| Encode a Contract\_type\_bool\_exp into a value that can be used as an argument.
-}
encodeContract_type_bool_exp : Contract_type_bool_exp -> Value
encodeContract_type_bool_exp (Contract_type_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeContract_type_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeContract_type_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeContract_type_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "id", encodeString_comparison_exp |> Encode.optional input____.id ), ( "label", encodeString_comparison_exp |> Encode.optional input____.label ) ]


buildContract_type_enum_comparison_exp :
    (Contract_type_enum_comparison_expOptionalFields -> Contract_type_enum_comparison_expOptionalFields)
    -> Contract_type_enum_comparison_exp
buildContract_type_enum_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, in_ = Absent, is_null_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals____.eq_, in_ = optionals____.in_, is_null_ = optionals____.is_null_, neq_ = optionals____.neq_, nin_ = optionals____.nin_ }


type alias Contract_type_enum_comparison_expOptionalFields =
    { eq_ : OptionalArgument CdbGQL.Enum.Contract_type_enum.Contract_type_enum
    , in_ : OptionalArgument (List CdbGQL.Enum.Contract_type_enum.Contract_type_enum)
    , is_null_ : OptionalArgument Bool
    , neq_ : OptionalArgument CdbGQL.Enum.Contract_type_enum.Contract_type_enum
    , nin_ : OptionalArgument (List CdbGQL.Enum.Contract_type_enum.Contract_type_enum)
    }


{-| Type for the Contract\_type\_enum\_comparison\_exp input object.
-}
type alias Contract_type_enum_comparison_exp =
    { eq_ : OptionalArgument CdbGQL.Enum.Contract_type_enum.Contract_type_enum
    , in_ : OptionalArgument (List CdbGQL.Enum.Contract_type_enum.Contract_type_enum)
    , is_null_ : OptionalArgument Bool
    , neq_ : OptionalArgument CdbGQL.Enum.Contract_type_enum.Contract_type_enum
    , nin_ : OptionalArgument (List CdbGQL.Enum.Contract_type_enum.Contract_type_enum)
    }


{-| Encode a Contract\_type\_enum\_comparison\_exp into a value that can be used as an argument.
-}
encodeContract_type_enum_comparison_exp : Contract_type_enum_comparison_exp -> Value
encodeContract_type_enum_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", Encode.enum CdbGQL.Enum.Contract_type_enum.toString |> Encode.optional input____.eq_ ), ( "_in", (Encode.enum CdbGQL.Enum.Contract_type_enum.toString |> Encode.list) |> Encode.optional input____.in_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_neq", Encode.enum CdbGQL.Enum.Contract_type_enum.toString |> Encode.optional input____.neq_ ), ( "_nin", (Encode.enum CdbGQL.Enum.Contract_type_enum.toString |> Encode.list) |> Encode.optional input____.nin_ ) ]


buildContract_type_insert_input :
    (Contract_type_insert_inputOptionalFields -> Contract_type_insert_inputOptionalFields)
    -> Contract_type_insert_input
buildContract_type_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, label = Absent }
    in
    { id = optionals____.id, label = optionals____.label }


type alias Contract_type_insert_inputOptionalFields =
    { id : OptionalArgument String
    , label : OptionalArgument String
    }


{-| Type for the Contract\_type\_insert\_input input object.
-}
type alias Contract_type_insert_input =
    { id : OptionalArgument String
    , label : OptionalArgument String
    }


{-| Encode a Contract\_type\_insert\_input into a value that can be used as an argument.
-}
encodeContract_type_insert_input : Contract_type_insert_input -> Value
encodeContract_type_insert_input input____ =
    Encode.maybeObject
        [ ( "id", Encode.string |> Encode.optional input____.id ), ( "label", Encode.string |> Encode.optional input____.label ) ]


buildContract_type_obj_rel_insert_input :
    Contract_type_obj_rel_insert_inputRequiredFields
    -> (Contract_type_obj_rel_insert_inputOptionalFields -> Contract_type_obj_rel_insert_inputOptionalFields)
    -> Contract_type_obj_rel_insert_input
buildContract_type_obj_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Contract_type_obj_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Contract_type_obj_rel_insert_inputRequiredFields =
    { data : Contract_type_insert_input }


type alias Contract_type_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Contract_type_on_conflict }


{-| Type alias for the `Contract_type_obj_rel_insert_input` attributes. Note that this type
needs to use the `Contract_type_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Contract_type_obj_rel_insert_inputRaw =
    { data : Contract_type_insert_input
    , on_conflict : OptionalArgument Contract_type_on_conflict
    }


{-| Type for the Contract\_type\_obj\_rel\_insert\_input input object.
-}
type Contract_type_obj_rel_insert_input
    = Contract_type_obj_rel_insert_input Contract_type_obj_rel_insert_inputRaw


{-| Encode a Contract\_type\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeContract_type_obj_rel_insert_input : Contract_type_obj_rel_insert_input -> Value
encodeContract_type_obj_rel_insert_input (Contract_type_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeContract_type_insert_input input____.data |> Just ), ( "on_conflict", encodeContract_type_on_conflict |> Encode.optional input____.on_conflict ) ]


buildContract_type_on_conflict :
    Contract_type_on_conflictRequiredFields
    -> (Contract_type_on_conflictOptionalFields -> Contract_type_on_conflictOptionalFields)
    -> Contract_type_on_conflict
buildContract_type_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Contract_type_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Contract_type_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Contract_type_constraint.Contract_type_constraint
    , update_columns : List CdbGQL.Enum.Contract_type_update_column.Contract_type_update_column
    }


type alias Contract_type_on_conflictOptionalFields =
    { where_ : OptionalArgument Contract_type_bool_exp }


{-| Type alias for the `Contract_type_on_conflict` attributes. Note that this type
needs to use the `Contract_type_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Contract_type_on_conflictRaw =
    { constraint : CdbGQL.Enum.Contract_type_constraint.Contract_type_constraint
    , update_columns : List CdbGQL.Enum.Contract_type_update_column.Contract_type_update_column
    , where_ : OptionalArgument Contract_type_bool_exp
    }


{-| Type for the Contract\_type\_on\_conflict input object.
-}
type Contract_type_on_conflict
    = Contract_type_on_conflict Contract_type_on_conflictRaw


{-| Encode a Contract\_type\_on\_conflict into a value that can be used as an argument.
-}
encodeContract_type_on_conflict : Contract_type_on_conflict -> Value
encodeContract_type_on_conflict (Contract_type_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Contract_type_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Contract_type_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeContract_type_bool_exp |> Encode.optional input____.where_ ) ]


buildContract_type_order_by :
    (Contract_type_order_byOptionalFields -> Contract_type_order_byOptionalFields)
    -> Contract_type_order_by
buildContract_type_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, label = Absent }
    in
    { id = optionals____.id, label = optionals____.label }


type alias Contract_type_order_byOptionalFields =
    { id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , label : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Contract\_type\_order\_by input object.
-}
type alias Contract_type_order_by =
    { id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , label : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Contract\_type\_order\_by into a value that can be used as an argument.
-}
encodeContract_type_order_by : Contract_type_order_by -> Value
encodeContract_type_order_by input____ =
    Encode.maybeObject
        [ ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "label", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.label ) ]


buildContract_type_pk_columns_input :
    Contract_type_pk_columns_inputRequiredFields
    -> Contract_type_pk_columns_input
buildContract_type_pk_columns_input required____ =
    { id = required____.id }


type alias Contract_type_pk_columns_inputRequiredFields =
    { id : String }


{-| Type for the Contract\_type\_pk\_columns\_input input object.
-}
type alias Contract_type_pk_columns_input =
    { id : String }


{-| Encode a Contract\_type\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeContract_type_pk_columns_input : Contract_type_pk_columns_input -> Value
encodeContract_type_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", Encode.string input____.id |> Just ) ]


buildContract_type_set_input :
    (Contract_type_set_inputOptionalFields -> Contract_type_set_inputOptionalFields)
    -> Contract_type_set_input
buildContract_type_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, label = Absent }
    in
    { id = optionals____.id, label = optionals____.label }


type alias Contract_type_set_inputOptionalFields =
    { id : OptionalArgument String
    , label : OptionalArgument String
    }


{-| Type for the Contract\_type\_set\_input input object.
-}
type alias Contract_type_set_input =
    { id : OptionalArgument String
    , label : OptionalArgument String
    }


{-| Encode a Contract\_type\_set\_input into a value that can be used as an argument.
-}
encodeContract_type_set_input : Contract_type_set_input -> Value
encodeContract_type_set_input input____ =
    Encode.maybeObject
        [ ( "id", Encode.string |> Encode.optional input____.id ), ( "label", Encode.string |> Encode.optional input____.label ) ]


buildContract_type_stream_cursor_input :
    Contract_type_stream_cursor_inputRequiredFields
    -> (Contract_type_stream_cursor_inputOptionalFields -> Contract_type_stream_cursor_inputOptionalFields)
    -> Contract_type_stream_cursor_input
buildContract_type_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Contract_type_stream_cursor_inputRequiredFields =
    { initial_value : Contract_type_stream_cursor_value_input }


type alias Contract_type_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Contract\_type\_stream\_cursor\_input input object.
-}
type alias Contract_type_stream_cursor_input =
    { initial_value : Contract_type_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Contract\_type\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeContract_type_stream_cursor_input : Contract_type_stream_cursor_input -> Value
encodeContract_type_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeContract_type_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildContract_type_stream_cursor_value_input :
    (Contract_type_stream_cursor_value_inputOptionalFields -> Contract_type_stream_cursor_value_inputOptionalFields)
    -> Contract_type_stream_cursor_value_input
buildContract_type_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, label = Absent }
    in
    { id = optionals____.id, label = optionals____.label }


type alias Contract_type_stream_cursor_value_inputOptionalFields =
    { id : OptionalArgument String
    , label : OptionalArgument String
    }


{-| Type for the Contract\_type\_stream\_cursor\_value\_input input object.
-}
type alias Contract_type_stream_cursor_value_input =
    { id : OptionalArgument String
    , label : OptionalArgument String
    }


{-| Encode a Contract\_type\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeContract_type_stream_cursor_value_input : Contract_type_stream_cursor_value_input -> Value
encodeContract_type_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "id", Encode.string |> Encode.optional input____.id ), ( "label", Encode.string |> Encode.optional input____.label ) ]


buildContract_type_updates :
    Contract_type_updatesRequiredFields
    -> (Contract_type_updatesOptionalFields -> Contract_type_updatesOptionalFields)
    -> Contract_type_updates
buildContract_type_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Contract_type_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Contract_type_updatesRequiredFields =
    { where_ : Contract_type_bool_exp }


type alias Contract_type_updatesOptionalFields =
    { set_ : OptionalArgument Contract_type_set_input }


{-| Type alias for the `Contract_type_updates` attributes. Note that this type
needs to use the `Contract_type_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Contract_type_updatesRaw =
    { set_ : OptionalArgument Contract_type_set_input
    , where_ : Contract_type_bool_exp
    }


{-| Type for the Contract\_type\_updates input object.
-}
type Contract_type_updates
    = Contract_type_updates Contract_type_updatesRaw


{-| Encode a Contract\_type\_updates into a value that can be used as an argument.
-}
encodeContract_type_updates : Contract_type_updates -> Value
encodeContract_type_updates (Contract_type_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeContract_type_set_input |> Encode.optional input____.set_ ), ( "where", encodeContract_type_bool_exp input____.where_ |> Just ) ]


buildDate_comparison_exp :
    (Date_comparison_expOptionalFields -> Date_comparison_expOptionalFields)
    -> Date_comparison_exp
buildDate_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals____.eq_, gt_ = optionals____.gt_, gte_ = optionals____.gte_, in_ = optionals____.in_, is_null_ = optionals____.is_null_, lt_ = optionals____.lt_, lte_ = optionals____.lte_, neq_ = optionals____.neq_, nin_ = optionals____.nin_ }


type alias Date_comparison_expOptionalFields =
    { eq_ : OptionalArgument CdbGQL.ScalarCodecs.Date
    , gt_ : OptionalArgument CdbGQL.ScalarCodecs.Date
    , gte_ : OptionalArgument CdbGQL.ScalarCodecs.Date
    , in_ : OptionalArgument (List CdbGQL.ScalarCodecs.Date)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CdbGQL.ScalarCodecs.Date
    , lte_ : OptionalArgument CdbGQL.ScalarCodecs.Date
    , neq_ : OptionalArgument CdbGQL.ScalarCodecs.Date
    , nin_ : OptionalArgument (List CdbGQL.ScalarCodecs.Date)
    }


{-| Type for the Date\_comparison\_exp input object.
-}
type alias Date_comparison_exp =
    { eq_ : OptionalArgument CdbGQL.ScalarCodecs.Date
    , gt_ : OptionalArgument CdbGQL.ScalarCodecs.Date
    , gte_ : OptionalArgument CdbGQL.ScalarCodecs.Date
    , in_ : OptionalArgument (List CdbGQL.ScalarCodecs.Date)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CdbGQL.ScalarCodecs.Date
    , lte_ : OptionalArgument CdbGQL.ScalarCodecs.Date
    , neq_ : OptionalArgument CdbGQL.ScalarCodecs.Date
    , nin_ : OptionalArgument (List CdbGQL.ScalarCodecs.Date)
    }


{-| Encode a Date\_comparison\_exp into a value that can be used as an argument.
-}
encodeDate_comparison_exp : Date_comparison_exp -> Value
encodeDate_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.eq_ ), ( "_gt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.gt_ ), ( "_gte", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.gte_ ), ( "_in", ((CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.list) |> Encode.optional input____.in_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_lt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.lt_ ), ( "_lte", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.lte_ ), ( "_neq", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.neq_ ), ( "_nin", ((CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.list) |> Encode.optional input____.nin_ ) ]


buildDeployment_append_input :
    (Deployment_append_inputOptionalFields -> Deployment_append_inputOptionalFields)
    -> Deployment_append_input
buildDeployment_append_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { config = Absent }
    in
    { config = optionals____.config }


type alias Deployment_append_inputOptionalFields =
    { config : OptionalArgument CdbGQL.ScalarCodecs.Jsonb }


{-| Type for the Deployment\_append\_input input object.
-}
type alias Deployment_append_input =
    { config : OptionalArgument CdbGQL.ScalarCodecs.Jsonb }


{-| Encode a Deployment\_append\_input into a value that can be used as an argument.
-}
encodeDeployment_append_input : Deployment_append_input -> Value
encodeDeployment_append_input input____ =
    Encode.maybeObject
        [ ( "config", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input____.config ) ]


buildDeployment_bool_exp :
    (Deployment_bool_expOptionalFields -> Deployment_bool_expOptionalFields)
    -> Deployment_bool_exp
buildDeployment_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, admin_structures = Absent, admin_structures_aggregate = Absent, beneficiaries = Absent, beneficiaries_aggregate = Absent, config = Absent, createdAt = Absent, departmentCode = Absent, id = Absent, label = Absent, managers = Absent, managers_aggregate = Absent, orientationSystems = Absent, orientationSystems_aggregate = Absent, orientation_managers = Absent, orientation_managers_aggregate = Absent, structures = Absent, structures_aggregate = Absent, updatedAt = Absent }
    in
    Deployment_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, admin_structures = optionals____.admin_structures, admin_structures_aggregate = optionals____.admin_structures_aggregate, beneficiaries = optionals____.beneficiaries, beneficiaries_aggregate = optionals____.beneficiaries_aggregate, config = optionals____.config, createdAt = optionals____.createdAt, departmentCode = optionals____.departmentCode, id = optionals____.id, label = optionals____.label, managers = optionals____.managers, managers_aggregate = optionals____.managers_aggregate, orientationSystems = optionals____.orientationSystems, orientationSystems_aggregate = optionals____.orientationSystems_aggregate, orientation_managers = optionals____.orientation_managers, orientation_managers_aggregate = optionals____.orientation_managers_aggregate, structures = optionals____.structures, structures_aggregate = optionals____.structures_aggregate, updatedAt = optionals____.updatedAt }


type alias Deployment_bool_expOptionalFields =
    { and_ : OptionalArgument (List Deployment_bool_exp)
    , not_ : OptionalArgument Deployment_bool_exp
    , or_ : OptionalArgument (List Deployment_bool_exp)
    , admin_structures : OptionalArgument Admin_structure_bool_exp
    , admin_structures_aggregate : OptionalArgument Admin_structure_aggregate_bool_exp
    , beneficiaries : OptionalArgument Beneficiary_bool_exp
    , beneficiaries_aggregate : OptionalArgument Beneficiary_aggregate_bool_exp
    , config : OptionalArgument Jsonb_comparison_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , departmentCode : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , label : OptionalArgument String_comparison_exp
    , managers : OptionalArgument Manager_bool_exp
    , managers_aggregate : OptionalArgument Manager_aggregate_bool_exp
    , orientationSystems : OptionalArgument Orientation_system_bool_exp
    , orientationSystems_aggregate : OptionalArgument Orientation_system_aggregate_bool_exp
    , orientation_managers : OptionalArgument Orientation_manager_bool_exp
    , orientation_managers_aggregate : OptionalArgument Orientation_manager_aggregate_bool_exp
    , structures : OptionalArgument Structure_bool_exp
    , structures_aggregate : OptionalArgument Structure_aggregate_bool_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type alias for the `Deployment_bool_exp` attributes. Note that this type
needs to use the `Deployment_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Deployment_bool_expRaw =
    { and_ : OptionalArgument (List Deployment_bool_exp)
    , not_ : OptionalArgument Deployment_bool_exp
    , or_ : OptionalArgument (List Deployment_bool_exp)
    , admin_structures : OptionalArgument Admin_structure_bool_exp
    , admin_structures_aggregate : OptionalArgument Admin_structure_aggregate_bool_exp
    , beneficiaries : OptionalArgument Beneficiary_bool_exp
    , beneficiaries_aggregate : OptionalArgument Beneficiary_aggregate_bool_exp
    , config : OptionalArgument Jsonb_comparison_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , departmentCode : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , label : OptionalArgument String_comparison_exp
    , managers : OptionalArgument Manager_bool_exp
    , managers_aggregate : OptionalArgument Manager_aggregate_bool_exp
    , orientationSystems : OptionalArgument Orientation_system_bool_exp
    , orientationSystems_aggregate : OptionalArgument Orientation_system_aggregate_bool_exp
    , orientation_managers : OptionalArgument Orientation_manager_bool_exp
    , orientation_managers_aggregate : OptionalArgument Orientation_manager_aggregate_bool_exp
    , structures : OptionalArgument Structure_bool_exp
    , structures_aggregate : OptionalArgument Structure_aggregate_bool_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type for the Deployment\_bool\_exp input object.
-}
type Deployment_bool_exp
    = Deployment_bool_exp Deployment_bool_expRaw


{-| Encode a Deployment\_bool\_exp into a value that can be used as an argument.
-}
encodeDeployment_bool_exp : Deployment_bool_exp -> Value
encodeDeployment_bool_exp (Deployment_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeDeployment_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeDeployment_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeDeployment_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "admin_structures", encodeAdmin_structure_bool_exp |> Encode.optional input____.admin_structures ), ( "admin_structures_aggregate", encodeAdmin_structure_aggregate_bool_exp |> Encode.optional input____.admin_structures_aggregate ), ( "beneficiaries", encodeBeneficiary_bool_exp |> Encode.optional input____.beneficiaries ), ( "beneficiaries_aggregate", encodeBeneficiary_aggregate_bool_exp |> Encode.optional input____.beneficiaries_aggregate ), ( "config", encodeJsonb_comparison_exp |> Encode.optional input____.config ), ( "createdAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.createdAt ), ( "departmentCode", encodeString_comparison_exp |> Encode.optional input____.departmentCode ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "label", encodeString_comparison_exp |> Encode.optional input____.label ), ( "managers", encodeManager_bool_exp |> Encode.optional input____.managers ), ( "managers_aggregate", encodeManager_aggregate_bool_exp |> Encode.optional input____.managers_aggregate ), ( "orientationSystems", encodeOrientation_system_bool_exp |> Encode.optional input____.orientationSystems ), ( "orientationSystems_aggregate", encodeOrientation_system_aggregate_bool_exp |> Encode.optional input____.orientationSystems_aggregate ), ( "orientation_managers", encodeOrientation_manager_bool_exp |> Encode.optional input____.orientation_managers ), ( "orientation_managers_aggregate", encodeOrientation_manager_aggregate_bool_exp |> Encode.optional input____.orientation_managers_aggregate ), ( "structures", encodeStructure_bool_exp |> Encode.optional input____.structures ), ( "structures_aggregate", encodeStructure_aggregate_bool_exp |> Encode.optional input____.structures_aggregate ), ( "updatedAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.updatedAt ) ]


buildDeployment_delete_at_path_input :
    (Deployment_delete_at_path_inputOptionalFields -> Deployment_delete_at_path_inputOptionalFields)
    -> Deployment_delete_at_path_input
buildDeployment_delete_at_path_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { config = Absent }
    in
    { config = optionals____.config }


type alias Deployment_delete_at_path_inputOptionalFields =
    { config : OptionalArgument (List String) }


{-| Type for the Deployment\_delete\_at\_path\_input input object.
-}
type alias Deployment_delete_at_path_input =
    { config : OptionalArgument (List String) }


{-| Encode a Deployment\_delete\_at\_path\_input into a value that can be used as an argument.
-}
encodeDeployment_delete_at_path_input : Deployment_delete_at_path_input -> Value
encodeDeployment_delete_at_path_input input____ =
    Encode.maybeObject
        [ ( "config", (Encode.string |> Encode.list) |> Encode.optional input____.config ) ]


buildDeployment_delete_elem_input :
    (Deployment_delete_elem_inputOptionalFields -> Deployment_delete_elem_inputOptionalFields)
    -> Deployment_delete_elem_input
buildDeployment_delete_elem_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { config = Absent }
    in
    { config = optionals____.config }


type alias Deployment_delete_elem_inputOptionalFields =
    { config : OptionalArgument Int }


{-| Type for the Deployment\_delete\_elem\_input input object.
-}
type alias Deployment_delete_elem_input =
    { config : OptionalArgument Int }


{-| Encode a Deployment\_delete\_elem\_input into a value that can be used as an argument.
-}
encodeDeployment_delete_elem_input : Deployment_delete_elem_input -> Value
encodeDeployment_delete_elem_input input____ =
    Encode.maybeObject
        [ ( "config", Encode.int |> Encode.optional input____.config ) ]


buildDeployment_delete_key_input :
    (Deployment_delete_key_inputOptionalFields -> Deployment_delete_key_inputOptionalFields)
    -> Deployment_delete_key_input
buildDeployment_delete_key_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { config = Absent }
    in
    { config = optionals____.config }


type alias Deployment_delete_key_inputOptionalFields =
    { config : OptionalArgument String }


{-| Type for the Deployment\_delete\_key\_input input object.
-}
type alias Deployment_delete_key_input =
    { config : OptionalArgument String }


{-| Encode a Deployment\_delete\_key\_input into a value that can be used as an argument.
-}
encodeDeployment_delete_key_input : Deployment_delete_key_input -> Value
encodeDeployment_delete_key_input input____ =
    Encode.maybeObject
        [ ( "config", Encode.string |> Encode.optional input____.config ) ]


buildDeployment_insert_input :
    (Deployment_insert_inputOptionalFields -> Deployment_insert_inputOptionalFields)
    -> Deployment_insert_input
buildDeployment_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { admin_structures = Absent, beneficiaries = Absent, config = Absent, createdAt = Absent, departmentCode = Absent, id = Absent, label = Absent, managers = Absent, orientationSystems = Absent, orientation_managers = Absent, structures = Absent, updatedAt = Absent }
    in
    Deployment_insert_input { admin_structures = optionals____.admin_structures, beneficiaries = optionals____.beneficiaries, config = optionals____.config, createdAt = optionals____.createdAt, departmentCode = optionals____.departmentCode, id = optionals____.id, label = optionals____.label, managers = optionals____.managers, orientationSystems = optionals____.orientationSystems, orientation_managers = optionals____.orientation_managers, structures = optionals____.structures, updatedAt = optionals____.updatedAt }


type alias Deployment_insert_inputOptionalFields =
    { admin_structures : OptionalArgument Admin_structure_arr_rel_insert_input
    , beneficiaries : OptionalArgument Beneficiary_arr_rel_insert_input
    , config : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , departmentCode : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , label : OptionalArgument String
    , managers : OptionalArgument Manager_arr_rel_insert_input
    , orientationSystems : OptionalArgument Orientation_system_arr_rel_insert_input
    , orientation_managers : OptionalArgument Orientation_manager_arr_rel_insert_input
    , structures : OptionalArgument Structure_arr_rel_insert_input
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type alias for the `Deployment_insert_input` attributes. Note that this type
needs to use the `Deployment_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Deployment_insert_inputRaw =
    { admin_structures : OptionalArgument Admin_structure_arr_rel_insert_input
    , beneficiaries : OptionalArgument Beneficiary_arr_rel_insert_input
    , config : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , departmentCode : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , label : OptionalArgument String
    , managers : OptionalArgument Manager_arr_rel_insert_input
    , orientationSystems : OptionalArgument Orientation_system_arr_rel_insert_input
    , orientation_managers : OptionalArgument Orientation_manager_arr_rel_insert_input
    , structures : OptionalArgument Structure_arr_rel_insert_input
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Deployment\_insert\_input input object.
-}
type Deployment_insert_input
    = Deployment_insert_input Deployment_insert_inputRaw


{-| Encode a Deployment\_insert\_input into a value that can be used as an argument.
-}
encodeDeployment_insert_input : Deployment_insert_input -> Value
encodeDeployment_insert_input (Deployment_insert_input input____) =
    Encode.maybeObject
        [ ( "admin_structures", encodeAdmin_structure_arr_rel_insert_input |> Encode.optional input____.admin_structures ), ( "beneficiaries", encodeBeneficiary_arr_rel_insert_input |> Encode.optional input____.beneficiaries ), ( "config", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input____.config ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "departmentCode", Encode.string |> Encode.optional input____.departmentCode ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "label", Encode.string |> Encode.optional input____.label ), ( "managers", encodeManager_arr_rel_insert_input |> Encode.optional input____.managers ), ( "orientationSystems", encodeOrientation_system_arr_rel_insert_input |> Encode.optional input____.orientationSystems ), ( "orientation_managers", encodeOrientation_manager_arr_rel_insert_input |> Encode.optional input____.orientation_managers ), ( "structures", encodeStructure_arr_rel_insert_input |> Encode.optional input____.structures ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildDeployment_obj_rel_insert_input :
    Deployment_obj_rel_insert_inputRequiredFields
    -> (Deployment_obj_rel_insert_inputOptionalFields -> Deployment_obj_rel_insert_inputOptionalFields)
    -> Deployment_obj_rel_insert_input
buildDeployment_obj_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Deployment_obj_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Deployment_obj_rel_insert_inputRequiredFields =
    { data : Deployment_insert_input }


type alias Deployment_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Deployment_on_conflict }


{-| Type alias for the `Deployment_obj_rel_insert_input` attributes. Note that this type
needs to use the `Deployment_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Deployment_obj_rel_insert_inputRaw =
    { data : Deployment_insert_input
    , on_conflict : OptionalArgument Deployment_on_conflict
    }


{-| Type for the Deployment\_obj\_rel\_insert\_input input object.
-}
type Deployment_obj_rel_insert_input
    = Deployment_obj_rel_insert_input Deployment_obj_rel_insert_inputRaw


{-| Encode a Deployment\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeDeployment_obj_rel_insert_input : Deployment_obj_rel_insert_input -> Value
encodeDeployment_obj_rel_insert_input (Deployment_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeDeployment_insert_input input____.data |> Just ), ( "on_conflict", encodeDeployment_on_conflict |> Encode.optional input____.on_conflict ) ]


buildDeployment_on_conflict :
    Deployment_on_conflictRequiredFields
    -> (Deployment_on_conflictOptionalFields -> Deployment_on_conflictOptionalFields)
    -> Deployment_on_conflict
buildDeployment_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Deployment_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Deployment_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Deployment_constraint.Deployment_constraint
    , update_columns : List CdbGQL.Enum.Deployment_update_column.Deployment_update_column
    }


type alias Deployment_on_conflictOptionalFields =
    { where_ : OptionalArgument Deployment_bool_exp }


{-| Type alias for the `Deployment_on_conflict` attributes. Note that this type
needs to use the `Deployment_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Deployment_on_conflictRaw =
    { constraint : CdbGQL.Enum.Deployment_constraint.Deployment_constraint
    , update_columns : List CdbGQL.Enum.Deployment_update_column.Deployment_update_column
    , where_ : OptionalArgument Deployment_bool_exp
    }


{-| Type for the Deployment\_on\_conflict input object.
-}
type Deployment_on_conflict
    = Deployment_on_conflict Deployment_on_conflictRaw


{-| Encode a Deployment\_on\_conflict into a value that can be used as an argument.
-}
encodeDeployment_on_conflict : Deployment_on_conflict -> Value
encodeDeployment_on_conflict (Deployment_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Deployment_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Deployment_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeDeployment_bool_exp |> Encode.optional input____.where_ ) ]


buildDeployment_order_by :
    (Deployment_order_byOptionalFields -> Deployment_order_byOptionalFields)
    -> Deployment_order_by
buildDeployment_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { admin_structures_aggregate = Absent, beneficiaries_aggregate = Absent, config = Absent, createdAt = Absent, departmentCode = Absent, id = Absent, label = Absent, managers_aggregate = Absent, orientationSystems_aggregate = Absent, orientation_managers_aggregate = Absent, structures_aggregate = Absent, updatedAt = Absent }
    in
    { admin_structures_aggregate = optionals____.admin_structures_aggregate, beneficiaries_aggregate = optionals____.beneficiaries_aggregate, config = optionals____.config, createdAt = optionals____.createdAt, departmentCode = optionals____.departmentCode, id = optionals____.id, label = optionals____.label, managers_aggregate = optionals____.managers_aggregate, orientationSystems_aggregate = optionals____.orientationSystems_aggregate, orientation_managers_aggregate = optionals____.orientation_managers_aggregate, structures_aggregate = optionals____.structures_aggregate, updatedAt = optionals____.updatedAt }


type alias Deployment_order_byOptionalFields =
    { admin_structures_aggregate : OptionalArgument Admin_structure_aggregate_order_by
    , beneficiaries_aggregate : OptionalArgument Beneficiary_aggregate_order_by
    , config : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , departmentCode : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , label : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , managers_aggregate : OptionalArgument Manager_aggregate_order_by
    , orientationSystems_aggregate : OptionalArgument Orientation_system_aggregate_order_by
    , orientation_managers_aggregate : OptionalArgument Orientation_manager_aggregate_order_by
    , structures_aggregate : OptionalArgument Structure_aggregate_order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Deployment\_order\_by input object.
-}
type alias Deployment_order_by =
    { admin_structures_aggregate : OptionalArgument Admin_structure_aggregate_order_by
    , beneficiaries_aggregate : OptionalArgument Beneficiary_aggregate_order_by
    , config : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , departmentCode : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , label : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , managers_aggregate : OptionalArgument Manager_aggregate_order_by
    , orientationSystems_aggregate : OptionalArgument Orientation_system_aggregate_order_by
    , orientation_managers_aggregate : OptionalArgument Orientation_manager_aggregate_order_by
    , structures_aggregate : OptionalArgument Structure_aggregate_order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Deployment\_order\_by into a value that can be used as an argument.
-}
encodeDeployment_order_by : Deployment_order_by -> Value
encodeDeployment_order_by input____ =
    Encode.maybeObject
        [ ( "admin_structures_aggregate", encodeAdmin_structure_aggregate_order_by |> Encode.optional input____.admin_structures_aggregate ), ( "beneficiaries_aggregate", encodeBeneficiary_aggregate_order_by |> Encode.optional input____.beneficiaries_aggregate ), ( "config", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.config ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "departmentCode", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.departmentCode ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "label", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.label ), ( "managers_aggregate", encodeManager_aggregate_order_by |> Encode.optional input____.managers_aggregate ), ( "orientationSystems_aggregate", encodeOrientation_system_aggregate_order_by |> Encode.optional input____.orientationSystems_aggregate ), ( "orientation_managers_aggregate", encodeOrientation_manager_aggregate_order_by |> Encode.optional input____.orientation_managers_aggregate ), ( "structures_aggregate", encodeStructure_aggregate_order_by |> Encode.optional input____.structures_aggregate ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildDeployment_pk_columns_input :
    Deployment_pk_columns_inputRequiredFields
    -> Deployment_pk_columns_input
buildDeployment_pk_columns_input required____ =
    { id = required____.id }


type alias Deployment_pk_columns_inputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the Deployment\_pk\_columns\_input input object.
-}
type alias Deployment_pk_columns_input =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a Deployment\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeDeployment_pk_columns_input : Deployment_pk_columns_input -> Value
encodeDeployment_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildDeployment_prepend_input :
    (Deployment_prepend_inputOptionalFields -> Deployment_prepend_inputOptionalFields)
    -> Deployment_prepend_input
buildDeployment_prepend_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { config = Absent }
    in
    { config = optionals____.config }


type alias Deployment_prepend_inputOptionalFields =
    { config : OptionalArgument CdbGQL.ScalarCodecs.Jsonb }


{-| Type for the Deployment\_prepend\_input input object.
-}
type alias Deployment_prepend_input =
    { config : OptionalArgument CdbGQL.ScalarCodecs.Jsonb }


{-| Encode a Deployment\_prepend\_input into a value that can be used as an argument.
-}
encodeDeployment_prepend_input : Deployment_prepend_input -> Value
encodeDeployment_prepend_input input____ =
    Encode.maybeObject
        [ ( "config", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input____.config ) ]


buildDeployment_set_input :
    (Deployment_set_inputOptionalFields -> Deployment_set_inputOptionalFields)
    -> Deployment_set_input
buildDeployment_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { config = Absent, createdAt = Absent, departmentCode = Absent, id = Absent, label = Absent, updatedAt = Absent }
    in
    { config = optionals____.config, createdAt = optionals____.createdAt, departmentCode = optionals____.departmentCode, id = optionals____.id, label = optionals____.label, updatedAt = optionals____.updatedAt }


type alias Deployment_set_inputOptionalFields =
    { config : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , departmentCode : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , label : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Deployment\_set\_input input object.
-}
type alias Deployment_set_input =
    { config : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , departmentCode : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , label : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Deployment\_set\_input into a value that can be used as an argument.
-}
encodeDeployment_set_input : Deployment_set_input -> Value
encodeDeployment_set_input input____ =
    Encode.maybeObject
        [ ( "config", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input____.config ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "departmentCode", Encode.string |> Encode.optional input____.departmentCode ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "label", Encode.string |> Encode.optional input____.label ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildDeployment_stream_cursor_input :
    Deployment_stream_cursor_inputRequiredFields
    -> (Deployment_stream_cursor_inputOptionalFields -> Deployment_stream_cursor_inputOptionalFields)
    -> Deployment_stream_cursor_input
buildDeployment_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Deployment_stream_cursor_inputRequiredFields =
    { initial_value : Deployment_stream_cursor_value_input }


type alias Deployment_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Deployment\_stream\_cursor\_input input object.
-}
type alias Deployment_stream_cursor_input =
    { initial_value : Deployment_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Deployment\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeDeployment_stream_cursor_input : Deployment_stream_cursor_input -> Value
encodeDeployment_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeDeployment_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildDeployment_stream_cursor_value_input :
    (Deployment_stream_cursor_value_inputOptionalFields -> Deployment_stream_cursor_value_inputOptionalFields)
    -> Deployment_stream_cursor_value_input
buildDeployment_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { config = Absent, createdAt = Absent, departmentCode = Absent, id = Absent, label = Absent, updatedAt = Absent }
    in
    { config = optionals____.config, createdAt = optionals____.createdAt, departmentCode = optionals____.departmentCode, id = optionals____.id, label = optionals____.label, updatedAt = optionals____.updatedAt }


type alias Deployment_stream_cursor_value_inputOptionalFields =
    { config : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , departmentCode : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , label : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Deployment\_stream\_cursor\_value\_input input object.
-}
type alias Deployment_stream_cursor_value_input =
    { config : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , departmentCode : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , label : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Deployment\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeDeployment_stream_cursor_value_input : Deployment_stream_cursor_value_input -> Value
encodeDeployment_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "config", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input____.config ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "departmentCode", Encode.string |> Encode.optional input____.departmentCode ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "label", Encode.string |> Encode.optional input____.label ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildDeployment_updates :
    Deployment_updatesRequiredFields
    -> (Deployment_updatesOptionalFields -> Deployment_updatesOptionalFields)
    -> Deployment_updates
buildDeployment_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { append_ = Absent, delete_at_path_ = Absent, delete_elem_ = Absent, delete_key_ = Absent, prepend_ = Absent, set_ = Absent }
    in
    Deployment_updates { append_ = optionals____.append_, delete_at_path_ = optionals____.delete_at_path_, delete_elem_ = optionals____.delete_elem_, delete_key_ = optionals____.delete_key_, prepend_ = optionals____.prepend_, set_ = optionals____.set_, where_ = required____.where_ }


type alias Deployment_updatesRequiredFields =
    { where_ : Deployment_bool_exp }


type alias Deployment_updatesOptionalFields =
    { append_ : OptionalArgument Deployment_append_input
    , delete_at_path_ : OptionalArgument Deployment_delete_at_path_input
    , delete_elem_ : OptionalArgument Deployment_delete_elem_input
    , delete_key_ : OptionalArgument Deployment_delete_key_input
    , prepend_ : OptionalArgument Deployment_prepend_input
    , set_ : OptionalArgument Deployment_set_input
    }


{-| Type alias for the `Deployment_updates` attributes. Note that this type
needs to use the `Deployment_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Deployment_updatesRaw =
    { append_ : OptionalArgument Deployment_append_input
    , delete_at_path_ : OptionalArgument Deployment_delete_at_path_input
    , delete_elem_ : OptionalArgument Deployment_delete_elem_input
    , delete_key_ : OptionalArgument Deployment_delete_key_input
    , prepend_ : OptionalArgument Deployment_prepend_input
    , set_ : OptionalArgument Deployment_set_input
    , where_ : Deployment_bool_exp
    }


{-| Type for the Deployment\_updates input object.
-}
type Deployment_updates
    = Deployment_updates Deployment_updatesRaw


{-| Encode a Deployment\_updates into a value that can be used as an argument.
-}
encodeDeployment_updates : Deployment_updates -> Value
encodeDeployment_updates (Deployment_updates input____) =
    Encode.maybeObject
        [ ( "_append", encodeDeployment_append_input |> Encode.optional input____.append_ ), ( "_delete_at_path", encodeDeployment_delete_at_path_input |> Encode.optional input____.delete_at_path_ ), ( "_delete_elem", encodeDeployment_delete_elem_input |> Encode.optional input____.delete_elem_ ), ( "_delete_key", encodeDeployment_delete_key_input |> Encode.optional input____.delete_key_ ), ( "_prepend", encodeDeployment_prepend_input |> Encode.optional input____.prepend_ ), ( "_set", encodeDeployment_set_input |> Encode.optional input____.set_ ), ( "where", encodeDeployment_bool_exp input____.where_ |> Just ) ]


buildEmployment_type_bool_exp :
    (Employment_type_bool_expOptionalFields -> Employment_type_bool_expOptionalFields)
    -> Employment_type_bool_exp
buildEmployment_type_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, id = Absent, label = Absent }
    in
    Employment_type_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, id = optionals____.id, label = optionals____.label }


type alias Employment_type_bool_expOptionalFields =
    { and_ : OptionalArgument (List Employment_type_bool_exp)
    , not_ : OptionalArgument Employment_type_bool_exp
    , or_ : OptionalArgument (List Employment_type_bool_exp)
    , id : OptionalArgument String_comparison_exp
    , label : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Employment_type_bool_exp` attributes. Note that this type
needs to use the `Employment_type_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Employment_type_bool_expRaw =
    { and_ : OptionalArgument (List Employment_type_bool_exp)
    , not_ : OptionalArgument Employment_type_bool_exp
    , or_ : OptionalArgument (List Employment_type_bool_exp)
    , id : OptionalArgument String_comparison_exp
    , label : OptionalArgument String_comparison_exp
    }


{-| Type for the Employment\_type\_bool\_exp input object.
-}
type Employment_type_bool_exp
    = Employment_type_bool_exp Employment_type_bool_expRaw


{-| Encode a Employment\_type\_bool\_exp into a value that can be used as an argument.
-}
encodeEmployment_type_bool_exp : Employment_type_bool_exp -> Value
encodeEmployment_type_bool_exp (Employment_type_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeEmployment_type_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeEmployment_type_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeEmployment_type_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "id", encodeString_comparison_exp |> Encode.optional input____.id ), ( "label", encodeString_comparison_exp |> Encode.optional input____.label ) ]


buildEmployment_type_enum_comparison_exp :
    (Employment_type_enum_comparison_expOptionalFields -> Employment_type_enum_comparison_expOptionalFields)
    -> Employment_type_enum_comparison_exp
buildEmployment_type_enum_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, in_ = Absent, is_null_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals____.eq_, in_ = optionals____.in_, is_null_ = optionals____.is_null_, neq_ = optionals____.neq_, nin_ = optionals____.nin_ }


type alias Employment_type_enum_comparison_expOptionalFields =
    { eq_ : OptionalArgument CdbGQL.Enum.Employment_type_enum.Employment_type_enum
    , in_ : OptionalArgument (List CdbGQL.Enum.Employment_type_enum.Employment_type_enum)
    , is_null_ : OptionalArgument Bool
    , neq_ : OptionalArgument CdbGQL.Enum.Employment_type_enum.Employment_type_enum
    , nin_ : OptionalArgument (List CdbGQL.Enum.Employment_type_enum.Employment_type_enum)
    }


{-| Type for the Employment\_type\_enum\_comparison\_exp input object.
-}
type alias Employment_type_enum_comparison_exp =
    { eq_ : OptionalArgument CdbGQL.Enum.Employment_type_enum.Employment_type_enum
    , in_ : OptionalArgument (List CdbGQL.Enum.Employment_type_enum.Employment_type_enum)
    , is_null_ : OptionalArgument Bool
    , neq_ : OptionalArgument CdbGQL.Enum.Employment_type_enum.Employment_type_enum
    , nin_ : OptionalArgument (List CdbGQL.Enum.Employment_type_enum.Employment_type_enum)
    }


{-| Encode a Employment\_type\_enum\_comparison\_exp into a value that can be used as an argument.
-}
encodeEmployment_type_enum_comparison_exp : Employment_type_enum_comparison_exp -> Value
encodeEmployment_type_enum_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", Encode.enum CdbGQL.Enum.Employment_type_enum.toString |> Encode.optional input____.eq_ ), ( "_in", (Encode.enum CdbGQL.Enum.Employment_type_enum.toString |> Encode.list) |> Encode.optional input____.in_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_neq", Encode.enum CdbGQL.Enum.Employment_type_enum.toString |> Encode.optional input____.neq_ ), ( "_nin", (Encode.enum CdbGQL.Enum.Employment_type_enum.toString |> Encode.list) |> Encode.optional input____.nin_ ) ]


buildEmployment_type_insert_input :
    (Employment_type_insert_inputOptionalFields -> Employment_type_insert_inputOptionalFields)
    -> Employment_type_insert_input
buildEmployment_type_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, label = Absent }
    in
    { id = optionals____.id, label = optionals____.label }


type alias Employment_type_insert_inputOptionalFields =
    { id : OptionalArgument String
    , label : OptionalArgument String
    }


{-| Type for the Employment\_type\_insert\_input input object.
-}
type alias Employment_type_insert_input =
    { id : OptionalArgument String
    , label : OptionalArgument String
    }


{-| Encode a Employment\_type\_insert\_input into a value that can be used as an argument.
-}
encodeEmployment_type_insert_input : Employment_type_insert_input -> Value
encodeEmployment_type_insert_input input____ =
    Encode.maybeObject
        [ ( "id", Encode.string |> Encode.optional input____.id ), ( "label", Encode.string |> Encode.optional input____.label ) ]


buildEmployment_type_obj_rel_insert_input :
    Employment_type_obj_rel_insert_inputRequiredFields
    -> (Employment_type_obj_rel_insert_inputOptionalFields -> Employment_type_obj_rel_insert_inputOptionalFields)
    -> Employment_type_obj_rel_insert_input
buildEmployment_type_obj_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Employment_type_obj_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Employment_type_obj_rel_insert_inputRequiredFields =
    { data : Employment_type_insert_input }


type alias Employment_type_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Employment_type_on_conflict }


{-| Type alias for the `Employment_type_obj_rel_insert_input` attributes. Note that this type
needs to use the `Employment_type_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Employment_type_obj_rel_insert_inputRaw =
    { data : Employment_type_insert_input
    , on_conflict : OptionalArgument Employment_type_on_conflict
    }


{-| Type for the Employment\_type\_obj\_rel\_insert\_input input object.
-}
type Employment_type_obj_rel_insert_input
    = Employment_type_obj_rel_insert_input Employment_type_obj_rel_insert_inputRaw


{-| Encode a Employment\_type\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeEmployment_type_obj_rel_insert_input : Employment_type_obj_rel_insert_input -> Value
encodeEmployment_type_obj_rel_insert_input (Employment_type_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeEmployment_type_insert_input input____.data |> Just ), ( "on_conflict", encodeEmployment_type_on_conflict |> Encode.optional input____.on_conflict ) ]


buildEmployment_type_on_conflict :
    Employment_type_on_conflictRequiredFields
    -> (Employment_type_on_conflictOptionalFields -> Employment_type_on_conflictOptionalFields)
    -> Employment_type_on_conflict
buildEmployment_type_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Employment_type_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Employment_type_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Employment_type_constraint.Employment_type_constraint
    , update_columns : List CdbGQL.Enum.Employment_type_update_column.Employment_type_update_column
    }


type alias Employment_type_on_conflictOptionalFields =
    { where_ : OptionalArgument Employment_type_bool_exp }


{-| Type alias for the `Employment_type_on_conflict` attributes. Note that this type
needs to use the `Employment_type_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Employment_type_on_conflictRaw =
    { constraint : CdbGQL.Enum.Employment_type_constraint.Employment_type_constraint
    , update_columns : List CdbGQL.Enum.Employment_type_update_column.Employment_type_update_column
    , where_ : OptionalArgument Employment_type_bool_exp
    }


{-| Type for the Employment\_type\_on\_conflict input object.
-}
type Employment_type_on_conflict
    = Employment_type_on_conflict Employment_type_on_conflictRaw


{-| Encode a Employment\_type\_on\_conflict into a value that can be used as an argument.
-}
encodeEmployment_type_on_conflict : Employment_type_on_conflict -> Value
encodeEmployment_type_on_conflict (Employment_type_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Employment_type_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Employment_type_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeEmployment_type_bool_exp |> Encode.optional input____.where_ ) ]


buildEmployment_type_order_by :
    (Employment_type_order_byOptionalFields -> Employment_type_order_byOptionalFields)
    -> Employment_type_order_by
buildEmployment_type_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, label = Absent }
    in
    { id = optionals____.id, label = optionals____.label }


type alias Employment_type_order_byOptionalFields =
    { id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , label : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Employment\_type\_order\_by input object.
-}
type alias Employment_type_order_by =
    { id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , label : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Employment\_type\_order\_by into a value that can be used as an argument.
-}
encodeEmployment_type_order_by : Employment_type_order_by -> Value
encodeEmployment_type_order_by input____ =
    Encode.maybeObject
        [ ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "label", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.label ) ]


buildEmployment_type_pk_columns_input :
    Employment_type_pk_columns_inputRequiredFields
    -> Employment_type_pk_columns_input
buildEmployment_type_pk_columns_input required____ =
    { id = required____.id }


type alias Employment_type_pk_columns_inputRequiredFields =
    { id : String }


{-| Type for the Employment\_type\_pk\_columns\_input input object.
-}
type alias Employment_type_pk_columns_input =
    { id : String }


{-| Encode a Employment\_type\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeEmployment_type_pk_columns_input : Employment_type_pk_columns_input -> Value
encodeEmployment_type_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", Encode.string input____.id |> Just ) ]


buildEmployment_type_set_input :
    (Employment_type_set_inputOptionalFields -> Employment_type_set_inputOptionalFields)
    -> Employment_type_set_input
buildEmployment_type_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, label = Absent }
    in
    { id = optionals____.id, label = optionals____.label }


type alias Employment_type_set_inputOptionalFields =
    { id : OptionalArgument String
    , label : OptionalArgument String
    }


{-| Type for the Employment\_type\_set\_input input object.
-}
type alias Employment_type_set_input =
    { id : OptionalArgument String
    , label : OptionalArgument String
    }


{-| Encode a Employment\_type\_set\_input into a value that can be used as an argument.
-}
encodeEmployment_type_set_input : Employment_type_set_input -> Value
encodeEmployment_type_set_input input____ =
    Encode.maybeObject
        [ ( "id", Encode.string |> Encode.optional input____.id ), ( "label", Encode.string |> Encode.optional input____.label ) ]


buildEmployment_type_stream_cursor_input :
    Employment_type_stream_cursor_inputRequiredFields
    -> (Employment_type_stream_cursor_inputOptionalFields -> Employment_type_stream_cursor_inputOptionalFields)
    -> Employment_type_stream_cursor_input
buildEmployment_type_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Employment_type_stream_cursor_inputRequiredFields =
    { initial_value : Employment_type_stream_cursor_value_input }


type alias Employment_type_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Employment\_type\_stream\_cursor\_input input object.
-}
type alias Employment_type_stream_cursor_input =
    { initial_value : Employment_type_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Employment\_type\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeEmployment_type_stream_cursor_input : Employment_type_stream_cursor_input -> Value
encodeEmployment_type_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeEmployment_type_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildEmployment_type_stream_cursor_value_input :
    (Employment_type_stream_cursor_value_inputOptionalFields -> Employment_type_stream_cursor_value_inputOptionalFields)
    -> Employment_type_stream_cursor_value_input
buildEmployment_type_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, label = Absent }
    in
    { id = optionals____.id, label = optionals____.label }


type alias Employment_type_stream_cursor_value_inputOptionalFields =
    { id : OptionalArgument String
    , label : OptionalArgument String
    }


{-| Type for the Employment\_type\_stream\_cursor\_value\_input input object.
-}
type alias Employment_type_stream_cursor_value_input =
    { id : OptionalArgument String
    , label : OptionalArgument String
    }


{-| Encode a Employment\_type\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeEmployment_type_stream_cursor_value_input : Employment_type_stream_cursor_value_input -> Value
encodeEmployment_type_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "id", Encode.string |> Encode.optional input____.id ), ( "label", Encode.string |> Encode.optional input____.label ) ]


buildEmployment_type_updates :
    Employment_type_updatesRequiredFields
    -> (Employment_type_updatesOptionalFields -> Employment_type_updatesOptionalFields)
    -> Employment_type_updates
buildEmployment_type_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Employment_type_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Employment_type_updatesRequiredFields =
    { where_ : Employment_type_bool_exp }


type alias Employment_type_updatesOptionalFields =
    { set_ : OptionalArgument Employment_type_set_input }


{-| Type alias for the `Employment_type_updates` attributes. Note that this type
needs to use the `Employment_type_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Employment_type_updatesRaw =
    { set_ : OptionalArgument Employment_type_set_input
    , where_ : Employment_type_bool_exp
    }


{-| Type for the Employment\_type\_updates input object.
-}
type Employment_type_updates
    = Employment_type_updates Employment_type_updatesRaw


{-| Encode a Employment\_type\_updates into a value that can be used as an argument.
-}
encodeEmployment_type_updates : Employment_type_updates -> Value
encodeEmployment_type_updates (Employment_type_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeEmployment_type_set_input |> Encode.optional input____.set_ ), ( "where", encodeEmployment_type_bool_exp input____.where_ |> Just ) ]


buildExternal_data_aggregate_bool_exp :
    (External_data_aggregate_bool_expOptionalFields -> External_data_aggregate_bool_expOptionalFields)
    -> External_data_aggregate_bool_exp
buildExternal_data_aggregate_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent }
    in
    External_data_aggregate_bool_exp { count = optionals____.count }


type alias External_data_aggregate_bool_expOptionalFields =
    { count : OptionalArgument External_data_aggregate_bool_exp_count }


{-| Type alias for the `External_data_aggregate_bool_exp` attributes. Note that this type
needs to use the `External_data_aggregate_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias External_data_aggregate_bool_expRaw =
    { count : OptionalArgument External_data_aggregate_bool_exp_count }


{-| Type for the External\_data\_aggregate\_bool\_exp input object.
-}
type External_data_aggregate_bool_exp
    = External_data_aggregate_bool_exp External_data_aggregate_bool_expRaw


{-| Encode a External\_data\_aggregate\_bool\_exp into a value that can be used as an argument.
-}
encodeExternal_data_aggregate_bool_exp : External_data_aggregate_bool_exp -> Value
encodeExternal_data_aggregate_bool_exp (External_data_aggregate_bool_exp input____) =
    Encode.maybeObject
        [ ( "count", encodeExternal_data_aggregate_bool_exp_count |> Encode.optional input____.count ) ]


buildExternal_data_aggregate_bool_exp_count :
    External_data_aggregate_bool_exp_countRequiredFields
    -> (External_data_aggregate_bool_exp_countOptionalFields -> External_data_aggregate_bool_exp_countOptionalFields)
    -> External_data_aggregate_bool_exp_count
buildExternal_data_aggregate_bool_exp_count required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { arguments = Absent, distinct = Absent, filter = Absent }
    in
    External_data_aggregate_bool_exp_count { arguments = optionals____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias External_data_aggregate_bool_exp_countRequiredFields =
    { predicate : Int_comparison_exp }


type alias External_data_aggregate_bool_exp_countOptionalFields =
    { arguments : OptionalArgument (List CdbGQL.Enum.External_data_select_column.External_data_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument External_data_bool_exp
    }


{-| Type alias for the `External_data_aggregate_bool_exp_count` attributes. Note that this type
needs to use the `External_data_aggregate_bool_exp_count` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias External_data_aggregate_bool_exp_countRaw =
    { arguments : OptionalArgument (List CdbGQL.Enum.External_data_select_column.External_data_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument External_data_bool_exp
    , predicate : Int_comparison_exp
    }


{-| Type for the External\_data\_aggregate\_bool\_exp\_count input object.
-}
type External_data_aggregate_bool_exp_count
    = External_data_aggregate_bool_exp_count External_data_aggregate_bool_exp_countRaw


{-| Encode a External\_data\_aggregate\_bool\_exp\_count into a value that can be used as an argument.
-}
encodeExternal_data_aggregate_bool_exp_count : External_data_aggregate_bool_exp_count -> Value
encodeExternal_data_aggregate_bool_exp_count (External_data_aggregate_bool_exp_count input____) =
    Encode.maybeObject
        [ ( "arguments", (Encode.enum CdbGQL.Enum.External_data_select_column.toString |> Encode.list) |> Encode.optional input____.arguments ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeExternal_data_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeInt_comparison_exp input____.predicate |> Just ) ]


buildExternal_data_aggregate_order_by :
    (External_data_aggregate_order_byOptionalFields -> External_data_aggregate_order_byOptionalFields)
    -> External_data_aggregate_order_by
buildExternal_data_aggregate_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals____.count, max = optionals____.max, min = optionals____.min }


type alias External_data_aggregate_order_byOptionalFields =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument External_data_max_order_by
    , min : OptionalArgument External_data_min_order_by
    }


{-| Type for the External\_data\_aggregate\_order\_by input object.
-}
type alias External_data_aggregate_order_by =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument External_data_max_order_by
    , min : OptionalArgument External_data_min_order_by
    }


{-| Encode a External\_data\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeExternal_data_aggregate_order_by : External_data_aggregate_order_by -> Value
encodeExternal_data_aggregate_order_by input____ =
    Encode.maybeObject
        [ ( "count", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.count ), ( "max", encodeExternal_data_max_order_by |> Encode.optional input____.max ), ( "min", encodeExternal_data_min_order_by |> Encode.optional input____.min ) ]


buildExternal_data_append_input :
    (External_data_append_inputOptionalFields -> External_data_append_inputOptionalFields)
    -> External_data_append_input
buildExternal_data_append_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { data = Absent }
    in
    { data = optionals____.data }


type alias External_data_append_inputOptionalFields =
    { data : OptionalArgument CdbGQL.ScalarCodecs.Jsonb }


{-| Type for the External\_data\_append\_input input object.
-}
type alias External_data_append_input =
    { data : OptionalArgument CdbGQL.ScalarCodecs.Jsonb }


{-| Encode a External\_data\_append\_input into a value that can be used as an argument.
-}
encodeExternal_data_append_input : External_data_append_input -> Value
encodeExternal_data_append_input input____ =
    Encode.maybeObject
        [ ( "data", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input____.data ) ]


buildExternal_data_arr_rel_insert_input :
    External_data_arr_rel_insert_inputRequiredFields
    -> (External_data_arr_rel_insert_inputOptionalFields -> External_data_arr_rel_insert_inputOptionalFields)
    -> External_data_arr_rel_insert_input
buildExternal_data_arr_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    External_data_arr_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias External_data_arr_rel_insert_inputRequiredFields =
    { data : List External_data_insert_input }


type alias External_data_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument External_data_on_conflict }


{-| Type alias for the `External_data_arr_rel_insert_input` attributes. Note that this type
needs to use the `External_data_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias External_data_arr_rel_insert_inputRaw =
    { data : List External_data_insert_input
    , on_conflict : OptionalArgument External_data_on_conflict
    }


{-| Type for the External\_data\_arr\_rel\_insert\_input input object.
-}
type External_data_arr_rel_insert_input
    = External_data_arr_rel_insert_input External_data_arr_rel_insert_inputRaw


{-| Encode a External\_data\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeExternal_data_arr_rel_insert_input : External_data_arr_rel_insert_input -> Value
encodeExternal_data_arr_rel_insert_input (External_data_arr_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", (encodeExternal_data_insert_input |> Encode.list) input____.data |> Just ), ( "on_conflict", encodeExternal_data_on_conflict |> Encode.optional input____.on_conflict ) ]


buildExternal_data_bool_exp :
    (External_data_bool_expOptionalFields -> External_data_bool_expOptionalFields)
    -> External_data_bool_exp
buildExternal_data_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, created_at = Absent, data = Absent, externalDataInfo = Absent, external_source = Absent, hash = Absent, id = Absent, source = Absent, updated_at = Absent }
    in
    External_data_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, created_at = optionals____.created_at, data = optionals____.data, externalDataInfo = optionals____.externalDataInfo, external_source = optionals____.external_source, hash = optionals____.hash, id = optionals____.id, source = optionals____.source, updated_at = optionals____.updated_at }


type alias External_data_bool_expOptionalFields =
    { and_ : OptionalArgument (List External_data_bool_exp)
    , not_ : OptionalArgument External_data_bool_exp
    , or_ : OptionalArgument (List External_data_bool_exp)
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , data : OptionalArgument Jsonb_comparison_exp
    , externalDataInfo : OptionalArgument External_data_info_bool_exp
    , external_source : OptionalArgument External_source_bool_exp
    , hash : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , source : OptionalArgument External_source_enum_comparison_exp
    , updated_at : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type alias for the `External_data_bool_exp` attributes. Note that this type
needs to use the `External_data_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias External_data_bool_expRaw =
    { and_ : OptionalArgument (List External_data_bool_exp)
    , not_ : OptionalArgument External_data_bool_exp
    , or_ : OptionalArgument (List External_data_bool_exp)
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , data : OptionalArgument Jsonb_comparison_exp
    , externalDataInfo : OptionalArgument External_data_info_bool_exp
    , external_source : OptionalArgument External_source_bool_exp
    , hash : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , source : OptionalArgument External_source_enum_comparison_exp
    , updated_at : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type for the External\_data\_bool\_exp input object.
-}
type External_data_bool_exp
    = External_data_bool_exp External_data_bool_expRaw


{-| Encode a External\_data\_bool\_exp into a value that can be used as an argument.
-}
encodeExternal_data_bool_exp : External_data_bool_exp -> Value
encodeExternal_data_bool_exp (External_data_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeExternal_data_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeExternal_data_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeExternal_data_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "created_at", encodeTimestamptz_comparison_exp |> Encode.optional input____.created_at ), ( "data", encodeJsonb_comparison_exp |> Encode.optional input____.data ), ( "externalDataInfo", encodeExternal_data_info_bool_exp |> Encode.optional input____.externalDataInfo ), ( "external_source", encodeExternal_source_bool_exp |> Encode.optional input____.external_source ), ( "hash", encodeString_comparison_exp |> Encode.optional input____.hash ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "source", encodeExternal_source_enum_comparison_exp |> Encode.optional input____.source ), ( "updated_at", encodeTimestamptz_comparison_exp |> Encode.optional input____.updated_at ) ]


buildExternal_data_delete_at_path_input :
    (External_data_delete_at_path_inputOptionalFields -> External_data_delete_at_path_inputOptionalFields)
    -> External_data_delete_at_path_input
buildExternal_data_delete_at_path_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { data = Absent }
    in
    { data = optionals____.data }


type alias External_data_delete_at_path_inputOptionalFields =
    { data : OptionalArgument (List String) }


{-| Type for the External\_data\_delete\_at\_path\_input input object.
-}
type alias External_data_delete_at_path_input =
    { data : OptionalArgument (List String) }


{-| Encode a External\_data\_delete\_at\_path\_input into a value that can be used as an argument.
-}
encodeExternal_data_delete_at_path_input : External_data_delete_at_path_input -> Value
encodeExternal_data_delete_at_path_input input____ =
    Encode.maybeObject
        [ ( "data", (Encode.string |> Encode.list) |> Encode.optional input____.data ) ]


buildExternal_data_delete_elem_input :
    (External_data_delete_elem_inputOptionalFields -> External_data_delete_elem_inputOptionalFields)
    -> External_data_delete_elem_input
buildExternal_data_delete_elem_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { data = Absent }
    in
    { data = optionals____.data }


type alias External_data_delete_elem_inputOptionalFields =
    { data : OptionalArgument Int }


{-| Type for the External\_data\_delete\_elem\_input input object.
-}
type alias External_data_delete_elem_input =
    { data : OptionalArgument Int }


{-| Encode a External\_data\_delete\_elem\_input into a value that can be used as an argument.
-}
encodeExternal_data_delete_elem_input : External_data_delete_elem_input -> Value
encodeExternal_data_delete_elem_input input____ =
    Encode.maybeObject
        [ ( "data", Encode.int |> Encode.optional input____.data ) ]


buildExternal_data_delete_key_input :
    (External_data_delete_key_inputOptionalFields -> External_data_delete_key_inputOptionalFields)
    -> External_data_delete_key_input
buildExternal_data_delete_key_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { data = Absent }
    in
    { data = optionals____.data }


type alias External_data_delete_key_inputOptionalFields =
    { data : OptionalArgument String }


{-| Type for the External\_data\_delete\_key\_input input object.
-}
type alias External_data_delete_key_input =
    { data : OptionalArgument String }


{-| Encode a External\_data\_delete\_key\_input into a value that can be used as an argument.
-}
encodeExternal_data_delete_key_input : External_data_delete_key_input -> Value
encodeExternal_data_delete_key_input input____ =
    Encode.maybeObject
        [ ( "data", Encode.string |> Encode.optional input____.data ) ]


buildExternal_data_info_aggregate_bool_exp :
    (External_data_info_aggregate_bool_expOptionalFields -> External_data_info_aggregate_bool_expOptionalFields)
    -> External_data_info_aggregate_bool_exp
buildExternal_data_info_aggregate_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent }
    in
    External_data_info_aggregate_bool_exp { count = optionals____.count }


type alias External_data_info_aggregate_bool_expOptionalFields =
    { count : OptionalArgument External_data_info_aggregate_bool_exp_count }


{-| Type alias for the `External_data_info_aggregate_bool_exp` attributes. Note that this type
needs to use the `External_data_info_aggregate_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias External_data_info_aggregate_bool_expRaw =
    { count : OptionalArgument External_data_info_aggregate_bool_exp_count }


{-| Type for the External\_data\_info\_aggregate\_bool\_exp input object.
-}
type External_data_info_aggregate_bool_exp
    = External_data_info_aggregate_bool_exp External_data_info_aggregate_bool_expRaw


{-| Encode a External\_data\_info\_aggregate\_bool\_exp into a value that can be used as an argument.
-}
encodeExternal_data_info_aggregate_bool_exp : External_data_info_aggregate_bool_exp -> Value
encodeExternal_data_info_aggregate_bool_exp (External_data_info_aggregate_bool_exp input____) =
    Encode.maybeObject
        [ ( "count", encodeExternal_data_info_aggregate_bool_exp_count |> Encode.optional input____.count ) ]


buildExternal_data_info_aggregate_bool_exp_count :
    External_data_info_aggregate_bool_exp_countRequiredFields
    -> (External_data_info_aggregate_bool_exp_countOptionalFields -> External_data_info_aggregate_bool_exp_countOptionalFields)
    -> External_data_info_aggregate_bool_exp_count
buildExternal_data_info_aggregate_bool_exp_count required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { arguments = Absent, distinct = Absent, filter = Absent }
    in
    External_data_info_aggregate_bool_exp_count { arguments = optionals____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias External_data_info_aggregate_bool_exp_countRequiredFields =
    { predicate : Int_comparison_exp }


type alias External_data_info_aggregate_bool_exp_countOptionalFields =
    { arguments : OptionalArgument (List CdbGQL.Enum.External_data_info_select_column.External_data_info_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument External_data_info_bool_exp
    }


{-| Type alias for the `External_data_info_aggregate_bool_exp_count` attributes. Note that this type
needs to use the `External_data_info_aggregate_bool_exp_count` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias External_data_info_aggregate_bool_exp_countRaw =
    { arguments : OptionalArgument (List CdbGQL.Enum.External_data_info_select_column.External_data_info_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument External_data_info_bool_exp
    , predicate : Int_comparison_exp
    }


{-| Type for the External\_data\_info\_aggregate\_bool\_exp\_count input object.
-}
type External_data_info_aggregate_bool_exp_count
    = External_data_info_aggregate_bool_exp_count External_data_info_aggregate_bool_exp_countRaw


{-| Encode a External\_data\_info\_aggregate\_bool\_exp\_count into a value that can be used as an argument.
-}
encodeExternal_data_info_aggregate_bool_exp_count : External_data_info_aggregate_bool_exp_count -> Value
encodeExternal_data_info_aggregate_bool_exp_count (External_data_info_aggregate_bool_exp_count input____) =
    Encode.maybeObject
        [ ( "arguments", (Encode.enum CdbGQL.Enum.External_data_info_select_column.toString |> Encode.list) |> Encode.optional input____.arguments ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeExternal_data_info_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeInt_comparison_exp input____.predicate |> Just ) ]


buildExternal_data_info_aggregate_order_by :
    (External_data_info_aggregate_order_byOptionalFields -> External_data_info_aggregate_order_byOptionalFields)
    -> External_data_info_aggregate_order_by
buildExternal_data_info_aggregate_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals____.count, max = optionals____.max, min = optionals____.min }


type alias External_data_info_aggregate_order_byOptionalFields =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument External_data_info_max_order_by
    , min : OptionalArgument External_data_info_min_order_by
    }


{-| Type for the External\_data\_info\_aggregate\_order\_by input object.
-}
type alias External_data_info_aggregate_order_by =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument External_data_info_max_order_by
    , min : OptionalArgument External_data_info_min_order_by
    }


{-| Encode a External\_data\_info\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeExternal_data_info_aggregate_order_by : External_data_info_aggregate_order_by -> Value
encodeExternal_data_info_aggregate_order_by input____ =
    Encode.maybeObject
        [ ( "count", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.count ), ( "max", encodeExternal_data_info_max_order_by |> Encode.optional input____.max ), ( "min", encodeExternal_data_info_min_order_by |> Encode.optional input____.min ) ]


buildExternal_data_info_arr_rel_insert_input :
    External_data_info_arr_rel_insert_inputRequiredFields
    -> (External_data_info_arr_rel_insert_inputOptionalFields -> External_data_info_arr_rel_insert_inputOptionalFields)
    -> External_data_info_arr_rel_insert_input
buildExternal_data_info_arr_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    External_data_info_arr_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias External_data_info_arr_rel_insert_inputRequiredFields =
    { data : List External_data_info_insert_input }


type alias External_data_info_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument External_data_info_on_conflict }


{-| Type alias for the `External_data_info_arr_rel_insert_input` attributes. Note that this type
needs to use the `External_data_info_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias External_data_info_arr_rel_insert_inputRaw =
    { data : List External_data_info_insert_input
    , on_conflict : OptionalArgument External_data_info_on_conflict
    }


{-| Type for the External\_data\_info\_arr\_rel\_insert\_input input object.
-}
type External_data_info_arr_rel_insert_input
    = External_data_info_arr_rel_insert_input External_data_info_arr_rel_insert_inputRaw


{-| Encode a External\_data\_info\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeExternal_data_info_arr_rel_insert_input : External_data_info_arr_rel_insert_input -> Value
encodeExternal_data_info_arr_rel_insert_input (External_data_info_arr_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", (encodeExternal_data_info_insert_input |> Encode.list) input____.data |> Just ), ( "on_conflict", encodeExternal_data_info_on_conflict |> Encode.optional input____.on_conflict ) ]


buildExternal_data_info_bool_exp :
    (External_data_info_bool_expOptionalFields -> External_data_info_bool_expOptionalFields)
    -> External_data_info_bool_exp
buildExternal_data_info_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, beneficiary = Absent, beneficiary_id = Absent, created_at = Absent, externalData = Absent, external_data_id = Absent, professional_id = Absent, updated_at = Absent }
    in
    External_data_info_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, beneficiary = optionals____.beneficiary, beneficiary_id = optionals____.beneficiary_id, created_at = optionals____.created_at, externalData = optionals____.externalData, external_data_id = optionals____.external_data_id, professional_id = optionals____.professional_id, updated_at = optionals____.updated_at }


type alias External_data_info_bool_expOptionalFields =
    { and_ : OptionalArgument (List External_data_info_bool_exp)
    , not_ : OptionalArgument External_data_info_bool_exp
    , or_ : OptionalArgument (List External_data_info_bool_exp)
    , beneficiary : OptionalArgument Beneficiary_bool_exp
    , beneficiary_id : OptionalArgument Uuid_comparison_exp
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , externalData : OptionalArgument External_data_bool_exp
    , external_data_id : OptionalArgument Uuid_comparison_exp
    , professional_id : OptionalArgument Uuid_comparison_exp
    , updated_at : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type alias for the `External_data_info_bool_exp` attributes. Note that this type
needs to use the `External_data_info_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias External_data_info_bool_expRaw =
    { and_ : OptionalArgument (List External_data_info_bool_exp)
    , not_ : OptionalArgument External_data_info_bool_exp
    , or_ : OptionalArgument (List External_data_info_bool_exp)
    , beneficiary : OptionalArgument Beneficiary_bool_exp
    , beneficiary_id : OptionalArgument Uuid_comparison_exp
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , externalData : OptionalArgument External_data_bool_exp
    , external_data_id : OptionalArgument Uuid_comparison_exp
    , professional_id : OptionalArgument Uuid_comparison_exp
    , updated_at : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type for the External\_data\_info\_bool\_exp input object.
-}
type External_data_info_bool_exp
    = External_data_info_bool_exp External_data_info_bool_expRaw


{-| Encode a External\_data\_info\_bool\_exp into a value that can be used as an argument.
-}
encodeExternal_data_info_bool_exp : External_data_info_bool_exp -> Value
encodeExternal_data_info_bool_exp (External_data_info_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeExternal_data_info_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeExternal_data_info_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeExternal_data_info_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "beneficiary", encodeBeneficiary_bool_exp |> Encode.optional input____.beneficiary ), ( "beneficiary_id", encodeUuid_comparison_exp |> Encode.optional input____.beneficiary_id ), ( "created_at", encodeTimestamptz_comparison_exp |> Encode.optional input____.created_at ), ( "externalData", encodeExternal_data_bool_exp |> Encode.optional input____.externalData ), ( "external_data_id", encodeUuid_comparison_exp |> Encode.optional input____.external_data_id ), ( "professional_id", encodeUuid_comparison_exp |> Encode.optional input____.professional_id ), ( "updated_at", encodeTimestamptz_comparison_exp |> Encode.optional input____.updated_at ) ]


buildExternal_data_info_insert_input :
    (External_data_info_insert_inputOptionalFields -> External_data_info_insert_inputOptionalFields)
    -> External_data_info_insert_input
buildExternal_data_info_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { beneficiary = Absent, beneficiary_id = Absent, created_at = Absent, externalData = Absent, external_data_id = Absent, professional_id = Absent, updated_at = Absent }
    in
    External_data_info_insert_input { beneficiary = optionals____.beneficiary, beneficiary_id = optionals____.beneficiary_id, created_at = optionals____.created_at, externalData = optionals____.externalData, external_data_id = optionals____.external_data_id, professional_id = optionals____.professional_id, updated_at = optionals____.updated_at }


type alias External_data_info_insert_inputOptionalFields =
    { beneficiary : OptionalArgument Beneficiary_obj_rel_insert_input
    , beneficiary_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , created_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , externalData : OptionalArgument External_data_obj_rel_insert_input
    , external_data_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , professional_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updated_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type alias for the `External_data_info_insert_input` attributes. Note that this type
needs to use the `External_data_info_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias External_data_info_insert_inputRaw =
    { beneficiary : OptionalArgument Beneficiary_obj_rel_insert_input
    , beneficiary_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , created_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , externalData : OptionalArgument External_data_obj_rel_insert_input
    , external_data_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , professional_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updated_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the External\_data\_info\_insert\_input input object.
-}
type External_data_info_insert_input
    = External_data_info_insert_input External_data_info_insert_inputRaw


{-| Encode a External\_data\_info\_insert\_input into a value that can be used as an argument.
-}
encodeExternal_data_info_insert_input : External_data_info_insert_input -> Value
encodeExternal_data_info_insert_input (External_data_info_insert_input input____) =
    Encode.maybeObject
        [ ( "beneficiary", encodeBeneficiary_obj_rel_insert_input |> Encode.optional input____.beneficiary ), ( "beneficiary_id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.beneficiary_id ), ( "created_at", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.created_at ), ( "externalData", encodeExternal_data_obj_rel_insert_input |> Encode.optional input____.externalData ), ( "external_data_id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.external_data_id ), ( "professional_id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.professional_id ), ( "updated_at", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updated_at ) ]


buildExternal_data_info_max_order_by :
    (External_data_info_max_order_byOptionalFields -> External_data_info_max_order_byOptionalFields)
    -> External_data_info_max_order_by
buildExternal_data_info_max_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { beneficiary_id = Absent, created_at = Absent, external_data_id = Absent, professional_id = Absent, updated_at = Absent }
    in
    { beneficiary_id = optionals____.beneficiary_id, created_at = optionals____.created_at, external_data_id = optionals____.external_data_id, professional_id = optionals____.professional_id, updated_at = optionals____.updated_at }


type alias External_data_info_max_order_byOptionalFields =
    { beneficiary_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , created_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , external_data_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , professional_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updated_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the External\_data\_info\_max\_order\_by input object.
-}
type alias External_data_info_max_order_by =
    { beneficiary_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , created_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , external_data_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , professional_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updated_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a External\_data\_info\_max\_order\_by into a value that can be used as an argument.
-}
encodeExternal_data_info_max_order_by : External_data_info_max_order_by -> Value
encodeExternal_data_info_max_order_by input____ =
    Encode.maybeObject
        [ ( "beneficiary_id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.beneficiary_id ), ( "created_at", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.created_at ), ( "external_data_id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.external_data_id ), ( "professional_id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.professional_id ), ( "updated_at", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updated_at ) ]


buildExternal_data_info_min_order_by :
    (External_data_info_min_order_byOptionalFields -> External_data_info_min_order_byOptionalFields)
    -> External_data_info_min_order_by
buildExternal_data_info_min_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { beneficiary_id = Absent, created_at = Absent, external_data_id = Absent, professional_id = Absent, updated_at = Absent }
    in
    { beneficiary_id = optionals____.beneficiary_id, created_at = optionals____.created_at, external_data_id = optionals____.external_data_id, professional_id = optionals____.professional_id, updated_at = optionals____.updated_at }


type alias External_data_info_min_order_byOptionalFields =
    { beneficiary_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , created_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , external_data_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , professional_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updated_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the External\_data\_info\_min\_order\_by input object.
-}
type alias External_data_info_min_order_by =
    { beneficiary_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , created_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , external_data_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , professional_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updated_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a External\_data\_info\_min\_order\_by into a value that can be used as an argument.
-}
encodeExternal_data_info_min_order_by : External_data_info_min_order_by -> Value
encodeExternal_data_info_min_order_by input____ =
    Encode.maybeObject
        [ ( "beneficiary_id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.beneficiary_id ), ( "created_at", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.created_at ), ( "external_data_id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.external_data_id ), ( "professional_id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.professional_id ), ( "updated_at", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updated_at ) ]


buildExternal_data_info_obj_rel_insert_input :
    External_data_info_obj_rel_insert_inputRequiredFields
    -> (External_data_info_obj_rel_insert_inputOptionalFields -> External_data_info_obj_rel_insert_inputOptionalFields)
    -> External_data_info_obj_rel_insert_input
buildExternal_data_info_obj_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    External_data_info_obj_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias External_data_info_obj_rel_insert_inputRequiredFields =
    { data : External_data_info_insert_input }


type alias External_data_info_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument External_data_info_on_conflict }


{-| Type alias for the `External_data_info_obj_rel_insert_input` attributes. Note that this type
needs to use the `External_data_info_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias External_data_info_obj_rel_insert_inputRaw =
    { data : External_data_info_insert_input
    , on_conflict : OptionalArgument External_data_info_on_conflict
    }


{-| Type for the External\_data\_info\_obj\_rel\_insert\_input input object.
-}
type External_data_info_obj_rel_insert_input
    = External_data_info_obj_rel_insert_input External_data_info_obj_rel_insert_inputRaw


{-| Encode a External\_data\_info\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeExternal_data_info_obj_rel_insert_input : External_data_info_obj_rel_insert_input -> Value
encodeExternal_data_info_obj_rel_insert_input (External_data_info_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeExternal_data_info_insert_input input____.data |> Just ), ( "on_conflict", encodeExternal_data_info_on_conflict |> Encode.optional input____.on_conflict ) ]


buildExternal_data_info_on_conflict :
    External_data_info_on_conflictRequiredFields
    -> (External_data_info_on_conflictOptionalFields -> External_data_info_on_conflictOptionalFields)
    -> External_data_info_on_conflict
buildExternal_data_info_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    External_data_info_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias External_data_info_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.External_data_info_constraint.External_data_info_constraint
    , update_columns : List CdbGQL.Enum.External_data_info_update_column.External_data_info_update_column
    }


type alias External_data_info_on_conflictOptionalFields =
    { where_ : OptionalArgument External_data_info_bool_exp }


{-| Type alias for the `External_data_info_on_conflict` attributes. Note that this type
needs to use the `External_data_info_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias External_data_info_on_conflictRaw =
    { constraint : CdbGQL.Enum.External_data_info_constraint.External_data_info_constraint
    , update_columns : List CdbGQL.Enum.External_data_info_update_column.External_data_info_update_column
    , where_ : OptionalArgument External_data_info_bool_exp
    }


{-| Type for the External\_data\_info\_on\_conflict input object.
-}
type External_data_info_on_conflict
    = External_data_info_on_conflict External_data_info_on_conflictRaw


{-| Encode a External\_data\_info\_on\_conflict into a value that can be used as an argument.
-}
encodeExternal_data_info_on_conflict : External_data_info_on_conflict -> Value
encodeExternal_data_info_on_conflict (External_data_info_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.External_data_info_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.External_data_info_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeExternal_data_info_bool_exp |> Encode.optional input____.where_ ) ]


buildExternal_data_info_order_by :
    (External_data_info_order_byOptionalFields -> External_data_info_order_byOptionalFields)
    -> External_data_info_order_by
buildExternal_data_info_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { beneficiary = Absent, beneficiary_id = Absent, created_at = Absent, externalData = Absent, external_data_id = Absent, professional_id = Absent, updated_at = Absent }
    in
    External_data_info_order_by { beneficiary = optionals____.beneficiary, beneficiary_id = optionals____.beneficiary_id, created_at = optionals____.created_at, externalData = optionals____.externalData, external_data_id = optionals____.external_data_id, professional_id = optionals____.professional_id, updated_at = optionals____.updated_at }


type alias External_data_info_order_byOptionalFields =
    { beneficiary : OptionalArgument Beneficiary_order_by
    , beneficiary_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , created_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , externalData : OptionalArgument External_data_order_by
    , external_data_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , professional_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updated_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type alias for the `External_data_info_order_by` attributes. Note that this type
needs to use the `External_data_info_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias External_data_info_order_byRaw =
    { beneficiary : OptionalArgument Beneficiary_order_by
    , beneficiary_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , created_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , externalData : OptionalArgument External_data_order_by
    , external_data_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , professional_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updated_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the External\_data\_info\_order\_by input object.
-}
type External_data_info_order_by
    = External_data_info_order_by External_data_info_order_byRaw


{-| Encode a External\_data\_info\_order\_by into a value that can be used as an argument.
-}
encodeExternal_data_info_order_by : External_data_info_order_by -> Value
encodeExternal_data_info_order_by (External_data_info_order_by input____) =
    Encode.maybeObject
        [ ( "beneficiary", encodeBeneficiary_order_by |> Encode.optional input____.beneficiary ), ( "beneficiary_id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.beneficiary_id ), ( "created_at", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.created_at ), ( "externalData", encodeExternal_data_order_by |> Encode.optional input____.externalData ), ( "external_data_id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.external_data_id ), ( "professional_id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.professional_id ), ( "updated_at", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updated_at ) ]


buildExternal_data_info_pk_columns_input :
    External_data_info_pk_columns_inputRequiredFields
    -> External_data_info_pk_columns_input
buildExternal_data_info_pk_columns_input required____ =
    { external_data_id = required____.external_data_id }


type alias External_data_info_pk_columns_inputRequiredFields =
    { external_data_id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the External\_data\_info\_pk\_columns\_input input object.
-}
type alias External_data_info_pk_columns_input =
    { external_data_id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a External\_data\_info\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeExternal_data_info_pk_columns_input : External_data_info_pk_columns_input -> Value
encodeExternal_data_info_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "external_data_id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.external_data_id |> Just ) ]


buildExternal_data_info_set_input :
    (External_data_info_set_inputOptionalFields -> External_data_info_set_inputOptionalFields)
    -> External_data_info_set_input
buildExternal_data_info_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { beneficiary_id = Absent, created_at = Absent, external_data_id = Absent, professional_id = Absent, updated_at = Absent }
    in
    { beneficiary_id = optionals____.beneficiary_id, created_at = optionals____.created_at, external_data_id = optionals____.external_data_id, professional_id = optionals____.professional_id, updated_at = optionals____.updated_at }


type alias External_data_info_set_inputOptionalFields =
    { beneficiary_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , created_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , external_data_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , professional_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updated_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the External\_data\_info\_set\_input input object.
-}
type alias External_data_info_set_input =
    { beneficiary_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , created_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , external_data_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , professional_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updated_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a External\_data\_info\_set\_input into a value that can be used as an argument.
-}
encodeExternal_data_info_set_input : External_data_info_set_input -> Value
encodeExternal_data_info_set_input input____ =
    Encode.maybeObject
        [ ( "beneficiary_id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.beneficiary_id ), ( "created_at", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.created_at ), ( "external_data_id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.external_data_id ), ( "professional_id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.professional_id ), ( "updated_at", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updated_at ) ]


buildExternal_data_info_stream_cursor_input :
    External_data_info_stream_cursor_inputRequiredFields
    -> (External_data_info_stream_cursor_inputOptionalFields -> External_data_info_stream_cursor_inputOptionalFields)
    -> External_data_info_stream_cursor_input
buildExternal_data_info_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias External_data_info_stream_cursor_inputRequiredFields =
    { initial_value : External_data_info_stream_cursor_value_input }


type alias External_data_info_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the External\_data\_info\_stream\_cursor\_input input object.
-}
type alias External_data_info_stream_cursor_input =
    { initial_value : External_data_info_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a External\_data\_info\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeExternal_data_info_stream_cursor_input : External_data_info_stream_cursor_input -> Value
encodeExternal_data_info_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeExternal_data_info_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildExternal_data_info_stream_cursor_value_input :
    (External_data_info_stream_cursor_value_inputOptionalFields -> External_data_info_stream_cursor_value_inputOptionalFields)
    -> External_data_info_stream_cursor_value_input
buildExternal_data_info_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { beneficiary_id = Absent, created_at = Absent, external_data_id = Absent, professional_id = Absent, updated_at = Absent }
    in
    { beneficiary_id = optionals____.beneficiary_id, created_at = optionals____.created_at, external_data_id = optionals____.external_data_id, professional_id = optionals____.professional_id, updated_at = optionals____.updated_at }


type alias External_data_info_stream_cursor_value_inputOptionalFields =
    { beneficiary_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , created_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , external_data_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , professional_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updated_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the External\_data\_info\_stream\_cursor\_value\_input input object.
-}
type alias External_data_info_stream_cursor_value_input =
    { beneficiary_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , created_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , external_data_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , professional_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updated_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a External\_data\_info\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeExternal_data_info_stream_cursor_value_input : External_data_info_stream_cursor_value_input -> Value
encodeExternal_data_info_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "beneficiary_id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.beneficiary_id ), ( "created_at", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.created_at ), ( "external_data_id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.external_data_id ), ( "professional_id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.professional_id ), ( "updated_at", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updated_at ) ]


buildExternal_data_info_updates :
    External_data_info_updatesRequiredFields
    -> (External_data_info_updatesOptionalFields -> External_data_info_updatesOptionalFields)
    -> External_data_info_updates
buildExternal_data_info_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    External_data_info_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias External_data_info_updatesRequiredFields =
    { where_ : External_data_info_bool_exp }


type alias External_data_info_updatesOptionalFields =
    { set_ : OptionalArgument External_data_info_set_input }


{-| Type alias for the `External_data_info_updates` attributes. Note that this type
needs to use the `External_data_info_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias External_data_info_updatesRaw =
    { set_ : OptionalArgument External_data_info_set_input
    , where_ : External_data_info_bool_exp
    }


{-| Type for the External\_data\_info\_updates input object.
-}
type External_data_info_updates
    = External_data_info_updates External_data_info_updatesRaw


{-| Encode a External\_data\_info\_updates into a value that can be used as an argument.
-}
encodeExternal_data_info_updates : External_data_info_updates -> Value
encodeExternal_data_info_updates (External_data_info_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeExternal_data_info_set_input |> Encode.optional input____.set_ ), ( "where", encodeExternal_data_info_bool_exp input____.where_ |> Just ) ]


buildExternal_data_insert_input :
    (External_data_insert_inputOptionalFields -> External_data_insert_inputOptionalFields)
    -> External_data_insert_input
buildExternal_data_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { created_at = Absent, data = Absent, externalDataInfo = Absent, external_source = Absent, hash = Absent, id = Absent, source = Absent, updated_at = Absent }
    in
    External_data_insert_input { created_at = optionals____.created_at, data = optionals____.data, externalDataInfo = optionals____.externalDataInfo, external_source = optionals____.external_source, hash = optionals____.hash, id = optionals____.id, source = optionals____.source, updated_at = optionals____.updated_at }


type alias External_data_insert_inputOptionalFields =
    { created_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , data : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , externalDataInfo : OptionalArgument External_data_info_obj_rel_insert_input
    , external_source : OptionalArgument External_source_obj_rel_insert_input
    , hash : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , source : OptionalArgument CdbGQL.Enum.External_source_enum.External_source_enum
    , updated_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type alias for the `External_data_insert_input` attributes. Note that this type
needs to use the `External_data_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias External_data_insert_inputRaw =
    { created_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , data : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , externalDataInfo : OptionalArgument External_data_info_obj_rel_insert_input
    , external_source : OptionalArgument External_source_obj_rel_insert_input
    , hash : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , source : OptionalArgument CdbGQL.Enum.External_source_enum.External_source_enum
    , updated_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the External\_data\_insert\_input input object.
-}
type External_data_insert_input
    = External_data_insert_input External_data_insert_inputRaw


{-| Encode a External\_data\_insert\_input into a value that can be used as an argument.
-}
encodeExternal_data_insert_input : External_data_insert_input -> Value
encodeExternal_data_insert_input (External_data_insert_input input____) =
    Encode.maybeObject
        [ ( "created_at", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.created_at ), ( "data", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input____.data ), ( "externalDataInfo", encodeExternal_data_info_obj_rel_insert_input |> Encode.optional input____.externalDataInfo ), ( "external_source", encodeExternal_source_obj_rel_insert_input |> Encode.optional input____.external_source ), ( "hash", Encode.string |> Encode.optional input____.hash ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "source", Encode.enum CdbGQL.Enum.External_source_enum.toString |> Encode.optional input____.source ), ( "updated_at", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updated_at ) ]


buildExternal_data_max_order_by :
    (External_data_max_order_byOptionalFields -> External_data_max_order_byOptionalFields)
    -> External_data_max_order_by
buildExternal_data_max_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { created_at = Absent, hash = Absent, id = Absent, updated_at = Absent }
    in
    { created_at = optionals____.created_at, hash = optionals____.hash, id = optionals____.id, updated_at = optionals____.updated_at }


type alias External_data_max_order_byOptionalFields =
    { created_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , hash : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updated_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the External\_data\_max\_order\_by input object.
-}
type alias External_data_max_order_by =
    { created_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , hash : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updated_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a External\_data\_max\_order\_by into a value that can be used as an argument.
-}
encodeExternal_data_max_order_by : External_data_max_order_by -> Value
encodeExternal_data_max_order_by input____ =
    Encode.maybeObject
        [ ( "created_at", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.created_at ), ( "hash", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.hash ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "updated_at", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updated_at ) ]


buildExternal_data_min_order_by :
    (External_data_min_order_byOptionalFields -> External_data_min_order_byOptionalFields)
    -> External_data_min_order_by
buildExternal_data_min_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { created_at = Absent, hash = Absent, id = Absent, updated_at = Absent }
    in
    { created_at = optionals____.created_at, hash = optionals____.hash, id = optionals____.id, updated_at = optionals____.updated_at }


type alias External_data_min_order_byOptionalFields =
    { created_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , hash : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updated_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the External\_data\_min\_order\_by input object.
-}
type alias External_data_min_order_by =
    { created_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , hash : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updated_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a External\_data\_min\_order\_by into a value that can be used as an argument.
-}
encodeExternal_data_min_order_by : External_data_min_order_by -> Value
encodeExternal_data_min_order_by input____ =
    Encode.maybeObject
        [ ( "created_at", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.created_at ), ( "hash", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.hash ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "updated_at", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updated_at ) ]


buildExternal_data_obj_rel_insert_input :
    External_data_obj_rel_insert_inputRequiredFields
    -> (External_data_obj_rel_insert_inputOptionalFields -> External_data_obj_rel_insert_inputOptionalFields)
    -> External_data_obj_rel_insert_input
buildExternal_data_obj_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    External_data_obj_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias External_data_obj_rel_insert_inputRequiredFields =
    { data : External_data_insert_input }


type alias External_data_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument External_data_on_conflict }


{-| Type alias for the `External_data_obj_rel_insert_input` attributes. Note that this type
needs to use the `External_data_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias External_data_obj_rel_insert_inputRaw =
    { data : External_data_insert_input
    , on_conflict : OptionalArgument External_data_on_conflict
    }


{-| Type for the External\_data\_obj\_rel\_insert\_input input object.
-}
type External_data_obj_rel_insert_input
    = External_data_obj_rel_insert_input External_data_obj_rel_insert_inputRaw


{-| Encode a External\_data\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeExternal_data_obj_rel_insert_input : External_data_obj_rel_insert_input -> Value
encodeExternal_data_obj_rel_insert_input (External_data_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeExternal_data_insert_input input____.data |> Just ), ( "on_conflict", encodeExternal_data_on_conflict |> Encode.optional input____.on_conflict ) ]


buildExternal_data_on_conflict :
    External_data_on_conflictRequiredFields
    -> (External_data_on_conflictOptionalFields -> External_data_on_conflictOptionalFields)
    -> External_data_on_conflict
buildExternal_data_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    External_data_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias External_data_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.External_data_constraint.External_data_constraint
    , update_columns : List CdbGQL.Enum.External_data_update_column.External_data_update_column
    }


type alias External_data_on_conflictOptionalFields =
    { where_ : OptionalArgument External_data_bool_exp }


{-| Type alias for the `External_data_on_conflict` attributes. Note that this type
needs to use the `External_data_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias External_data_on_conflictRaw =
    { constraint : CdbGQL.Enum.External_data_constraint.External_data_constraint
    , update_columns : List CdbGQL.Enum.External_data_update_column.External_data_update_column
    , where_ : OptionalArgument External_data_bool_exp
    }


{-| Type for the External\_data\_on\_conflict input object.
-}
type External_data_on_conflict
    = External_data_on_conflict External_data_on_conflictRaw


{-| Encode a External\_data\_on\_conflict into a value that can be used as an argument.
-}
encodeExternal_data_on_conflict : External_data_on_conflict -> Value
encodeExternal_data_on_conflict (External_data_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.External_data_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.External_data_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeExternal_data_bool_exp |> Encode.optional input____.where_ ) ]


buildExternal_data_order_by :
    (External_data_order_byOptionalFields -> External_data_order_byOptionalFields)
    -> External_data_order_by
buildExternal_data_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { created_at = Absent, data = Absent, externalDataInfo = Absent, external_source = Absent, hash = Absent, id = Absent, source = Absent, updated_at = Absent }
    in
    External_data_order_by { created_at = optionals____.created_at, data = optionals____.data, externalDataInfo = optionals____.externalDataInfo, external_source = optionals____.external_source, hash = optionals____.hash, id = optionals____.id, source = optionals____.source, updated_at = optionals____.updated_at }


type alias External_data_order_byOptionalFields =
    { created_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , data : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , externalDataInfo : OptionalArgument External_data_info_order_by
    , external_source : OptionalArgument External_source_order_by
    , hash : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , source : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updated_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type alias for the `External_data_order_by` attributes. Note that this type
needs to use the `External_data_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias External_data_order_byRaw =
    { created_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , data : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , externalDataInfo : OptionalArgument External_data_info_order_by
    , external_source : OptionalArgument External_source_order_by
    , hash : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , source : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updated_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the External\_data\_order\_by input object.
-}
type External_data_order_by
    = External_data_order_by External_data_order_byRaw


{-| Encode a External\_data\_order\_by into a value that can be used as an argument.
-}
encodeExternal_data_order_by : External_data_order_by -> Value
encodeExternal_data_order_by (External_data_order_by input____) =
    Encode.maybeObject
        [ ( "created_at", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.created_at ), ( "data", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.data ), ( "externalDataInfo", encodeExternal_data_info_order_by |> Encode.optional input____.externalDataInfo ), ( "external_source", encodeExternal_source_order_by |> Encode.optional input____.external_source ), ( "hash", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.hash ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "source", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.source ), ( "updated_at", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updated_at ) ]


buildExternal_data_pk_columns_input :
    External_data_pk_columns_inputRequiredFields
    -> External_data_pk_columns_input
buildExternal_data_pk_columns_input required____ =
    { id = required____.id }


type alias External_data_pk_columns_inputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the External\_data\_pk\_columns\_input input object.
-}
type alias External_data_pk_columns_input =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a External\_data\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeExternal_data_pk_columns_input : External_data_pk_columns_input -> Value
encodeExternal_data_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildExternal_data_prepend_input :
    (External_data_prepend_inputOptionalFields -> External_data_prepend_inputOptionalFields)
    -> External_data_prepend_input
buildExternal_data_prepend_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { data = Absent }
    in
    { data = optionals____.data }


type alias External_data_prepend_inputOptionalFields =
    { data : OptionalArgument CdbGQL.ScalarCodecs.Jsonb }


{-| Type for the External\_data\_prepend\_input input object.
-}
type alias External_data_prepend_input =
    { data : OptionalArgument CdbGQL.ScalarCodecs.Jsonb }


{-| Encode a External\_data\_prepend\_input into a value that can be used as an argument.
-}
encodeExternal_data_prepend_input : External_data_prepend_input -> Value
encodeExternal_data_prepend_input input____ =
    Encode.maybeObject
        [ ( "data", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input____.data ) ]


buildExternal_data_set_input :
    (External_data_set_inputOptionalFields -> External_data_set_inputOptionalFields)
    -> External_data_set_input
buildExternal_data_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { created_at = Absent, data = Absent, hash = Absent, id = Absent, source = Absent, updated_at = Absent }
    in
    { created_at = optionals____.created_at, data = optionals____.data, hash = optionals____.hash, id = optionals____.id, source = optionals____.source, updated_at = optionals____.updated_at }


type alias External_data_set_inputOptionalFields =
    { created_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , data : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , hash : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , source : OptionalArgument CdbGQL.Enum.External_source_enum.External_source_enum
    , updated_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the External\_data\_set\_input input object.
-}
type alias External_data_set_input =
    { created_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , data : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , hash : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , source : OptionalArgument CdbGQL.Enum.External_source_enum.External_source_enum
    , updated_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a External\_data\_set\_input into a value that can be used as an argument.
-}
encodeExternal_data_set_input : External_data_set_input -> Value
encodeExternal_data_set_input input____ =
    Encode.maybeObject
        [ ( "created_at", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.created_at ), ( "data", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input____.data ), ( "hash", Encode.string |> Encode.optional input____.hash ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "source", Encode.enum CdbGQL.Enum.External_source_enum.toString |> Encode.optional input____.source ), ( "updated_at", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updated_at ) ]


buildExternal_data_stream_cursor_input :
    External_data_stream_cursor_inputRequiredFields
    -> (External_data_stream_cursor_inputOptionalFields -> External_data_stream_cursor_inputOptionalFields)
    -> External_data_stream_cursor_input
buildExternal_data_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias External_data_stream_cursor_inputRequiredFields =
    { initial_value : External_data_stream_cursor_value_input }


type alias External_data_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the External\_data\_stream\_cursor\_input input object.
-}
type alias External_data_stream_cursor_input =
    { initial_value : External_data_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a External\_data\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeExternal_data_stream_cursor_input : External_data_stream_cursor_input -> Value
encodeExternal_data_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeExternal_data_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildExternal_data_stream_cursor_value_input :
    (External_data_stream_cursor_value_inputOptionalFields -> External_data_stream_cursor_value_inputOptionalFields)
    -> External_data_stream_cursor_value_input
buildExternal_data_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { created_at = Absent, data = Absent, hash = Absent, id = Absent, source = Absent, updated_at = Absent }
    in
    { created_at = optionals____.created_at, data = optionals____.data, hash = optionals____.hash, id = optionals____.id, source = optionals____.source, updated_at = optionals____.updated_at }


type alias External_data_stream_cursor_value_inputOptionalFields =
    { created_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , data : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , hash : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , source : OptionalArgument CdbGQL.Enum.External_source_enum.External_source_enum
    , updated_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the External\_data\_stream\_cursor\_value\_input input object.
-}
type alias External_data_stream_cursor_value_input =
    { created_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , data : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , hash : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , source : OptionalArgument CdbGQL.Enum.External_source_enum.External_source_enum
    , updated_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a External\_data\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeExternal_data_stream_cursor_value_input : External_data_stream_cursor_value_input -> Value
encodeExternal_data_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "created_at", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.created_at ), ( "data", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input____.data ), ( "hash", Encode.string |> Encode.optional input____.hash ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "source", Encode.enum CdbGQL.Enum.External_source_enum.toString |> Encode.optional input____.source ), ( "updated_at", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updated_at ) ]


buildExternal_data_updates :
    External_data_updatesRequiredFields
    -> (External_data_updatesOptionalFields -> External_data_updatesOptionalFields)
    -> External_data_updates
buildExternal_data_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { append_ = Absent, delete_at_path_ = Absent, delete_elem_ = Absent, delete_key_ = Absent, prepend_ = Absent, set_ = Absent }
    in
    External_data_updates { append_ = optionals____.append_, delete_at_path_ = optionals____.delete_at_path_, delete_elem_ = optionals____.delete_elem_, delete_key_ = optionals____.delete_key_, prepend_ = optionals____.prepend_, set_ = optionals____.set_, where_ = required____.where_ }


type alias External_data_updatesRequiredFields =
    { where_ : External_data_bool_exp }


type alias External_data_updatesOptionalFields =
    { append_ : OptionalArgument External_data_append_input
    , delete_at_path_ : OptionalArgument External_data_delete_at_path_input
    , delete_elem_ : OptionalArgument External_data_delete_elem_input
    , delete_key_ : OptionalArgument External_data_delete_key_input
    , prepend_ : OptionalArgument External_data_prepend_input
    , set_ : OptionalArgument External_data_set_input
    }


{-| Type alias for the `External_data_updates` attributes. Note that this type
needs to use the `External_data_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias External_data_updatesRaw =
    { append_ : OptionalArgument External_data_append_input
    , delete_at_path_ : OptionalArgument External_data_delete_at_path_input
    , delete_elem_ : OptionalArgument External_data_delete_elem_input
    , delete_key_ : OptionalArgument External_data_delete_key_input
    , prepend_ : OptionalArgument External_data_prepend_input
    , set_ : OptionalArgument External_data_set_input
    , where_ : External_data_bool_exp
    }


{-| Type for the External\_data\_updates input object.
-}
type External_data_updates
    = External_data_updates External_data_updatesRaw


{-| Encode a External\_data\_updates into a value that can be used as an argument.
-}
encodeExternal_data_updates : External_data_updates -> Value
encodeExternal_data_updates (External_data_updates input____) =
    Encode.maybeObject
        [ ( "_append", encodeExternal_data_append_input |> Encode.optional input____.append_ ), ( "_delete_at_path", encodeExternal_data_delete_at_path_input |> Encode.optional input____.delete_at_path_ ), ( "_delete_elem", encodeExternal_data_delete_elem_input |> Encode.optional input____.delete_elem_ ), ( "_delete_key", encodeExternal_data_delete_key_input |> Encode.optional input____.delete_key_ ), ( "_prepend", encodeExternal_data_prepend_input |> Encode.optional input____.prepend_ ), ( "_set", encodeExternal_data_set_input |> Encode.optional input____.set_ ), ( "where", encodeExternal_data_bool_exp input____.where_ |> Just ) ]


buildExternal_source_bool_exp :
    (External_source_bool_expOptionalFields -> External_source_bool_expOptionalFields)
    -> External_source_bool_exp
buildExternal_source_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, comment = Absent, external_data = Absent, external_data_aggregate = Absent, value = Absent }
    in
    External_source_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, comment = optionals____.comment, external_data = optionals____.external_data, external_data_aggregate = optionals____.external_data_aggregate, value = optionals____.value }


type alias External_source_bool_expOptionalFields =
    { and_ : OptionalArgument (List External_source_bool_exp)
    , not_ : OptionalArgument External_source_bool_exp
    , or_ : OptionalArgument (List External_source_bool_exp)
    , comment : OptionalArgument String_comparison_exp
    , external_data : OptionalArgument External_data_bool_exp
    , external_data_aggregate : OptionalArgument External_data_aggregate_bool_exp
    , value : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `External_source_bool_exp` attributes. Note that this type
needs to use the `External_source_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias External_source_bool_expRaw =
    { and_ : OptionalArgument (List External_source_bool_exp)
    , not_ : OptionalArgument External_source_bool_exp
    , or_ : OptionalArgument (List External_source_bool_exp)
    , comment : OptionalArgument String_comparison_exp
    , external_data : OptionalArgument External_data_bool_exp
    , external_data_aggregate : OptionalArgument External_data_aggregate_bool_exp
    , value : OptionalArgument String_comparison_exp
    }


{-| Type for the External\_source\_bool\_exp input object.
-}
type External_source_bool_exp
    = External_source_bool_exp External_source_bool_expRaw


{-| Encode a External\_source\_bool\_exp into a value that can be used as an argument.
-}
encodeExternal_source_bool_exp : External_source_bool_exp -> Value
encodeExternal_source_bool_exp (External_source_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeExternal_source_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeExternal_source_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeExternal_source_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "comment", encodeString_comparison_exp |> Encode.optional input____.comment ), ( "external_data", encodeExternal_data_bool_exp |> Encode.optional input____.external_data ), ( "external_data_aggregate", encodeExternal_data_aggregate_bool_exp |> Encode.optional input____.external_data_aggregate ), ( "value", encodeString_comparison_exp |> Encode.optional input____.value ) ]


buildExternal_source_enum_comparison_exp :
    (External_source_enum_comparison_expOptionalFields -> External_source_enum_comparison_expOptionalFields)
    -> External_source_enum_comparison_exp
buildExternal_source_enum_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, in_ = Absent, is_null_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals____.eq_, in_ = optionals____.in_, is_null_ = optionals____.is_null_, neq_ = optionals____.neq_, nin_ = optionals____.nin_ }


type alias External_source_enum_comparison_expOptionalFields =
    { eq_ : OptionalArgument CdbGQL.Enum.External_source_enum.External_source_enum
    , in_ : OptionalArgument (List CdbGQL.Enum.External_source_enum.External_source_enum)
    , is_null_ : OptionalArgument Bool
    , neq_ : OptionalArgument CdbGQL.Enum.External_source_enum.External_source_enum
    , nin_ : OptionalArgument (List CdbGQL.Enum.External_source_enum.External_source_enum)
    }


{-| Type for the External\_source\_enum\_comparison\_exp input object.
-}
type alias External_source_enum_comparison_exp =
    { eq_ : OptionalArgument CdbGQL.Enum.External_source_enum.External_source_enum
    , in_ : OptionalArgument (List CdbGQL.Enum.External_source_enum.External_source_enum)
    , is_null_ : OptionalArgument Bool
    , neq_ : OptionalArgument CdbGQL.Enum.External_source_enum.External_source_enum
    , nin_ : OptionalArgument (List CdbGQL.Enum.External_source_enum.External_source_enum)
    }


{-| Encode a External\_source\_enum\_comparison\_exp into a value that can be used as an argument.
-}
encodeExternal_source_enum_comparison_exp : External_source_enum_comparison_exp -> Value
encodeExternal_source_enum_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", Encode.enum CdbGQL.Enum.External_source_enum.toString |> Encode.optional input____.eq_ ), ( "_in", (Encode.enum CdbGQL.Enum.External_source_enum.toString |> Encode.list) |> Encode.optional input____.in_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_neq", Encode.enum CdbGQL.Enum.External_source_enum.toString |> Encode.optional input____.neq_ ), ( "_nin", (Encode.enum CdbGQL.Enum.External_source_enum.toString |> Encode.list) |> Encode.optional input____.nin_ ) ]


buildExternal_source_insert_input :
    (External_source_insert_inputOptionalFields -> External_source_insert_inputOptionalFields)
    -> External_source_insert_input
buildExternal_source_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { comment = Absent, external_data = Absent, value = Absent }
    in
    External_source_insert_input { comment = optionals____.comment, external_data = optionals____.external_data, value = optionals____.value }


type alias External_source_insert_inputOptionalFields =
    { comment : OptionalArgument String
    , external_data : OptionalArgument External_data_arr_rel_insert_input
    , value : OptionalArgument String
    }


{-| Type alias for the `External_source_insert_input` attributes. Note that this type
needs to use the `External_source_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias External_source_insert_inputRaw =
    { comment : OptionalArgument String
    , external_data : OptionalArgument External_data_arr_rel_insert_input
    , value : OptionalArgument String
    }


{-| Type for the External\_source\_insert\_input input object.
-}
type External_source_insert_input
    = External_source_insert_input External_source_insert_inputRaw


{-| Encode a External\_source\_insert\_input into a value that can be used as an argument.
-}
encodeExternal_source_insert_input : External_source_insert_input -> Value
encodeExternal_source_insert_input (External_source_insert_input input____) =
    Encode.maybeObject
        [ ( "comment", Encode.string |> Encode.optional input____.comment ), ( "external_data", encodeExternal_data_arr_rel_insert_input |> Encode.optional input____.external_data ), ( "value", Encode.string |> Encode.optional input____.value ) ]


buildExternal_source_obj_rel_insert_input :
    External_source_obj_rel_insert_inputRequiredFields
    -> (External_source_obj_rel_insert_inputOptionalFields -> External_source_obj_rel_insert_inputOptionalFields)
    -> External_source_obj_rel_insert_input
buildExternal_source_obj_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    External_source_obj_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias External_source_obj_rel_insert_inputRequiredFields =
    { data : External_source_insert_input }


type alias External_source_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument External_source_on_conflict }


{-| Type alias for the `External_source_obj_rel_insert_input` attributes. Note that this type
needs to use the `External_source_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias External_source_obj_rel_insert_inputRaw =
    { data : External_source_insert_input
    , on_conflict : OptionalArgument External_source_on_conflict
    }


{-| Type for the External\_source\_obj\_rel\_insert\_input input object.
-}
type External_source_obj_rel_insert_input
    = External_source_obj_rel_insert_input External_source_obj_rel_insert_inputRaw


{-| Encode a External\_source\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeExternal_source_obj_rel_insert_input : External_source_obj_rel_insert_input -> Value
encodeExternal_source_obj_rel_insert_input (External_source_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeExternal_source_insert_input input____.data |> Just ), ( "on_conflict", encodeExternal_source_on_conflict |> Encode.optional input____.on_conflict ) ]


buildExternal_source_on_conflict :
    External_source_on_conflictRequiredFields
    -> (External_source_on_conflictOptionalFields -> External_source_on_conflictOptionalFields)
    -> External_source_on_conflict
buildExternal_source_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    External_source_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias External_source_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.External_source_constraint.External_source_constraint
    , update_columns : List CdbGQL.Enum.External_source_update_column.External_source_update_column
    }


type alias External_source_on_conflictOptionalFields =
    { where_ : OptionalArgument External_source_bool_exp }


{-| Type alias for the `External_source_on_conflict` attributes. Note that this type
needs to use the `External_source_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias External_source_on_conflictRaw =
    { constraint : CdbGQL.Enum.External_source_constraint.External_source_constraint
    , update_columns : List CdbGQL.Enum.External_source_update_column.External_source_update_column
    , where_ : OptionalArgument External_source_bool_exp
    }


{-| Type for the External\_source\_on\_conflict input object.
-}
type External_source_on_conflict
    = External_source_on_conflict External_source_on_conflictRaw


{-| Encode a External\_source\_on\_conflict into a value that can be used as an argument.
-}
encodeExternal_source_on_conflict : External_source_on_conflict -> Value
encodeExternal_source_on_conflict (External_source_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.External_source_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.External_source_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeExternal_source_bool_exp |> Encode.optional input____.where_ ) ]


buildExternal_source_order_by :
    (External_source_order_byOptionalFields -> External_source_order_byOptionalFields)
    -> External_source_order_by
buildExternal_source_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { comment = Absent, external_data_aggregate = Absent, value = Absent }
    in
    { comment = optionals____.comment, external_data_aggregate = optionals____.external_data_aggregate, value = optionals____.value }


type alias External_source_order_byOptionalFields =
    { comment : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , external_data_aggregate : OptionalArgument External_data_aggregate_order_by
    , value : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the External\_source\_order\_by input object.
-}
type alias External_source_order_by =
    { comment : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , external_data_aggregate : OptionalArgument External_data_aggregate_order_by
    , value : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a External\_source\_order\_by into a value that can be used as an argument.
-}
encodeExternal_source_order_by : External_source_order_by -> Value
encodeExternal_source_order_by input____ =
    Encode.maybeObject
        [ ( "comment", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.comment ), ( "external_data_aggregate", encodeExternal_data_aggregate_order_by |> Encode.optional input____.external_data_aggregate ), ( "value", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.value ) ]


buildExternal_source_pk_columns_input :
    External_source_pk_columns_inputRequiredFields
    -> External_source_pk_columns_input
buildExternal_source_pk_columns_input required____ =
    { value = required____.value }


type alias External_source_pk_columns_inputRequiredFields =
    { value : String }


{-| Type for the External\_source\_pk\_columns\_input input object.
-}
type alias External_source_pk_columns_input =
    { value : String }


{-| Encode a External\_source\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeExternal_source_pk_columns_input : External_source_pk_columns_input -> Value
encodeExternal_source_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "value", Encode.string input____.value |> Just ) ]


buildExternal_source_set_input :
    (External_source_set_inputOptionalFields -> External_source_set_inputOptionalFields)
    -> External_source_set_input
buildExternal_source_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { comment = Absent, value = Absent }
    in
    { comment = optionals____.comment, value = optionals____.value }


type alias External_source_set_inputOptionalFields =
    { comment : OptionalArgument String
    , value : OptionalArgument String
    }


{-| Type for the External\_source\_set\_input input object.
-}
type alias External_source_set_input =
    { comment : OptionalArgument String
    , value : OptionalArgument String
    }


{-| Encode a External\_source\_set\_input into a value that can be used as an argument.
-}
encodeExternal_source_set_input : External_source_set_input -> Value
encodeExternal_source_set_input input____ =
    Encode.maybeObject
        [ ( "comment", Encode.string |> Encode.optional input____.comment ), ( "value", Encode.string |> Encode.optional input____.value ) ]


buildExternal_source_stream_cursor_input :
    External_source_stream_cursor_inputRequiredFields
    -> (External_source_stream_cursor_inputOptionalFields -> External_source_stream_cursor_inputOptionalFields)
    -> External_source_stream_cursor_input
buildExternal_source_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias External_source_stream_cursor_inputRequiredFields =
    { initial_value : External_source_stream_cursor_value_input }


type alias External_source_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the External\_source\_stream\_cursor\_input input object.
-}
type alias External_source_stream_cursor_input =
    { initial_value : External_source_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a External\_source\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeExternal_source_stream_cursor_input : External_source_stream_cursor_input -> Value
encodeExternal_source_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeExternal_source_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildExternal_source_stream_cursor_value_input :
    (External_source_stream_cursor_value_inputOptionalFields -> External_source_stream_cursor_value_inputOptionalFields)
    -> External_source_stream_cursor_value_input
buildExternal_source_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { comment = Absent, value = Absent }
    in
    { comment = optionals____.comment, value = optionals____.value }


type alias External_source_stream_cursor_value_inputOptionalFields =
    { comment : OptionalArgument String
    , value : OptionalArgument String
    }


{-| Type for the External\_source\_stream\_cursor\_value\_input input object.
-}
type alias External_source_stream_cursor_value_input =
    { comment : OptionalArgument String
    , value : OptionalArgument String
    }


{-| Encode a External\_source\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeExternal_source_stream_cursor_value_input : External_source_stream_cursor_value_input -> Value
encodeExternal_source_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "comment", Encode.string |> Encode.optional input____.comment ), ( "value", Encode.string |> Encode.optional input____.value ) ]


buildExternal_source_updates :
    External_source_updatesRequiredFields
    -> (External_source_updatesOptionalFields -> External_source_updatesOptionalFields)
    -> External_source_updates
buildExternal_source_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    External_source_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias External_source_updatesRequiredFields =
    { where_ : External_source_bool_exp }


type alias External_source_updatesOptionalFields =
    { set_ : OptionalArgument External_source_set_input }


{-| Type alias for the `External_source_updates` attributes. Note that this type
needs to use the `External_source_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias External_source_updatesRaw =
    { set_ : OptionalArgument External_source_set_input
    , where_ : External_source_bool_exp
    }


{-| Type for the External\_source\_updates input object.
-}
type External_source_updates
    = External_source_updates External_source_updatesRaw


{-| Encode a External\_source\_updates into a value that can be used as an argument.
-}
encodeExternal_source_updates : External_source_updates -> Value
encodeExternal_source_updates (External_source_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeExternal_source_set_input |> Encode.optional input____.set_ ), ( "where", encodeExternal_source_bool_exp input____.where_ |> Just ) ]


buildFloat8_comparison_exp :
    (Float8_comparison_expOptionalFields -> Float8_comparison_expOptionalFields)
    -> Float8_comparison_exp
buildFloat8_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals____.eq_, gt_ = optionals____.gt_, gte_ = optionals____.gte_, in_ = optionals____.in_, is_null_ = optionals____.is_null_, lt_ = optionals____.lt_, lte_ = optionals____.lte_, neq_ = optionals____.neq_, nin_ = optionals____.nin_ }


type alias Float8_comparison_expOptionalFields =
    { eq_ : OptionalArgument CdbGQL.ScalarCodecs.Float8
    , gt_ : OptionalArgument CdbGQL.ScalarCodecs.Float8
    , gte_ : OptionalArgument CdbGQL.ScalarCodecs.Float8
    , in_ : OptionalArgument (List CdbGQL.ScalarCodecs.Float8)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CdbGQL.ScalarCodecs.Float8
    , lte_ : OptionalArgument CdbGQL.ScalarCodecs.Float8
    , neq_ : OptionalArgument CdbGQL.ScalarCodecs.Float8
    , nin_ : OptionalArgument (List CdbGQL.ScalarCodecs.Float8)
    }


{-| Type for the Float8\_comparison\_exp input object.
-}
type alias Float8_comparison_exp =
    { eq_ : OptionalArgument CdbGQL.ScalarCodecs.Float8
    , gt_ : OptionalArgument CdbGQL.ScalarCodecs.Float8
    , gte_ : OptionalArgument CdbGQL.ScalarCodecs.Float8
    , in_ : OptionalArgument (List CdbGQL.ScalarCodecs.Float8)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CdbGQL.ScalarCodecs.Float8
    , lte_ : OptionalArgument CdbGQL.ScalarCodecs.Float8
    , neq_ : OptionalArgument CdbGQL.ScalarCodecs.Float8
    , nin_ : OptionalArgument (List CdbGQL.ScalarCodecs.Float8)
    }


{-| Encode a Float8\_comparison\_exp into a value that can be used as an argument.
-}
encodeFloat8_comparison_exp : Float8_comparison_exp -> Value
encodeFloat8_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecFloat8) |> Encode.optional input____.eq_ ), ( "_gt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecFloat8) |> Encode.optional input____.gt_ ), ( "_gte", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecFloat8) |> Encode.optional input____.gte_ ), ( "_in", ((CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecFloat8) |> Encode.list) |> Encode.optional input____.in_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_lt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecFloat8) |> Encode.optional input____.lt_ ), ( "_lte", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecFloat8) |> Encode.optional input____.lte_ ), ( "_neq", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecFloat8) |> Encode.optional input____.neq_ ), ( "_nin", ((CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecFloat8) |> Encode.list) |> Encode.optional input____.nin_ ) ]


buildGet_beneficiaries_from_nir_args :
    (Get_beneficiaries_from_nir_argsOptionalFields -> Get_beneficiaries_from_nir_argsOptionalFields)
    -> Get_beneficiaries_from_nir_args
buildGet_beneficiaries_from_nir_args fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { search_nir = Absent }
    in
    { search_nir = optionals____.search_nir }


type alias Get_beneficiaries_from_nir_argsOptionalFields =
    { search_nir : OptionalArgument String }


{-| Type for the Get\_beneficiaries\_from\_nir\_args input object.
-}
type alias Get_beneficiaries_from_nir_args =
    { search_nir : OptionalArgument String }


{-| Encode a Get\_beneficiaries\_from\_nir\_args into a value that can be used as an argument.
-}
encodeGet_beneficiaries_from_nir_args : Get_beneficiaries_from_nir_args -> Value
encodeGet_beneficiaries_from_nir_args input____ =
    Encode.maybeObject
        [ ( "search_nir", Encode.string |> Encode.optional input____.search_nir ) ]


buildInt_comparison_exp :
    (Int_comparison_expOptionalFields -> Int_comparison_expOptionalFields)
    -> Int_comparison_exp
buildInt_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals____.eq_, gt_ = optionals____.gt_, gte_ = optionals____.gte_, in_ = optionals____.in_, is_null_ = optionals____.is_null_, lt_ = optionals____.lt_, lte_ = optionals____.lte_, neq_ = optionals____.neq_, nin_ = optionals____.nin_ }


type alias Int_comparison_expOptionalFields =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List Int)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List Int)
    }


{-| Type for the Int\_comparison\_exp input object.
-}
type alias Int_comparison_exp =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List Int)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List Int)
    }


{-| Encode a Int\_comparison\_exp into a value that can be used as an argument.
-}
encodeInt_comparison_exp : Int_comparison_exp -> Value
encodeInt_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", Encode.int |> Encode.optional input____.eq_ ), ( "_gt", Encode.int |> Encode.optional input____.gt_ ), ( "_gte", Encode.int |> Encode.optional input____.gte_ ), ( "_in", (Encode.int |> Encode.list) |> Encode.optional input____.in_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_lt", Encode.int |> Encode.optional input____.lt_ ), ( "_lte", Encode.int |> Encode.optional input____.lte_ ), ( "_neq", Encode.int |> Encode.optional input____.neq_ ), ( "_nin", (Encode.int |> Encode.list) |> Encode.optional input____.nin_ ) ]


buildJsonb_cast_exp :
    (Jsonb_cast_expOptionalFields -> Jsonb_cast_expOptionalFields)
    -> Jsonb_cast_exp
buildJsonb_cast_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { string = Absent }
    in
    { string = optionals____.string }


type alias Jsonb_cast_expOptionalFields =
    { string : OptionalArgument String_comparison_exp }


{-| Type for the Jsonb\_cast\_exp input object.
-}
type alias Jsonb_cast_exp =
    { string : OptionalArgument String_comparison_exp }


{-| Encode a Jsonb\_cast\_exp into a value that can be used as an argument.
-}
encodeJsonb_cast_exp : Jsonb_cast_exp -> Value
encodeJsonb_cast_exp input____ =
    Encode.maybeObject
        [ ( "String", encodeString_comparison_exp |> Encode.optional input____.string ) ]


buildJsonb_comparison_exp :
    (Jsonb_comparison_expOptionalFields -> Jsonb_comparison_expOptionalFields)
    -> Jsonb_comparison_exp
buildJsonb_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { cast_ = Absent, contained_in_ = Absent, contains_ = Absent, eq_ = Absent, gt_ = Absent, gte_ = Absent, has_key_ = Absent, has_keys_all_ = Absent, has_keys_any_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { cast_ = optionals____.cast_, contained_in_ = optionals____.contained_in_, contains_ = optionals____.contains_, eq_ = optionals____.eq_, gt_ = optionals____.gt_, gte_ = optionals____.gte_, has_key_ = optionals____.has_key_, has_keys_all_ = optionals____.has_keys_all_, has_keys_any_ = optionals____.has_keys_any_, in_ = optionals____.in_, is_null_ = optionals____.is_null_, lt_ = optionals____.lt_, lte_ = optionals____.lte_, neq_ = optionals____.neq_, nin_ = optionals____.nin_ }


type alias Jsonb_comparison_expOptionalFields =
    { cast_ : OptionalArgument Jsonb_cast_exp
    , contained_in_ : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , contains_ : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , eq_ : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , gt_ : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , gte_ : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , has_key_ : OptionalArgument String
    , has_keys_all_ : OptionalArgument (List String)
    , has_keys_any_ : OptionalArgument (List String)
    , in_ : OptionalArgument (List CdbGQL.ScalarCodecs.Jsonb)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , lte_ : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , neq_ : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , nin_ : OptionalArgument (List CdbGQL.ScalarCodecs.Jsonb)
    }


{-| Type for the Jsonb\_comparison\_exp input object.
-}
type alias Jsonb_comparison_exp =
    { cast_ : OptionalArgument Jsonb_cast_exp
    , contained_in_ : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , contains_ : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , eq_ : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , gt_ : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , gte_ : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , has_key_ : OptionalArgument String
    , has_keys_all_ : OptionalArgument (List String)
    , has_keys_any_ : OptionalArgument (List String)
    , in_ : OptionalArgument (List CdbGQL.ScalarCodecs.Jsonb)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , lte_ : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , neq_ : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , nin_ : OptionalArgument (List CdbGQL.ScalarCodecs.Jsonb)
    }


{-| Encode a Jsonb\_comparison\_exp into a value that can be used as an argument.
-}
encodeJsonb_comparison_exp : Jsonb_comparison_exp -> Value
encodeJsonb_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_cast", encodeJsonb_cast_exp |> Encode.optional input____.cast_ ), ( "_contained_in", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input____.contained_in_ ), ( "_contains", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input____.contains_ ), ( "_eq", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input____.eq_ ), ( "_gt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input____.gt_ ), ( "_gte", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input____.gte_ ), ( "_has_key", Encode.string |> Encode.optional input____.has_key_ ), ( "_has_keys_all", (Encode.string |> Encode.list) |> Encode.optional input____.has_keys_all_ ), ( "_has_keys_any", (Encode.string |> Encode.list) |> Encode.optional input____.has_keys_any_ ), ( "_in", ((CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.list) |> Encode.optional input____.in_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_lt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input____.lt_ ), ( "_lte", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input____.lte_ ), ( "_neq", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input____.neq_ ), ( "_nin", ((CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.list) |> Encode.optional input____.nin_ ) ]


buildManager_aggregate_bool_exp :
    (Manager_aggregate_bool_expOptionalFields -> Manager_aggregate_bool_expOptionalFields)
    -> Manager_aggregate_bool_exp
buildManager_aggregate_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent }
    in
    Manager_aggregate_bool_exp { count = optionals____.count }


type alias Manager_aggregate_bool_expOptionalFields =
    { count : OptionalArgument Manager_aggregate_bool_exp_count }


{-| Type alias for the `Manager_aggregate_bool_exp` attributes. Note that this type
needs to use the `Manager_aggregate_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Manager_aggregate_bool_expRaw =
    { count : OptionalArgument Manager_aggregate_bool_exp_count }


{-| Type for the Manager\_aggregate\_bool\_exp input object.
-}
type Manager_aggregate_bool_exp
    = Manager_aggregate_bool_exp Manager_aggregate_bool_expRaw


{-| Encode a Manager\_aggregate\_bool\_exp into a value that can be used as an argument.
-}
encodeManager_aggregate_bool_exp : Manager_aggregate_bool_exp -> Value
encodeManager_aggregate_bool_exp (Manager_aggregate_bool_exp input____) =
    Encode.maybeObject
        [ ( "count", encodeManager_aggregate_bool_exp_count |> Encode.optional input____.count ) ]


buildManager_aggregate_bool_exp_count :
    Manager_aggregate_bool_exp_countRequiredFields
    -> (Manager_aggregate_bool_exp_countOptionalFields -> Manager_aggregate_bool_exp_countOptionalFields)
    -> Manager_aggregate_bool_exp_count
buildManager_aggregate_bool_exp_count required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { arguments = Absent, distinct = Absent, filter = Absent }
    in
    Manager_aggregate_bool_exp_count { arguments = optionals____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Manager_aggregate_bool_exp_countRequiredFields =
    { predicate : Int_comparison_exp }


type alias Manager_aggregate_bool_exp_countOptionalFields =
    { arguments : OptionalArgument (List CdbGQL.Enum.Manager_select_column.Manager_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Manager_bool_exp
    }


{-| Type alias for the `Manager_aggregate_bool_exp_count` attributes. Note that this type
needs to use the `Manager_aggregate_bool_exp_count` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Manager_aggregate_bool_exp_countRaw =
    { arguments : OptionalArgument (List CdbGQL.Enum.Manager_select_column.Manager_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Manager_bool_exp
    , predicate : Int_comparison_exp
    }


{-| Type for the Manager\_aggregate\_bool\_exp\_count input object.
-}
type Manager_aggregate_bool_exp_count
    = Manager_aggregate_bool_exp_count Manager_aggregate_bool_exp_countRaw


{-| Encode a Manager\_aggregate\_bool\_exp\_count into a value that can be used as an argument.
-}
encodeManager_aggregate_bool_exp_count : Manager_aggregate_bool_exp_count -> Value
encodeManager_aggregate_bool_exp_count (Manager_aggregate_bool_exp_count input____) =
    Encode.maybeObject
        [ ( "arguments", (Encode.enum CdbGQL.Enum.Manager_select_column.toString |> Encode.list) |> Encode.optional input____.arguments ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeManager_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeInt_comparison_exp input____.predicate |> Just ) ]


buildManager_aggregate_order_by :
    (Manager_aggregate_order_byOptionalFields -> Manager_aggregate_order_byOptionalFields)
    -> Manager_aggregate_order_by
buildManager_aggregate_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals____.count, max = optionals____.max, min = optionals____.min }


type alias Manager_aggregate_order_byOptionalFields =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Manager_max_order_by
    , min : OptionalArgument Manager_min_order_by
    }


{-| Type for the Manager\_aggregate\_order\_by input object.
-}
type alias Manager_aggregate_order_by =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Manager_max_order_by
    , min : OptionalArgument Manager_min_order_by
    }


{-| Encode a Manager\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeManager_aggregate_order_by : Manager_aggregate_order_by -> Value
encodeManager_aggregate_order_by input____ =
    Encode.maybeObject
        [ ( "count", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.count ), ( "max", encodeManager_max_order_by |> Encode.optional input____.max ), ( "min", encodeManager_min_order_by |> Encode.optional input____.min ) ]


buildManager_arr_rel_insert_input :
    Manager_arr_rel_insert_inputRequiredFields
    -> (Manager_arr_rel_insert_inputOptionalFields -> Manager_arr_rel_insert_inputOptionalFields)
    -> Manager_arr_rel_insert_input
buildManager_arr_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Manager_arr_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Manager_arr_rel_insert_inputRequiredFields =
    { data : List Manager_insert_input }


type alias Manager_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Manager_on_conflict }


{-| Type alias for the `Manager_arr_rel_insert_input` attributes. Note that this type
needs to use the `Manager_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Manager_arr_rel_insert_inputRaw =
    { data : List Manager_insert_input
    , on_conflict : OptionalArgument Manager_on_conflict
    }


{-| Type for the Manager\_arr\_rel\_insert\_input input object.
-}
type Manager_arr_rel_insert_input
    = Manager_arr_rel_insert_input Manager_arr_rel_insert_inputRaw


{-| Encode a Manager\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeManager_arr_rel_insert_input : Manager_arr_rel_insert_input -> Value
encodeManager_arr_rel_insert_input (Manager_arr_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", (encodeManager_insert_input |> Encode.list) input____.data |> Just ), ( "on_conflict", encodeManager_on_conflict |> Encode.optional input____.on_conflict ) ]


buildManager_bool_exp :
    (Manager_bool_expOptionalFields -> Manager_bool_expOptionalFields)
    -> Manager_bool_exp
buildManager_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, account = Absent, createdAt = Absent, deployment = Absent, deploymentId = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, updatedAt = Absent }
    in
    Manager_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, account = optionals____.account, createdAt = optionals____.createdAt, deployment = optionals____.deployment, deploymentId = optionals____.deploymentId, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, updatedAt = optionals____.updatedAt }


type alias Manager_bool_expOptionalFields =
    { and_ : OptionalArgument (List Manager_bool_exp)
    , not_ : OptionalArgument Manager_bool_exp
    , or_ : OptionalArgument (List Manager_bool_exp)
    , account : OptionalArgument Account_bool_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , deployment : OptionalArgument Deployment_bool_exp
    , deploymentId : OptionalArgument Uuid_comparison_exp
    , email : OptionalArgument Citext_comparison_exp
    , firstname : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , lastname : OptionalArgument String_comparison_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type alias for the `Manager_bool_exp` attributes. Note that this type
needs to use the `Manager_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Manager_bool_expRaw =
    { and_ : OptionalArgument (List Manager_bool_exp)
    , not_ : OptionalArgument Manager_bool_exp
    , or_ : OptionalArgument (List Manager_bool_exp)
    , account : OptionalArgument Account_bool_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , deployment : OptionalArgument Deployment_bool_exp
    , deploymentId : OptionalArgument Uuid_comparison_exp
    , email : OptionalArgument Citext_comparison_exp
    , firstname : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , lastname : OptionalArgument String_comparison_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type for the Manager\_bool\_exp input object.
-}
type Manager_bool_exp
    = Manager_bool_exp Manager_bool_expRaw


{-| Encode a Manager\_bool\_exp into a value that can be used as an argument.
-}
encodeManager_bool_exp : Manager_bool_exp -> Value
encodeManager_bool_exp (Manager_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeManager_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeManager_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeManager_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "account", encodeAccount_bool_exp |> Encode.optional input____.account ), ( "createdAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.createdAt ), ( "deployment", encodeDeployment_bool_exp |> Encode.optional input____.deployment ), ( "deploymentId", encodeUuid_comparison_exp |> Encode.optional input____.deploymentId ), ( "email", encodeCitext_comparison_exp |> Encode.optional input____.email ), ( "firstname", encodeString_comparison_exp |> Encode.optional input____.firstname ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "lastname", encodeString_comparison_exp |> Encode.optional input____.lastname ), ( "updatedAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.updatedAt ) ]


buildManager_insert_input :
    (Manager_insert_inputOptionalFields -> Manager_insert_inputOptionalFields)
    -> Manager_insert_input
buildManager_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { account = Absent, createdAt = Absent, deployment = Absent, deploymentId = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, updatedAt = Absent }
    in
    Manager_insert_input { account = optionals____.account, createdAt = optionals____.createdAt, deployment = optionals____.deployment, deploymentId = optionals____.deploymentId, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, updatedAt = optionals____.updatedAt }


type alias Manager_insert_inputOptionalFields =
    { account : OptionalArgument Account_obj_rel_insert_input
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deployment : OptionalArgument Deployment_obj_rel_insert_input
    , deploymentId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastname : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type alias for the `Manager_insert_input` attributes. Note that this type
needs to use the `Manager_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Manager_insert_inputRaw =
    { account : OptionalArgument Account_obj_rel_insert_input
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deployment : OptionalArgument Deployment_obj_rel_insert_input
    , deploymentId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastname : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Manager\_insert\_input input object.
-}
type Manager_insert_input
    = Manager_insert_input Manager_insert_inputRaw


{-| Encode a Manager\_insert\_input into a value that can be used as an argument.
-}
encodeManager_insert_input : Manager_insert_input -> Value
encodeManager_insert_input (Manager_insert_input input____) =
    Encode.maybeObject
        [ ( "account", encodeAccount_obj_rel_insert_input |> Encode.optional input____.account ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "deployment", encodeDeployment_obj_rel_insert_input |> Encode.optional input____.deployment ), ( "deploymentId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.deploymentId ), ( "email", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.email ), ( "firstname", Encode.string |> Encode.optional input____.firstname ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "lastname", Encode.string |> Encode.optional input____.lastname ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildManager_max_order_by :
    (Manager_max_order_byOptionalFields -> Manager_max_order_byOptionalFields)
    -> Manager_max_order_by
buildManager_max_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, deploymentId = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, deploymentId = optionals____.deploymentId, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, updatedAt = optionals____.updatedAt }


type alias Manager_max_order_byOptionalFields =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deploymentId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Manager\_max\_order\_by input object.
-}
type alias Manager_max_order_by =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deploymentId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Manager\_max\_order\_by into a value that can be used as an argument.
-}
encodeManager_max_order_by : Manager_max_order_by -> Value
encodeManager_max_order_by input____ =
    Encode.maybeObject
        [ ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "deploymentId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deploymentId ), ( "email", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.email ), ( "firstname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.firstname ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "lastname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.lastname ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildManager_min_order_by :
    (Manager_min_order_byOptionalFields -> Manager_min_order_byOptionalFields)
    -> Manager_min_order_by
buildManager_min_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, deploymentId = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, deploymentId = optionals____.deploymentId, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, updatedAt = optionals____.updatedAt }


type alias Manager_min_order_byOptionalFields =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deploymentId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Manager\_min\_order\_by input object.
-}
type alias Manager_min_order_by =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deploymentId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Manager\_min\_order\_by into a value that can be used as an argument.
-}
encodeManager_min_order_by : Manager_min_order_by -> Value
encodeManager_min_order_by input____ =
    Encode.maybeObject
        [ ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "deploymentId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deploymentId ), ( "email", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.email ), ( "firstname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.firstname ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "lastname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.lastname ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildManager_obj_rel_insert_input :
    Manager_obj_rel_insert_inputRequiredFields
    -> (Manager_obj_rel_insert_inputOptionalFields -> Manager_obj_rel_insert_inputOptionalFields)
    -> Manager_obj_rel_insert_input
buildManager_obj_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Manager_obj_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Manager_obj_rel_insert_inputRequiredFields =
    { data : Manager_insert_input }


type alias Manager_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Manager_on_conflict }


{-| Type alias for the `Manager_obj_rel_insert_input` attributes. Note that this type
needs to use the `Manager_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Manager_obj_rel_insert_inputRaw =
    { data : Manager_insert_input
    , on_conflict : OptionalArgument Manager_on_conflict
    }


{-| Type for the Manager\_obj\_rel\_insert\_input input object.
-}
type Manager_obj_rel_insert_input
    = Manager_obj_rel_insert_input Manager_obj_rel_insert_inputRaw


{-| Encode a Manager\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeManager_obj_rel_insert_input : Manager_obj_rel_insert_input -> Value
encodeManager_obj_rel_insert_input (Manager_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeManager_insert_input input____.data |> Just ), ( "on_conflict", encodeManager_on_conflict |> Encode.optional input____.on_conflict ) ]


buildManager_on_conflict :
    Manager_on_conflictRequiredFields
    -> (Manager_on_conflictOptionalFields -> Manager_on_conflictOptionalFields)
    -> Manager_on_conflict
buildManager_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Manager_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Manager_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Manager_constraint.Manager_constraint
    , update_columns : List CdbGQL.Enum.Manager_update_column.Manager_update_column
    }


type alias Manager_on_conflictOptionalFields =
    { where_ : OptionalArgument Manager_bool_exp }


{-| Type alias for the `Manager_on_conflict` attributes. Note that this type
needs to use the `Manager_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Manager_on_conflictRaw =
    { constraint : CdbGQL.Enum.Manager_constraint.Manager_constraint
    , update_columns : List CdbGQL.Enum.Manager_update_column.Manager_update_column
    , where_ : OptionalArgument Manager_bool_exp
    }


{-| Type for the Manager\_on\_conflict input object.
-}
type Manager_on_conflict
    = Manager_on_conflict Manager_on_conflictRaw


{-| Encode a Manager\_on\_conflict into a value that can be used as an argument.
-}
encodeManager_on_conflict : Manager_on_conflict -> Value
encodeManager_on_conflict (Manager_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Manager_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Manager_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeManager_bool_exp |> Encode.optional input____.where_ ) ]


buildManager_order_by :
    (Manager_order_byOptionalFields -> Manager_order_byOptionalFields)
    -> Manager_order_by
buildManager_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { account = Absent, createdAt = Absent, deployment = Absent, deploymentId = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, updatedAt = Absent }
    in
    Manager_order_by { account = optionals____.account, createdAt = optionals____.createdAt, deployment = optionals____.deployment, deploymentId = optionals____.deploymentId, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, updatedAt = optionals____.updatedAt }


type alias Manager_order_byOptionalFields =
    { account : OptionalArgument Account_order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deployment : OptionalArgument Deployment_order_by
    , deploymentId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type alias for the `Manager_order_by` attributes. Note that this type
needs to use the `Manager_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Manager_order_byRaw =
    { account : OptionalArgument Account_order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deployment : OptionalArgument Deployment_order_by
    , deploymentId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Manager\_order\_by input object.
-}
type Manager_order_by
    = Manager_order_by Manager_order_byRaw


{-| Encode a Manager\_order\_by into a value that can be used as an argument.
-}
encodeManager_order_by : Manager_order_by -> Value
encodeManager_order_by (Manager_order_by input____) =
    Encode.maybeObject
        [ ( "account", encodeAccount_order_by |> Encode.optional input____.account ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "deployment", encodeDeployment_order_by |> Encode.optional input____.deployment ), ( "deploymentId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deploymentId ), ( "email", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.email ), ( "firstname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.firstname ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "lastname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.lastname ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildManager_pk_columns_input :
    Manager_pk_columns_inputRequiredFields
    -> Manager_pk_columns_input
buildManager_pk_columns_input required____ =
    { id = required____.id }


type alias Manager_pk_columns_inputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the Manager\_pk\_columns\_input input object.
-}
type alias Manager_pk_columns_input =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a Manager\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeManager_pk_columns_input : Manager_pk_columns_input -> Value
encodeManager_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildManager_set_input :
    (Manager_set_inputOptionalFields -> Manager_set_inputOptionalFields)
    -> Manager_set_input
buildManager_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, deploymentId = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, deploymentId = optionals____.deploymentId, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, updatedAt = optionals____.updatedAt }


type alias Manager_set_inputOptionalFields =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deploymentId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastname : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Manager\_set\_input input object.
-}
type alias Manager_set_input =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deploymentId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastname : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Manager\_set\_input into a value that can be used as an argument.
-}
encodeManager_set_input : Manager_set_input -> Value
encodeManager_set_input input____ =
    Encode.maybeObject
        [ ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "deploymentId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.deploymentId ), ( "email", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.email ), ( "firstname", Encode.string |> Encode.optional input____.firstname ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "lastname", Encode.string |> Encode.optional input____.lastname ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildManager_stream_cursor_input :
    Manager_stream_cursor_inputRequiredFields
    -> (Manager_stream_cursor_inputOptionalFields -> Manager_stream_cursor_inputOptionalFields)
    -> Manager_stream_cursor_input
buildManager_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Manager_stream_cursor_inputRequiredFields =
    { initial_value : Manager_stream_cursor_value_input }


type alias Manager_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Manager\_stream\_cursor\_input input object.
-}
type alias Manager_stream_cursor_input =
    { initial_value : Manager_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Manager\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeManager_stream_cursor_input : Manager_stream_cursor_input -> Value
encodeManager_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeManager_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildManager_stream_cursor_value_input :
    (Manager_stream_cursor_value_inputOptionalFields -> Manager_stream_cursor_value_inputOptionalFields)
    -> Manager_stream_cursor_value_input
buildManager_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, deploymentId = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, deploymentId = optionals____.deploymentId, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, updatedAt = optionals____.updatedAt }


type alias Manager_stream_cursor_value_inputOptionalFields =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deploymentId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastname : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Manager\_stream\_cursor\_value\_input input object.
-}
type alias Manager_stream_cursor_value_input =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deploymentId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastname : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Manager\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeManager_stream_cursor_value_input : Manager_stream_cursor_value_input -> Value
encodeManager_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "deploymentId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.deploymentId ), ( "email", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.email ), ( "firstname", Encode.string |> Encode.optional input____.firstname ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "lastname", Encode.string |> Encode.optional input____.lastname ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildManager_updates :
    Manager_updatesRequiredFields
    -> (Manager_updatesOptionalFields -> Manager_updatesOptionalFields)
    -> Manager_updates
buildManager_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Manager_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Manager_updatesRequiredFields =
    { where_ : Manager_bool_exp }


type alias Manager_updatesOptionalFields =
    { set_ : OptionalArgument Manager_set_input }


{-| Type alias for the `Manager_updates` attributes. Note that this type
needs to use the `Manager_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Manager_updatesRaw =
    { set_ : OptionalArgument Manager_set_input
    , where_ : Manager_bool_exp
    }


{-| Type for the Manager\_updates input object.
-}
type Manager_updates
    = Manager_updates Manager_updatesRaw


{-| Encode a Manager\_updates into a value that can be used as an argument.
-}
encodeManager_updates : Manager_updates -> Value
encodeManager_updates (Manager_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeManager_set_input |> Encode.optional input____.set_ ), ( "where", encodeManager_bool_exp input____.where_ |> Just ) ]


buildNotebook_action_aggregate_bool_exp :
    (Notebook_action_aggregate_bool_expOptionalFields -> Notebook_action_aggregate_bool_expOptionalFields)
    -> Notebook_action_aggregate_bool_exp
buildNotebook_action_aggregate_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent }
    in
    Notebook_action_aggregate_bool_exp { count = optionals____.count }


type alias Notebook_action_aggregate_bool_expOptionalFields =
    { count : OptionalArgument Notebook_action_aggregate_bool_exp_count }


{-| Type alias for the `Notebook_action_aggregate_bool_exp` attributes. Note that this type
needs to use the `Notebook_action_aggregate_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_action_aggregate_bool_expRaw =
    { count : OptionalArgument Notebook_action_aggregate_bool_exp_count }


{-| Type for the Notebook\_action\_aggregate\_bool\_exp input object.
-}
type Notebook_action_aggregate_bool_exp
    = Notebook_action_aggregate_bool_exp Notebook_action_aggregate_bool_expRaw


{-| Encode a Notebook\_action\_aggregate\_bool\_exp into a value that can be used as an argument.
-}
encodeNotebook_action_aggregate_bool_exp : Notebook_action_aggregate_bool_exp -> Value
encodeNotebook_action_aggregate_bool_exp (Notebook_action_aggregate_bool_exp input____) =
    Encode.maybeObject
        [ ( "count", encodeNotebook_action_aggregate_bool_exp_count |> Encode.optional input____.count ) ]


buildNotebook_action_aggregate_bool_exp_count :
    Notebook_action_aggregate_bool_exp_countRequiredFields
    -> (Notebook_action_aggregate_bool_exp_countOptionalFields -> Notebook_action_aggregate_bool_exp_countOptionalFields)
    -> Notebook_action_aggregate_bool_exp_count
buildNotebook_action_aggregate_bool_exp_count required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { arguments = Absent, distinct = Absent, filter = Absent }
    in
    Notebook_action_aggregate_bool_exp_count { arguments = optionals____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Notebook_action_aggregate_bool_exp_countRequiredFields =
    { predicate : Int_comparison_exp }


type alias Notebook_action_aggregate_bool_exp_countOptionalFields =
    { arguments : OptionalArgument (List CdbGQL.Enum.Notebook_action_select_column.Notebook_action_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Notebook_action_bool_exp
    }


{-| Type alias for the `Notebook_action_aggregate_bool_exp_count` attributes. Note that this type
needs to use the `Notebook_action_aggregate_bool_exp_count` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_action_aggregate_bool_exp_countRaw =
    { arguments : OptionalArgument (List CdbGQL.Enum.Notebook_action_select_column.Notebook_action_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Notebook_action_bool_exp
    , predicate : Int_comparison_exp
    }


{-| Type for the Notebook\_action\_aggregate\_bool\_exp\_count input object.
-}
type Notebook_action_aggregate_bool_exp_count
    = Notebook_action_aggregate_bool_exp_count Notebook_action_aggregate_bool_exp_countRaw


{-| Encode a Notebook\_action\_aggregate\_bool\_exp\_count into a value that can be used as an argument.
-}
encodeNotebook_action_aggregate_bool_exp_count : Notebook_action_aggregate_bool_exp_count -> Value
encodeNotebook_action_aggregate_bool_exp_count (Notebook_action_aggregate_bool_exp_count input____) =
    Encode.maybeObject
        [ ( "arguments", (Encode.enum CdbGQL.Enum.Notebook_action_select_column.toString |> Encode.list) |> Encode.optional input____.arguments ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeNotebook_action_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeInt_comparison_exp input____.predicate |> Just ) ]


buildNotebook_action_aggregate_order_by :
    (Notebook_action_aggregate_order_byOptionalFields -> Notebook_action_aggregate_order_byOptionalFields)
    -> Notebook_action_aggregate_order_by
buildNotebook_action_aggregate_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals____.count, max = optionals____.max, min = optionals____.min }


type alias Notebook_action_aggregate_order_byOptionalFields =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Notebook_action_max_order_by
    , min : OptionalArgument Notebook_action_min_order_by
    }


{-| Type for the Notebook\_action\_aggregate\_order\_by input object.
-}
type alias Notebook_action_aggregate_order_by =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Notebook_action_max_order_by
    , min : OptionalArgument Notebook_action_min_order_by
    }


{-| Encode a Notebook\_action\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_action_aggregate_order_by : Notebook_action_aggregate_order_by -> Value
encodeNotebook_action_aggregate_order_by input____ =
    Encode.maybeObject
        [ ( "count", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.count ), ( "max", encodeNotebook_action_max_order_by |> Encode.optional input____.max ), ( "min", encodeNotebook_action_min_order_by |> Encode.optional input____.min ) ]


buildNotebook_action_arr_rel_insert_input :
    Notebook_action_arr_rel_insert_inputRequiredFields
    -> (Notebook_action_arr_rel_insert_inputOptionalFields -> Notebook_action_arr_rel_insert_inputOptionalFields)
    -> Notebook_action_arr_rel_insert_input
buildNotebook_action_arr_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Notebook_action_arr_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Notebook_action_arr_rel_insert_inputRequiredFields =
    { data : List Notebook_action_insert_input }


type alias Notebook_action_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Notebook_action_on_conflict }


{-| Type alias for the `Notebook_action_arr_rel_insert_input` attributes. Note that this type
needs to use the `Notebook_action_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_action_arr_rel_insert_inputRaw =
    { data : List Notebook_action_insert_input
    , on_conflict : OptionalArgument Notebook_action_on_conflict
    }


{-| Type for the Notebook\_action\_arr\_rel\_insert\_input input object.
-}
type Notebook_action_arr_rel_insert_input
    = Notebook_action_arr_rel_insert_input Notebook_action_arr_rel_insert_inputRaw


{-| Encode a Notebook\_action\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeNotebook_action_arr_rel_insert_input : Notebook_action_arr_rel_insert_input -> Value
encodeNotebook_action_arr_rel_insert_input (Notebook_action_arr_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", (encodeNotebook_action_insert_input |> Encode.list) input____.data |> Just ), ( "on_conflict", encodeNotebook_action_on_conflict |> Encode.optional input____.on_conflict ) ]


buildNotebook_action_bool_exp :
    (Notebook_action_bool_expOptionalFields -> Notebook_action_bool_expOptionalFields)
    -> Notebook_action_bool_exp
buildNotebook_action_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, action = Absent, createdAt = Absent, creator = Absent, creatorId = Absent, id = Absent, startingAt = Absent, status = Absent, target = Absent, targetId = Absent, updatedAt = Absent }
    in
    Notebook_action_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, action = optionals____.action, createdAt = optionals____.createdAt, creator = optionals____.creator, creatorId = optionals____.creatorId, id = optionals____.id, startingAt = optionals____.startingAt, status = optionals____.status, target = optionals____.target, targetId = optionals____.targetId, updatedAt = optionals____.updatedAt }


type alias Notebook_action_bool_expOptionalFields =
    { and_ : OptionalArgument (List Notebook_action_bool_exp)
    , not_ : OptionalArgument Notebook_action_bool_exp
    , or_ : OptionalArgument (List Notebook_action_bool_exp)
    , action : OptionalArgument String_comparison_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , creator : OptionalArgument Account_bool_exp
    , creatorId : OptionalArgument Uuid_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , startingAt : OptionalArgument Timestamptz_comparison_exp
    , status : OptionalArgument Action_status_enum_comparison_exp
    , target : OptionalArgument Notebook_target_bool_exp
    , targetId : OptionalArgument Uuid_comparison_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type alias for the `Notebook_action_bool_exp` attributes. Note that this type
needs to use the `Notebook_action_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_action_bool_expRaw =
    { and_ : OptionalArgument (List Notebook_action_bool_exp)
    , not_ : OptionalArgument Notebook_action_bool_exp
    , or_ : OptionalArgument (List Notebook_action_bool_exp)
    , action : OptionalArgument String_comparison_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , creator : OptionalArgument Account_bool_exp
    , creatorId : OptionalArgument Uuid_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , startingAt : OptionalArgument Timestamptz_comparison_exp
    , status : OptionalArgument Action_status_enum_comparison_exp
    , target : OptionalArgument Notebook_target_bool_exp
    , targetId : OptionalArgument Uuid_comparison_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type for the Notebook\_action\_bool\_exp input object.
-}
type Notebook_action_bool_exp
    = Notebook_action_bool_exp Notebook_action_bool_expRaw


{-| Encode a Notebook\_action\_bool\_exp into a value that can be used as an argument.
-}
encodeNotebook_action_bool_exp : Notebook_action_bool_exp -> Value
encodeNotebook_action_bool_exp (Notebook_action_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeNotebook_action_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeNotebook_action_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeNotebook_action_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "action", encodeString_comparison_exp |> Encode.optional input____.action ), ( "createdAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.createdAt ), ( "creator", encodeAccount_bool_exp |> Encode.optional input____.creator ), ( "creatorId", encodeUuid_comparison_exp |> Encode.optional input____.creatorId ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "startingAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.startingAt ), ( "status", encodeAction_status_enum_comparison_exp |> Encode.optional input____.status ), ( "target", encodeNotebook_target_bool_exp |> Encode.optional input____.target ), ( "targetId", encodeUuid_comparison_exp |> Encode.optional input____.targetId ), ( "updatedAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.updatedAt ) ]


buildNotebook_action_insert_input :
    (Notebook_action_insert_inputOptionalFields -> Notebook_action_insert_inputOptionalFields)
    -> Notebook_action_insert_input
buildNotebook_action_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { action = Absent, createdAt = Absent, creator = Absent, creatorId = Absent, id = Absent, startingAt = Absent, status = Absent, target = Absent, targetId = Absent, updatedAt = Absent }
    in
    Notebook_action_insert_input { action = optionals____.action, createdAt = optionals____.createdAt, creator = optionals____.creator, creatorId = optionals____.creatorId, id = optionals____.id, startingAt = optionals____.startingAt, status = optionals____.status, target = optionals____.target, targetId = optionals____.targetId, updatedAt = optionals____.updatedAt }


type alias Notebook_action_insert_inputOptionalFields =
    { action : OptionalArgument String
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , creator : OptionalArgument Account_obj_rel_insert_input
    , creatorId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , startingAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , status : OptionalArgument CdbGQL.Enum.Action_status_enum.Action_status_enum
    , target : OptionalArgument Notebook_target_obj_rel_insert_input
    , targetId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type alias for the `Notebook_action_insert_input` attributes. Note that this type
needs to use the `Notebook_action_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_action_insert_inputRaw =
    { action : OptionalArgument String
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , creator : OptionalArgument Account_obj_rel_insert_input
    , creatorId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , startingAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , status : OptionalArgument CdbGQL.Enum.Action_status_enum.Action_status_enum
    , target : OptionalArgument Notebook_target_obj_rel_insert_input
    , targetId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Notebook\_action\_insert\_input input object.
-}
type Notebook_action_insert_input
    = Notebook_action_insert_input Notebook_action_insert_inputRaw


{-| Encode a Notebook\_action\_insert\_input into a value that can be used as an argument.
-}
encodeNotebook_action_insert_input : Notebook_action_insert_input -> Value
encodeNotebook_action_insert_input (Notebook_action_insert_input input____) =
    Encode.maybeObject
        [ ( "action", Encode.string |> Encode.optional input____.action ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "creator", encodeAccount_obj_rel_insert_input |> Encode.optional input____.creator ), ( "creatorId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.creatorId ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "startingAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.startingAt ), ( "status", Encode.enum CdbGQL.Enum.Action_status_enum.toString |> Encode.optional input____.status ), ( "target", encodeNotebook_target_obj_rel_insert_input |> Encode.optional input____.target ), ( "targetId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.targetId ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildNotebook_action_max_order_by :
    (Notebook_action_max_order_byOptionalFields -> Notebook_action_max_order_byOptionalFields)
    -> Notebook_action_max_order_by
buildNotebook_action_max_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { action = Absent, createdAt = Absent, creatorId = Absent, id = Absent, startingAt = Absent, targetId = Absent, updatedAt = Absent }
    in
    { action = optionals____.action, createdAt = optionals____.createdAt, creatorId = optionals____.creatorId, id = optionals____.id, startingAt = optionals____.startingAt, targetId = optionals____.targetId, updatedAt = optionals____.updatedAt }


type alias Notebook_action_max_order_byOptionalFields =
    { action : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creatorId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , startingAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , targetId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Notebook\_action\_max\_order\_by input object.
-}
type alias Notebook_action_max_order_by =
    { action : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creatorId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , startingAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , targetId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Notebook\_action\_max\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_action_max_order_by : Notebook_action_max_order_by -> Value
encodeNotebook_action_max_order_by input____ =
    Encode.maybeObject
        [ ( "action", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.action ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "creatorId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.creatorId ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "startingAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.startingAt ), ( "targetId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.targetId ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildNotebook_action_min_order_by :
    (Notebook_action_min_order_byOptionalFields -> Notebook_action_min_order_byOptionalFields)
    -> Notebook_action_min_order_by
buildNotebook_action_min_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { action = Absent, createdAt = Absent, creatorId = Absent, id = Absent, startingAt = Absent, targetId = Absent, updatedAt = Absent }
    in
    { action = optionals____.action, createdAt = optionals____.createdAt, creatorId = optionals____.creatorId, id = optionals____.id, startingAt = optionals____.startingAt, targetId = optionals____.targetId, updatedAt = optionals____.updatedAt }


type alias Notebook_action_min_order_byOptionalFields =
    { action : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creatorId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , startingAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , targetId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Notebook\_action\_min\_order\_by input object.
-}
type alias Notebook_action_min_order_by =
    { action : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creatorId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , startingAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , targetId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Notebook\_action\_min\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_action_min_order_by : Notebook_action_min_order_by -> Value
encodeNotebook_action_min_order_by input____ =
    Encode.maybeObject
        [ ( "action", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.action ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "creatorId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.creatorId ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "startingAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.startingAt ), ( "targetId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.targetId ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildNotebook_action_on_conflict :
    Notebook_action_on_conflictRequiredFields
    -> (Notebook_action_on_conflictOptionalFields -> Notebook_action_on_conflictOptionalFields)
    -> Notebook_action_on_conflict
buildNotebook_action_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Notebook_action_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Notebook_action_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Notebook_action_constraint.Notebook_action_constraint
    , update_columns : List CdbGQL.Enum.Notebook_action_update_column.Notebook_action_update_column
    }


type alias Notebook_action_on_conflictOptionalFields =
    { where_ : OptionalArgument Notebook_action_bool_exp }


{-| Type alias for the `Notebook_action_on_conflict` attributes. Note that this type
needs to use the `Notebook_action_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_action_on_conflictRaw =
    { constraint : CdbGQL.Enum.Notebook_action_constraint.Notebook_action_constraint
    , update_columns : List CdbGQL.Enum.Notebook_action_update_column.Notebook_action_update_column
    , where_ : OptionalArgument Notebook_action_bool_exp
    }


{-| Type for the Notebook\_action\_on\_conflict input object.
-}
type Notebook_action_on_conflict
    = Notebook_action_on_conflict Notebook_action_on_conflictRaw


{-| Encode a Notebook\_action\_on\_conflict into a value that can be used as an argument.
-}
encodeNotebook_action_on_conflict : Notebook_action_on_conflict -> Value
encodeNotebook_action_on_conflict (Notebook_action_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Notebook_action_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Notebook_action_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeNotebook_action_bool_exp |> Encode.optional input____.where_ ) ]


buildNotebook_action_order_by :
    (Notebook_action_order_byOptionalFields -> Notebook_action_order_byOptionalFields)
    -> Notebook_action_order_by
buildNotebook_action_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { action = Absent, createdAt = Absent, creator = Absent, creatorId = Absent, id = Absent, startingAt = Absent, status = Absent, target = Absent, targetId = Absent, updatedAt = Absent }
    in
    Notebook_action_order_by { action = optionals____.action, createdAt = optionals____.createdAt, creator = optionals____.creator, creatorId = optionals____.creatorId, id = optionals____.id, startingAt = optionals____.startingAt, status = optionals____.status, target = optionals____.target, targetId = optionals____.targetId, updatedAt = optionals____.updatedAt }


type alias Notebook_action_order_byOptionalFields =
    { action : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creator : OptionalArgument Account_order_by
    , creatorId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , startingAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , status : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , target : OptionalArgument Notebook_target_order_by
    , targetId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type alias for the `Notebook_action_order_by` attributes. Note that this type
needs to use the `Notebook_action_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_action_order_byRaw =
    { action : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creator : OptionalArgument Account_order_by
    , creatorId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , startingAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , status : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , target : OptionalArgument Notebook_target_order_by
    , targetId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Notebook\_action\_order\_by input object.
-}
type Notebook_action_order_by
    = Notebook_action_order_by Notebook_action_order_byRaw


{-| Encode a Notebook\_action\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_action_order_by : Notebook_action_order_by -> Value
encodeNotebook_action_order_by (Notebook_action_order_by input____) =
    Encode.maybeObject
        [ ( "action", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.action ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "creator", encodeAccount_order_by |> Encode.optional input____.creator ), ( "creatorId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.creatorId ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "startingAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.startingAt ), ( "status", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.status ), ( "target", encodeNotebook_target_order_by |> Encode.optional input____.target ), ( "targetId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.targetId ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildNotebook_action_pk_columns_input :
    Notebook_action_pk_columns_inputRequiredFields
    -> Notebook_action_pk_columns_input
buildNotebook_action_pk_columns_input required____ =
    { id = required____.id }


type alias Notebook_action_pk_columns_inputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the Notebook\_action\_pk\_columns\_input input object.
-}
type alias Notebook_action_pk_columns_input =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a Notebook\_action\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeNotebook_action_pk_columns_input : Notebook_action_pk_columns_input -> Value
encodeNotebook_action_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildNotebook_action_set_input :
    (Notebook_action_set_inputOptionalFields -> Notebook_action_set_inputOptionalFields)
    -> Notebook_action_set_input
buildNotebook_action_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { action = Absent, createdAt = Absent, creatorId = Absent, id = Absent, startingAt = Absent, status = Absent, targetId = Absent, updatedAt = Absent }
    in
    { action = optionals____.action, createdAt = optionals____.createdAt, creatorId = optionals____.creatorId, id = optionals____.id, startingAt = optionals____.startingAt, status = optionals____.status, targetId = optionals____.targetId, updatedAt = optionals____.updatedAt }


type alias Notebook_action_set_inputOptionalFields =
    { action : OptionalArgument String
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , creatorId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , startingAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , status : OptionalArgument CdbGQL.Enum.Action_status_enum.Action_status_enum
    , targetId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Notebook\_action\_set\_input input object.
-}
type alias Notebook_action_set_input =
    { action : OptionalArgument String
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , creatorId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , startingAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , status : OptionalArgument CdbGQL.Enum.Action_status_enum.Action_status_enum
    , targetId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Notebook\_action\_set\_input into a value that can be used as an argument.
-}
encodeNotebook_action_set_input : Notebook_action_set_input -> Value
encodeNotebook_action_set_input input____ =
    Encode.maybeObject
        [ ( "action", Encode.string |> Encode.optional input____.action ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "creatorId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.creatorId ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "startingAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.startingAt ), ( "status", Encode.enum CdbGQL.Enum.Action_status_enum.toString |> Encode.optional input____.status ), ( "targetId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.targetId ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildNotebook_action_stream_cursor_input :
    Notebook_action_stream_cursor_inputRequiredFields
    -> (Notebook_action_stream_cursor_inputOptionalFields -> Notebook_action_stream_cursor_inputOptionalFields)
    -> Notebook_action_stream_cursor_input
buildNotebook_action_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Notebook_action_stream_cursor_inputRequiredFields =
    { initial_value : Notebook_action_stream_cursor_value_input }


type alias Notebook_action_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Notebook\_action\_stream\_cursor\_input input object.
-}
type alias Notebook_action_stream_cursor_input =
    { initial_value : Notebook_action_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Notebook\_action\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeNotebook_action_stream_cursor_input : Notebook_action_stream_cursor_input -> Value
encodeNotebook_action_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeNotebook_action_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildNotebook_action_stream_cursor_value_input :
    (Notebook_action_stream_cursor_value_inputOptionalFields -> Notebook_action_stream_cursor_value_inputOptionalFields)
    -> Notebook_action_stream_cursor_value_input
buildNotebook_action_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { action = Absent, createdAt = Absent, creatorId = Absent, id = Absent, startingAt = Absent, status = Absent, targetId = Absent, updatedAt = Absent }
    in
    { action = optionals____.action, createdAt = optionals____.createdAt, creatorId = optionals____.creatorId, id = optionals____.id, startingAt = optionals____.startingAt, status = optionals____.status, targetId = optionals____.targetId, updatedAt = optionals____.updatedAt }


type alias Notebook_action_stream_cursor_value_inputOptionalFields =
    { action : OptionalArgument String
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , creatorId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , startingAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , status : OptionalArgument CdbGQL.Enum.Action_status_enum.Action_status_enum
    , targetId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Notebook\_action\_stream\_cursor\_value\_input input object.
-}
type alias Notebook_action_stream_cursor_value_input =
    { action : OptionalArgument String
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , creatorId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , startingAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , status : OptionalArgument CdbGQL.Enum.Action_status_enum.Action_status_enum
    , targetId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Notebook\_action\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeNotebook_action_stream_cursor_value_input : Notebook_action_stream_cursor_value_input -> Value
encodeNotebook_action_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "action", Encode.string |> Encode.optional input____.action ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "creatorId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.creatorId ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "startingAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.startingAt ), ( "status", Encode.enum CdbGQL.Enum.Action_status_enum.toString |> Encode.optional input____.status ), ( "targetId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.targetId ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildNotebook_action_updates :
    Notebook_action_updatesRequiredFields
    -> (Notebook_action_updatesOptionalFields -> Notebook_action_updatesOptionalFields)
    -> Notebook_action_updates
buildNotebook_action_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Notebook_action_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Notebook_action_updatesRequiredFields =
    { where_ : Notebook_action_bool_exp }


type alias Notebook_action_updatesOptionalFields =
    { set_ : OptionalArgument Notebook_action_set_input }


{-| Type alias for the `Notebook_action_updates` attributes. Note that this type
needs to use the `Notebook_action_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_action_updatesRaw =
    { set_ : OptionalArgument Notebook_action_set_input
    , where_ : Notebook_action_bool_exp
    }


{-| Type for the Notebook\_action\_updates input object.
-}
type Notebook_action_updates
    = Notebook_action_updates Notebook_action_updatesRaw


{-| Encode a Notebook\_action\_updates into a value that can be used as an argument.
-}
encodeNotebook_action_updates : Notebook_action_updates -> Value
encodeNotebook_action_updates (Notebook_action_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeNotebook_action_set_input |> Encode.optional input____.set_ ), ( "where", encodeNotebook_action_bool_exp input____.where_ |> Just ) ]


buildNotebook_appointment_aggregate_bool_exp :
    (Notebook_appointment_aggregate_bool_expOptionalFields -> Notebook_appointment_aggregate_bool_expOptionalFields)
    -> Notebook_appointment_aggregate_bool_exp
buildNotebook_appointment_aggregate_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent }
    in
    Notebook_appointment_aggregate_bool_exp { count = optionals____.count }


type alias Notebook_appointment_aggregate_bool_expOptionalFields =
    { count : OptionalArgument Notebook_appointment_aggregate_bool_exp_count }


{-| Type alias for the `Notebook_appointment_aggregate_bool_exp` attributes. Note that this type
needs to use the `Notebook_appointment_aggregate_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_appointment_aggregate_bool_expRaw =
    { count : OptionalArgument Notebook_appointment_aggregate_bool_exp_count }


{-| Type for the Notebook\_appointment\_aggregate\_bool\_exp input object.
-}
type Notebook_appointment_aggregate_bool_exp
    = Notebook_appointment_aggregate_bool_exp Notebook_appointment_aggregate_bool_expRaw


{-| Encode a Notebook\_appointment\_aggregate\_bool\_exp into a value that can be used as an argument.
-}
encodeNotebook_appointment_aggregate_bool_exp : Notebook_appointment_aggregate_bool_exp -> Value
encodeNotebook_appointment_aggregate_bool_exp (Notebook_appointment_aggregate_bool_exp input____) =
    Encode.maybeObject
        [ ( "count", encodeNotebook_appointment_aggregate_bool_exp_count |> Encode.optional input____.count ) ]


buildNotebook_appointment_aggregate_bool_exp_count :
    Notebook_appointment_aggregate_bool_exp_countRequiredFields
    -> (Notebook_appointment_aggregate_bool_exp_countOptionalFields -> Notebook_appointment_aggregate_bool_exp_countOptionalFields)
    -> Notebook_appointment_aggregate_bool_exp_count
buildNotebook_appointment_aggregate_bool_exp_count required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { arguments = Absent, distinct = Absent, filter = Absent }
    in
    Notebook_appointment_aggregate_bool_exp_count { arguments = optionals____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Notebook_appointment_aggregate_bool_exp_countRequiredFields =
    { predicate : Int_comparison_exp }


type alias Notebook_appointment_aggregate_bool_exp_countOptionalFields =
    { arguments : OptionalArgument (List CdbGQL.Enum.Notebook_appointment_select_column.Notebook_appointment_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Notebook_appointment_bool_exp
    }


{-| Type alias for the `Notebook_appointment_aggregate_bool_exp_count` attributes. Note that this type
needs to use the `Notebook_appointment_aggregate_bool_exp_count` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_appointment_aggregate_bool_exp_countRaw =
    { arguments : OptionalArgument (List CdbGQL.Enum.Notebook_appointment_select_column.Notebook_appointment_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Notebook_appointment_bool_exp
    , predicate : Int_comparison_exp
    }


{-| Type for the Notebook\_appointment\_aggregate\_bool\_exp\_count input object.
-}
type Notebook_appointment_aggregate_bool_exp_count
    = Notebook_appointment_aggregate_bool_exp_count Notebook_appointment_aggregate_bool_exp_countRaw


{-| Encode a Notebook\_appointment\_aggregate\_bool\_exp\_count into a value that can be used as an argument.
-}
encodeNotebook_appointment_aggregate_bool_exp_count : Notebook_appointment_aggregate_bool_exp_count -> Value
encodeNotebook_appointment_aggregate_bool_exp_count (Notebook_appointment_aggregate_bool_exp_count input____) =
    Encode.maybeObject
        [ ( "arguments", (Encode.enum CdbGQL.Enum.Notebook_appointment_select_column.toString |> Encode.list) |> Encode.optional input____.arguments ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeNotebook_appointment_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeInt_comparison_exp input____.predicate |> Just ) ]


buildNotebook_appointment_aggregate_order_by :
    (Notebook_appointment_aggregate_order_byOptionalFields -> Notebook_appointment_aggregate_order_byOptionalFields)
    -> Notebook_appointment_aggregate_order_by
buildNotebook_appointment_aggregate_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals____.count, max = optionals____.max, min = optionals____.min }


type alias Notebook_appointment_aggregate_order_byOptionalFields =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Notebook_appointment_max_order_by
    , min : OptionalArgument Notebook_appointment_min_order_by
    }


{-| Type for the Notebook\_appointment\_aggregate\_order\_by input object.
-}
type alias Notebook_appointment_aggregate_order_by =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Notebook_appointment_max_order_by
    , min : OptionalArgument Notebook_appointment_min_order_by
    }


{-| Encode a Notebook\_appointment\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_appointment_aggregate_order_by : Notebook_appointment_aggregate_order_by -> Value
encodeNotebook_appointment_aggregate_order_by input____ =
    Encode.maybeObject
        [ ( "count", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.count ), ( "max", encodeNotebook_appointment_max_order_by |> Encode.optional input____.max ), ( "min", encodeNotebook_appointment_min_order_by |> Encode.optional input____.min ) ]


buildNotebook_appointment_arr_rel_insert_input :
    Notebook_appointment_arr_rel_insert_inputRequiredFields
    -> (Notebook_appointment_arr_rel_insert_inputOptionalFields -> Notebook_appointment_arr_rel_insert_inputOptionalFields)
    -> Notebook_appointment_arr_rel_insert_input
buildNotebook_appointment_arr_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Notebook_appointment_arr_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Notebook_appointment_arr_rel_insert_inputRequiredFields =
    { data : List Notebook_appointment_insert_input }


type alias Notebook_appointment_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Notebook_appointment_on_conflict }


{-| Type alias for the `Notebook_appointment_arr_rel_insert_input` attributes. Note that this type
needs to use the `Notebook_appointment_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_appointment_arr_rel_insert_inputRaw =
    { data : List Notebook_appointment_insert_input
    , on_conflict : OptionalArgument Notebook_appointment_on_conflict
    }


{-| Type for the Notebook\_appointment\_arr\_rel\_insert\_input input object.
-}
type Notebook_appointment_arr_rel_insert_input
    = Notebook_appointment_arr_rel_insert_input Notebook_appointment_arr_rel_insert_inputRaw


{-| Encode a Notebook\_appointment\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeNotebook_appointment_arr_rel_insert_input : Notebook_appointment_arr_rel_insert_input -> Value
encodeNotebook_appointment_arr_rel_insert_input (Notebook_appointment_arr_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", (encodeNotebook_appointment_insert_input |> Encode.list) input____.data |> Just ), ( "on_conflict", encodeNotebook_appointment_on_conflict |> Encode.optional input____.on_conflict ) ]


buildNotebook_appointment_bool_exp :
    (Notebook_appointment_bool_expOptionalFields -> Notebook_appointment_bool_expOptionalFields)
    -> Notebook_appointment_bool_exp
buildNotebook_appointment_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, account = Absent, accountByDeletedBy = Absent, created_at = Absent, date = Absent, deleted_at = Absent, deleted_by = Absent, id = Absent, memberAccountId = Absent, notebook = Absent, notebookId = Absent, status = Absent, updated_at = Absent }
    in
    Notebook_appointment_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, account = optionals____.account, accountByDeletedBy = optionals____.accountByDeletedBy, created_at = optionals____.created_at, date = optionals____.date, deleted_at = optionals____.deleted_at, deleted_by = optionals____.deleted_by, id = optionals____.id, memberAccountId = optionals____.memberAccountId, notebook = optionals____.notebook, notebookId = optionals____.notebookId, status = optionals____.status, updated_at = optionals____.updated_at }


type alias Notebook_appointment_bool_expOptionalFields =
    { and_ : OptionalArgument (List Notebook_appointment_bool_exp)
    , not_ : OptionalArgument Notebook_appointment_bool_exp
    , or_ : OptionalArgument (List Notebook_appointment_bool_exp)
    , account : OptionalArgument Account_bool_exp
    , accountByDeletedBy : OptionalArgument Account_bool_exp
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , date : OptionalArgument Timestamp_comparison_exp
    , deleted_at : OptionalArgument Timestamptz_comparison_exp
    , deleted_by : OptionalArgument Uuid_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , memberAccountId : OptionalArgument Uuid_comparison_exp
    , notebook : OptionalArgument Notebook_bool_exp
    , notebookId : OptionalArgument Uuid_comparison_exp
    , status : OptionalArgument String_comparison_exp
    , updated_at : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type alias for the `Notebook_appointment_bool_exp` attributes. Note that this type
needs to use the `Notebook_appointment_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_appointment_bool_expRaw =
    { and_ : OptionalArgument (List Notebook_appointment_bool_exp)
    , not_ : OptionalArgument Notebook_appointment_bool_exp
    , or_ : OptionalArgument (List Notebook_appointment_bool_exp)
    , account : OptionalArgument Account_bool_exp
    , accountByDeletedBy : OptionalArgument Account_bool_exp
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , date : OptionalArgument Timestamp_comparison_exp
    , deleted_at : OptionalArgument Timestamptz_comparison_exp
    , deleted_by : OptionalArgument Uuid_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , memberAccountId : OptionalArgument Uuid_comparison_exp
    , notebook : OptionalArgument Notebook_bool_exp
    , notebookId : OptionalArgument Uuid_comparison_exp
    , status : OptionalArgument String_comparison_exp
    , updated_at : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type for the Notebook\_appointment\_bool\_exp input object.
-}
type Notebook_appointment_bool_exp
    = Notebook_appointment_bool_exp Notebook_appointment_bool_expRaw


{-| Encode a Notebook\_appointment\_bool\_exp into a value that can be used as an argument.
-}
encodeNotebook_appointment_bool_exp : Notebook_appointment_bool_exp -> Value
encodeNotebook_appointment_bool_exp (Notebook_appointment_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeNotebook_appointment_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeNotebook_appointment_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeNotebook_appointment_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "account", encodeAccount_bool_exp |> Encode.optional input____.account ), ( "accountByDeletedBy", encodeAccount_bool_exp |> Encode.optional input____.accountByDeletedBy ), ( "created_at", encodeTimestamptz_comparison_exp |> Encode.optional input____.created_at ), ( "date", encodeTimestamp_comparison_exp |> Encode.optional input____.date ), ( "deleted_at", encodeTimestamptz_comparison_exp |> Encode.optional input____.deleted_at ), ( "deleted_by", encodeUuid_comparison_exp |> Encode.optional input____.deleted_by ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "memberAccountId", encodeUuid_comparison_exp |> Encode.optional input____.memberAccountId ), ( "notebook", encodeNotebook_bool_exp |> Encode.optional input____.notebook ), ( "notebookId", encodeUuid_comparison_exp |> Encode.optional input____.notebookId ), ( "status", encodeString_comparison_exp |> Encode.optional input____.status ), ( "updated_at", encodeTimestamptz_comparison_exp |> Encode.optional input____.updated_at ) ]


buildNotebook_appointment_insert_input :
    (Notebook_appointment_insert_inputOptionalFields -> Notebook_appointment_insert_inputOptionalFields)
    -> Notebook_appointment_insert_input
buildNotebook_appointment_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { account = Absent, accountByDeletedBy = Absent, created_at = Absent, date = Absent, deleted_at = Absent, deleted_by = Absent, id = Absent, memberAccountId = Absent, notebook = Absent, notebookId = Absent, status = Absent, updated_at = Absent }
    in
    Notebook_appointment_insert_input { account = optionals____.account, accountByDeletedBy = optionals____.accountByDeletedBy, created_at = optionals____.created_at, date = optionals____.date, deleted_at = optionals____.deleted_at, deleted_by = optionals____.deleted_by, id = optionals____.id, memberAccountId = optionals____.memberAccountId, notebook = optionals____.notebook, notebookId = optionals____.notebookId, status = optionals____.status, updated_at = optionals____.updated_at }


type alias Notebook_appointment_insert_inputOptionalFields =
    { account : OptionalArgument Account_obj_rel_insert_input
    , accountByDeletedBy : OptionalArgument Account_obj_rel_insert_input
    , created_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , date : OptionalArgument CdbGQL.ScalarCodecs.Timestamp
    , deleted_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deleted_by : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , memberAccountId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , notebook : OptionalArgument Notebook_obj_rel_insert_input
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , status : OptionalArgument String
    , updated_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type alias for the `Notebook_appointment_insert_input` attributes. Note that this type
needs to use the `Notebook_appointment_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_appointment_insert_inputRaw =
    { account : OptionalArgument Account_obj_rel_insert_input
    , accountByDeletedBy : OptionalArgument Account_obj_rel_insert_input
    , created_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , date : OptionalArgument CdbGQL.ScalarCodecs.Timestamp
    , deleted_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deleted_by : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , memberAccountId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , notebook : OptionalArgument Notebook_obj_rel_insert_input
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , status : OptionalArgument String
    , updated_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Notebook\_appointment\_insert\_input input object.
-}
type Notebook_appointment_insert_input
    = Notebook_appointment_insert_input Notebook_appointment_insert_inputRaw


{-| Encode a Notebook\_appointment\_insert\_input into a value that can be used as an argument.
-}
encodeNotebook_appointment_insert_input : Notebook_appointment_insert_input -> Value
encodeNotebook_appointment_insert_input (Notebook_appointment_insert_input input____) =
    Encode.maybeObject
        [ ( "account", encodeAccount_obj_rel_insert_input |> Encode.optional input____.account ), ( "accountByDeletedBy", encodeAccount_obj_rel_insert_input |> Encode.optional input____.accountByDeletedBy ), ( "created_at", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.created_at ), ( "date", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamp) |> Encode.optional input____.date ), ( "deleted_at", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.deleted_at ), ( "deleted_by", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.deleted_by ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "memberAccountId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.memberAccountId ), ( "notebook", encodeNotebook_obj_rel_insert_input |> Encode.optional input____.notebook ), ( "notebookId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.notebookId ), ( "status", Encode.string |> Encode.optional input____.status ), ( "updated_at", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updated_at ) ]


buildNotebook_appointment_max_order_by :
    (Notebook_appointment_max_order_byOptionalFields -> Notebook_appointment_max_order_byOptionalFields)
    -> Notebook_appointment_max_order_by
buildNotebook_appointment_max_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { created_at = Absent, date = Absent, deleted_at = Absent, deleted_by = Absent, id = Absent, memberAccountId = Absent, notebookId = Absent, status = Absent, updated_at = Absent }
    in
    { created_at = optionals____.created_at, date = optionals____.date, deleted_at = optionals____.deleted_at, deleted_by = optionals____.deleted_by, id = optionals____.id, memberAccountId = optionals____.memberAccountId, notebookId = optionals____.notebookId, status = optionals____.status, updated_at = optionals____.updated_at }


type alias Notebook_appointment_max_order_byOptionalFields =
    { created_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , date : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deleted_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deleted_by : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , memberAccountId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , status : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updated_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Notebook\_appointment\_max\_order\_by input object.
-}
type alias Notebook_appointment_max_order_by =
    { created_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , date : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deleted_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deleted_by : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , memberAccountId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , status : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updated_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Notebook\_appointment\_max\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_appointment_max_order_by : Notebook_appointment_max_order_by -> Value
encodeNotebook_appointment_max_order_by input____ =
    Encode.maybeObject
        [ ( "created_at", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.created_at ), ( "date", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.date ), ( "deleted_at", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deleted_at ), ( "deleted_by", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deleted_by ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "memberAccountId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.memberAccountId ), ( "notebookId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.notebookId ), ( "status", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.status ), ( "updated_at", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updated_at ) ]


buildNotebook_appointment_min_order_by :
    (Notebook_appointment_min_order_byOptionalFields -> Notebook_appointment_min_order_byOptionalFields)
    -> Notebook_appointment_min_order_by
buildNotebook_appointment_min_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { created_at = Absent, date = Absent, deleted_at = Absent, deleted_by = Absent, id = Absent, memberAccountId = Absent, notebookId = Absent, status = Absent, updated_at = Absent }
    in
    { created_at = optionals____.created_at, date = optionals____.date, deleted_at = optionals____.deleted_at, deleted_by = optionals____.deleted_by, id = optionals____.id, memberAccountId = optionals____.memberAccountId, notebookId = optionals____.notebookId, status = optionals____.status, updated_at = optionals____.updated_at }


type alias Notebook_appointment_min_order_byOptionalFields =
    { created_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , date : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deleted_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deleted_by : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , memberAccountId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , status : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updated_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Notebook\_appointment\_min\_order\_by input object.
-}
type alias Notebook_appointment_min_order_by =
    { created_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , date : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deleted_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deleted_by : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , memberAccountId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , status : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updated_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Notebook\_appointment\_min\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_appointment_min_order_by : Notebook_appointment_min_order_by -> Value
encodeNotebook_appointment_min_order_by input____ =
    Encode.maybeObject
        [ ( "created_at", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.created_at ), ( "date", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.date ), ( "deleted_at", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deleted_at ), ( "deleted_by", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deleted_by ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "memberAccountId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.memberAccountId ), ( "notebookId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.notebookId ), ( "status", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.status ), ( "updated_at", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updated_at ) ]


buildNotebook_appointment_on_conflict :
    Notebook_appointment_on_conflictRequiredFields
    -> (Notebook_appointment_on_conflictOptionalFields -> Notebook_appointment_on_conflictOptionalFields)
    -> Notebook_appointment_on_conflict
buildNotebook_appointment_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Notebook_appointment_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Notebook_appointment_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Notebook_appointment_constraint.Notebook_appointment_constraint
    , update_columns : List CdbGQL.Enum.Notebook_appointment_update_column.Notebook_appointment_update_column
    }


type alias Notebook_appointment_on_conflictOptionalFields =
    { where_ : OptionalArgument Notebook_appointment_bool_exp }


{-| Type alias for the `Notebook_appointment_on_conflict` attributes. Note that this type
needs to use the `Notebook_appointment_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_appointment_on_conflictRaw =
    { constraint : CdbGQL.Enum.Notebook_appointment_constraint.Notebook_appointment_constraint
    , update_columns : List CdbGQL.Enum.Notebook_appointment_update_column.Notebook_appointment_update_column
    , where_ : OptionalArgument Notebook_appointment_bool_exp
    }


{-| Type for the Notebook\_appointment\_on\_conflict input object.
-}
type Notebook_appointment_on_conflict
    = Notebook_appointment_on_conflict Notebook_appointment_on_conflictRaw


{-| Encode a Notebook\_appointment\_on\_conflict into a value that can be used as an argument.
-}
encodeNotebook_appointment_on_conflict : Notebook_appointment_on_conflict -> Value
encodeNotebook_appointment_on_conflict (Notebook_appointment_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Notebook_appointment_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Notebook_appointment_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeNotebook_appointment_bool_exp |> Encode.optional input____.where_ ) ]


buildNotebook_appointment_order_by :
    (Notebook_appointment_order_byOptionalFields -> Notebook_appointment_order_byOptionalFields)
    -> Notebook_appointment_order_by
buildNotebook_appointment_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { account = Absent, accountByDeletedBy = Absent, created_at = Absent, date = Absent, deleted_at = Absent, deleted_by = Absent, id = Absent, memberAccountId = Absent, notebook = Absent, notebookId = Absent, status = Absent, updated_at = Absent }
    in
    Notebook_appointment_order_by { account = optionals____.account, accountByDeletedBy = optionals____.accountByDeletedBy, created_at = optionals____.created_at, date = optionals____.date, deleted_at = optionals____.deleted_at, deleted_by = optionals____.deleted_by, id = optionals____.id, memberAccountId = optionals____.memberAccountId, notebook = optionals____.notebook, notebookId = optionals____.notebookId, status = optionals____.status, updated_at = optionals____.updated_at }


type alias Notebook_appointment_order_byOptionalFields =
    { account : OptionalArgument Account_order_by
    , accountByDeletedBy : OptionalArgument Account_order_by
    , created_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , date : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deleted_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deleted_by : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , memberAccountId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebook : OptionalArgument Notebook_order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , status : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updated_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type alias for the `Notebook_appointment_order_by` attributes. Note that this type
needs to use the `Notebook_appointment_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_appointment_order_byRaw =
    { account : OptionalArgument Account_order_by
    , accountByDeletedBy : OptionalArgument Account_order_by
    , created_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , date : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deleted_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deleted_by : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , memberAccountId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebook : OptionalArgument Notebook_order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , status : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updated_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Notebook\_appointment\_order\_by input object.
-}
type Notebook_appointment_order_by
    = Notebook_appointment_order_by Notebook_appointment_order_byRaw


{-| Encode a Notebook\_appointment\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_appointment_order_by : Notebook_appointment_order_by -> Value
encodeNotebook_appointment_order_by (Notebook_appointment_order_by input____) =
    Encode.maybeObject
        [ ( "account", encodeAccount_order_by |> Encode.optional input____.account ), ( "accountByDeletedBy", encodeAccount_order_by |> Encode.optional input____.accountByDeletedBy ), ( "created_at", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.created_at ), ( "date", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.date ), ( "deleted_at", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deleted_at ), ( "deleted_by", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deleted_by ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "memberAccountId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.memberAccountId ), ( "notebook", encodeNotebook_order_by |> Encode.optional input____.notebook ), ( "notebookId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.notebookId ), ( "status", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.status ), ( "updated_at", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updated_at ) ]


buildNotebook_appointment_pk_columns_input :
    Notebook_appointment_pk_columns_inputRequiredFields
    -> Notebook_appointment_pk_columns_input
buildNotebook_appointment_pk_columns_input required____ =
    { id = required____.id }


type alias Notebook_appointment_pk_columns_inputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the Notebook\_appointment\_pk\_columns\_input input object.
-}
type alias Notebook_appointment_pk_columns_input =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a Notebook\_appointment\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeNotebook_appointment_pk_columns_input : Notebook_appointment_pk_columns_input -> Value
encodeNotebook_appointment_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildNotebook_appointment_set_input :
    (Notebook_appointment_set_inputOptionalFields -> Notebook_appointment_set_inputOptionalFields)
    -> Notebook_appointment_set_input
buildNotebook_appointment_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { created_at = Absent, date = Absent, deleted_at = Absent, deleted_by = Absent, id = Absent, memberAccountId = Absent, notebookId = Absent, status = Absent, updated_at = Absent }
    in
    { created_at = optionals____.created_at, date = optionals____.date, deleted_at = optionals____.deleted_at, deleted_by = optionals____.deleted_by, id = optionals____.id, memberAccountId = optionals____.memberAccountId, notebookId = optionals____.notebookId, status = optionals____.status, updated_at = optionals____.updated_at }


type alias Notebook_appointment_set_inputOptionalFields =
    { created_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , date : OptionalArgument CdbGQL.ScalarCodecs.Timestamp
    , deleted_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deleted_by : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , memberAccountId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , status : OptionalArgument String
    , updated_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Notebook\_appointment\_set\_input input object.
-}
type alias Notebook_appointment_set_input =
    { created_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , date : OptionalArgument CdbGQL.ScalarCodecs.Timestamp
    , deleted_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deleted_by : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , memberAccountId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , status : OptionalArgument String
    , updated_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Notebook\_appointment\_set\_input into a value that can be used as an argument.
-}
encodeNotebook_appointment_set_input : Notebook_appointment_set_input -> Value
encodeNotebook_appointment_set_input input____ =
    Encode.maybeObject
        [ ( "created_at", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.created_at ), ( "date", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamp) |> Encode.optional input____.date ), ( "deleted_at", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.deleted_at ), ( "deleted_by", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.deleted_by ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "memberAccountId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.memberAccountId ), ( "notebookId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.notebookId ), ( "status", Encode.string |> Encode.optional input____.status ), ( "updated_at", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updated_at ) ]


buildNotebook_appointment_stream_cursor_input :
    Notebook_appointment_stream_cursor_inputRequiredFields
    -> (Notebook_appointment_stream_cursor_inputOptionalFields -> Notebook_appointment_stream_cursor_inputOptionalFields)
    -> Notebook_appointment_stream_cursor_input
buildNotebook_appointment_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Notebook_appointment_stream_cursor_inputRequiredFields =
    { initial_value : Notebook_appointment_stream_cursor_value_input }


type alias Notebook_appointment_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Notebook\_appointment\_stream\_cursor\_input input object.
-}
type alias Notebook_appointment_stream_cursor_input =
    { initial_value : Notebook_appointment_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Notebook\_appointment\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeNotebook_appointment_stream_cursor_input : Notebook_appointment_stream_cursor_input -> Value
encodeNotebook_appointment_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeNotebook_appointment_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildNotebook_appointment_stream_cursor_value_input :
    (Notebook_appointment_stream_cursor_value_inputOptionalFields -> Notebook_appointment_stream_cursor_value_inputOptionalFields)
    -> Notebook_appointment_stream_cursor_value_input
buildNotebook_appointment_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { created_at = Absent, date = Absent, deleted_at = Absent, deleted_by = Absent, id = Absent, memberAccountId = Absent, notebookId = Absent, status = Absent, updated_at = Absent }
    in
    { created_at = optionals____.created_at, date = optionals____.date, deleted_at = optionals____.deleted_at, deleted_by = optionals____.deleted_by, id = optionals____.id, memberAccountId = optionals____.memberAccountId, notebookId = optionals____.notebookId, status = optionals____.status, updated_at = optionals____.updated_at }


type alias Notebook_appointment_stream_cursor_value_inputOptionalFields =
    { created_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , date : OptionalArgument CdbGQL.ScalarCodecs.Timestamp
    , deleted_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deleted_by : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , memberAccountId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , status : OptionalArgument String
    , updated_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Notebook\_appointment\_stream\_cursor\_value\_input input object.
-}
type alias Notebook_appointment_stream_cursor_value_input =
    { created_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , date : OptionalArgument CdbGQL.ScalarCodecs.Timestamp
    , deleted_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deleted_by : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , memberAccountId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , status : OptionalArgument String
    , updated_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Notebook\_appointment\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeNotebook_appointment_stream_cursor_value_input : Notebook_appointment_stream_cursor_value_input -> Value
encodeNotebook_appointment_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "created_at", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.created_at ), ( "date", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamp) |> Encode.optional input____.date ), ( "deleted_at", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.deleted_at ), ( "deleted_by", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.deleted_by ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "memberAccountId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.memberAccountId ), ( "notebookId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.notebookId ), ( "status", Encode.string |> Encode.optional input____.status ), ( "updated_at", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updated_at ) ]


buildNotebook_appointment_updates :
    Notebook_appointment_updatesRequiredFields
    -> (Notebook_appointment_updatesOptionalFields -> Notebook_appointment_updatesOptionalFields)
    -> Notebook_appointment_updates
buildNotebook_appointment_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Notebook_appointment_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Notebook_appointment_updatesRequiredFields =
    { where_ : Notebook_appointment_bool_exp }


type alias Notebook_appointment_updatesOptionalFields =
    { set_ : OptionalArgument Notebook_appointment_set_input }


{-| Type alias for the `Notebook_appointment_updates` attributes. Note that this type
needs to use the `Notebook_appointment_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_appointment_updatesRaw =
    { set_ : OptionalArgument Notebook_appointment_set_input
    , where_ : Notebook_appointment_bool_exp
    }


{-| Type for the Notebook\_appointment\_updates input object.
-}
type Notebook_appointment_updates
    = Notebook_appointment_updates Notebook_appointment_updatesRaw


{-| Encode a Notebook\_appointment\_updates into a value that can be used as an argument.
-}
encodeNotebook_appointment_updates : Notebook_appointment_updates -> Value
encodeNotebook_appointment_updates (Notebook_appointment_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeNotebook_appointment_set_input |> Encode.optional input____.set_ ), ( "where", encodeNotebook_appointment_bool_exp input____.where_ |> Just ) ]


buildNotebook_bool_exp :
    (Notebook_bool_expOptionalFields -> Notebook_bool_expOptionalFields)
    -> Notebook_bool_exp
buildNotebook_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, appointments = Absent, appointments_aggregate = Absent, beneficiary = Absent, beneficiaryId = Absent, contractEndDate = Absent, contractSignDate = Absent, contractStartDate = Absent, contractType = Absent, createdAt = Absent, educationLevel = Absent, events = Absent, events_aggregate = Absent, focuses = Absent, focuses_aggregate = Absent, id = Absent, lastJobEndedAt = Absent, members = Absent, members_aggregate = Absent, notebookInfo = Absent, professionalProjects = Absent, professionalProjects_aggregate = Absent, rightRqth = Absent, situations = Absent, situations_aggregate = Absent, updatedAt = Absent, workSituation = Absent, workSituationDate = Absent, workSituationEndDate = Absent }
    in
    Notebook_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, appointments = optionals____.appointments, appointments_aggregate = optionals____.appointments_aggregate, beneficiary = optionals____.beneficiary, beneficiaryId = optionals____.beneficiaryId, contractEndDate = optionals____.contractEndDate, contractSignDate = optionals____.contractSignDate, contractStartDate = optionals____.contractStartDate, contractType = optionals____.contractType, createdAt = optionals____.createdAt, educationLevel = optionals____.educationLevel, events = optionals____.events, events_aggregate = optionals____.events_aggregate, focuses = optionals____.focuses, focuses_aggregate = optionals____.focuses_aggregate, id = optionals____.id, lastJobEndedAt = optionals____.lastJobEndedAt, members = optionals____.members, members_aggregate = optionals____.members_aggregate, notebookInfo = optionals____.notebookInfo, professionalProjects = optionals____.professionalProjects, professionalProjects_aggregate = optionals____.professionalProjects_aggregate, rightRqth = optionals____.rightRqth, situations = optionals____.situations, situations_aggregate = optionals____.situations_aggregate, updatedAt = optionals____.updatedAt, workSituation = optionals____.workSituation, workSituationDate = optionals____.workSituationDate, workSituationEndDate = optionals____.workSituationEndDate }


type alias Notebook_bool_expOptionalFields =
    { and_ : OptionalArgument (List Notebook_bool_exp)
    , not_ : OptionalArgument Notebook_bool_exp
    , or_ : OptionalArgument (List Notebook_bool_exp)
    , appointments : OptionalArgument Notebook_appointment_bool_exp
    , appointments_aggregate : OptionalArgument Notebook_appointment_aggregate_bool_exp
    , beneficiary : OptionalArgument Beneficiary_bool_exp
    , beneficiaryId : OptionalArgument Uuid_comparison_exp
    , contractEndDate : OptionalArgument Date_comparison_exp
    , contractSignDate : OptionalArgument Date_comparison_exp
    , contractStartDate : OptionalArgument Date_comparison_exp
    , contractType : OptionalArgument String_comparison_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , educationLevel : OptionalArgument String_comparison_exp
    , events : OptionalArgument Notebook_event_bool_exp
    , events_aggregate : OptionalArgument Notebook_event_aggregate_bool_exp
    , focuses : OptionalArgument Notebook_focus_bool_exp
    , focuses_aggregate : OptionalArgument Notebook_focus_aggregate_bool_exp
    , id : OptionalArgument Uuid_comparison_exp
    , lastJobEndedAt : OptionalArgument Date_comparison_exp
    , members : OptionalArgument Notebook_member_bool_exp
    , members_aggregate : OptionalArgument Notebook_member_aggregate_bool_exp
    , notebookInfo : OptionalArgument Notebook_info_bool_exp
    , professionalProjects : OptionalArgument Professional_project_bool_exp
    , professionalProjects_aggregate : OptionalArgument Professional_project_aggregate_bool_exp
    , rightRqth : OptionalArgument Boolean_comparison_exp
    , situations : OptionalArgument Notebook_situation_bool_exp
    , situations_aggregate : OptionalArgument Notebook_situation_aggregate_bool_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    , workSituation : OptionalArgument String_comparison_exp
    , workSituationDate : OptionalArgument Date_comparison_exp
    , workSituationEndDate : OptionalArgument Date_comparison_exp
    }


{-| Type alias for the `Notebook_bool_exp` attributes. Note that this type
needs to use the `Notebook_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_bool_expRaw =
    { and_ : OptionalArgument (List Notebook_bool_exp)
    , not_ : OptionalArgument Notebook_bool_exp
    , or_ : OptionalArgument (List Notebook_bool_exp)
    , appointments : OptionalArgument Notebook_appointment_bool_exp
    , appointments_aggregate : OptionalArgument Notebook_appointment_aggregate_bool_exp
    , beneficiary : OptionalArgument Beneficiary_bool_exp
    , beneficiaryId : OptionalArgument Uuid_comparison_exp
    , contractEndDate : OptionalArgument Date_comparison_exp
    , contractSignDate : OptionalArgument Date_comparison_exp
    , contractStartDate : OptionalArgument Date_comparison_exp
    , contractType : OptionalArgument String_comparison_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , educationLevel : OptionalArgument String_comparison_exp
    , events : OptionalArgument Notebook_event_bool_exp
    , events_aggregate : OptionalArgument Notebook_event_aggregate_bool_exp
    , focuses : OptionalArgument Notebook_focus_bool_exp
    , focuses_aggregate : OptionalArgument Notebook_focus_aggregate_bool_exp
    , id : OptionalArgument Uuid_comparison_exp
    , lastJobEndedAt : OptionalArgument Date_comparison_exp
    , members : OptionalArgument Notebook_member_bool_exp
    , members_aggregate : OptionalArgument Notebook_member_aggregate_bool_exp
    , notebookInfo : OptionalArgument Notebook_info_bool_exp
    , professionalProjects : OptionalArgument Professional_project_bool_exp
    , professionalProjects_aggregate : OptionalArgument Professional_project_aggregate_bool_exp
    , rightRqth : OptionalArgument Boolean_comparison_exp
    , situations : OptionalArgument Notebook_situation_bool_exp
    , situations_aggregate : OptionalArgument Notebook_situation_aggregate_bool_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    , workSituation : OptionalArgument String_comparison_exp
    , workSituationDate : OptionalArgument Date_comparison_exp
    , workSituationEndDate : OptionalArgument Date_comparison_exp
    }


{-| Type for the Notebook\_bool\_exp input object.
-}
type Notebook_bool_exp
    = Notebook_bool_exp Notebook_bool_expRaw


{-| Encode a Notebook\_bool\_exp into a value that can be used as an argument.
-}
encodeNotebook_bool_exp : Notebook_bool_exp -> Value
encodeNotebook_bool_exp (Notebook_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeNotebook_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeNotebook_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeNotebook_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "appointments", encodeNotebook_appointment_bool_exp |> Encode.optional input____.appointments ), ( "appointments_aggregate", encodeNotebook_appointment_aggregate_bool_exp |> Encode.optional input____.appointments_aggregate ), ( "beneficiary", encodeBeneficiary_bool_exp |> Encode.optional input____.beneficiary ), ( "beneficiaryId", encodeUuid_comparison_exp |> Encode.optional input____.beneficiaryId ), ( "contractEndDate", encodeDate_comparison_exp |> Encode.optional input____.contractEndDate ), ( "contractSignDate", encodeDate_comparison_exp |> Encode.optional input____.contractSignDate ), ( "contractStartDate", encodeDate_comparison_exp |> Encode.optional input____.contractStartDate ), ( "contractType", encodeString_comparison_exp |> Encode.optional input____.contractType ), ( "createdAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.createdAt ), ( "educationLevel", encodeString_comparison_exp |> Encode.optional input____.educationLevel ), ( "events", encodeNotebook_event_bool_exp |> Encode.optional input____.events ), ( "events_aggregate", encodeNotebook_event_aggregate_bool_exp |> Encode.optional input____.events_aggregate ), ( "focuses", encodeNotebook_focus_bool_exp |> Encode.optional input____.focuses ), ( "focuses_aggregate", encodeNotebook_focus_aggregate_bool_exp |> Encode.optional input____.focuses_aggregate ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "lastJobEndedAt", encodeDate_comparison_exp |> Encode.optional input____.lastJobEndedAt ), ( "members", encodeNotebook_member_bool_exp |> Encode.optional input____.members ), ( "members_aggregate", encodeNotebook_member_aggregate_bool_exp |> Encode.optional input____.members_aggregate ), ( "notebookInfo", encodeNotebook_info_bool_exp |> Encode.optional input____.notebookInfo ), ( "professionalProjects", encodeProfessional_project_bool_exp |> Encode.optional input____.professionalProjects ), ( "professionalProjects_aggregate", encodeProfessional_project_aggregate_bool_exp |> Encode.optional input____.professionalProjects_aggregate ), ( "rightRqth", encodeBoolean_comparison_exp |> Encode.optional input____.rightRqth ), ( "situations", encodeNotebook_situation_bool_exp |> Encode.optional input____.situations ), ( "situations_aggregate", encodeNotebook_situation_aggregate_bool_exp |> Encode.optional input____.situations_aggregate ), ( "updatedAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.updatedAt ), ( "workSituation", encodeString_comparison_exp |> Encode.optional input____.workSituation ), ( "workSituationDate", encodeDate_comparison_exp |> Encode.optional input____.workSituationDate ), ( "workSituationEndDate", encodeDate_comparison_exp |> Encode.optional input____.workSituationEndDate ) ]


buildNotebook_event_aggregate_bool_exp :
    (Notebook_event_aggregate_bool_expOptionalFields -> Notebook_event_aggregate_bool_expOptionalFields)
    -> Notebook_event_aggregate_bool_exp
buildNotebook_event_aggregate_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent }
    in
    Notebook_event_aggregate_bool_exp { count = optionals____.count }


type alias Notebook_event_aggregate_bool_expOptionalFields =
    { count : OptionalArgument Notebook_event_aggregate_bool_exp_count }


{-| Type alias for the `Notebook_event_aggregate_bool_exp` attributes. Note that this type
needs to use the `Notebook_event_aggregate_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_event_aggregate_bool_expRaw =
    { count : OptionalArgument Notebook_event_aggregate_bool_exp_count }


{-| Type for the Notebook\_event\_aggregate\_bool\_exp input object.
-}
type Notebook_event_aggregate_bool_exp
    = Notebook_event_aggregate_bool_exp Notebook_event_aggregate_bool_expRaw


{-| Encode a Notebook\_event\_aggregate\_bool\_exp into a value that can be used as an argument.
-}
encodeNotebook_event_aggregate_bool_exp : Notebook_event_aggregate_bool_exp -> Value
encodeNotebook_event_aggregate_bool_exp (Notebook_event_aggregate_bool_exp input____) =
    Encode.maybeObject
        [ ( "count", encodeNotebook_event_aggregate_bool_exp_count |> Encode.optional input____.count ) ]


buildNotebook_event_aggregate_bool_exp_count :
    Notebook_event_aggregate_bool_exp_countRequiredFields
    -> (Notebook_event_aggregate_bool_exp_countOptionalFields -> Notebook_event_aggregate_bool_exp_countOptionalFields)
    -> Notebook_event_aggregate_bool_exp_count
buildNotebook_event_aggregate_bool_exp_count required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { arguments = Absent, distinct = Absent, filter = Absent }
    in
    Notebook_event_aggregate_bool_exp_count { arguments = optionals____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Notebook_event_aggregate_bool_exp_countRequiredFields =
    { predicate : Int_comparison_exp }


type alias Notebook_event_aggregate_bool_exp_countOptionalFields =
    { arguments : OptionalArgument (List CdbGQL.Enum.Notebook_event_select_column.Notebook_event_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Notebook_event_bool_exp
    }


{-| Type alias for the `Notebook_event_aggregate_bool_exp_count` attributes. Note that this type
needs to use the `Notebook_event_aggregate_bool_exp_count` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_event_aggregate_bool_exp_countRaw =
    { arguments : OptionalArgument (List CdbGQL.Enum.Notebook_event_select_column.Notebook_event_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Notebook_event_bool_exp
    , predicate : Int_comparison_exp
    }


{-| Type for the Notebook\_event\_aggregate\_bool\_exp\_count input object.
-}
type Notebook_event_aggregate_bool_exp_count
    = Notebook_event_aggregate_bool_exp_count Notebook_event_aggregate_bool_exp_countRaw


{-| Encode a Notebook\_event\_aggregate\_bool\_exp\_count into a value that can be used as an argument.
-}
encodeNotebook_event_aggregate_bool_exp_count : Notebook_event_aggregate_bool_exp_count -> Value
encodeNotebook_event_aggregate_bool_exp_count (Notebook_event_aggregate_bool_exp_count input____) =
    Encode.maybeObject
        [ ( "arguments", (Encode.enum CdbGQL.Enum.Notebook_event_select_column.toString |> Encode.list) |> Encode.optional input____.arguments ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeNotebook_event_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeInt_comparison_exp input____.predicate |> Just ) ]


buildNotebook_event_aggregate_order_by :
    (Notebook_event_aggregate_order_byOptionalFields -> Notebook_event_aggregate_order_byOptionalFields)
    -> Notebook_event_aggregate_order_by
buildNotebook_event_aggregate_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals____.count, max = optionals____.max, min = optionals____.min }


type alias Notebook_event_aggregate_order_byOptionalFields =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Notebook_event_max_order_by
    , min : OptionalArgument Notebook_event_min_order_by
    }


{-| Type for the Notebook\_event\_aggregate\_order\_by input object.
-}
type alias Notebook_event_aggregate_order_by =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Notebook_event_max_order_by
    , min : OptionalArgument Notebook_event_min_order_by
    }


{-| Encode a Notebook\_event\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_event_aggregate_order_by : Notebook_event_aggregate_order_by -> Value
encodeNotebook_event_aggregate_order_by input____ =
    Encode.maybeObject
        [ ( "count", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.count ), ( "max", encodeNotebook_event_max_order_by |> Encode.optional input____.max ), ( "min", encodeNotebook_event_min_order_by |> Encode.optional input____.min ) ]


buildNotebook_event_append_input :
    (Notebook_event_append_inputOptionalFields -> Notebook_event_append_inputOptionalFields)
    -> Notebook_event_append_input
buildNotebook_event_append_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { event = Absent }
    in
    { event = optionals____.event }


type alias Notebook_event_append_inputOptionalFields =
    { event : OptionalArgument CdbGQL.ScalarCodecs.Jsonb }


{-| Type for the Notebook\_event\_append\_input input object.
-}
type alias Notebook_event_append_input =
    { event : OptionalArgument CdbGQL.ScalarCodecs.Jsonb }


{-| Encode a Notebook\_event\_append\_input into a value that can be used as an argument.
-}
encodeNotebook_event_append_input : Notebook_event_append_input -> Value
encodeNotebook_event_append_input input____ =
    Encode.maybeObject
        [ ( "event", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input____.event ) ]


buildNotebook_event_arr_rel_insert_input :
    Notebook_event_arr_rel_insert_inputRequiredFields
    -> (Notebook_event_arr_rel_insert_inputOptionalFields -> Notebook_event_arr_rel_insert_inputOptionalFields)
    -> Notebook_event_arr_rel_insert_input
buildNotebook_event_arr_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Notebook_event_arr_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Notebook_event_arr_rel_insert_inputRequiredFields =
    { data : List Notebook_event_insert_input }


type alias Notebook_event_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Notebook_event_on_conflict }


{-| Type alias for the `Notebook_event_arr_rel_insert_input` attributes. Note that this type
needs to use the `Notebook_event_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_event_arr_rel_insert_inputRaw =
    { data : List Notebook_event_insert_input
    , on_conflict : OptionalArgument Notebook_event_on_conflict
    }


{-| Type for the Notebook\_event\_arr\_rel\_insert\_input input object.
-}
type Notebook_event_arr_rel_insert_input
    = Notebook_event_arr_rel_insert_input Notebook_event_arr_rel_insert_inputRaw


{-| Encode a Notebook\_event\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeNotebook_event_arr_rel_insert_input : Notebook_event_arr_rel_insert_input -> Value
encodeNotebook_event_arr_rel_insert_input (Notebook_event_arr_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", (encodeNotebook_event_insert_input |> Encode.list) input____.data |> Just ), ( "on_conflict", encodeNotebook_event_on_conflict |> Encode.optional input____.on_conflict ) ]


buildNotebook_event_bool_exp :
    (Notebook_event_bool_expOptionalFields -> Notebook_event_bool_expOptionalFields)
    -> Notebook_event_bool_exp
buildNotebook_event_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, creationDate = Absent, creator = Absent, creatorId = Absent, event = Absent, eventDate = Absent, eventType = Absent, id = Absent, notebook = Absent, notebookId = Absent, notebook_event_type = Absent }
    in
    Notebook_event_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, creationDate = optionals____.creationDate, creator = optionals____.creator, creatorId = optionals____.creatorId, event = optionals____.event, eventDate = optionals____.eventDate, eventType = optionals____.eventType, id = optionals____.id, notebook = optionals____.notebook, notebookId = optionals____.notebookId, notebook_event_type = optionals____.notebook_event_type }


type alias Notebook_event_bool_expOptionalFields =
    { and_ : OptionalArgument (List Notebook_event_bool_exp)
    , not_ : OptionalArgument Notebook_event_bool_exp
    , or_ : OptionalArgument (List Notebook_event_bool_exp)
    , creationDate : OptionalArgument Timestamptz_comparison_exp
    , creator : OptionalArgument Account_bool_exp
    , creatorId : OptionalArgument Uuid_comparison_exp
    , event : OptionalArgument Jsonb_comparison_exp
    , eventDate : OptionalArgument Timestamptz_comparison_exp
    , eventType : OptionalArgument Notebook_event_type_enum_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , notebook : OptionalArgument Notebook_bool_exp
    , notebookId : OptionalArgument Uuid_comparison_exp
    , notebook_event_type : OptionalArgument Notebook_event_type_bool_exp
    }


{-| Type alias for the `Notebook_event_bool_exp` attributes. Note that this type
needs to use the `Notebook_event_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_event_bool_expRaw =
    { and_ : OptionalArgument (List Notebook_event_bool_exp)
    , not_ : OptionalArgument Notebook_event_bool_exp
    , or_ : OptionalArgument (List Notebook_event_bool_exp)
    , creationDate : OptionalArgument Timestamptz_comparison_exp
    , creator : OptionalArgument Account_bool_exp
    , creatorId : OptionalArgument Uuid_comparison_exp
    , event : OptionalArgument Jsonb_comparison_exp
    , eventDate : OptionalArgument Timestamptz_comparison_exp
    , eventType : OptionalArgument Notebook_event_type_enum_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , notebook : OptionalArgument Notebook_bool_exp
    , notebookId : OptionalArgument Uuid_comparison_exp
    , notebook_event_type : OptionalArgument Notebook_event_type_bool_exp
    }


{-| Type for the Notebook\_event\_bool\_exp input object.
-}
type Notebook_event_bool_exp
    = Notebook_event_bool_exp Notebook_event_bool_expRaw


{-| Encode a Notebook\_event\_bool\_exp into a value that can be used as an argument.
-}
encodeNotebook_event_bool_exp : Notebook_event_bool_exp -> Value
encodeNotebook_event_bool_exp (Notebook_event_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeNotebook_event_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeNotebook_event_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeNotebook_event_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "creationDate", encodeTimestamptz_comparison_exp |> Encode.optional input____.creationDate ), ( "creator", encodeAccount_bool_exp |> Encode.optional input____.creator ), ( "creatorId", encodeUuid_comparison_exp |> Encode.optional input____.creatorId ), ( "event", encodeJsonb_comparison_exp |> Encode.optional input____.event ), ( "eventDate", encodeTimestamptz_comparison_exp |> Encode.optional input____.eventDate ), ( "eventType", encodeNotebook_event_type_enum_comparison_exp |> Encode.optional input____.eventType ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "notebook", encodeNotebook_bool_exp |> Encode.optional input____.notebook ), ( "notebookId", encodeUuid_comparison_exp |> Encode.optional input____.notebookId ), ( "notebook_event_type", encodeNotebook_event_type_bool_exp |> Encode.optional input____.notebook_event_type ) ]


buildNotebook_event_delete_at_path_input :
    (Notebook_event_delete_at_path_inputOptionalFields -> Notebook_event_delete_at_path_inputOptionalFields)
    -> Notebook_event_delete_at_path_input
buildNotebook_event_delete_at_path_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { event = Absent }
    in
    { event = optionals____.event }


type alias Notebook_event_delete_at_path_inputOptionalFields =
    { event : OptionalArgument (List String) }


{-| Type for the Notebook\_event\_delete\_at\_path\_input input object.
-}
type alias Notebook_event_delete_at_path_input =
    { event : OptionalArgument (List String) }


{-| Encode a Notebook\_event\_delete\_at\_path\_input into a value that can be used as an argument.
-}
encodeNotebook_event_delete_at_path_input : Notebook_event_delete_at_path_input -> Value
encodeNotebook_event_delete_at_path_input input____ =
    Encode.maybeObject
        [ ( "event", (Encode.string |> Encode.list) |> Encode.optional input____.event ) ]


buildNotebook_event_delete_elem_input :
    (Notebook_event_delete_elem_inputOptionalFields -> Notebook_event_delete_elem_inputOptionalFields)
    -> Notebook_event_delete_elem_input
buildNotebook_event_delete_elem_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { event = Absent }
    in
    { event = optionals____.event }


type alias Notebook_event_delete_elem_inputOptionalFields =
    { event : OptionalArgument Int }


{-| Type for the Notebook\_event\_delete\_elem\_input input object.
-}
type alias Notebook_event_delete_elem_input =
    { event : OptionalArgument Int }


{-| Encode a Notebook\_event\_delete\_elem\_input into a value that can be used as an argument.
-}
encodeNotebook_event_delete_elem_input : Notebook_event_delete_elem_input -> Value
encodeNotebook_event_delete_elem_input input____ =
    Encode.maybeObject
        [ ( "event", Encode.int |> Encode.optional input____.event ) ]


buildNotebook_event_delete_key_input :
    (Notebook_event_delete_key_inputOptionalFields -> Notebook_event_delete_key_inputOptionalFields)
    -> Notebook_event_delete_key_input
buildNotebook_event_delete_key_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { event = Absent }
    in
    { event = optionals____.event }


type alias Notebook_event_delete_key_inputOptionalFields =
    { event : OptionalArgument String }


{-| Type for the Notebook\_event\_delete\_key\_input input object.
-}
type alias Notebook_event_delete_key_input =
    { event : OptionalArgument String }


{-| Encode a Notebook\_event\_delete\_key\_input into a value that can be used as an argument.
-}
encodeNotebook_event_delete_key_input : Notebook_event_delete_key_input -> Value
encodeNotebook_event_delete_key_input input____ =
    Encode.maybeObject
        [ ( "event", Encode.string |> Encode.optional input____.event ) ]


buildNotebook_event_insert_input :
    (Notebook_event_insert_inputOptionalFields -> Notebook_event_insert_inputOptionalFields)
    -> Notebook_event_insert_input
buildNotebook_event_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { creationDate = Absent, creator = Absent, creatorId = Absent, event = Absent, eventDate = Absent, eventType = Absent, id = Absent, notebook = Absent, notebookId = Absent, notebook_event_type = Absent }
    in
    Notebook_event_insert_input { creationDate = optionals____.creationDate, creator = optionals____.creator, creatorId = optionals____.creatorId, event = optionals____.event, eventDate = optionals____.eventDate, eventType = optionals____.eventType, id = optionals____.id, notebook = optionals____.notebook, notebookId = optionals____.notebookId, notebook_event_type = optionals____.notebook_event_type }


type alias Notebook_event_insert_inputOptionalFields =
    { creationDate : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , creator : OptionalArgument Account_obj_rel_insert_input
    , creatorId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , event : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , eventDate : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , eventType : OptionalArgument CdbGQL.Enum.Notebook_event_type_enum.Notebook_event_type_enum
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , notebook : OptionalArgument Notebook_obj_rel_insert_input
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , notebook_event_type : OptionalArgument Notebook_event_type_obj_rel_insert_input
    }


{-| Type alias for the `Notebook_event_insert_input` attributes. Note that this type
needs to use the `Notebook_event_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_event_insert_inputRaw =
    { creationDate : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , creator : OptionalArgument Account_obj_rel_insert_input
    , creatorId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , event : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , eventDate : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , eventType : OptionalArgument CdbGQL.Enum.Notebook_event_type_enum.Notebook_event_type_enum
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , notebook : OptionalArgument Notebook_obj_rel_insert_input
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , notebook_event_type : OptionalArgument Notebook_event_type_obj_rel_insert_input
    }


{-| Type for the Notebook\_event\_insert\_input input object.
-}
type Notebook_event_insert_input
    = Notebook_event_insert_input Notebook_event_insert_inputRaw


{-| Encode a Notebook\_event\_insert\_input into a value that can be used as an argument.
-}
encodeNotebook_event_insert_input : Notebook_event_insert_input -> Value
encodeNotebook_event_insert_input (Notebook_event_insert_input input____) =
    Encode.maybeObject
        [ ( "creationDate", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.creationDate ), ( "creator", encodeAccount_obj_rel_insert_input |> Encode.optional input____.creator ), ( "creatorId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.creatorId ), ( "event", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input____.event ), ( "eventDate", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.eventDate ), ( "eventType", Encode.enum CdbGQL.Enum.Notebook_event_type_enum.toString |> Encode.optional input____.eventType ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "notebook", encodeNotebook_obj_rel_insert_input |> Encode.optional input____.notebook ), ( "notebookId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.notebookId ), ( "notebook_event_type", encodeNotebook_event_type_obj_rel_insert_input |> Encode.optional input____.notebook_event_type ) ]


buildNotebook_event_max_order_by :
    (Notebook_event_max_order_byOptionalFields -> Notebook_event_max_order_byOptionalFields)
    -> Notebook_event_max_order_by
buildNotebook_event_max_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { creationDate = Absent, creatorId = Absent, eventDate = Absent, id = Absent, notebookId = Absent }
    in
    { creationDate = optionals____.creationDate, creatorId = optionals____.creatorId, eventDate = optionals____.eventDate, id = optionals____.id, notebookId = optionals____.notebookId }


type alias Notebook_event_max_order_byOptionalFields =
    { creationDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creatorId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , eventDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Notebook\_event\_max\_order\_by input object.
-}
type alias Notebook_event_max_order_by =
    { creationDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creatorId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , eventDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Notebook\_event\_max\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_event_max_order_by : Notebook_event_max_order_by -> Value
encodeNotebook_event_max_order_by input____ =
    Encode.maybeObject
        [ ( "creationDate", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.creationDate ), ( "creatorId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.creatorId ), ( "eventDate", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.eventDate ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "notebookId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.notebookId ) ]


buildNotebook_event_min_order_by :
    (Notebook_event_min_order_byOptionalFields -> Notebook_event_min_order_byOptionalFields)
    -> Notebook_event_min_order_by
buildNotebook_event_min_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { creationDate = Absent, creatorId = Absent, eventDate = Absent, id = Absent, notebookId = Absent }
    in
    { creationDate = optionals____.creationDate, creatorId = optionals____.creatorId, eventDate = optionals____.eventDate, id = optionals____.id, notebookId = optionals____.notebookId }


type alias Notebook_event_min_order_byOptionalFields =
    { creationDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creatorId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , eventDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Notebook\_event\_min\_order\_by input object.
-}
type alias Notebook_event_min_order_by =
    { creationDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creatorId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , eventDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Notebook\_event\_min\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_event_min_order_by : Notebook_event_min_order_by -> Value
encodeNotebook_event_min_order_by input____ =
    Encode.maybeObject
        [ ( "creationDate", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.creationDate ), ( "creatorId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.creatorId ), ( "eventDate", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.eventDate ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "notebookId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.notebookId ) ]


buildNotebook_event_on_conflict :
    Notebook_event_on_conflictRequiredFields
    -> (Notebook_event_on_conflictOptionalFields -> Notebook_event_on_conflictOptionalFields)
    -> Notebook_event_on_conflict
buildNotebook_event_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Notebook_event_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Notebook_event_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Notebook_event_constraint.Notebook_event_constraint
    , update_columns : List CdbGQL.Enum.Notebook_event_update_column.Notebook_event_update_column
    }


type alias Notebook_event_on_conflictOptionalFields =
    { where_ : OptionalArgument Notebook_event_bool_exp }


{-| Type alias for the `Notebook_event_on_conflict` attributes. Note that this type
needs to use the `Notebook_event_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_event_on_conflictRaw =
    { constraint : CdbGQL.Enum.Notebook_event_constraint.Notebook_event_constraint
    , update_columns : List CdbGQL.Enum.Notebook_event_update_column.Notebook_event_update_column
    , where_ : OptionalArgument Notebook_event_bool_exp
    }


{-| Type for the Notebook\_event\_on\_conflict input object.
-}
type Notebook_event_on_conflict
    = Notebook_event_on_conflict Notebook_event_on_conflictRaw


{-| Encode a Notebook\_event\_on\_conflict into a value that can be used as an argument.
-}
encodeNotebook_event_on_conflict : Notebook_event_on_conflict -> Value
encodeNotebook_event_on_conflict (Notebook_event_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Notebook_event_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Notebook_event_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeNotebook_event_bool_exp |> Encode.optional input____.where_ ) ]


buildNotebook_event_order_by :
    (Notebook_event_order_byOptionalFields -> Notebook_event_order_byOptionalFields)
    -> Notebook_event_order_by
buildNotebook_event_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { creationDate = Absent, creator = Absent, creatorId = Absent, event = Absent, eventDate = Absent, eventType = Absent, id = Absent, notebook = Absent, notebookId = Absent, notebook_event_type = Absent }
    in
    Notebook_event_order_by { creationDate = optionals____.creationDate, creator = optionals____.creator, creatorId = optionals____.creatorId, event = optionals____.event, eventDate = optionals____.eventDate, eventType = optionals____.eventType, id = optionals____.id, notebook = optionals____.notebook, notebookId = optionals____.notebookId, notebook_event_type = optionals____.notebook_event_type }


type alias Notebook_event_order_byOptionalFields =
    { creationDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creator : OptionalArgument Account_order_by
    , creatorId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , event : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , eventDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , eventType : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebook : OptionalArgument Notebook_order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebook_event_type : OptionalArgument Notebook_event_type_order_by
    }


{-| Type alias for the `Notebook_event_order_by` attributes. Note that this type
needs to use the `Notebook_event_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_event_order_byRaw =
    { creationDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creator : OptionalArgument Account_order_by
    , creatorId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , event : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , eventDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , eventType : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebook : OptionalArgument Notebook_order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebook_event_type : OptionalArgument Notebook_event_type_order_by
    }


{-| Type for the Notebook\_event\_order\_by input object.
-}
type Notebook_event_order_by
    = Notebook_event_order_by Notebook_event_order_byRaw


{-| Encode a Notebook\_event\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_event_order_by : Notebook_event_order_by -> Value
encodeNotebook_event_order_by (Notebook_event_order_by input____) =
    Encode.maybeObject
        [ ( "creationDate", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.creationDate ), ( "creator", encodeAccount_order_by |> Encode.optional input____.creator ), ( "creatorId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.creatorId ), ( "event", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.event ), ( "eventDate", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.eventDate ), ( "eventType", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.eventType ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "notebook", encodeNotebook_order_by |> Encode.optional input____.notebook ), ( "notebookId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.notebookId ), ( "notebook_event_type", encodeNotebook_event_type_order_by |> Encode.optional input____.notebook_event_type ) ]


buildNotebook_event_pk_columns_input :
    Notebook_event_pk_columns_inputRequiredFields
    -> Notebook_event_pk_columns_input
buildNotebook_event_pk_columns_input required____ =
    { id = required____.id }


type alias Notebook_event_pk_columns_inputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the Notebook\_event\_pk\_columns\_input input object.
-}
type alias Notebook_event_pk_columns_input =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a Notebook\_event\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeNotebook_event_pk_columns_input : Notebook_event_pk_columns_input -> Value
encodeNotebook_event_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildNotebook_event_prepend_input :
    (Notebook_event_prepend_inputOptionalFields -> Notebook_event_prepend_inputOptionalFields)
    -> Notebook_event_prepend_input
buildNotebook_event_prepend_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { event = Absent }
    in
    { event = optionals____.event }


type alias Notebook_event_prepend_inputOptionalFields =
    { event : OptionalArgument CdbGQL.ScalarCodecs.Jsonb }


{-| Type for the Notebook\_event\_prepend\_input input object.
-}
type alias Notebook_event_prepend_input =
    { event : OptionalArgument CdbGQL.ScalarCodecs.Jsonb }


{-| Encode a Notebook\_event\_prepend\_input into a value that can be used as an argument.
-}
encodeNotebook_event_prepend_input : Notebook_event_prepend_input -> Value
encodeNotebook_event_prepend_input input____ =
    Encode.maybeObject
        [ ( "event", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input____.event ) ]


buildNotebook_event_set_input :
    (Notebook_event_set_inputOptionalFields -> Notebook_event_set_inputOptionalFields)
    -> Notebook_event_set_input
buildNotebook_event_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { creationDate = Absent, creatorId = Absent, event = Absent, eventDate = Absent, eventType = Absent, id = Absent, notebookId = Absent }
    in
    { creationDate = optionals____.creationDate, creatorId = optionals____.creatorId, event = optionals____.event, eventDate = optionals____.eventDate, eventType = optionals____.eventType, id = optionals____.id, notebookId = optionals____.notebookId }


type alias Notebook_event_set_inputOptionalFields =
    { creationDate : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , creatorId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , event : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , eventDate : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , eventType : OptionalArgument CdbGQL.Enum.Notebook_event_type_enum.Notebook_event_type_enum
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Type for the Notebook\_event\_set\_input input object.
-}
type alias Notebook_event_set_input =
    { creationDate : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , creatorId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , event : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , eventDate : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , eventType : OptionalArgument CdbGQL.Enum.Notebook_event_type_enum.Notebook_event_type_enum
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Encode a Notebook\_event\_set\_input into a value that can be used as an argument.
-}
encodeNotebook_event_set_input : Notebook_event_set_input -> Value
encodeNotebook_event_set_input input____ =
    Encode.maybeObject
        [ ( "creationDate", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.creationDate ), ( "creatorId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.creatorId ), ( "event", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input____.event ), ( "eventDate", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.eventDate ), ( "eventType", Encode.enum CdbGQL.Enum.Notebook_event_type_enum.toString |> Encode.optional input____.eventType ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "notebookId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.notebookId ) ]


buildNotebook_event_stream_cursor_input :
    Notebook_event_stream_cursor_inputRequiredFields
    -> (Notebook_event_stream_cursor_inputOptionalFields -> Notebook_event_stream_cursor_inputOptionalFields)
    -> Notebook_event_stream_cursor_input
buildNotebook_event_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Notebook_event_stream_cursor_inputRequiredFields =
    { initial_value : Notebook_event_stream_cursor_value_input }


type alias Notebook_event_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Notebook\_event\_stream\_cursor\_input input object.
-}
type alias Notebook_event_stream_cursor_input =
    { initial_value : Notebook_event_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Notebook\_event\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeNotebook_event_stream_cursor_input : Notebook_event_stream_cursor_input -> Value
encodeNotebook_event_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeNotebook_event_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildNotebook_event_stream_cursor_value_input :
    (Notebook_event_stream_cursor_value_inputOptionalFields -> Notebook_event_stream_cursor_value_inputOptionalFields)
    -> Notebook_event_stream_cursor_value_input
buildNotebook_event_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { creationDate = Absent, creatorId = Absent, event = Absent, eventDate = Absent, eventType = Absent, id = Absent, notebookId = Absent }
    in
    { creationDate = optionals____.creationDate, creatorId = optionals____.creatorId, event = optionals____.event, eventDate = optionals____.eventDate, eventType = optionals____.eventType, id = optionals____.id, notebookId = optionals____.notebookId }


type alias Notebook_event_stream_cursor_value_inputOptionalFields =
    { creationDate : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , creatorId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , event : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , eventDate : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , eventType : OptionalArgument CdbGQL.Enum.Notebook_event_type_enum.Notebook_event_type_enum
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Type for the Notebook\_event\_stream\_cursor\_value\_input input object.
-}
type alias Notebook_event_stream_cursor_value_input =
    { creationDate : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , creatorId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , event : OptionalArgument CdbGQL.ScalarCodecs.Jsonb
    , eventDate : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , eventType : OptionalArgument CdbGQL.Enum.Notebook_event_type_enum.Notebook_event_type_enum
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Encode a Notebook\_event\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeNotebook_event_stream_cursor_value_input : Notebook_event_stream_cursor_value_input -> Value
encodeNotebook_event_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "creationDate", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.creationDate ), ( "creatorId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.creatorId ), ( "event", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input____.event ), ( "eventDate", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.eventDate ), ( "eventType", Encode.enum CdbGQL.Enum.Notebook_event_type_enum.toString |> Encode.optional input____.eventType ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "notebookId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.notebookId ) ]


buildNotebook_event_type_bool_exp :
    (Notebook_event_type_bool_expOptionalFields -> Notebook_event_type_bool_expOptionalFields)
    -> Notebook_event_type_bool_exp
buildNotebook_event_type_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, comment = Absent, notebook_events = Absent, notebook_events_aggregate = Absent, value = Absent }
    in
    Notebook_event_type_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, comment = optionals____.comment, notebook_events = optionals____.notebook_events, notebook_events_aggregate = optionals____.notebook_events_aggregate, value = optionals____.value }


type alias Notebook_event_type_bool_expOptionalFields =
    { and_ : OptionalArgument (List Notebook_event_type_bool_exp)
    , not_ : OptionalArgument Notebook_event_type_bool_exp
    , or_ : OptionalArgument (List Notebook_event_type_bool_exp)
    , comment : OptionalArgument String_comparison_exp
    , notebook_events : OptionalArgument Notebook_event_bool_exp
    , notebook_events_aggregate : OptionalArgument Notebook_event_aggregate_bool_exp
    , value : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Notebook_event_type_bool_exp` attributes. Note that this type
needs to use the `Notebook_event_type_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_event_type_bool_expRaw =
    { and_ : OptionalArgument (List Notebook_event_type_bool_exp)
    , not_ : OptionalArgument Notebook_event_type_bool_exp
    , or_ : OptionalArgument (List Notebook_event_type_bool_exp)
    , comment : OptionalArgument String_comparison_exp
    , notebook_events : OptionalArgument Notebook_event_bool_exp
    , notebook_events_aggregate : OptionalArgument Notebook_event_aggregate_bool_exp
    , value : OptionalArgument String_comparison_exp
    }


{-| Type for the Notebook\_event\_type\_bool\_exp input object.
-}
type Notebook_event_type_bool_exp
    = Notebook_event_type_bool_exp Notebook_event_type_bool_expRaw


{-| Encode a Notebook\_event\_type\_bool\_exp into a value that can be used as an argument.
-}
encodeNotebook_event_type_bool_exp : Notebook_event_type_bool_exp -> Value
encodeNotebook_event_type_bool_exp (Notebook_event_type_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeNotebook_event_type_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeNotebook_event_type_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeNotebook_event_type_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "comment", encodeString_comparison_exp |> Encode.optional input____.comment ), ( "notebook_events", encodeNotebook_event_bool_exp |> Encode.optional input____.notebook_events ), ( "notebook_events_aggregate", encodeNotebook_event_aggregate_bool_exp |> Encode.optional input____.notebook_events_aggregate ), ( "value", encodeString_comparison_exp |> Encode.optional input____.value ) ]


buildNotebook_event_type_enum_comparison_exp :
    (Notebook_event_type_enum_comparison_expOptionalFields -> Notebook_event_type_enum_comparison_expOptionalFields)
    -> Notebook_event_type_enum_comparison_exp
buildNotebook_event_type_enum_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, in_ = Absent, is_null_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals____.eq_, in_ = optionals____.in_, is_null_ = optionals____.is_null_, neq_ = optionals____.neq_, nin_ = optionals____.nin_ }


type alias Notebook_event_type_enum_comparison_expOptionalFields =
    { eq_ : OptionalArgument CdbGQL.Enum.Notebook_event_type_enum.Notebook_event_type_enum
    , in_ : OptionalArgument (List CdbGQL.Enum.Notebook_event_type_enum.Notebook_event_type_enum)
    , is_null_ : OptionalArgument Bool
    , neq_ : OptionalArgument CdbGQL.Enum.Notebook_event_type_enum.Notebook_event_type_enum
    , nin_ : OptionalArgument (List CdbGQL.Enum.Notebook_event_type_enum.Notebook_event_type_enum)
    }


{-| Type for the Notebook\_event\_type\_enum\_comparison\_exp input object.
-}
type alias Notebook_event_type_enum_comparison_exp =
    { eq_ : OptionalArgument CdbGQL.Enum.Notebook_event_type_enum.Notebook_event_type_enum
    , in_ : OptionalArgument (List CdbGQL.Enum.Notebook_event_type_enum.Notebook_event_type_enum)
    , is_null_ : OptionalArgument Bool
    , neq_ : OptionalArgument CdbGQL.Enum.Notebook_event_type_enum.Notebook_event_type_enum
    , nin_ : OptionalArgument (List CdbGQL.Enum.Notebook_event_type_enum.Notebook_event_type_enum)
    }


{-| Encode a Notebook\_event\_type\_enum\_comparison\_exp into a value that can be used as an argument.
-}
encodeNotebook_event_type_enum_comparison_exp : Notebook_event_type_enum_comparison_exp -> Value
encodeNotebook_event_type_enum_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", Encode.enum CdbGQL.Enum.Notebook_event_type_enum.toString |> Encode.optional input____.eq_ ), ( "_in", (Encode.enum CdbGQL.Enum.Notebook_event_type_enum.toString |> Encode.list) |> Encode.optional input____.in_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_neq", Encode.enum CdbGQL.Enum.Notebook_event_type_enum.toString |> Encode.optional input____.neq_ ), ( "_nin", (Encode.enum CdbGQL.Enum.Notebook_event_type_enum.toString |> Encode.list) |> Encode.optional input____.nin_ ) ]


buildNotebook_event_type_insert_input :
    (Notebook_event_type_insert_inputOptionalFields -> Notebook_event_type_insert_inputOptionalFields)
    -> Notebook_event_type_insert_input
buildNotebook_event_type_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { comment = Absent, notebook_events = Absent, value = Absent }
    in
    Notebook_event_type_insert_input { comment = optionals____.comment, notebook_events = optionals____.notebook_events, value = optionals____.value }


type alias Notebook_event_type_insert_inputOptionalFields =
    { comment : OptionalArgument String
    , notebook_events : OptionalArgument Notebook_event_arr_rel_insert_input
    , value : OptionalArgument String
    }


{-| Type alias for the `Notebook_event_type_insert_input` attributes. Note that this type
needs to use the `Notebook_event_type_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_event_type_insert_inputRaw =
    { comment : OptionalArgument String
    , notebook_events : OptionalArgument Notebook_event_arr_rel_insert_input
    , value : OptionalArgument String
    }


{-| Type for the Notebook\_event\_type\_insert\_input input object.
-}
type Notebook_event_type_insert_input
    = Notebook_event_type_insert_input Notebook_event_type_insert_inputRaw


{-| Encode a Notebook\_event\_type\_insert\_input into a value that can be used as an argument.
-}
encodeNotebook_event_type_insert_input : Notebook_event_type_insert_input -> Value
encodeNotebook_event_type_insert_input (Notebook_event_type_insert_input input____) =
    Encode.maybeObject
        [ ( "comment", Encode.string |> Encode.optional input____.comment ), ( "notebook_events", encodeNotebook_event_arr_rel_insert_input |> Encode.optional input____.notebook_events ), ( "value", Encode.string |> Encode.optional input____.value ) ]


buildNotebook_event_type_obj_rel_insert_input :
    Notebook_event_type_obj_rel_insert_inputRequiredFields
    -> (Notebook_event_type_obj_rel_insert_inputOptionalFields -> Notebook_event_type_obj_rel_insert_inputOptionalFields)
    -> Notebook_event_type_obj_rel_insert_input
buildNotebook_event_type_obj_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Notebook_event_type_obj_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Notebook_event_type_obj_rel_insert_inputRequiredFields =
    { data : Notebook_event_type_insert_input }


type alias Notebook_event_type_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Notebook_event_type_on_conflict }


{-| Type alias for the `Notebook_event_type_obj_rel_insert_input` attributes. Note that this type
needs to use the `Notebook_event_type_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_event_type_obj_rel_insert_inputRaw =
    { data : Notebook_event_type_insert_input
    , on_conflict : OptionalArgument Notebook_event_type_on_conflict
    }


{-| Type for the Notebook\_event\_type\_obj\_rel\_insert\_input input object.
-}
type Notebook_event_type_obj_rel_insert_input
    = Notebook_event_type_obj_rel_insert_input Notebook_event_type_obj_rel_insert_inputRaw


{-| Encode a Notebook\_event\_type\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeNotebook_event_type_obj_rel_insert_input : Notebook_event_type_obj_rel_insert_input -> Value
encodeNotebook_event_type_obj_rel_insert_input (Notebook_event_type_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeNotebook_event_type_insert_input input____.data |> Just ), ( "on_conflict", encodeNotebook_event_type_on_conflict |> Encode.optional input____.on_conflict ) ]


buildNotebook_event_type_on_conflict :
    Notebook_event_type_on_conflictRequiredFields
    -> (Notebook_event_type_on_conflictOptionalFields -> Notebook_event_type_on_conflictOptionalFields)
    -> Notebook_event_type_on_conflict
buildNotebook_event_type_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Notebook_event_type_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Notebook_event_type_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Notebook_event_type_constraint.Notebook_event_type_constraint
    , update_columns : List CdbGQL.Enum.Notebook_event_type_update_column.Notebook_event_type_update_column
    }


type alias Notebook_event_type_on_conflictOptionalFields =
    { where_ : OptionalArgument Notebook_event_type_bool_exp }


{-| Type alias for the `Notebook_event_type_on_conflict` attributes. Note that this type
needs to use the `Notebook_event_type_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_event_type_on_conflictRaw =
    { constraint : CdbGQL.Enum.Notebook_event_type_constraint.Notebook_event_type_constraint
    , update_columns : List CdbGQL.Enum.Notebook_event_type_update_column.Notebook_event_type_update_column
    , where_ : OptionalArgument Notebook_event_type_bool_exp
    }


{-| Type for the Notebook\_event\_type\_on\_conflict input object.
-}
type Notebook_event_type_on_conflict
    = Notebook_event_type_on_conflict Notebook_event_type_on_conflictRaw


{-| Encode a Notebook\_event\_type\_on\_conflict into a value that can be used as an argument.
-}
encodeNotebook_event_type_on_conflict : Notebook_event_type_on_conflict -> Value
encodeNotebook_event_type_on_conflict (Notebook_event_type_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Notebook_event_type_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Notebook_event_type_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeNotebook_event_type_bool_exp |> Encode.optional input____.where_ ) ]


buildNotebook_event_type_order_by :
    (Notebook_event_type_order_byOptionalFields -> Notebook_event_type_order_byOptionalFields)
    -> Notebook_event_type_order_by
buildNotebook_event_type_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { comment = Absent, notebook_events_aggregate = Absent, value = Absent }
    in
    { comment = optionals____.comment, notebook_events_aggregate = optionals____.notebook_events_aggregate, value = optionals____.value }


type alias Notebook_event_type_order_byOptionalFields =
    { comment : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebook_events_aggregate : OptionalArgument Notebook_event_aggregate_order_by
    , value : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Notebook\_event\_type\_order\_by input object.
-}
type alias Notebook_event_type_order_by =
    { comment : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebook_events_aggregate : OptionalArgument Notebook_event_aggregate_order_by
    , value : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Notebook\_event\_type\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_event_type_order_by : Notebook_event_type_order_by -> Value
encodeNotebook_event_type_order_by input____ =
    Encode.maybeObject
        [ ( "comment", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.comment ), ( "notebook_events_aggregate", encodeNotebook_event_aggregate_order_by |> Encode.optional input____.notebook_events_aggregate ), ( "value", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.value ) ]


buildNotebook_event_type_pk_columns_input :
    Notebook_event_type_pk_columns_inputRequiredFields
    -> Notebook_event_type_pk_columns_input
buildNotebook_event_type_pk_columns_input required____ =
    { value = required____.value }


type alias Notebook_event_type_pk_columns_inputRequiredFields =
    { value : String }


{-| Type for the Notebook\_event\_type\_pk\_columns\_input input object.
-}
type alias Notebook_event_type_pk_columns_input =
    { value : String }


{-| Encode a Notebook\_event\_type\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeNotebook_event_type_pk_columns_input : Notebook_event_type_pk_columns_input -> Value
encodeNotebook_event_type_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "value", Encode.string input____.value |> Just ) ]


buildNotebook_event_type_set_input :
    (Notebook_event_type_set_inputOptionalFields -> Notebook_event_type_set_inputOptionalFields)
    -> Notebook_event_type_set_input
buildNotebook_event_type_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { comment = Absent, value = Absent }
    in
    { comment = optionals____.comment, value = optionals____.value }


type alias Notebook_event_type_set_inputOptionalFields =
    { comment : OptionalArgument String
    , value : OptionalArgument String
    }


{-| Type for the Notebook\_event\_type\_set\_input input object.
-}
type alias Notebook_event_type_set_input =
    { comment : OptionalArgument String
    , value : OptionalArgument String
    }


{-| Encode a Notebook\_event\_type\_set\_input into a value that can be used as an argument.
-}
encodeNotebook_event_type_set_input : Notebook_event_type_set_input -> Value
encodeNotebook_event_type_set_input input____ =
    Encode.maybeObject
        [ ( "comment", Encode.string |> Encode.optional input____.comment ), ( "value", Encode.string |> Encode.optional input____.value ) ]


buildNotebook_event_type_stream_cursor_input :
    Notebook_event_type_stream_cursor_inputRequiredFields
    -> (Notebook_event_type_stream_cursor_inputOptionalFields -> Notebook_event_type_stream_cursor_inputOptionalFields)
    -> Notebook_event_type_stream_cursor_input
buildNotebook_event_type_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Notebook_event_type_stream_cursor_inputRequiredFields =
    { initial_value : Notebook_event_type_stream_cursor_value_input }


type alias Notebook_event_type_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Notebook\_event\_type\_stream\_cursor\_input input object.
-}
type alias Notebook_event_type_stream_cursor_input =
    { initial_value : Notebook_event_type_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Notebook\_event\_type\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeNotebook_event_type_stream_cursor_input : Notebook_event_type_stream_cursor_input -> Value
encodeNotebook_event_type_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeNotebook_event_type_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildNotebook_event_type_stream_cursor_value_input :
    (Notebook_event_type_stream_cursor_value_inputOptionalFields -> Notebook_event_type_stream_cursor_value_inputOptionalFields)
    -> Notebook_event_type_stream_cursor_value_input
buildNotebook_event_type_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { comment = Absent, value = Absent }
    in
    { comment = optionals____.comment, value = optionals____.value }


type alias Notebook_event_type_stream_cursor_value_inputOptionalFields =
    { comment : OptionalArgument String
    , value : OptionalArgument String
    }


{-| Type for the Notebook\_event\_type\_stream\_cursor\_value\_input input object.
-}
type alias Notebook_event_type_stream_cursor_value_input =
    { comment : OptionalArgument String
    , value : OptionalArgument String
    }


{-| Encode a Notebook\_event\_type\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeNotebook_event_type_stream_cursor_value_input : Notebook_event_type_stream_cursor_value_input -> Value
encodeNotebook_event_type_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "comment", Encode.string |> Encode.optional input____.comment ), ( "value", Encode.string |> Encode.optional input____.value ) ]


buildNotebook_event_type_updates :
    Notebook_event_type_updatesRequiredFields
    -> (Notebook_event_type_updatesOptionalFields -> Notebook_event_type_updatesOptionalFields)
    -> Notebook_event_type_updates
buildNotebook_event_type_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Notebook_event_type_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Notebook_event_type_updatesRequiredFields =
    { where_ : Notebook_event_type_bool_exp }


type alias Notebook_event_type_updatesOptionalFields =
    { set_ : OptionalArgument Notebook_event_type_set_input }


{-| Type alias for the `Notebook_event_type_updates` attributes. Note that this type
needs to use the `Notebook_event_type_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_event_type_updatesRaw =
    { set_ : OptionalArgument Notebook_event_type_set_input
    , where_ : Notebook_event_type_bool_exp
    }


{-| Type for the Notebook\_event\_type\_updates input object.
-}
type Notebook_event_type_updates
    = Notebook_event_type_updates Notebook_event_type_updatesRaw


{-| Encode a Notebook\_event\_type\_updates into a value that can be used as an argument.
-}
encodeNotebook_event_type_updates : Notebook_event_type_updates -> Value
encodeNotebook_event_type_updates (Notebook_event_type_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeNotebook_event_type_set_input |> Encode.optional input____.set_ ), ( "where", encodeNotebook_event_type_bool_exp input____.where_ |> Just ) ]


buildNotebook_event_updates :
    Notebook_event_updatesRequiredFields
    -> (Notebook_event_updatesOptionalFields -> Notebook_event_updatesOptionalFields)
    -> Notebook_event_updates
buildNotebook_event_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { append_ = Absent, delete_at_path_ = Absent, delete_elem_ = Absent, delete_key_ = Absent, prepend_ = Absent, set_ = Absent }
    in
    Notebook_event_updates { append_ = optionals____.append_, delete_at_path_ = optionals____.delete_at_path_, delete_elem_ = optionals____.delete_elem_, delete_key_ = optionals____.delete_key_, prepend_ = optionals____.prepend_, set_ = optionals____.set_, where_ = required____.where_ }


type alias Notebook_event_updatesRequiredFields =
    { where_ : Notebook_event_bool_exp }


type alias Notebook_event_updatesOptionalFields =
    { append_ : OptionalArgument Notebook_event_append_input
    , delete_at_path_ : OptionalArgument Notebook_event_delete_at_path_input
    , delete_elem_ : OptionalArgument Notebook_event_delete_elem_input
    , delete_key_ : OptionalArgument Notebook_event_delete_key_input
    , prepend_ : OptionalArgument Notebook_event_prepend_input
    , set_ : OptionalArgument Notebook_event_set_input
    }


{-| Type alias for the `Notebook_event_updates` attributes. Note that this type
needs to use the `Notebook_event_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_event_updatesRaw =
    { append_ : OptionalArgument Notebook_event_append_input
    , delete_at_path_ : OptionalArgument Notebook_event_delete_at_path_input
    , delete_elem_ : OptionalArgument Notebook_event_delete_elem_input
    , delete_key_ : OptionalArgument Notebook_event_delete_key_input
    , prepend_ : OptionalArgument Notebook_event_prepend_input
    , set_ : OptionalArgument Notebook_event_set_input
    , where_ : Notebook_event_bool_exp
    }


{-| Type for the Notebook\_event\_updates input object.
-}
type Notebook_event_updates
    = Notebook_event_updates Notebook_event_updatesRaw


{-| Encode a Notebook\_event\_updates into a value that can be used as an argument.
-}
encodeNotebook_event_updates : Notebook_event_updates -> Value
encodeNotebook_event_updates (Notebook_event_updates input____) =
    Encode.maybeObject
        [ ( "_append", encodeNotebook_event_append_input |> Encode.optional input____.append_ ), ( "_delete_at_path", encodeNotebook_event_delete_at_path_input |> Encode.optional input____.delete_at_path_ ), ( "_delete_elem", encodeNotebook_event_delete_elem_input |> Encode.optional input____.delete_elem_ ), ( "_delete_key", encodeNotebook_event_delete_key_input |> Encode.optional input____.delete_key_ ), ( "_prepend", encodeNotebook_event_prepend_input |> Encode.optional input____.prepend_ ), ( "_set", encodeNotebook_event_set_input |> Encode.optional input____.set_ ), ( "where", encodeNotebook_event_bool_exp input____.where_ |> Just ) ]


buildNotebook_focus_aggregate_bool_exp :
    (Notebook_focus_aggregate_bool_expOptionalFields -> Notebook_focus_aggregate_bool_expOptionalFields)
    -> Notebook_focus_aggregate_bool_exp
buildNotebook_focus_aggregate_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent }
    in
    Notebook_focus_aggregate_bool_exp { count = optionals____.count }


type alias Notebook_focus_aggregate_bool_expOptionalFields =
    { count : OptionalArgument Notebook_focus_aggregate_bool_exp_count }


{-| Type alias for the `Notebook_focus_aggregate_bool_exp` attributes. Note that this type
needs to use the `Notebook_focus_aggregate_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_focus_aggregate_bool_expRaw =
    { count : OptionalArgument Notebook_focus_aggregate_bool_exp_count }


{-| Type for the Notebook\_focus\_aggregate\_bool\_exp input object.
-}
type Notebook_focus_aggregate_bool_exp
    = Notebook_focus_aggregate_bool_exp Notebook_focus_aggregate_bool_expRaw


{-| Encode a Notebook\_focus\_aggregate\_bool\_exp into a value that can be used as an argument.
-}
encodeNotebook_focus_aggregate_bool_exp : Notebook_focus_aggregate_bool_exp -> Value
encodeNotebook_focus_aggregate_bool_exp (Notebook_focus_aggregate_bool_exp input____) =
    Encode.maybeObject
        [ ( "count", encodeNotebook_focus_aggregate_bool_exp_count |> Encode.optional input____.count ) ]


buildNotebook_focus_aggregate_bool_exp_count :
    Notebook_focus_aggregate_bool_exp_countRequiredFields
    -> (Notebook_focus_aggregate_bool_exp_countOptionalFields -> Notebook_focus_aggregate_bool_exp_countOptionalFields)
    -> Notebook_focus_aggregate_bool_exp_count
buildNotebook_focus_aggregate_bool_exp_count required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { arguments = Absent, distinct = Absent, filter = Absent }
    in
    Notebook_focus_aggregate_bool_exp_count { arguments = optionals____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Notebook_focus_aggregate_bool_exp_countRequiredFields =
    { predicate : Int_comparison_exp }


type alias Notebook_focus_aggregate_bool_exp_countOptionalFields =
    { arguments : OptionalArgument (List CdbGQL.Enum.Notebook_focus_select_column.Notebook_focus_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Notebook_focus_bool_exp
    }


{-| Type alias for the `Notebook_focus_aggregate_bool_exp_count` attributes. Note that this type
needs to use the `Notebook_focus_aggregate_bool_exp_count` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_focus_aggregate_bool_exp_countRaw =
    { arguments : OptionalArgument (List CdbGQL.Enum.Notebook_focus_select_column.Notebook_focus_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Notebook_focus_bool_exp
    , predicate : Int_comparison_exp
    }


{-| Type for the Notebook\_focus\_aggregate\_bool\_exp\_count input object.
-}
type Notebook_focus_aggregate_bool_exp_count
    = Notebook_focus_aggregate_bool_exp_count Notebook_focus_aggregate_bool_exp_countRaw


{-| Encode a Notebook\_focus\_aggregate\_bool\_exp\_count into a value that can be used as an argument.
-}
encodeNotebook_focus_aggregate_bool_exp_count : Notebook_focus_aggregate_bool_exp_count -> Value
encodeNotebook_focus_aggregate_bool_exp_count (Notebook_focus_aggregate_bool_exp_count input____) =
    Encode.maybeObject
        [ ( "arguments", (Encode.enum CdbGQL.Enum.Notebook_focus_select_column.toString |> Encode.list) |> Encode.optional input____.arguments ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeNotebook_focus_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeInt_comparison_exp input____.predicate |> Just ) ]


buildNotebook_focus_aggregate_order_by :
    (Notebook_focus_aggregate_order_byOptionalFields -> Notebook_focus_aggregate_order_byOptionalFields)
    -> Notebook_focus_aggregate_order_by
buildNotebook_focus_aggregate_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals____.count, max = optionals____.max, min = optionals____.min }


type alias Notebook_focus_aggregate_order_byOptionalFields =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Notebook_focus_max_order_by
    , min : OptionalArgument Notebook_focus_min_order_by
    }


{-| Type for the Notebook\_focus\_aggregate\_order\_by input object.
-}
type alias Notebook_focus_aggregate_order_by =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Notebook_focus_max_order_by
    , min : OptionalArgument Notebook_focus_min_order_by
    }


{-| Encode a Notebook\_focus\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_focus_aggregate_order_by : Notebook_focus_aggregate_order_by -> Value
encodeNotebook_focus_aggregate_order_by input____ =
    Encode.maybeObject
        [ ( "count", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.count ), ( "max", encodeNotebook_focus_max_order_by |> Encode.optional input____.max ), ( "min", encodeNotebook_focus_min_order_by |> Encode.optional input____.min ) ]


buildNotebook_focus_arr_rel_insert_input :
    Notebook_focus_arr_rel_insert_inputRequiredFields
    -> (Notebook_focus_arr_rel_insert_inputOptionalFields -> Notebook_focus_arr_rel_insert_inputOptionalFields)
    -> Notebook_focus_arr_rel_insert_input
buildNotebook_focus_arr_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Notebook_focus_arr_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Notebook_focus_arr_rel_insert_inputRequiredFields =
    { data : List Notebook_focus_insert_input }


type alias Notebook_focus_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Notebook_focus_on_conflict }


{-| Type alias for the `Notebook_focus_arr_rel_insert_input` attributes. Note that this type
needs to use the `Notebook_focus_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_focus_arr_rel_insert_inputRaw =
    { data : List Notebook_focus_insert_input
    , on_conflict : OptionalArgument Notebook_focus_on_conflict
    }


{-| Type for the Notebook\_focus\_arr\_rel\_insert\_input input object.
-}
type Notebook_focus_arr_rel_insert_input
    = Notebook_focus_arr_rel_insert_input Notebook_focus_arr_rel_insert_inputRaw


{-| Encode a Notebook\_focus\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeNotebook_focus_arr_rel_insert_input : Notebook_focus_arr_rel_insert_input -> Value
encodeNotebook_focus_arr_rel_insert_input (Notebook_focus_arr_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", (encodeNotebook_focus_insert_input |> Encode.list) input____.data |> Just ), ( "on_conflict", encodeNotebook_focus_on_conflict |> Encode.optional input____.on_conflict ) ]


buildNotebook_focus_bool_exp :
    (Notebook_focus_bool_expOptionalFields -> Notebook_focus_bool_expOptionalFields)
    -> Notebook_focus_bool_exp
buildNotebook_focus_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, createdAt = Absent, creator = Absent, creatorId = Absent, id = Absent, linkedTo = Absent, notebook = Absent, notebookId = Absent, targets = Absent, targets_aggregate = Absent, theme = Absent, updatedAt = Absent }
    in
    Notebook_focus_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, createdAt = optionals____.createdAt, creator = optionals____.creator, creatorId = optionals____.creatorId, id = optionals____.id, linkedTo = optionals____.linkedTo, notebook = optionals____.notebook, notebookId = optionals____.notebookId, targets = optionals____.targets, targets_aggregate = optionals____.targets_aggregate, theme = optionals____.theme, updatedAt = optionals____.updatedAt }


type alias Notebook_focus_bool_expOptionalFields =
    { and_ : OptionalArgument (List Notebook_focus_bool_exp)
    , not_ : OptionalArgument Notebook_focus_bool_exp
    , or_ : OptionalArgument (List Notebook_focus_bool_exp)
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , creator : OptionalArgument Account_bool_exp
    , creatorId : OptionalArgument Uuid_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , linkedTo : OptionalArgument String_comparison_exp
    , notebook : OptionalArgument Notebook_bool_exp
    , notebookId : OptionalArgument Uuid_comparison_exp
    , targets : OptionalArgument Notebook_target_bool_exp
    , targets_aggregate : OptionalArgument Notebook_target_aggregate_bool_exp
    , theme : OptionalArgument String_comparison_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type alias for the `Notebook_focus_bool_exp` attributes. Note that this type
needs to use the `Notebook_focus_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_focus_bool_expRaw =
    { and_ : OptionalArgument (List Notebook_focus_bool_exp)
    , not_ : OptionalArgument Notebook_focus_bool_exp
    , or_ : OptionalArgument (List Notebook_focus_bool_exp)
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , creator : OptionalArgument Account_bool_exp
    , creatorId : OptionalArgument Uuid_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , linkedTo : OptionalArgument String_comparison_exp
    , notebook : OptionalArgument Notebook_bool_exp
    , notebookId : OptionalArgument Uuid_comparison_exp
    , targets : OptionalArgument Notebook_target_bool_exp
    , targets_aggregate : OptionalArgument Notebook_target_aggregate_bool_exp
    , theme : OptionalArgument String_comparison_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type for the Notebook\_focus\_bool\_exp input object.
-}
type Notebook_focus_bool_exp
    = Notebook_focus_bool_exp Notebook_focus_bool_expRaw


{-| Encode a Notebook\_focus\_bool\_exp into a value that can be used as an argument.
-}
encodeNotebook_focus_bool_exp : Notebook_focus_bool_exp -> Value
encodeNotebook_focus_bool_exp (Notebook_focus_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeNotebook_focus_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeNotebook_focus_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeNotebook_focus_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "createdAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.createdAt ), ( "creator", encodeAccount_bool_exp |> Encode.optional input____.creator ), ( "creatorId", encodeUuid_comparison_exp |> Encode.optional input____.creatorId ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "linkedTo", encodeString_comparison_exp |> Encode.optional input____.linkedTo ), ( "notebook", encodeNotebook_bool_exp |> Encode.optional input____.notebook ), ( "notebookId", encodeUuid_comparison_exp |> Encode.optional input____.notebookId ), ( "targets", encodeNotebook_target_bool_exp |> Encode.optional input____.targets ), ( "targets_aggregate", encodeNotebook_target_aggregate_bool_exp |> Encode.optional input____.targets_aggregate ), ( "theme", encodeString_comparison_exp |> Encode.optional input____.theme ), ( "updatedAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.updatedAt ) ]


buildNotebook_focus_insert_input :
    (Notebook_focus_insert_inputOptionalFields -> Notebook_focus_insert_inputOptionalFields)
    -> Notebook_focus_insert_input
buildNotebook_focus_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, creator = Absent, creatorId = Absent, id = Absent, linkedTo = Absent, notebook = Absent, notebookId = Absent, targets = Absent, theme = Absent, updatedAt = Absent }
    in
    Notebook_focus_insert_input { createdAt = optionals____.createdAt, creator = optionals____.creator, creatorId = optionals____.creatorId, id = optionals____.id, linkedTo = optionals____.linkedTo, notebook = optionals____.notebook, notebookId = optionals____.notebookId, targets = optionals____.targets, theme = optionals____.theme, updatedAt = optionals____.updatedAt }


type alias Notebook_focus_insert_inputOptionalFields =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , creator : OptionalArgument Account_obj_rel_insert_input
    , creatorId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , linkedTo : OptionalArgument String
    , notebook : OptionalArgument Notebook_obj_rel_insert_input
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , targets : OptionalArgument Notebook_target_arr_rel_insert_input
    , theme : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type alias for the `Notebook_focus_insert_input` attributes. Note that this type
needs to use the `Notebook_focus_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_focus_insert_inputRaw =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , creator : OptionalArgument Account_obj_rel_insert_input
    , creatorId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , linkedTo : OptionalArgument String
    , notebook : OptionalArgument Notebook_obj_rel_insert_input
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , targets : OptionalArgument Notebook_target_arr_rel_insert_input
    , theme : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Notebook\_focus\_insert\_input input object.
-}
type Notebook_focus_insert_input
    = Notebook_focus_insert_input Notebook_focus_insert_inputRaw


{-| Encode a Notebook\_focus\_insert\_input into a value that can be used as an argument.
-}
encodeNotebook_focus_insert_input : Notebook_focus_insert_input -> Value
encodeNotebook_focus_insert_input (Notebook_focus_insert_input input____) =
    Encode.maybeObject
        [ ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "creator", encodeAccount_obj_rel_insert_input |> Encode.optional input____.creator ), ( "creatorId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.creatorId ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "linkedTo", Encode.string |> Encode.optional input____.linkedTo ), ( "notebook", encodeNotebook_obj_rel_insert_input |> Encode.optional input____.notebook ), ( "notebookId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.notebookId ), ( "targets", encodeNotebook_target_arr_rel_insert_input |> Encode.optional input____.targets ), ( "theme", Encode.string |> Encode.optional input____.theme ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildNotebook_focus_max_order_by :
    (Notebook_focus_max_order_byOptionalFields -> Notebook_focus_max_order_byOptionalFields)
    -> Notebook_focus_max_order_by
buildNotebook_focus_max_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, creatorId = Absent, id = Absent, linkedTo = Absent, notebookId = Absent, theme = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, creatorId = optionals____.creatorId, id = optionals____.id, linkedTo = optionals____.linkedTo, notebookId = optionals____.notebookId, theme = optionals____.theme, updatedAt = optionals____.updatedAt }


type alias Notebook_focus_max_order_byOptionalFields =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creatorId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , linkedTo : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , theme : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Notebook\_focus\_max\_order\_by input object.
-}
type alias Notebook_focus_max_order_by =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creatorId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , linkedTo : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , theme : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Notebook\_focus\_max\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_focus_max_order_by : Notebook_focus_max_order_by -> Value
encodeNotebook_focus_max_order_by input____ =
    Encode.maybeObject
        [ ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "creatorId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.creatorId ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "linkedTo", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.linkedTo ), ( "notebookId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.notebookId ), ( "theme", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.theme ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildNotebook_focus_min_order_by :
    (Notebook_focus_min_order_byOptionalFields -> Notebook_focus_min_order_byOptionalFields)
    -> Notebook_focus_min_order_by
buildNotebook_focus_min_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, creatorId = Absent, id = Absent, linkedTo = Absent, notebookId = Absent, theme = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, creatorId = optionals____.creatorId, id = optionals____.id, linkedTo = optionals____.linkedTo, notebookId = optionals____.notebookId, theme = optionals____.theme, updatedAt = optionals____.updatedAt }


type alias Notebook_focus_min_order_byOptionalFields =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creatorId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , linkedTo : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , theme : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Notebook\_focus\_min\_order\_by input object.
-}
type alias Notebook_focus_min_order_by =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creatorId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , linkedTo : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , theme : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Notebook\_focus\_min\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_focus_min_order_by : Notebook_focus_min_order_by -> Value
encodeNotebook_focus_min_order_by input____ =
    Encode.maybeObject
        [ ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "creatorId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.creatorId ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "linkedTo", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.linkedTo ), ( "notebookId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.notebookId ), ( "theme", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.theme ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildNotebook_focus_obj_rel_insert_input :
    Notebook_focus_obj_rel_insert_inputRequiredFields
    -> (Notebook_focus_obj_rel_insert_inputOptionalFields -> Notebook_focus_obj_rel_insert_inputOptionalFields)
    -> Notebook_focus_obj_rel_insert_input
buildNotebook_focus_obj_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Notebook_focus_obj_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Notebook_focus_obj_rel_insert_inputRequiredFields =
    { data : Notebook_focus_insert_input }


type alias Notebook_focus_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Notebook_focus_on_conflict }


{-| Type alias for the `Notebook_focus_obj_rel_insert_input` attributes. Note that this type
needs to use the `Notebook_focus_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_focus_obj_rel_insert_inputRaw =
    { data : Notebook_focus_insert_input
    , on_conflict : OptionalArgument Notebook_focus_on_conflict
    }


{-| Type for the Notebook\_focus\_obj\_rel\_insert\_input input object.
-}
type Notebook_focus_obj_rel_insert_input
    = Notebook_focus_obj_rel_insert_input Notebook_focus_obj_rel_insert_inputRaw


{-| Encode a Notebook\_focus\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeNotebook_focus_obj_rel_insert_input : Notebook_focus_obj_rel_insert_input -> Value
encodeNotebook_focus_obj_rel_insert_input (Notebook_focus_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeNotebook_focus_insert_input input____.data |> Just ), ( "on_conflict", encodeNotebook_focus_on_conflict |> Encode.optional input____.on_conflict ) ]


buildNotebook_focus_on_conflict :
    Notebook_focus_on_conflictRequiredFields
    -> (Notebook_focus_on_conflictOptionalFields -> Notebook_focus_on_conflictOptionalFields)
    -> Notebook_focus_on_conflict
buildNotebook_focus_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Notebook_focus_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Notebook_focus_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Notebook_focus_constraint.Notebook_focus_constraint
    , update_columns : List CdbGQL.Enum.Notebook_focus_update_column.Notebook_focus_update_column
    }


type alias Notebook_focus_on_conflictOptionalFields =
    { where_ : OptionalArgument Notebook_focus_bool_exp }


{-| Type alias for the `Notebook_focus_on_conflict` attributes. Note that this type
needs to use the `Notebook_focus_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_focus_on_conflictRaw =
    { constraint : CdbGQL.Enum.Notebook_focus_constraint.Notebook_focus_constraint
    , update_columns : List CdbGQL.Enum.Notebook_focus_update_column.Notebook_focus_update_column
    , where_ : OptionalArgument Notebook_focus_bool_exp
    }


{-| Type for the Notebook\_focus\_on\_conflict input object.
-}
type Notebook_focus_on_conflict
    = Notebook_focus_on_conflict Notebook_focus_on_conflictRaw


{-| Encode a Notebook\_focus\_on\_conflict into a value that can be used as an argument.
-}
encodeNotebook_focus_on_conflict : Notebook_focus_on_conflict -> Value
encodeNotebook_focus_on_conflict (Notebook_focus_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Notebook_focus_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Notebook_focus_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeNotebook_focus_bool_exp |> Encode.optional input____.where_ ) ]


buildNotebook_focus_order_by :
    (Notebook_focus_order_byOptionalFields -> Notebook_focus_order_byOptionalFields)
    -> Notebook_focus_order_by
buildNotebook_focus_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, creator = Absent, creatorId = Absent, id = Absent, linkedTo = Absent, notebook = Absent, notebookId = Absent, targets_aggregate = Absent, theme = Absent, updatedAt = Absent }
    in
    Notebook_focus_order_by { createdAt = optionals____.createdAt, creator = optionals____.creator, creatorId = optionals____.creatorId, id = optionals____.id, linkedTo = optionals____.linkedTo, notebook = optionals____.notebook, notebookId = optionals____.notebookId, targets_aggregate = optionals____.targets_aggregate, theme = optionals____.theme, updatedAt = optionals____.updatedAt }


type alias Notebook_focus_order_byOptionalFields =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creator : OptionalArgument Account_order_by
    , creatorId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , linkedTo : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebook : OptionalArgument Notebook_order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , targets_aggregate : OptionalArgument Notebook_target_aggregate_order_by
    , theme : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type alias for the `Notebook_focus_order_by` attributes. Note that this type
needs to use the `Notebook_focus_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_focus_order_byRaw =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creator : OptionalArgument Account_order_by
    , creatorId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , linkedTo : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebook : OptionalArgument Notebook_order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , targets_aggregate : OptionalArgument Notebook_target_aggregate_order_by
    , theme : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Notebook\_focus\_order\_by input object.
-}
type Notebook_focus_order_by
    = Notebook_focus_order_by Notebook_focus_order_byRaw


{-| Encode a Notebook\_focus\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_focus_order_by : Notebook_focus_order_by -> Value
encodeNotebook_focus_order_by (Notebook_focus_order_by input____) =
    Encode.maybeObject
        [ ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "creator", encodeAccount_order_by |> Encode.optional input____.creator ), ( "creatorId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.creatorId ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "linkedTo", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.linkedTo ), ( "notebook", encodeNotebook_order_by |> Encode.optional input____.notebook ), ( "notebookId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.notebookId ), ( "targets_aggregate", encodeNotebook_target_aggregate_order_by |> Encode.optional input____.targets_aggregate ), ( "theme", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.theme ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildNotebook_focus_pk_columns_input :
    Notebook_focus_pk_columns_inputRequiredFields
    -> Notebook_focus_pk_columns_input
buildNotebook_focus_pk_columns_input required____ =
    { id = required____.id }


type alias Notebook_focus_pk_columns_inputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the Notebook\_focus\_pk\_columns\_input input object.
-}
type alias Notebook_focus_pk_columns_input =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a Notebook\_focus\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeNotebook_focus_pk_columns_input : Notebook_focus_pk_columns_input -> Value
encodeNotebook_focus_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildNotebook_focus_set_input :
    (Notebook_focus_set_inputOptionalFields -> Notebook_focus_set_inputOptionalFields)
    -> Notebook_focus_set_input
buildNotebook_focus_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, creatorId = Absent, id = Absent, linkedTo = Absent, notebookId = Absent, theme = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, creatorId = optionals____.creatorId, id = optionals____.id, linkedTo = optionals____.linkedTo, notebookId = optionals____.notebookId, theme = optionals____.theme, updatedAt = optionals____.updatedAt }


type alias Notebook_focus_set_inputOptionalFields =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , creatorId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , linkedTo : OptionalArgument String
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , theme : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Notebook\_focus\_set\_input input object.
-}
type alias Notebook_focus_set_input =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , creatorId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , linkedTo : OptionalArgument String
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , theme : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Notebook\_focus\_set\_input into a value that can be used as an argument.
-}
encodeNotebook_focus_set_input : Notebook_focus_set_input -> Value
encodeNotebook_focus_set_input input____ =
    Encode.maybeObject
        [ ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "creatorId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.creatorId ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "linkedTo", Encode.string |> Encode.optional input____.linkedTo ), ( "notebookId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.notebookId ), ( "theme", Encode.string |> Encode.optional input____.theme ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildNotebook_focus_stream_cursor_input :
    Notebook_focus_stream_cursor_inputRequiredFields
    -> (Notebook_focus_stream_cursor_inputOptionalFields -> Notebook_focus_stream_cursor_inputOptionalFields)
    -> Notebook_focus_stream_cursor_input
buildNotebook_focus_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Notebook_focus_stream_cursor_inputRequiredFields =
    { initial_value : Notebook_focus_stream_cursor_value_input }


type alias Notebook_focus_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Notebook\_focus\_stream\_cursor\_input input object.
-}
type alias Notebook_focus_stream_cursor_input =
    { initial_value : Notebook_focus_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Notebook\_focus\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeNotebook_focus_stream_cursor_input : Notebook_focus_stream_cursor_input -> Value
encodeNotebook_focus_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeNotebook_focus_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildNotebook_focus_stream_cursor_value_input :
    (Notebook_focus_stream_cursor_value_inputOptionalFields -> Notebook_focus_stream_cursor_value_inputOptionalFields)
    -> Notebook_focus_stream_cursor_value_input
buildNotebook_focus_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, creatorId = Absent, id = Absent, linkedTo = Absent, notebookId = Absent, theme = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, creatorId = optionals____.creatorId, id = optionals____.id, linkedTo = optionals____.linkedTo, notebookId = optionals____.notebookId, theme = optionals____.theme, updatedAt = optionals____.updatedAt }


type alias Notebook_focus_stream_cursor_value_inputOptionalFields =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , creatorId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , linkedTo : OptionalArgument String
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , theme : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Notebook\_focus\_stream\_cursor\_value\_input input object.
-}
type alias Notebook_focus_stream_cursor_value_input =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , creatorId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , linkedTo : OptionalArgument String
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , theme : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Notebook\_focus\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeNotebook_focus_stream_cursor_value_input : Notebook_focus_stream_cursor_value_input -> Value
encodeNotebook_focus_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "creatorId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.creatorId ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "linkedTo", Encode.string |> Encode.optional input____.linkedTo ), ( "notebookId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.notebookId ), ( "theme", Encode.string |> Encode.optional input____.theme ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildNotebook_focus_updates :
    Notebook_focus_updatesRequiredFields
    -> (Notebook_focus_updatesOptionalFields -> Notebook_focus_updatesOptionalFields)
    -> Notebook_focus_updates
buildNotebook_focus_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Notebook_focus_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Notebook_focus_updatesRequiredFields =
    { where_ : Notebook_focus_bool_exp }


type alias Notebook_focus_updatesOptionalFields =
    { set_ : OptionalArgument Notebook_focus_set_input }


{-| Type alias for the `Notebook_focus_updates` attributes. Note that this type
needs to use the `Notebook_focus_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_focus_updatesRaw =
    { set_ : OptionalArgument Notebook_focus_set_input
    , where_ : Notebook_focus_bool_exp
    }


{-| Type for the Notebook\_focus\_updates input object.
-}
type Notebook_focus_updates
    = Notebook_focus_updates Notebook_focus_updatesRaw


{-| Encode a Notebook\_focus\_updates into a value that can be used as an argument.
-}
encodeNotebook_focus_updates : Notebook_focus_updates -> Value
encodeNotebook_focus_updates (Notebook_focus_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeNotebook_focus_set_input |> Encode.optional input____.set_ ), ( "where", encodeNotebook_focus_bool_exp input____.where_ |> Just ) ]


buildNotebook_info_bool_exp :
    (Notebook_info_bool_expOptionalFields -> Notebook_info_bool_expOptionalFields)
    -> Notebook_info_bool_exp
buildNotebook_info_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, createdAt = Absent, needOrientation = Absent, notebook = Absent, notebookId = Absent, orientationReason = Absent, orientationSystem = Absent, orientationSystemId = Absent, updatedAt = Absent }
    in
    Notebook_info_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, createdAt = optionals____.createdAt, needOrientation = optionals____.needOrientation, notebook = optionals____.notebook, notebookId = optionals____.notebookId, orientationReason = optionals____.orientationReason, orientationSystem = optionals____.orientationSystem, orientationSystemId = optionals____.orientationSystemId, updatedAt = optionals____.updatedAt }


type alias Notebook_info_bool_expOptionalFields =
    { and_ : OptionalArgument (List Notebook_info_bool_exp)
    , not_ : OptionalArgument Notebook_info_bool_exp
    , or_ : OptionalArgument (List Notebook_info_bool_exp)
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , needOrientation : OptionalArgument Boolean_comparison_exp
    , notebook : OptionalArgument Notebook_bool_exp
    , notebookId : OptionalArgument Uuid_comparison_exp
    , orientationReason : OptionalArgument String_comparison_exp
    , orientationSystem : OptionalArgument Orientation_system_bool_exp
    , orientationSystemId : OptionalArgument Uuid_comparison_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type alias for the `Notebook_info_bool_exp` attributes. Note that this type
needs to use the `Notebook_info_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_info_bool_expRaw =
    { and_ : OptionalArgument (List Notebook_info_bool_exp)
    , not_ : OptionalArgument Notebook_info_bool_exp
    , or_ : OptionalArgument (List Notebook_info_bool_exp)
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , needOrientation : OptionalArgument Boolean_comparison_exp
    , notebook : OptionalArgument Notebook_bool_exp
    , notebookId : OptionalArgument Uuid_comparison_exp
    , orientationReason : OptionalArgument String_comparison_exp
    , orientationSystem : OptionalArgument Orientation_system_bool_exp
    , orientationSystemId : OptionalArgument Uuid_comparison_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type for the Notebook\_info\_bool\_exp input object.
-}
type Notebook_info_bool_exp
    = Notebook_info_bool_exp Notebook_info_bool_expRaw


{-| Encode a Notebook\_info\_bool\_exp into a value that can be used as an argument.
-}
encodeNotebook_info_bool_exp : Notebook_info_bool_exp -> Value
encodeNotebook_info_bool_exp (Notebook_info_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeNotebook_info_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeNotebook_info_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeNotebook_info_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "createdAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.createdAt ), ( "needOrientation", encodeBoolean_comparison_exp |> Encode.optional input____.needOrientation ), ( "notebook", encodeNotebook_bool_exp |> Encode.optional input____.notebook ), ( "notebookId", encodeUuid_comparison_exp |> Encode.optional input____.notebookId ), ( "orientationReason", encodeString_comparison_exp |> Encode.optional input____.orientationReason ), ( "orientationSystem", encodeOrientation_system_bool_exp |> Encode.optional input____.orientationSystem ), ( "orientationSystemId", encodeUuid_comparison_exp |> Encode.optional input____.orientationSystemId ), ( "updatedAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.updatedAt ) ]


buildNotebook_info_insert_input :
    (Notebook_info_insert_inputOptionalFields -> Notebook_info_insert_inputOptionalFields)
    -> Notebook_info_insert_input
buildNotebook_info_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, needOrientation = Absent, notebook = Absent, notebookId = Absent, orientationReason = Absent, orientationSystem = Absent, orientationSystemId = Absent, updatedAt = Absent }
    in
    Notebook_info_insert_input { createdAt = optionals____.createdAt, needOrientation = optionals____.needOrientation, notebook = optionals____.notebook, notebookId = optionals____.notebookId, orientationReason = optionals____.orientationReason, orientationSystem = optionals____.orientationSystem, orientationSystemId = optionals____.orientationSystemId, updatedAt = optionals____.updatedAt }


type alias Notebook_info_insert_inputOptionalFields =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , needOrientation : OptionalArgument Bool
    , notebook : OptionalArgument Notebook_obj_rel_insert_input
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , orientationReason : OptionalArgument String
    , orientationSystem : OptionalArgument Orientation_system_obj_rel_insert_input
    , orientationSystemId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type alias for the `Notebook_info_insert_input` attributes. Note that this type
needs to use the `Notebook_info_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_info_insert_inputRaw =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , needOrientation : OptionalArgument Bool
    , notebook : OptionalArgument Notebook_obj_rel_insert_input
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , orientationReason : OptionalArgument String
    , orientationSystem : OptionalArgument Orientation_system_obj_rel_insert_input
    , orientationSystemId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Notebook\_info\_insert\_input input object.
-}
type Notebook_info_insert_input
    = Notebook_info_insert_input Notebook_info_insert_inputRaw


{-| Encode a Notebook\_info\_insert\_input into a value that can be used as an argument.
-}
encodeNotebook_info_insert_input : Notebook_info_insert_input -> Value
encodeNotebook_info_insert_input (Notebook_info_insert_input input____) =
    Encode.maybeObject
        [ ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "needOrientation", Encode.bool |> Encode.optional input____.needOrientation ), ( "notebook", encodeNotebook_obj_rel_insert_input |> Encode.optional input____.notebook ), ( "notebookId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.notebookId ), ( "orientationReason", Encode.string |> Encode.optional input____.orientationReason ), ( "orientationSystem", encodeOrientation_system_obj_rel_insert_input |> Encode.optional input____.orientationSystem ), ( "orientationSystemId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.orientationSystemId ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildNotebook_info_obj_rel_insert_input :
    Notebook_info_obj_rel_insert_inputRequiredFields
    -> (Notebook_info_obj_rel_insert_inputOptionalFields -> Notebook_info_obj_rel_insert_inputOptionalFields)
    -> Notebook_info_obj_rel_insert_input
buildNotebook_info_obj_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Notebook_info_obj_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Notebook_info_obj_rel_insert_inputRequiredFields =
    { data : Notebook_info_insert_input }


type alias Notebook_info_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Notebook_info_on_conflict }


{-| Type alias for the `Notebook_info_obj_rel_insert_input` attributes. Note that this type
needs to use the `Notebook_info_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_info_obj_rel_insert_inputRaw =
    { data : Notebook_info_insert_input
    , on_conflict : OptionalArgument Notebook_info_on_conflict
    }


{-| Type for the Notebook\_info\_obj\_rel\_insert\_input input object.
-}
type Notebook_info_obj_rel_insert_input
    = Notebook_info_obj_rel_insert_input Notebook_info_obj_rel_insert_inputRaw


{-| Encode a Notebook\_info\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeNotebook_info_obj_rel_insert_input : Notebook_info_obj_rel_insert_input -> Value
encodeNotebook_info_obj_rel_insert_input (Notebook_info_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeNotebook_info_insert_input input____.data |> Just ), ( "on_conflict", encodeNotebook_info_on_conflict |> Encode.optional input____.on_conflict ) ]


buildNotebook_info_on_conflict :
    Notebook_info_on_conflictRequiredFields
    -> (Notebook_info_on_conflictOptionalFields -> Notebook_info_on_conflictOptionalFields)
    -> Notebook_info_on_conflict
buildNotebook_info_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Notebook_info_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Notebook_info_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Notebook_info_constraint.Notebook_info_constraint
    , update_columns : List CdbGQL.Enum.Notebook_info_update_column.Notebook_info_update_column
    }


type alias Notebook_info_on_conflictOptionalFields =
    { where_ : OptionalArgument Notebook_info_bool_exp }


{-| Type alias for the `Notebook_info_on_conflict` attributes. Note that this type
needs to use the `Notebook_info_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_info_on_conflictRaw =
    { constraint : CdbGQL.Enum.Notebook_info_constraint.Notebook_info_constraint
    , update_columns : List CdbGQL.Enum.Notebook_info_update_column.Notebook_info_update_column
    , where_ : OptionalArgument Notebook_info_bool_exp
    }


{-| Type for the Notebook\_info\_on\_conflict input object.
-}
type Notebook_info_on_conflict
    = Notebook_info_on_conflict Notebook_info_on_conflictRaw


{-| Encode a Notebook\_info\_on\_conflict into a value that can be used as an argument.
-}
encodeNotebook_info_on_conflict : Notebook_info_on_conflict -> Value
encodeNotebook_info_on_conflict (Notebook_info_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Notebook_info_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Notebook_info_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeNotebook_info_bool_exp |> Encode.optional input____.where_ ) ]


buildNotebook_info_order_by :
    (Notebook_info_order_byOptionalFields -> Notebook_info_order_byOptionalFields)
    -> Notebook_info_order_by
buildNotebook_info_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, needOrientation = Absent, notebook = Absent, notebookId = Absent, orientationReason = Absent, orientationSystem = Absent, orientationSystemId = Absent, updatedAt = Absent }
    in
    Notebook_info_order_by { createdAt = optionals____.createdAt, needOrientation = optionals____.needOrientation, notebook = optionals____.notebook, notebookId = optionals____.notebookId, orientationReason = optionals____.orientationReason, orientationSystem = optionals____.orientationSystem, orientationSystemId = optionals____.orientationSystemId, updatedAt = optionals____.updatedAt }


type alias Notebook_info_order_byOptionalFields =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , needOrientation : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebook : OptionalArgument Notebook_order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationReason : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationSystem : OptionalArgument Orientation_system_order_by
    , orientationSystemId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type alias for the `Notebook_info_order_by` attributes. Note that this type
needs to use the `Notebook_info_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_info_order_byRaw =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , needOrientation : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebook : OptionalArgument Notebook_order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationReason : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationSystem : OptionalArgument Orientation_system_order_by
    , orientationSystemId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Notebook\_info\_order\_by input object.
-}
type Notebook_info_order_by
    = Notebook_info_order_by Notebook_info_order_byRaw


{-| Encode a Notebook\_info\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_info_order_by : Notebook_info_order_by -> Value
encodeNotebook_info_order_by (Notebook_info_order_by input____) =
    Encode.maybeObject
        [ ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "needOrientation", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.needOrientation ), ( "notebook", encodeNotebook_order_by |> Encode.optional input____.notebook ), ( "notebookId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.notebookId ), ( "orientationReason", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.orientationReason ), ( "orientationSystem", encodeOrientation_system_order_by |> Encode.optional input____.orientationSystem ), ( "orientationSystemId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.orientationSystemId ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildNotebook_info_pk_columns_input :
    Notebook_info_pk_columns_inputRequiredFields
    -> Notebook_info_pk_columns_input
buildNotebook_info_pk_columns_input required____ =
    { notebookId = required____.notebookId }


type alias Notebook_info_pk_columns_inputRequiredFields =
    { notebookId : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the Notebook\_info\_pk\_columns\_input input object.
-}
type alias Notebook_info_pk_columns_input =
    { notebookId : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a Notebook\_info\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeNotebook_info_pk_columns_input : Notebook_info_pk_columns_input -> Value
encodeNotebook_info_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "notebookId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.notebookId |> Just ) ]


buildNotebook_info_set_input :
    (Notebook_info_set_inputOptionalFields -> Notebook_info_set_inputOptionalFields)
    -> Notebook_info_set_input
buildNotebook_info_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, needOrientation = Absent, notebookId = Absent, orientationReason = Absent, orientationSystemId = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, needOrientation = optionals____.needOrientation, notebookId = optionals____.notebookId, orientationReason = optionals____.orientationReason, orientationSystemId = optionals____.orientationSystemId, updatedAt = optionals____.updatedAt }


type alias Notebook_info_set_inputOptionalFields =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , needOrientation : OptionalArgument Bool
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , orientationReason : OptionalArgument String
    , orientationSystemId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Notebook\_info\_set\_input input object.
-}
type alias Notebook_info_set_input =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , needOrientation : OptionalArgument Bool
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , orientationReason : OptionalArgument String
    , orientationSystemId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Notebook\_info\_set\_input into a value that can be used as an argument.
-}
encodeNotebook_info_set_input : Notebook_info_set_input -> Value
encodeNotebook_info_set_input input____ =
    Encode.maybeObject
        [ ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "needOrientation", Encode.bool |> Encode.optional input____.needOrientation ), ( "notebookId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.notebookId ), ( "orientationReason", Encode.string |> Encode.optional input____.orientationReason ), ( "orientationSystemId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.orientationSystemId ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildNotebook_info_stream_cursor_input :
    Notebook_info_stream_cursor_inputRequiredFields
    -> (Notebook_info_stream_cursor_inputOptionalFields -> Notebook_info_stream_cursor_inputOptionalFields)
    -> Notebook_info_stream_cursor_input
buildNotebook_info_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Notebook_info_stream_cursor_inputRequiredFields =
    { initial_value : Notebook_info_stream_cursor_value_input }


type alias Notebook_info_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Notebook\_info\_stream\_cursor\_input input object.
-}
type alias Notebook_info_stream_cursor_input =
    { initial_value : Notebook_info_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Notebook\_info\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeNotebook_info_stream_cursor_input : Notebook_info_stream_cursor_input -> Value
encodeNotebook_info_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeNotebook_info_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildNotebook_info_stream_cursor_value_input :
    (Notebook_info_stream_cursor_value_inputOptionalFields -> Notebook_info_stream_cursor_value_inputOptionalFields)
    -> Notebook_info_stream_cursor_value_input
buildNotebook_info_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, needOrientation = Absent, notebookId = Absent, orientationReason = Absent, orientationSystemId = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, needOrientation = optionals____.needOrientation, notebookId = optionals____.notebookId, orientationReason = optionals____.orientationReason, orientationSystemId = optionals____.orientationSystemId, updatedAt = optionals____.updatedAt }


type alias Notebook_info_stream_cursor_value_inputOptionalFields =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , needOrientation : OptionalArgument Bool
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , orientationReason : OptionalArgument String
    , orientationSystemId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Notebook\_info\_stream\_cursor\_value\_input input object.
-}
type alias Notebook_info_stream_cursor_value_input =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , needOrientation : OptionalArgument Bool
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , orientationReason : OptionalArgument String
    , orientationSystemId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Notebook\_info\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeNotebook_info_stream_cursor_value_input : Notebook_info_stream_cursor_value_input -> Value
encodeNotebook_info_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "needOrientation", Encode.bool |> Encode.optional input____.needOrientation ), ( "notebookId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.notebookId ), ( "orientationReason", Encode.string |> Encode.optional input____.orientationReason ), ( "orientationSystemId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.orientationSystemId ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildNotebook_info_updates :
    Notebook_info_updatesRequiredFields
    -> (Notebook_info_updatesOptionalFields -> Notebook_info_updatesOptionalFields)
    -> Notebook_info_updates
buildNotebook_info_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Notebook_info_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Notebook_info_updatesRequiredFields =
    { where_ : Notebook_info_bool_exp }


type alias Notebook_info_updatesOptionalFields =
    { set_ : OptionalArgument Notebook_info_set_input }


{-| Type alias for the `Notebook_info_updates` attributes. Note that this type
needs to use the `Notebook_info_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_info_updatesRaw =
    { set_ : OptionalArgument Notebook_info_set_input
    , where_ : Notebook_info_bool_exp
    }


{-| Type for the Notebook\_info\_updates input object.
-}
type Notebook_info_updates
    = Notebook_info_updates Notebook_info_updatesRaw


{-| Encode a Notebook\_info\_updates into a value that can be used as an argument.
-}
encodeNotebook_info_updates : Notebook_info_updates -> Value
encodeNotebook_info_updates (Notebook_info_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeNotebook_info_set_input |> Encode.optional input____.set_ ), ( "where", encodeNotebook_info_bool_exp input____.where_ |> Just ) ]


buildNotebook_insert_input :
    (Notebook_insert_inputOptionalFields -> Notebook_insert_inputOptionalFields)
    -> Notebook_insert_input
buildNotebook_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { appointments = Absent, beneficiary = Absent, beneficiaryId = Absent, contractEndDate = Absent, contractSignDate = Absent, contractStartDate = Absent, contractType = Absent, createdAt = Absent, educationLevel = Absent, events = Absent, focuses = Absent, id = Absent, lastJobEndedAt = Absent, members = Absent, notebookInfo = Absent, professionalProjects = Absent, rightRqth = Absent, situations = Absent, updatedAt = Absent, workSituation = Absent, workSituationDate = Absent, workSituationEndDate = Absent }
    in
    Notebook_insert_input { appointments = optionals____.appointments, beneficiary = optionals____.beneficiary, beneficiaryId = optionals____.beneficiaryId, contractEndDate = optionals____.contractEndDate, contractSignDate = optionals____.contractSignDate, contractStartDate = optionals____.contractStartDate, contractType = optionals____.contractType, createdAt = optionals____.createdAt, educationLevel = optionals____.educationLevel, events = optionals____.events, focuses = optionals____.focuses, id = optionals____.id, lastJobEndedAt = optionals____.lastJobEndedAt, members = optionals____.members, notebookInfo = optionals____.notebookInfo, professionalProjects = optionals____.professionalProjects, rightRqth = optionals____.rightRqth, situations = optionals____.situations, updatedAt = optionals____.updatedAt, workSituation = optionals____.workSituation, workSituationDate = optionals____.workSituationDate, workSituationEndDate = optionals____.workSituationEndDate }


type alias Notebook_insert_inputOptionalFields =
    { appointments : OptionalArgument Notebook_appointment_arr_rel_insert_input
    , beneficiary : OptionalArgument Beneficiary_obj_rel_insert_input
    , beneficiaryId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , contractEndDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    , contractSignDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    , contractStartDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    , contractType : OptionalArgument String
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , educationLevel : OptionalArgument String
    , events : OptionalArgument Notebook_event_arr_rel_insert_input
    , focuses : OptionalArgument Notebook_focus_arr_rel_insert_input
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastJobEndedAt : OptionalArgument CdbGQL.ScalarCodecs.Date
    , members : OptionalArgument Notebook_member_arr_rel_insert_input
    , notebookInfo : OptionalArgument Notebook_info_obj_rel_insert_input
    , professionalProjects : OptionalArgument Professional_project_arr_rel_insert_input
    , rightRqth : OptionalArgument Bool
    , situations : OptionalArgument Notebook_situation_arr_rel_insert_input
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , workSituation : OptionalArgument String
    , workSituationDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    , workSituationEndDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    }


{-| Type alias for the `Notebook_insert_input` attributes. Note that this type
needs to use the `Notebook_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_insert_inputRaw =
    { appointments : OptionalArgument Notebook_appointment_arr_rel_insert_input
    , beneficiary : OptionalArgument Beneficiary_obj_rel_insert_input
    , beneficiaryId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , contractEndDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    , contractSignDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    , contractStartDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    , contractType : OptionalArgument String
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , educationLevel : OptionalArgument String
    , events : OptionalArgument Notebook_event_arr_rel_insert_input
    , focuses : OptionalArgument Notebook_focus_arr_rel_insert_input
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastJobEndedAt : OptionalArgument CdbGQL.ScalarCodecs.Date
    , members : OptionalArgument Notebook_member_arr_rel_insert_input
    , notebookInfo : OptionalArgument Notebook_info_obj_rel_insert_input
    , professionalProjects : OptionalArgument Professional_project_arr_rel_insert_input
    , rightRqth : OptionalArgument Bool
    , situations : OptionalArgument Notebook_situation_arr_rel_insert_input
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , workSituation : OptionalArgument String
    , workSituationDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    , workSituationEndDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    }


{-| Type for the Notebook\_insert\_input input object.
-}
type Notebook_insert_input
    = Notebook_insert_input Notebook_insert_inputRaw


{-| Encode a Notebook\_insert\_input into a value that can be used as an argument.
-}
encodeNotebook_insert_input : Notebook_insert_input -> Value
encodeNotebook_insert_input (Notebook_insert_input input____) =
    Encode.maybeObject
        [ ( "appointments", encodeNotebook_appointment_arr_rel_insert_input |> Encode.optional input____.appointments ), ( "beneficiary", encodeBeneficiary_obj_rel_insert_input |> Encode.optional input____.beneficiary ), ( "beneficiaryId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.beneficiaryId ), ( "contractEndDate", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.contractEndDate ), ( "contractSignDate", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.contractSignDate ), ( "contractStartDate", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.contractStartDate ), ( "contractType", Encode.string |> Encode.optional input____.contractType ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "educationLevel", Encode.string |> Encode.optional input____.educationLevel ), ( "events", encodeNotebook_event_arr_rel_insert_input |> Encode.optional input____.events ), ( "focuses", encodeNotebook_focus_arr_rel_insert_input |> Encode.optional input____.focuses ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "lastJobEndedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.lastJobEndedAt ), ( "members", encodeNotebook_member_arr_rel_insert_input |> Encode.optional input____.members ), ( "notebookInfo", encodeNotebook_info_obj_rel_insert_input |> Encode.optional input____.notebookInfo ), ( "professionalProjects", encodeProfessional_project_arr_rel_insert_input |> Encode.optional input____.professionalProjects ), ( "rightRqth", Encode.bool |> Encode.optional input____.rightRqth ), ( "situations", encodeNotebook_situation_arr_rel_insert_input |> Encode.optional input____.situations ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ), ( "workSituation", Encode.string |> Encode.optional input____.workSituation ), ( "workSituationDate", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.workSituationDate ), ( "workSituationEndDate", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.workSituationEndDate ) ]


buildNotebook_member_aggregate_bool_exp :
    (Notebook_member_aggregate_bool_expOptionalFields -> Notebook_member_aggregate_bool_expOptionalFields)
    -> Notebook_member_aggregate_bool_exp
buildNotebook_member_aggregate_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { bool_and = Absent, bool_or = Absent, count = Absent }
    in
    Notebook_member_aggregate_bool_exp { bool_and = optionals____.bool_and, bool_or = optionals____.bool_or, count = optionals____.count }


type alias Notebook_member_aggregate_bool_expOptionalFields =
    { bool_and : OptionalArgument Notebook_member_aggregate_bool_exp_bool_and
    , bool_or : OptionalArgument Notebook_member_aggregate_bool_exp_bool_or
    , count : OptionalArgument Notebook_member_aggregate_bool_exp_count
    }


{-| Type alias for the `Notebook_member_aggregate_bool_exp` attributes. Note that this type
needs to use the `Notebook_member_aggregate_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_member_aggregate_bool_expRaw =
    { bool_and : OptionalArgument Notebook_member_aggregate_bool_exp_bool_and
    , bool_or : OptionalArgument Notebook_member_aggregate_bool_exp_bool_or
    , count : OptionalArgument Notebook_member_aggregate_bool_exp_count
    }


{-| Type for the Notebook\_member\_aggregate\_bool\_exp input object.
-}
type Notebook_member_aggregate_bool_exp
    = Notebook_member_aggregate_bool_exp Notebook_member_aggregate_bool_expRaw


{-| Encode a Notebook\_member\_aggregate\_bool\_exp into a value that can be used as an argument.
-}
encodeNotebook_member_aggregate_bool_exp : Notebook_member_aggregate_bool_exp -> Value
encodeNotebook_member_aggregate_bool_exp (Notebook_member_aggregate_bool_exp input____) =
    Encode.maybeObject
        [ ( "bool_and", encodeNotebook_member_aggregate_bool_exp_bool_and |> Encode.optional input____.bool_and ), ( "bool_or", encodeNotebook_member_aggregate_bool_exp_bool_or |> Encode.optional input____.bool_or ), ( "count", encodeNotebook_member_aggregate_bool_exp_count |> Encode.optional input____.count ) ]


buildNotebook_member_aggregate_bool_exp_bool_and :
    Notebook_member_aggregate_bool_exp_bool_andRequiredFields
    -> (Notebook_member_aggregate_bool_exp_bool_andOptionalFields -> Notebook_member_aggregate_bool_exp_bool_andOptionalFields)
    -> Notebook_member_aggregate_bool_exp_bool_and
buildNotebook_member_aggregate_bool_exp_bool_and required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { distinct = Absent, filter = Absent }
    in
    Notebook_member_aggregate_bool_exp_bool_and { arguments = required____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Notebook_member_aggregate_bool_exp_bool_andRequiredFields =
    { arguments : CdbGQL.Enum.Notebook_member_select_column_notebook_member_aggregate_bool_exp_bool_and_arguments_columns.Notebook_member_select_column_notebook_member_aggregate_bool_exp_bool_and_arguments_columns
    , predicate : Boolean_comparison_exp
    }


type alias Notebook_member_aggregate_bool_exp_bool_andOptionalFields =
    { distinct : OptionalArgument Bool
    , filter : OptionalArgument Notebook_member_bool_exp
    }


{-| Type alias for the `Notebook_member_aggregate_bool_exp_bool_and` attributes. Note that this type
needs to use the `Notebook_member_aggregate_bool_exp_bool_and` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_member_aggregate_bool_exp_bool_andRaw =
    { arguments : CdbGQL.Enum.Notebook_member_select_column_notebook_member_aggregate_bool_exp_bool_and_arguments_columns.Notebook_member_select_column_notebook_member_aggregate_bool_exp_bool_and_arguments_columns
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Notebook_member_bool_exp
    , predicate : Boolean_comparison_exp
    }


{-| Type for the Notebook\_member\_aggregate\_bool\_exp\_bool\_and input object.
-}
type Notebook_member_aggregate_bool_exp_bool_and
    = Notebook_member_aggregate_bool_exp_bool_and Notebook_member_aggregate_bool_exp_bool_andRaw


{-| Encode a Notebook\_member\_aggregate\_bool\_exp\_bool\_and into a value that can be used as an argument.
-}
encodeNotebook_member_aggregate_bool_exp_bool_and : Notebook_member_aggregate_bool_exp_bool_and -> Value
encodeNotebook_member_aggregate_bool_exp_bool_and (Notebook_member_aggregate_bool_exp_bool_and input____) =
    Encode.maybeObject
        [ ( "arguments", Encode.enum CdbGQL.Enum.Notebook_member_select_column_notebook_member_aggregate_bool_exp_bool_and_arguments_columns.toString input____.arguments |> Just ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeNotebook_member_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeBoolean_comparison_exp input____.predicate |> Just ) ]


buildNotebook_member_aggregate_bool_exp_bool_or :
    Notebook_member_aggregate_bool_exp_bool_orRequiredFields
    -> (Notebook_member_aggregate_bool_exp_bool_orOptionalFields -> Notebook_member_aggregate_bool_exp_bool_orOptionalFields)
    -> Notebook_member_aggregate_bool_exp_bool_or
buildNotebook_member_aggregate_bool_exp_bool_or required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { distinct = Absent, filter = Absent }
    in
    Notebook_member_aggregate_bool_exp_bool_or { arguments = required____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Notebook_member_aggregate_bool_exp_bool_orRequiredFields =
    { arguments : CdbGQL.Enum.Notebook_member_select_column_notebook_member_aggregate_bool_exp_bool_or_arguments_columns.Notebook_member_select_column_notebook_member_aggregate_bool_exp_bool_or_arguments_columns
    , predicate : Boolean_comparison_exp
    }


type alias Notebook_member_aggregate_bool_exp_bool_orOptionalFields =
    { distinct : OptionalArgument Bool
    , filter : OptionalArgument Notebook_member_bool_exp
    }


{-| Type alias for the `Notebook_member_aggregate_bool_exp_bool_or` attributes. Note that this type
needs to use the `Notebook_member_aggregate_bool_exp_bool_or` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_member_aggregate_bool_exp_bool_orRaw =
    { arguments : CdbGQL.Enum.Notebook_member_select_column_notebook_member_aggregate_bool_exp_bool_or_arguments_columns.Notebook_member_select_column_notebook_member_aggregate_bool_exp_bool_or_arguments_columns
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Notebook_member_bool_exp
    , predicate : Boolean_comparison_exp
    }


{-| Type for the Notebook\_member\_aggregate\_bool\_exp\_bool\_or input object.
-}
type Notebook_member_aggregate_bool_exp_bool_or
    = Notebook_member_aggregate_bool_exp_bool_or Notebook_member_aggregate_bool_exp_bool_orRaw


{-| Encode a Notebook\_member\_aggregate\_bool\_exp\_bool\_or into a value that can be used as an argument.
-}
encodeNotebook_member_aggregate_bool_exp_bool_or : Notebook_member_aggregate_bool_exp_bool_or -> Value
encodeNotebook_member_aggregate_bool_exp_bool_or (Notebook_member_aggregate_bool_exp_bool_or input____) =
    Encode.maybeObject
        [ ( "arguments", Encode.enum CdbGQL.Enum.Notebook_member_select_column_notebook_member_aggregate_bool_exp_bool_or_arguments_columns.toString input____.arguments |> Just ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeNotebook_member_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeBoolean_comparison_exp input____.predicate |> Just ) ]


buildNotebook_member_aggregate_bool_exp_count :
    Notebook_member_aggregate_bool_exp_countRequiredFields
    -> (Notebook_member_aggregate_bool_exp_countOptionalFields -> Notebook_member_aggregate_bool_exp_countOptionalFields)
    -> Notebook_member_aggregate_bool_exp_count
buildNotebook_member_aggregate_bool_exp_count required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { arguments = Absent, distinct = Absent, filter = Absent }
    in
    Notebook_member_aggregate_bool_exp_count { arguments = optionals____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Notebook_member_aggregate_bool_exp_countRequiredFields =
    { predicate : Int_comparison_exp }


type alias Notebook_member_aggregate_bool_exp_countOptionalFields =
    { arguments : OptionalArgument (List CdbGQL.Enum.Notebook_member_select_column.Notebook_member_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Notebook_member_bool_exp
    }


{-| Type alias for the `Notebook_member_aggregate_bool_exp_count` attributes. Note that this type
needs to use the `Notebook_member_aggregate_bool_exp_count` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_member_aggregate_bool_exp_countRaw =
    { arguments : OptionalArgument (List CdbGQL.Enum.Notebook_member_select_column.Notebook_member_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Notebook_member_bool_exp
    , predicate : Int_comparison_exp
    }


{-| Type for the Notebook\_member\_aggregate\_bool\_exp\_count input object.
-}
type Notebook_member_aggregate_bool_exp_count
    = Notebook_member_aggregate_bool_exp_count Notebook_member_aggregate_bool_exp_countRaw


{-| Encode a Notebook\_member\_aggregate\_bool\_exp\_count into a value that can be used as an argument.
-}
encodeNotebook_member_aggregate_bool_exp_count : Notebook_member_aggregate_bool_exp_count -> Value
encodeNotebook_member_aggregate_bool_exp_count (Notebook_member_aggregate_bool_exp_count input____) =
    Encode.maybeObject
        [ ( "arguments", (Encode.enum CdbGQL.Enum.Notebook_member_select_column.toString |> Encode.list) |> Encode.optional input____.arguments ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeNotebook_member_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeInt_comparison_exp input____.predicate |> Just ) ]


buildNotebook_member_aggregate_order_by :
    (Notebook_member_aggregate_order_byOptionalFields -> Notebook_member_aggregate_order_byOptionalFields)
    -> Notebook_member_aggregate_order_by
buildNotebook_member_aggregate_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals____.count, max = optionals____.max, min = optionals____.min }


type alias Notebook_member_aggregate_order_byOptionalFields =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Notebook_member_max_order_by
    , min : OptionalArgument Notebook_member_min_order_by
    }


{-| Type for the Notebook\_member\_aggregate\_order\_by input object.
-}
type alias Notebook_member_aggregate_order_by =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Notebook_member_max_order_by
    , min : OptionalArgument Notebook_member_min_order_by
    }


{-| Encode a Notebook\_member\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_member_aggregate_order_by : Notebook_member_aggregate_order_by -> Value
encodeNotebook_member_aggregate_order_by input____ =
    Encode.maybeObject
        [ ( "count", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.count ), ( "max", encodeNotebook_member_max_order_by |> Encode.optional input____.max ), ( "min", encodeNotebook_member_min_order_by |> Encode.optional input____.min ) ]


buildNotebook_member_arr_rel_insert_input :
    Notebook_member_arr_rel_insert_inputRequiredFields
    -> (Notebook_member_arr_rel_insert_inputOptionalFields -> Notebook_member_arr_rel_insert_inputOptionalFields)
    -> Notebook_member_arr_rel_insert_input
buildNotebook_member_arr_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Notebook_member_arr_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Notebook_member_arr_rel_insert_inputRequiredFields =
    { data : List Notebook_member_insert_input }


type alias Notebook_member_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Notebook_member_on_conflict }


{-| Type alias for the `Notebook_member_arr_rel_insert_input` attributes. Note that this type
needs to use the `Notebook_member_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_member_arr_rel_insert_inputRaw =
    { data : List Notebook_member_insert_input
    , on_conflict : OptionalArgument Notebook_member_on_conflict
    }


{-| Type for the Notebook\_member\_arr\_rel\_insert\_input input object.
-}
type Notebook_member_arr_rel_insert_input
    = Notebook_member_arr_rel_insert_input Notebook_member_arr_rel_insert_inputRaw


{-| Encode a Notebook\_member\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeNotebook_member_arr_rel_insert_input : Notebook_member_arr_rel_insert_input -> Value
encodeNotebook_member_arr_rel_insert_input (Notebook_member_arr_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", (encodeNotebook_member_insert_input |> Encode.list) input____.data |> Just ), ( "on_conflict", encodeNotebook_member_on_conflict |> Encode.optional input____.on_conflict ) ]


buildNotebook_member_bool_exp :
    (Notebook_member_bool_expOptionalFields -> Notebook_member_bool_expOptionalFields)
    -> Notebook_member_bool_exp
buildNotebook_member_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, account = Absent, accountId = Absent, active = Absent, createdAt = Absent, creator = Absent, creatorId = Absent, id = Absent, invitationSendAt = Absent, lastModifiedAt = Absent, lastVisitedAt = Absent, memberType = Absent, membershipEndedAt = Absent, notebook = Absent, notebookId = Absent }
    in
    Notebook_member_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, account = optionals____.account, accountId = optionals____.accountId, active = optionals____.active, createdAt = optionals____.createdAt, creator = optionals____.creator, creatorId = optionals____.creatorId, id = optionals____.id, invitationSendAt = optionals____.invitationSendAt, lastModifiedAt = optionals____.lastModifiedAt, lastVisitedAt = optionals____.lastVisitedAt, memberType = optionals____.memberType, membershipEndedAt = optionals____.membershipEndedAt, notebook = optionals____.notebook, notebookId = optionals____.notebookId }


type alias Notebook_member_bool_expOptionalFields =
    { and_ : OptionalArgument (List Notebook_member_bool_exp)
    , not_ : OptionalArgument Notebook_member_bool_exp
    , or_ : OptionalArgument (List Notebook_member_bool_exp)
    , account : OptionalArgument Account_bool_exp
    , accountId : OptionalArgument Uuid_comparison_exp
    , active : OptionalArgument Boolean_comparison_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , creator : OptionalArgument Account_bool_exp
    , creatorId : OptionalArgument Uuid_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , invitationSendAt : OptionalArgument Timestamptz_comparison_exp
    , lastModifiedAt : OptionalArgument Timestamptz_comparison_exp
    , lastVisitedAt : OptionalArgument Timestamptz_comparison_exp
    , memberType : OptionalArgument String_comparison_exp
    , membershipEndedAt : OptionalArgument Timestamptz_comparison_exp
    , notebook : OptionalArgument Notebook_bool_exp
    , notebookId : OptionalArgument Uuid_comparison_exp
    }


{-| Type alias for the `Notebook_member_bool_exp` attributes. Note that this type
needs to use the `Notebook_member_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_member_bool_expRaw =
    { and_ : OptionalArgument (List Notebook_member_bool_exp)
    , not_ : OptionalArgument Notebook_member_bool_exp
    , or_ : OptionalArgument (List Notebook_member_bool_exp)
    , account : OptionalArgument Account_bool_exp
    , accountId : OptionalArgument Uuid_comparison_exp
    , active : OptionalArgument Boolean_comparison_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , creator : OptionalArgument Account_bool_exp
    , creatorId : OptionalArgument Uuid_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , invitationSendAt : OptionalArgument Timestamptz_comparison_exp
    , lastModifiedAt : OptionalArgument Timestamptz_comparison_exp
    , lastVisitedAt : OptionalArgument Timestamptz_comparison_exp
    , memberType : OptionalArgument String_comparison_exp
    , membershipEndedAt : OptionalArgument Timestamptz_comparison_exp
    , notebook : OptionalArgument Notebook_bool_exp
    , notebookId : OptionalArgument Uuid_comparison_exp
    }


{-| Type for the Notebook\_member\_bool\_exp input object.
-}
type Notebook_member_bool_exp
    = Notebook_member_bool_exp Notebook_member_bool_expRaw


{-| Encode a Notebook\_member\_bool\_exp into a value that can be used as an argument.
-}
encodeNotebook_member_bool_exp : Notebook_member_bool_exp -> Value
encodeNotebook_member_bool_exp (Notebook_member_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeNotebook_member_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeNotebook_member_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeNotebook_member_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "account", encodeAccount_bool_exp |> Encode.optional input____.account ), ( "accountId", encodeUuid_comparison_exp |> Encode.optional input____.accountId ), ( "active", encodeBoolean_comparison_exp |> Encode.optional input____.active ), ( "createdAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.createdAt ), ( "creator", encodeAccount_bool_exp |> Encode.optional input____.creator ), ( "creatorId", encodeUuid_comparison_exp |> Encode.optional input____.creatorId ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "invitationSendAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.invitationSendAt ), ( "lastModifiedAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.lastModifiedAt ), ( "lastVisitedAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.lastVisitedAt ), ( "memberType", encodeString_comparison_exp |> Encode.optional input____.memberType ), ( "membershipEndedAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.membershipEndedAt ), ( "notebook", encodeNotebook_bool_exp |> Encode.optional input____.notebook ), ( "notebookId", encodeUuid_comparison_exp |> Encode.optional input____.notebookId ) ]


buildNotebook_member_insert_input :
    (Notebook_member_insert_inputOptionalFields -> Notebook_member_insert_inputOptionalFields)
    -> Notebook_member_insert_input
buildNotebook_member_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { account = Absent, accountId = Absent, active = Absent, createdAt = Absent, creator = Absent, creatorId = Absent, id = Absent, invitationSendAt = Absent, lastModifiedAt = Absent, lastVisitedAt = Absent, memberType = Absent, membershipEndedAt = Absent, notebook = Absent, notebookId = Absent }
    in
    Notebook_member_insert_input { account = optionals____.account, accountId = optionals____.accountId, active = optionals____.active, createdAt = optionals____.createdAt, creator = optionals____.creator, creatorId = optionals____.creatorId, id = optionals____.id, invitationSendAt = optionals____.invitationSendAt, lastModifiedAt = optionals____.lastModifiedAt, lastVisitedAt = optionals____.lastVisitedAt, memberType = optionals____.memberType, membershipEndedAt = optionals____.membershipEndedAt, notebook = optionals____.notebook, notebookId = optionals____.notebookId }


type alias Notebook_member_insert_inputOptionalFields =
    { account : OptionalArgument Account_obj_rel_insert_input
    , accountId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , active : OptionalArgument Bool
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , creator : OptionalArgument Account_obj_rel_insert_input
    , creatorId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , invitationSendAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , lastModifiedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , lastVisitedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , memberType : OptionalArgument String
    , membershipEndedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , notebook : OptionalArgument Notebook_obj_rel_insert_input
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Type alias for the `Notebook_member_insert_input` attributes. Note that this type
needs to use the `Notebook_member_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_member_insert_inputRaw =
    { account : OptionalArgument Account_obj_rel_insert_input
    , accountId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , active : OptionalArgument Bool
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , creator : OptionalArgument Account_obj_rel_insert_input
    , creatorId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , invitationSendAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , lastModifiedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , lastVisitedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , memberType : OptionalArgument String
    , membershipEndedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , notebook : OptionalArgument Notebook_obj_rel_insert_input
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Type for the Notebook\_member\_insert\_input input object.
-}
type Notebook_member_insert_input
    = Notebook_member_insert_input Notebook_member_insert_inputRaw


{-| Encode a Notebook\_member\_insert\_input into a value that can be used as an argument.
-}
encodeNotebook_member_insert_input : Notebook_member_insert_input -> Value
encodeNotebook_member_insert_input (Notebook_member_insert_input input____) =
    Encode.maybeObject
        [ ( "account", encodeAccount_obj_rel_insert_input |> Encode.optional input____.account ), ( "accountId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.accountId ), ( "active", Encode.bool |> Encode.optional input____.active ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "creator", encodeAccount_obj_rel_insert_input |> Encode.optional input____.creator ), ( "creatorId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.creatorId ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "invitationSendAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.invitationSendAt ), ( "lastModifiedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.lastModifiedAt ), ( "lastVisitedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.lastVisitedAt ), ( "memberType", Encode.string |> Encode.optional input____.memberType ), ( "membershipEndedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.membershipEndedAt ), ( "notebook", encodeNotebook_obj_rel_insert_input |> Encode.optional input____.notebook ), ( "notebookId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.notebookId ) ]


buildNotebook_member_max_order_by :
    (Notebook_member_max_order_byOptionalFields -> Notebook_member_max_order_byOptionalFields)
    -> Notebook_member_max_order_by
buildNotebook_member_max_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { accountId = Absent, createdAt = Absent, creatorId = Absent, id = Absent, invitationSendAt = Absent, lastModifiedAt = Absent, lastVisitedAt = Absent, memberType = Absent, membershipEndedAt = Absent, notebookId = Absent }
    in
    { accountId = optionals____.accountId, createdAt = optionals____.createdAt, creatorId = optionals____.creatorId, id = optionals____.id, invitationSendAt = optionals____.invitationSendAt, lastModifiedAt = optionals____.lastModifiedAt, lastVisitedAt = optionals____.lastVisitedAt, memberType = optionals____.memberType, membershipEndedAt = optionals____.membershipEndedAt, notebookId = optionals____.notebookId }


type alias Notebook_member_max_order_byOptionalFields =
    { accountId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creatorId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , invitationSendAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastModifiedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastVisitedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , memberType : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , membershipEndedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Notebook\_member\_max\_order\_by input object.
-}
type alias Notebook_member_max_order_by =
    { accountId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creatorId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , invitationSendAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastModifiedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastVisitedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , memberType : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , membershipEndedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Notebook\_member\_max\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_member_max_order_by : Notebook_member_max_order_by -> Value
encodeNotebook_member_max_order_by input____ =
    Encode.maybeObject
        [ ( "accountId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.accountId ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "creatorId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.creatorId ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "invitationSendAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.invitationSendAt ), ( "lastModifiedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.lastModifiedAt ), ( "lastVisitedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.lastVisitedAt ), ( "memberType", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.memberType ), ( "membershipEndedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.membershipEndedAt ), ( "notebookId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.notebookId ) ]


buildNotebook_member_min_order_by :
    (Notebook_member_min_order_byOptionalFields -> Notebook_member_min_order_byOptionalFields)
    -> Notebook_member_min_order_by
buildNotebook_member_min_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { accountId = Absent, createdAt = Absent, creatorId = Absent, id = Absent, invitationSendAt = Absent, lastModifiedAt = Absent, lastVisitedAt = Absent, memberType = Absent, membershipEndedAt = Absent, notebookId = Absent }
    in
    { accountId = optionals____.accountId, createdAt = optionals____.createdAt, creatorId = optionals____.creatorId, id = optionals____.id, invitationSendAt = optionals____.invitationSendAt, lastModifiedAt = optionals____.lastModifiedAt, lastVisitedAt = optionals____.lastVisitedAt, memberType = optionals____.memberType, membershipEndedAt = optionals____.membershipEndedAt, notebookId = optionals____.notebookId }


type alias Notebook_member_min_order_byOptionalFields =
    { accountId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creatorId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , invitationSendAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastModifiedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastVisitedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , memberType : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , membershipEndedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Notebook\_member\_min\_order\_by input object.
-}
type alias Notebook_member_min_order_by =
    { accountId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creatorId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , invitationSendAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastModifiedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastVisitedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , memberType : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , membershipEndedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Notebook\_member\_min\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_member_min_order_by : Notebook_member_min_order_by -> Value
encodeNotebook_member_min_order_by input____ =
    Encode.maybeObject
        [ ( "accountId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.accountId ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "creatorId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.creatorId ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "invitationSendAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.invitationSendAt ), ( "lastModifiedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.lastModifiedAt ), ( "lastVisitedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.lastVisitedAt ), ( "memberType", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.memberType ), ( "membershipEndedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.membershipEndedAt ), ( "notebookId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.notebookId ) ]


buildNotebook_member_on_conflict :
    Notebook_member_on_conflictRequiredFields
    -> (Notebook_member_on_conflictOptionalFields -> Notebook_member_on_conflictOptionalFields)
    -> Notebook_member_on_conflict
buildNotebook_member_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Notebook_member_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Notebook_member_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Notebook_member_constraint.Notebook_member_constraint
    , update_columns : List CdbGQL.Enum.Notebook_member_update_column.Notebook_member_update_column
    }


type alias Notebook_member_on_conflictOptionalFields =
    { where_ : OptionalArgument Notebook_member_bool_exp }


{-| Type alias for the `Notebook_member_on_conflict` attributes. Note that this type
needs to use the `Notebook_member_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_member_on_conflictRaw =
    { constraint : CdbGQL.Enum.Notebook_member_constraint.Notebook_member_constraint
    , update_columns : List CdbGQL.Enum.Notebook_member_update_column.Notebook_member_update_column
    , where_ : OptionalArgument Notebook_member_bool_exp
    }


{-| Type for the Notebook\_member\_on\_conflict input object.
-}
type Notebook_member_on_conflict
    = Notebook_member_on_conflict Notebook_member_on_conflictRaw


{-| Encode a Notebook\_member\_on\_conflict into a value that can be used as an argument.
-}
encodeNotebook_member_on_conflict : Notebook_member_on_conflict -> Value
encodeNotebook_member_on_conflict (Notebook_member_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Notebook_member_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Notebook_member_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeNotebook_member_bool_exp |> Encode.optional input____.where_ ) ]


buildNotebook_member_order_by :
    (Notebook_member_order_byOptionalFields -> Notebook_member_order_byOptionalFields)
    -> Notebook_member_order_by
buildNotebook_member_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { account = Absent, accountId = Absent, active = Absent, createdAt = Absent, creator = Absent, creatorId = Absent, id = Absent, invitationSendAt = Absent, lastModifiedAt = Absent, lastVisitedAt = Absent, memberType = Absent, membershipEndedAt = Absent, notebook = Absent, notebookId = Absent }
    in
    Notebook_member_order_by { account = optionals____.account, accountId = optionals____.accountId, active = optionals____.active, createdAt = optionals____.createdAt, creator = optionals____.creator, creatorId = optionals____.creatorId, id = optionals____.id, invitationSendAt = optionals____.invitationSendAt, lastModifiedAt = optionals____.lastModifiedAt, lastVisitedAt = optionals____.lastVisitedAt, memberType = optionals____.memberType, membershipEndedAt = optionals____.membershipEndedAt, notebook = optionals____.notebook, notebookId = optionals____.notebookId }


type alias Notebook_member_order_byOptionalFields =
    { account : OptionalArgument Account_order_by
    , accountId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , active : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creator : OptionalArgument Account_order_by
    , creatorId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , invitationSendAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastModifiedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastVisitedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , memberType : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , membershipEndedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebook : OptionalArgument Notebook_order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type alias for the `Notebook_member_order_by` attributes. Note that this type
needs to use the `Notebook_member_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_member_order_byRaw =
    { account : OptionalArgument Account_order_by
    , accountId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , active : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creator : OptionalArgument Account_order_by
    , creatorId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , invitationSendAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastModifiedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastVisitedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , memberType : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , membershipEndedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebook : OptionalArgument Notebook_order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Notebook\_member\_order\_by input object.
-}
type Notebook_member_order_by
    = Notebook_member_order_by Notebook_member_order_byRaw


{-| Encode a Notebook\_member\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_member_order_by : Notebook_member_order_by -> Value
encodeNotebook_member_order_by (Notebook_member_order_by input____) =
    Encode.maybeObject
        [ ( "account", encodeAccount_order_by |> Encode.optional input____.account ), ( "accountId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.accountId ), ( "active", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.active ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "creator", encodeAccount_order_by |> Encode.optional input____.creator ), ( "creatorId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.creatorId ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "invitationSendAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.invitationSendAt ), ( "lastModifiedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.lastModifiedAt ), ( "lastVisitedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.lastVisitedAt ), ( "memberType", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.memberType ), ( "membershipEndedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.membershipEndedAt ), ( "notebook", encodeNotebook_order_by |> Encode.optional input____.notebook ), ( "notebookId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.notebookId ) ]


buildNotebook_member_pk_columns_input :
    Notebook_member_pk_columns_inputRequiredFields
    -> Notebook_member_pk_columns_input
buildNotebook_member_pk_columns_input required____ =
    { id = required____.id }


type alias Notebook_member_pk_columns_inputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the Notebook\_member\_pk\_columns\_input input object.
-}
type alias Notebook_member_pk_columns_input =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a Notebook\_member\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeNotebook_member_pk_columns_input : Notebook_member_pk_columns_input -> Value
encodeNotebook_member_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildNotebook_member_set_input :
    (Notebook_member_set_inputOptionalFields -> Notebook_member_set_inputOptionalFields)
    -> Notebook_member_set_input
buildNotebook_member_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { accountId = Absent, active = Absent, createdAt = Absent, creatorId = Absent, id = Absent, invitationSendAt = Absent, lastModifiedAt = Absent, lastVisitedAt = Absent, memberType = Absent, membershipEndedAt = Absent, notebookId = Absent }
    in
    { accountId = optionals____.accountId, active = optionals____.active, createdAt = optionals____.createdAt, creatorId = optionals____.creatorId, id = optionals____.id, invitationSendAt = optionals____.invitationSendAt, lastModifiedAt = optionals____.lastModifiedAt, lastVisitedAt = optionals____.lastVisitedAt, memberType = optionals____.memberType, membershipEndedAt = optionals____.membershipEndedAt, notebookId = optionals____.notebookId }


type alias Notebook_member_set_inputOptionalFields =
    { accountId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , active : OptionalArgument Bool
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , creatorId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , invitationSendAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , lastModifiedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , lastVisitedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , memberType : OptionalArgument String
    , membershipEndedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Type for the Notebook\_member\_set\_input input object.
-}
type alias Notebook_member_set_input =
    { accountId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , active : OptionalArgument Bool
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , creatorId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , invitationSendAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , lastModifiedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , lastVisitedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , memberType : OptionalArgument String
    , membershipEndedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Encode a Notebook\_member\_set\_input into a value that can be used as an argument.
-}
encodeNotebook_member_set_input : Notebook_member_set_input -> Value
encodeNotebook_member_set_input input____ =
    Encode.maybeObject
        [ ( "accountId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.accountId ), ( "active", Encode.bool |> Encode.optional input____.active ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "creatorId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.creatorId ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "invitationSendAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.invitationSendAt ), ( "lastModifiedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.lastModifiedAt ), ( "lastVisitedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.lastVisitedAt ), ( "memberType", Encode.string |> Encode.optional input____.memberType ), ( "membershipEndedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.membershipEndedAt ), ( "notebookId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.notebookId ) ]


buildNotebook_member_stream_cursor_input :
    Notebook_member_stream_cursor_inputRequiredFields
    -> (Notebook_member_stream_cursor_inputOptionalFields -> Notebook_member_stream_cursor_inputOptionalFields)
    -> Notebook_member_stream_cursor_input
buildNotebook_member_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Notebook_member_stream_cursor_inputRequiredFields =
    { initial_value : Notebook_member_stream_cursor_value_input }


type alias Notebook_member_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Notebook\_member\_stream\_cursor\_input input object.
-}
type alias Notebook_member_stream_cursor_input =
    { initial_value : Notebook_member_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Notebook\_member\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeNotebook_member_stream_cursor_input : Notebook_member_stream_cursor_input -> Value
encodeNotebook_member_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeNotebook_member_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildNotebook_member_stream_cursor_value_input :
    (Notebook_member_stream_cursor_value_inputOptionalFields -> Notebook_member_stream_cursor_value_inputOptionalFields)
    -> Notebook_member_stream_cursor_value_input
buildNotebook_member_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { accountId = Absent, active = Absent, createdAt = Absent, creatorId = Absent, id = Absent, invitationSendAt = Absent, lastModifiedAt = Absent, lastVisitedAt = Absent, memberType = Absent, membershipEndedAt = Absent, notebookId = Absent }
    in
    { accountId = optionals____.accountId, active = optionals____.active, createdAt = optionals____.createdAt, creatorId = optionals____.creatorId, id = optionals____.id, invitationSendAt = optionals____.invitationSendAt, lastModifiedAt = optionals____.lastModifiedAt, lastVisitedAt = optionals____.lastVisitedAt, memberType = optionals____.memberType, membershipEndedAt = optionals____.membershipEndedAt, notebookId = optionals____.notebookId }


type alias Notebook_member_stream_cursor_value_inputOptionalFields =
    { accountId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , active : OptionalArgument Bool
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , creatorId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , invitationSendAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , lastModifiedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , lastVisitedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , memberType : OptionalArgument String
    , membershipEndedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Type for the Notebook\_member\_stream\_cursor\_value\_input input object.
-}
type alias Notebook_member_stream_cursor_value_input =
    { accountId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , active : OptionalArgument Bool
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , creatorId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , invitationSendAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , lastModifiedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , lastVisitedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , memberType : OptionalArgument String
    , membershipEndedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Encode a Notebook\_member\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeNotebook_member_stream_cursor_value_input : Notebook_member_stream_cursor_value_input -> Value
encodeNotebook_member_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "accountId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.accountId ), ( "active", Encode.bool |> Encode.optional input____.active ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "creatorId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.creatorId ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "invitationSendAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.invitationSendAt ), ( "lastModifiedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.lastModifiedAt ), ( "lastVisitedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.lastVisitedAt ), ( "memberType", Encode.string |> Encode.optional input____.memberType ), ( "membershipEndedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.membershipEndedAt ), ( "notebookId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.notebookId ) ]


buildNotebook_member_updates :
    Notebook_member_updatesRequiredFields
    -> (Notebook_member_updatesOptionalFields -> Notebook_member_updatesOptionalFields)
    -> Notebook_member_updates
buildNotebook_member_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Notebook_member_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Notebook_member_updatesRequiredFields =
    { where_ : Notebook_member_bool_exp }


type alias Notebook_member_updatesOptionalFields =
    { set_ : OptionalArgument Notebook_member_set_input }


{-| Type alias for the `Notebook_member_updates` attributes. Note that this type
needs to use the `Notebook_member_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_member_updatesRaw =
    { set_ : OptionalArgument Notebook_member_set_input
    , where_ : Notebook_member_bool_exp
    }


{-| Type for the Notebook\_member\_updates input object.
-}
type Notebook_member_updates
    = Notebook_member_updates Notebook_member_updatesRaw


{-| Encode a Notebook\_member\_updates into a value that can be used as an argument.
-}
encodeNotebook_member_updates : Notebook_member_updates -> Value
encodeNotebook_member_updates (Notebook_member_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeNotebook_member_set_input |> Encode.optional input____.set_ ), ( "where", encodeNotebook_member_bool_exp input____.where_ |> Just ) ]


buildNotebook_obj_rel_insert_input :
    Notebook_obj_rel_insert_inputRequiredFields
    -> (Notebook_obj_rel_insert_inputOptionalFields -> Notebook_obj_rel_insert_inputOptionalFields)
    -> Notebook_obj_rel_insert_input
buildNotebook_obj_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Notebook_obj_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Notebook_obj_rel_insert_inputRequiredFields =
    { data : Notebook_insert_input }


type alias Notebook_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Notebook_on_conflict }


{-| Type alias for the `Notebook_obj_rel_insert_input` attributes. Note that this type
needs to use the `Notebook_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_obj_rel_insert_inputRaw =
    { data : Notebook_insert_input
    , on_conflict : OptionalArgument Notebook_on_conflict
    }


{-| Type for the Notebook\_obj\_rel\_insert\_input input object.
-}
type Notebook_obj_rel_insert_input
    = Notebook_obj_rel_insert_input Notebook_obj_rel_insert_inputRaw


{-| Encode a Notebook\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeNotebook_obj_rel_insert_input : Notebook_obj_rel_insert_input -> Value
encodeNotebook_obj_rel_insert_input (Notebook_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeNotebook_insert_input input____.data |> Just ), ( "on_conflict", encodeNotebook_on_conflict |> Encode.optional input____.on_conflict ) ]


buildNotebook_on_conflict :
    Notebook_on_conflictRequiredFields
    -> (Notebook_on_conflictOptionalFields -> Notebook_on_conflictOptionalFields)
    -> Notebook_on_conflict
buildNotebook_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Notebook_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Notebook_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Notebook_constraint.Notebook_constraint
    , update_columns : List CdbGQL.Enum.Notebook_update_column.Notebook_update_column
    }


type alias Notebook_on_conflictOptionalFields =
    { where_ : OptionalArgument Notebook_bool_exp }


{-| Type alias for the `Notebook_on_conflict` attributes. Note that this type
needs to use the `Notebook_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_on_conflictRaw =
    { constraint : CdbGQL.Enum.Notebook_constraint.Notebook_constraint
    , update_columns : List CdbGQL.Enum.Notebook_update_column.Notebook_update_column
    , where_ : OptionalArgument Notebook_bool_exp
    }


{-| Type for the Notebook\_on\_conflict input object.
-}
type Notebook_on_conflict
    = Notebook_on_conflict Notebook_on_conflictRaw


{-| Encode a Notebook\_on\_conflict into a value that can be used as an argument.
-}
encodeNotebook_on_conflict : Notebook_on_conflict -> Value
encodeNotebook_on_conflict (Notebook_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Notebook_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Notebook_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeNotebook_bool_exp |> Encode.optional input____.where_ ) ]


buildNotebook_order_by :
    (Notebook_order_byOptionalFields -> Notebook_order_byOptionalFields)
    -> Notebook_order_by
buildNotebook_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { appointments_aggregate = Absent, beneficiary = Absent, beneficiaryId = Absent, contractEndDate = Absent, contractSignDate = Absent, contractStartDate = Absent, contractType = Absent, createdAt = Absent, educationLevel = Absent, events_aggregate = Absent, focuses_aggregate = Absent, id = Absent, lastJobEndedAt = Absent, members_aggregate = Absent, notebookInfo = Absent, professionalProjects_aggregate = Absent, rightRqth = Absent, situations_aggregate = Absent, updatedAt = Absent, workSituation = Absent, workSituationDate = Absent, workSituationEndDate = Absent }
    in
    Notebook_order_by { appointments_aggregate = optionals____.appointments_aggregate, beneficiary = optionals____.beneficiary, beneficiaryId = optionals____.beneficiaryId, contractEndDate = optionals____.contractEndDate, contractSignDate = optionals____.contractSignDate, contractStartDate = optionals____.contractStartDate, contractType = optionals____.contractType, createdAt = optionals____.createdAt, educationLevel = optionals____.educationLevel, events_aggregate = optionals____.events_aggregate, focuses_aggregate = optionals____.focuses_aggregate, id = optionals____.id, lastJobEndedAt = optionals____.lastJobEndedAt, members_aggregate = optionals____.members_aggregate, notebookInfo = optionals____.notebookInfo, professionalProjects_aggregate = optionals____.professionalProjects_aggregate, rightRqth = optionals____.rightRqth, situations_aggregate = optionals____.situations_aggregate, updatedAt = optionals____.updatedAt, workSituation = optionals____.workSituation, workSituationDate = optionals____.workSituationDate, workSituationEndDate = optionals____.workSituationEndDate }


type alias Notebook_order_byOptionalFields =
    { appointments_aggregate : OptionalArgument Notebook_appointment_aggregate_order_by
    , beneficiary : OptionalArgument Beneficiary_order_by
    , beneficiaryId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , contractEndDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , contractSignDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , contractStartDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , contractType : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , educationLevel : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , events_aggregate : OptionalArgument Notebook_event_aggregate_order_by
    , focuses_aggregate : OptionalArgument Notebook_focus_aggregate_order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastJobEndedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , members_aggregate : OptionalArgument Notebook_member_aggregate_order_by
    , notebookInfo : OptionalArgument Notebook_info_order_by
    , professionalProjects_aggregate : OptionalArgument Professional_project_aggregate_order_by
    , rightRqth : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , situations_aggregate : OptionalArgument Notebook_situation_aggregate_order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , workSituation : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , workSituationDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , workSituationEndDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type alias for the `Notebook_order_by` attributes. Note that this type
needs to use the `Notebook_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_order_byRaw =
    { appointments_aggregate : OptionalArgument Notebook_appointment_aggregate_order_by
    , beneficiary : OptionalArgument Beneficiary_order_by
    , beneficiaryId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , contractEndDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , contractSignDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , contractStartDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , contractType : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , educationLevel : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , events_aggregate : OptionalArgument Notebook_event_aggregate_order_by
    , focuses_aggregate : OptionalArgument Notebook_focus_aggregate_order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastJobEndedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , members_aggregate : OptionalArgument Notebook_member_aggregate_order_by
    , notebookInfo : OptionalArgument Notebook_info_order_by
    , professionalProjects_aggregate : OptionalArgument Professional_project_aggregate_order_by
    , rightRqth : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , situations_aggregate : OptionalArgument Notebook_situation_aggregate_order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , workSituation : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , workSituationDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , workSituationEndDate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Notebook\_order\_by input object.
-}
type Notebook_order_by
    = Notebook_order_by Notebook_order_byRaw


{-| Encode a Notebook\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_order_by : Notebook_order_by -> Value
encodeNotebook_order_by (Notebook_order_by input____) =
    Encode.maybeObject
        [ ( "appointments_aggregate", encodeNotebook_appointment_aggregate_order_by |> Encode.optional input____.appointments_aggregate ), ( "beneficiary", encodeBeneficiary_order_by |> Encode.optional input____.beneficiary ), ( "beneficiaryId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.beneficiaryId ), ( "contractEndDate", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.contractEndDate ), ( "contractSignDate", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.contractSignDate ), ( "contractStartDate", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.contractStartDate ), ( "contractType", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.contractType ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "educationLevel", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.educationLevel ), ( "events_aggregate", encodeNotebook_event_aggregate_order_by |> Encode.optional input____.events_aggregate ), ( "focuses_aggregate", encodeNotebook_focus_aggregate_order_by |> Encode.optional input____.focuses_aggregate ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "lastJobEndedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.lastJobEndedAt ), ( "members_aggregate", encodeNotebook_member_aggregate_order_by |> Encode.optional input____.members_aggregate ), ( "notebookInfo", encodeNotebook_info_order_by |> Encode.optional input____.notebookInfo ), ( "professionalProjects_aggregate", encodeProfessional_project_aggregate_order_by |> Encode.optional input____.professionalProjects_aggregate ), ( "rightRqth", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.rightRqth ), ( "situations_aggregate", encodeNotebook_situation_aggregate_order_by |> Encode.optional input____.situations_aggregate ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ), ( "workSituation", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.workSituation ), ( "workSituationDate", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.workSituationDate ), ( "workSituationEndDate", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.workSituationEndDate ) ]


buildNotebook_pk_columns_input :
    Notebook_pk_columns_inputRequiredFields
    -> Notebook_pk_columns_input
buildNotebook_pk_columns_input required____ =
    { id = required____.id }


type alias Notebook_pk_columns_inputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the Notebook\_pk\_columns\_input input object.
-}
type alias Notebook_pk_columns_input =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a Notebook\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeNotebook_pk_columns_input : Notebook_pk_columns_input -> Value
encodeNotebook_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildNotebook_public_view_bool_exp :
    (Notebook_public_view_bool_expOptionalFields -> Notebook_public_view_bool_expOptionalFields)
    -> Notebook_public_view_bool_exp
buildNotebook_public_view_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, beneficiary = Absent, beneficiary_id = Absent, created_at = Absent, id = Absent, members = Absent, members_aggregate = Absent, notebook = Absent, updated_at = Absent }
    in
    Notebook_public_view_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, beneficiary = optionals____.beneficiary, beneficiary_id = optionals____.beneficiary_id, created_at = optionals____.created_at, id = optionals____.id, members = optionals____.members, members_aggregate = optionals____.members_aggregate, notebook = optionals____.notebook, updated_at = optionals____.updated_at }


type alias Notebook_public_view_bool_expOptionalFields =
    { and_ : OptionalArgument (List Notebook_public_view_bool_exp)
    , not_ : OptionalArgument Notebook_public_view_bool_exp
    , or_ : OptionalArgument (List Notebook_public_view_bool_exp)
    , beneficiary : OptionalArgument Beneficiary_bool_exp
    , beneficiary_id : OptionalArgument Uuid_comparison_exp
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , members : OptionalArgument Notebook_member_bool_exp
    , members_aggregate : OptionalArgument Notebook_member_aggregate_bool_exp
    , notebook : OptionalArgument Notebook_bool_exp
    , updated_at : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type alias for the `Notebook_public_view_bool_exp` attributes. Note that this type
needs to use the `Notebook_public_view_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_public_view_bool_expRaw =
    { and_ : OptionalArgument (List Notebook_public_view_bool_exp)
    , not_ : OptionalArgument Notebook_public_view_bool_exp
    , or_ : OptionalArgument (List Notebook_public_view_bool_exp)
    , beneficiary : OptionalArgument Beneficiary_bool_exp
    , beneficiary_id : OptionalArgument Uuid_comparison_exp
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , members : OptionalArgument Notebook_member_bool_exp
    , members_aggregate : OptionalArgument Notebook_member_aggregate_bool_exp
    , notebook : OptionalArgument Notebook_bool_exp
    , updated_at : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type for the Notebook\_public\_view\_bool\_exp input object.
-}
type Notebook_public_view_bool_exp
    = Notebook_public_view_bool_exp Notebook_public_view_bool_expRaw


{-| Encode a Notebook\_public\_view\_bool\_exp into a value that can be used as an argument.
-}
encodeNotebook_public_view_bool_exp : Notebook_public_view_bool_exp -> Value
encodeNotebook_public_view_bool_exp (Notebook_public_view_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeNotebook_public_view_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeNotebook_public_view_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeNotebook_public_view_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "beneficiary", encodeBeneficiary_bool_exp |> Encode.optional input____.beneficiary ), ( "beneficiary_id", encodeUuid_comparison_exp |> Encode.optional input____.beneficiary_id ), ( "created_at", encodeTimestamptz_comparison_exp |> Encode.optional input____.created_at ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "members", encodeNotebook_member_bool_exp |> Encode.optional input____.members ), ( "members_aggregate", encodeNotebook_member_aggregate_bool_exp |> Encode.optional input____.members_aggregate ), ( "notebook", encodeNotebook_bool_exp |> Encode.optional input____.notebook ), ( "updated_at", encodeTimestamptz_comparison_exp |> Encode.optional input____.updated_at ) ]


buildNotebook_public_view_insert_input :
    (Notebook_public_view_insert_inputOptionalFields -> Notebook_public_view_insert_inputOptionalFields)
    -> Notebook_public_view_insert_input
buildNotebook_public_view_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { beneficiary = Absent, beneficiary_id = Absent, created_at = Absent, id = Absent, members = Absent, notebook = Absent, updated_at = Absent }
    in
    Notebook_public_view_insert_input { beneficiary = optionals____.beneficiary, beneficiary_id = optionals____.beneficiary_id, created_at = optionals____.created_at, id = optionals____.id, members = optionals____.members, notebook = optionals____.notebook, updated_at = optionals____.updated_at }


type alias Notebook_public_view_insert_inputOptionalFields =
    { beneficiary : OptionalArgument Beneficiary_obj_rel_insert_input
    , beneficiary_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , created_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , members : OptionalArgument Notebook_member_arr_rel_insert_input
    , notebook : OptionalArgument Notebook_obj_rel_insert_input
    , updated_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type alias for the `Notebook_public_view_insert_input` attributes. Note that this type
needs to use the `Notebook_public_view_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_public_view_insert_inputRaw =
    { beneficiary : OptionalArgument Beneficiary_obj_rel_insert_input
    , beneficiary_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , created_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , members : OptionalArgument Notebook_member_arr_rel_insert_input
    , notebook : OptionalArgument Notebook_obj_rel_insert_input
    , updated_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Notebook\_public\_view\_insert\_input input object.
-}
type Notebook_public_view_insert_input
    = Notebook_public_view_insert_input Notebook_public_view_insert_inputRaw


{-| Encode a Notebook\_public\_view\_insert\_input into a value that can be used as an argument.
-}
encodeNotebook_public_view_insert_input : Notebook_public_view_insert_input -> Value
encodeNotebook_public_view_insert_input (Notebook_public_view_insert_input input____) =
    Encode.maybeObject
        [ ( "beneficiary", encodeBeneficiary_obj_rel_insert_input |> Encode.optional input____.beneficiary ), ( "beneficiary_id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.beneficiary_id ), ( "created_at", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.created_at ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "members", encodeNotebook_member_arr_rel_insert_input |> Encode.optional input____.members ), ( "notebook", encodeNotebook_obj_rel_insert_input |> Encode.optional input____.notebook ), ( "updated_at", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updated_at ) ]


buildNotebook_public_view_obj_rel_insert_input :
    Notebook_public_view_obj_rel_insert_inputRequiredFields
    -> Notebook_public_view_obj_rel_insert_input
buildNotebook_public_view_obj_rel_insert_input required____ =
    Notebook_public_view_obj_rel_insert_input { data = required____.data }


type alias Notebook_public_view_obj_rel_insert_inputRequiredFields =
    { data : Notebook_public_view_insert_input }


{-| Type alias for the `Notebook_public_view_obj_rel_insert_input` attributes. Note that this type
needs to use the `Notebook_public_view_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_public_view_obj_rel_insert_inputRaw =
    { data : Notebook_public_view_insert_input }


{-| Type for the Notebook\_public\_view\_obj\_rel\_insert\_input input object.
-}
type Notebook_public_view_obj_rel_insert_input
    = Notebook_public_view_obj_rel_insert_input Notebook_public_view_obj_rel_insert_inputRaw


{-| Encode a Notebook\_public\_view\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeNotebook_public_view_obj_rel_insert_input : Notebook_public_view_obj_rel_insert_input -> Value
encodeNotebook_public_view_obj_rel_insert_input (Notebook_public_view_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeNotebook_public_view_insert_input input____.data |> Just ) ]


buildNotebook_public_view_order_by :
    (Notebook_public_view_order_byOptionalFields -> Notebook_public_view_order_byOptionalFields)
    -> Notebook_public_view_order_by
buildNotebook_public_view_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { beneficiary = Absent, beneficiary_id = Absent, created_at = Absent, id = Absent, members_aggregate = Absent, notebook = Absent, updated_at = Absent }
    in
    Notebook_public_view_order_by { beneficiary = optionals____.beneficiary, beneficiary_id = optionals____.beneficiary_id, created_at = optionals____.created_at, id = optionals____.id, members_aggregate = optionals____.members_aggregate, notebook = optionals____.notebook, updated_at = optionals____.updated_at }


type alias Notebook_public_view_order_byOptionalFields =
    { beneficiary : OptionalArgument Beneficiary_order_by
    , beneficiary_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , created_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , members_aggregate : OptionalArgument Notebook_member_aggregate_order_by
    , notebook : OptionalArgument Notebook_order_by
    , updated_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type alias for the `Notebook_public_view_order_by` attributes. Note that this type
needs to use the `Notebook_public_view_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_public_view_order_byRaw =
    { beneficiary : OptionalArgument Beneficiary_order_by
    , beneficiary_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , created_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , members_aggregate : OptionalArgument Notebook_member_aggregate_order_by
    , notebook : OptionalArgument Notebook_order_by
    , updated_at : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Notebook\_public\_view\_order\_by input object.
-}
type Notebook_public_view_order_by
    = Notebook_public_view_order_by Notebook_public_view_order_byRaw


{-| Encode a Notebook\_public\_view\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_public_view_order_by : Notebook_public_view_order_by -> Value
encodeNotebook_public_view_order_by (Notebook_public_view_order_by input____) =
    Encode.maybeObject
        [ ( "beneficiary", encodeBeneficiary_order_by |> Encode.optional input____.beneficiary ), ( "beneficiary_id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.beneficiary_id ), ( "created_at", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.created_at ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "members_aggregate", encodeNotebook_member_aggregate_order_by |> Encode.optional input____.members_aggregate ), ( "notebook", encodeNotebook_order_by |> Encode.optional input____.notebook ), ( "updated_at", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updated_at ) ]


buildNotebook_public_view_set_input :
    (Notebook_public_view_set_inputOptionalFields -> Notebook_public_view_set_inputOptionalFields)
    -> Notebook_public_view_set_input
buildNotebook_public_view_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { beneficiary_id = Absent, created_at = Absent, id = Absent, updated_at = Absent }
    in
    { beneficiary_id = optionals____.beneficiary_id, created_at = optionals____.created_at, id = optionals____.id, updated_at = optionals____.updated_at }


type alias Notebook_public_view_set_inputOptionalFields =
    { beneficiary_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , created_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updated_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Notebook\_public\_view\_set\_input input object.
-}
type alias Notebook_public_view_set_input =
    { beneficiary_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , created_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updated_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Notebook\_public\_view\_set\_input into a value that can be used as an argument.
-}
encodeNotebook_public_view_set_input : Notebook_public_view_set_input -> Value
encodeNotebook_public_view_set_input input____ =
    Encode.maybeObject
        [ ( "beneficiary_id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.beneficiary_id ), ( "created_at", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.created_at ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "updated_at", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updated_at ) ]


buildNotebook_public_view_stream_cursor_input :
    Notebook_public_view_stream_cursor_inputRequiredFields
    -> (Notebook_public_view_stream_cursor_inputOptionalFields -> Notebook_public_view_stream_cursor_inputOptionalFields)
    -> Notebook_public_view_stream_cursor_input
buildNotebook_public_view_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Notebook_public_view_stream_cursor_inputRequiredFields =
    { initial_value : Notebook_public_view_stream_cursor_value_input }


type alias Notebook_public_view_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Notebook\_public\_view\_stream\_cursor\_input input object.
-}
type alias Notebook_public_view_stream_cursor_input =
    { initial_value : Notebook_public_view_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Notebook\_public\_view\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeNotebook_public_view_stream_cursor_input : Notebook_public_view_stream_cursor_input -> Value
encodeNotebook_public_view_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeNotebook_public_view_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildNotebook_public_view_stream_cursor_value_input :
    (Notebook_public_view_stream_cursor_value_inputOptionalFields -> Notebook_public_view_stream_cursor_value_inputOptionalFields)
    -> Notebook_public_view_stream_cursor_value_input
buildNotebook_public_view_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { beneficiary_id = Absent, created_at = Absent, id = Absent, updated_at = Absent }
    in
    { beneficiary_id = optionals____.beneficiary_id, created_at = optionals____.created_at, id = optionals____.id, updated_at = optionals____.updated_at }


type alias Notebook_public_view_stream_cursor_value_inputOptionalFields =
    { beneficiary_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , created_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updated_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Notebook\_public\_view\_stream\_cursor\_value\_input input object.
-}
type alias Notebook_public_view_stream_cursor_value_input =
    { beneficiary_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , created_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updated_at : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Notebook\_public\_view\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeNotebook_public_view_stream_cursor_value_input : Notebook_public_view_stream_cursor_value_input -> Value
encodeNotebook_public_view_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "beneficiary_id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.beneficiary_id ), ( "created_at", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.created_at ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "updated_at", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updated_at ) ]


buildNotebook_public_view_updates :
    Notebook_public_view_updatesRequiredFields
    -> (Notebook_public_view_updatesOptionalFields -> Notebook_public_view_updatesOptionalFields)
    -> Notebook_public_view_updates
buildNotebook_public_view_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Notebook_public_view_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Notebook_public_view_updatesRequiredFields =
    { where_ : Notebook_public_view_bool_exp }


type alias Notebook_public_view_updatesOptionalFields =
    { set_ : OptionalArgument Notebook_public_view_set_input }


{-| Type alias for the `Notebook_public_view_updates` attributes. Note that this type
needs to use the `Notebook_public_view_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_public_view_updatesRaw =
    { set_ : OptionalArgument Notebook_public_view_set_input
    , where_ : Notebook_public_view_bool_exp
    }


{-| Type for the Notebook\_public\_view\_updates input object.
-}
type Notebook_public_view_updates
    = Notebook_public_view_updates Notebook_public_view_updatesRaw


{-| Encode a Notebook\_public\_view\_updates into a value that can be used as an argument.
-}
encodeNotebook_public_view_updates : Notebook_public_view_updates -> Value
encodeNotebook_public_view_updates (Notebook_public_view_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeNotebook_public_view_set_input |> Encode.optional input____.set_ ), ( "where", encodeNotebook_public_view_bool_exp input____.where_ |> Just ) ]


buildNotebook_set_input :
    (Notebook_set_inputOptionalFields -> Notebook_set_inputOptionalFields)
    -> Notebook_set_input
buildNotebook_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { beneficiaryId = Absent, contractEndDate = Absent, contractSignDate = Absent, contractStartDate = Absent, contractType = Absent, createdAt = Absent, educationLevel = Absent, id = Absent, lastJobEndedAt = Absent, rightRqth = Absent, updatedAt = Absent, workSituation = Absent, workSituationDate = Absent, workSituationEndDate = Absent }
    in
    { beneficiaryId = optionals____.beneficiaryId, contractEndDate = optionals____.contractEndDate, contractSignDate = optionals____.contractSignDate, contractStartDate = optionals____.contractStartDate, contractType = optionals____.contractType, createdAt = optionals____.createdAt, educationLevel = optionals____.educationLevel, id = optionals____.id, lastJobEndedAt = optionals____.lastJobEndedAt, rightRqth = optionals____.rightRqth, updatedAt = optionals____.updatedAt, workSituation = optionals____.workSituation, workSituationDate = optionals____.workSituationDate, workSituationEndDate = optionals____.workSituationEndDate }


type alias Notebook_set_inputOptionalFields =
    { beneficiaryId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , contractEndDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    , contractSignDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    , contractStartDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    , contractType : OptionalArgument String
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , educationLevel : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastJobEndedAt : OptionalArgument CdbGQL.ScalarCodecs.Date
    , rightRqth : OptionalArgument Bool
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , workSituation : OptionalArgument String
    , workSituationDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    , workSituationEndDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    }


{-| Type for the Notebook\_set\_input input object.
-}
type alias Notebook_set_input =
    { beneficiaryId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , contractEndDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    , contractSignDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    , contractStartDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    , contractType : OptionalArgument String
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , educationLevel : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastJobEndedAt : OptionalArgument CdbGQL.ScalarCodecs.Date
    , rightRqth : OptionalArgument Bool
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , workSituation : OptionalArgument String
    , workSituationDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    , workSituationEndDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    }


{-| Encode a Notebook\_set\_input into a value that can be used as an argument.
-}
encodeNotebook_set_input : Notebook_set_input -> Value
encodeNotebook_set_input input____ =
    Encode.maybeObject
        [ ( "beneficiaryId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.beneficiaryId ), ( "contractEndDate", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.contractEndDate ), ( "contractSignDate", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.contractSignDate ), ( "contractStartDate", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.contractStartDate ), ( "contractType", Encode.string |> Encode.optional input____.contractType ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "educationLevel", Encode.string |> Encode.optional input____.educationLevel ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "lastJobEndedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.lastJobEndedAt ), ( "rightRqth", Encode.bool |> Encode.optional input____.rightRqth ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ), ( "workSituation", Encode.string |> Encode.optional input____.workSituation ), ( "workSituationDate", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.workSituationDate ), ( "workSituationEndDate", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.workSituationEndDate ) ]


buildNotebook_situation_aggregate_bool_exp :
    (Notebook_situation_aggregate_bool_expOptionalFields -> Notebook_situation_aggregate_bool_expOptionalFields)
    -> Notebook_situation_aggregate_bool_exp
buildNotebook_situation_aggregate_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent }
    in
    Notebook_situation_aggregate_bool_exp { count = optionals____.count }


type alias Notebook_situation_aggregate_bool_expOptionalFields =
    { count : OptionalArgument Notebook_situation_aggregate_bool_exp_count }


{-| Type alias for the `Notebook_situation_aggregate_bool_exp` attributes. Note that this type
needs to use the `Notebook_situation_aggregate_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_situation_aggregate_bool_expRaw =
    { count : OptionalArgument Notebook_situation_aggregate_bool_exp_count }


{-| Type for the Notebook\_situation\_aggregate\_bool\_exp input object.
-}
type Notebook_situation_aggregate_bool_exp
    = Notebook_situation_aggregate_bool_exp Notebook_situation_aggregate_bool_expRaw


{-| Encode a Notebook\_situation\_aggregate\_bool\_exp into a value that can be used as an argument.
-}
encodeNotebook_situation_aggregate_bool_exp : Notebook_situation_aggregate_bool_exp -> Value
encodeNotebook_situation_aggregate_bool_exp (Notebook_situation_aggregate_bool_exp input____) =
    Encode.maybeObject
        [ ( "count", encodeNotebook_situation_aggregate_bool_exp_count |> Encode.optional input____.count ) ]


buildNotebook_situation_aggregate_bool_exp_count :
    Notebook_situation_aggregate_bool_exp_countRequiredFields
    -> (Notebook_situation_aggregate_bool_exp_countOptionalFields -> Notebook_situation_aggregate_bool_exp_countOptionalFields)
    -> Notebook_situation_aggregate_bool_exp_count
buildNotebook_situation_aggregate_bool_exp_count required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { arguments = Absent, distinct = Absent, filter = Absent }
    in
    Notebook_situation_aggregate_bool_exp_count { arguments = optionals____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Notebook_situation_aggregate_bool_exp_countRequiredFields =
    { predicate : Int_comparison_exp }


type alias Notebook_situation_aggregate_bool_exp_countOptionalFields =
    { arguments : OptionalArgument (List CdbGQL.Enum.Notebook_situation_select_column.Notebook_situation_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Notebook_situation_bool_exp
    }


{-| Type alias for the `Notebook_situation_aggregate_bool_exp_count` attributes. Note that this type
needs to use the `Notebook_situation_aggregate_bool_exp_count` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_situation_aggregate_bool_exp_countRaw =
    { arguments : OptionalArgument (List CdbGQL.Enum.Notebook_situation_select_column.Notebook_situation_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Notebook_situation_bool_exp
    , predicate : Int_comparison_exp
    }


{-| Type for the Notebook\_situation\_aggregate\_bool\_exp\_count input object.
-}
type Notebook_situation_aggregate_bool_exp_count
    = Notebook_situation_aggregate_bool_exp_count Notebook_situation_aggregate_bool_exp_countRaw


{-| Encode a Notebook\_situation\_aggregate\_bool\_exp\_count into a value that can be used as an argument.
-}
encodeNotebook_situation_aggregate_bool_exp_count : Notebook_situation_aggregate_bool_exp_count -> Value
encodeNotebook_situation_aggregate_bool_exp_count (Notebook_situation_aggregate_bool_exp_count input____) =
    Encode.maybeObject
        [ ( "arguments", (Encode.enum CdbGQL.Enum.Notebook_situation_select_column.toString |> Encode.list) |> Encode.optional input____.arguments ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeNotebook_situation_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeInt_comparison_exp input____.predicate |> Just ) ]


buildNotebook_situation_aggregate_order_by :
    (Notebook_situation_aggregate_order_byOptionalFields -> Notebook_situation_aggregate_order_byOptionalFields)
    -> Notebook_situation_aggregate_order_by
buildNotebook_situation_aggregate_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals____.count, max = optionals____.max, min = optionals____.min }


type alias Notebook_situation_aggregate_order_byOptionalFields =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Notebook_situation_max_order_by
    , min : OptionalArgument Notebook_situation_min_order_by
    }


{-| Type for the Notebook\_situation\_aggregate\_order\_by input object.
-}
type alias Notebook_situation_aggregate_order_by =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Notebook_situation_max_order_by
    , min : OptionalArgument Notebook_situation_min_order_by
    }


{-| Encode a Notebook\_situation\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_situation_aggregate_order_by : Notebook_situation_aggregate_order_by -> Value
encodeNotebook_situation_aggregate_order_by input____ =
    Encode.maybeObject
        [ ( "count", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.count ), ( "max", encodeNotebook_situation_max_order_by |> Encode.optional input____.max ), ( "min", encodeNotebook_situation_min_order_by |> Encode.optional input____.min ) ]


buildNotebook_situation_arr_rel_insert_input :
    Notebook_situation_arr_rel_insert_inputRequiredFields
    -> (Notebook_situation_arr_rel_insert_inputOptionalFields -> Notebook_situation_arr_rel_insert_inputOptionalFields)
    -> Notebook_situation_arr_rel_insert_input
buildNotebook_situation_arr_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Notebook_situation_arr_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Notebook_situation_arr_rel_insert_inputRequiredFields =
    { data : List Notebook_situation_insert_input }


type alias Notebook_situation_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Notebook_situation_on_conflict }


{-| Type alias for the `Notebook_situation_arr_rel_insert_input` attributes. Note that this type
needs to use the `Notebook_situation_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_situation_arr_rel_insert_inputRaw =
    { data : List Notebook_situation_insert_input
    , on_conflict : OptionalArgument Notebook_situation_on_conflict
    }


{-| Type for the Notebook\_situation\_arr\_rel\_insert\_input input object.
-}
type Notebook_situation_arr_rel_insert_input
    = Notebook_situation_arr_rel_insert_input Notebook_situation_arr_rel_insert_inputRaw


{-| Encode a Notebook\_situation\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeNotebook_situation_arr_rel_insert_input : Notebook_situation_arr_rel_insert_input -> Value
encodeNotebook_situation_arr_rel_insert_input (Notebook_situation_arr_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", (encodeNotebook_situation_insert_input |> Encode.list) input____.data |> Just ), ( "on_conflict", encodeNotebook_situation_on_conflict |> Encode.optional input____.on_conflict ) ]


buildNotebook_situation_bool_exp :
    (Notebook_situation_bool_expOptionalFields -> Notebook_situation_bool_expOptionalFields)
    -> Notebook_situation_bool_exp
buildNotebook_situation_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, createdAt = Absent, createdBy = Absent, creator = Absent, deletedAt = Absent, deletedBy = Absent, deletor = Absent, id = Absent, notebook = Absent, notebookId = Absent, refSituation = Absent, situationId = Absent }
    in
    Notebook_situation_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, createdAt = optionals____.createdAt, createdBy = optionals____.createdBy, creator = optionals____.creator, deletedAt = optionals____.deletedAt, deletedBy = optionals____.deletedBy, deletor = optionals____.deletor, id = optionals____.id, notebook = optionals____.notebook, notebookId = optionals____.notebookId, refSituation = optionals____.refSituation, situationId = optionals____.situationId }


type alias Notebook_situation_bool_expOptionalFields =
    { and_ : OptionalArgument (List Notebook_situation_bool_exp)
    , not_ : OptionalArgument Notebook_situation_bool_exp
    , or_ : OptionalArgument (List Notebook_situation_bool_exp)
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , createdBy : OptionalArgument Uuid_comparison_exp
    , creator : OptionalArgument Account_bool_exp
    , deletedAt : OptionalArgument Timestamptz_comparison_exp
    , deletedBy : OptionalArgument Uuid_comparison_exp
    , deletor : OptionalArgument Account_bool_exp
    , id : OptionalArgument Uuid_comparison_exp
    , notebook : OptionalArgument Notebook_bool_exp
    , notebookId : OptionalArgument Uuid_comparison_exp
    , refSituation : OptionalArgument Ref_situation_bool_exp
    , situationId : OptionalArgument Uuid_comparison_exp
    }


{-| Type alias for the `Notebook_situation_bool_exp` attributes. Note that this type
needs to use the `Notebook_situation_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_situation_bool_expRaw =
    { and_ : OptionalArgument (List Notebook_situation_bool_exp)
    , not_ : OptionalArgument Notebook_situation_bool_exp
    , or_ : OptionalArgument (List Notebook_situation_bool_exp)
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , createdBy : OptionalArgument Uuid_comparison_exp
    , creator : OptionalArgument Account_bool_exp
    , deletedAt : OptionalArgument Timestamptz_comparison_exp
    , deletedBy : OptionalArgument Uuid_comparison_exp
    , deletor : OptionalArgument Account_bool_exp
    , id : OptionalArgument Uuid_comparison_exp
    , notebook : OptionalArgument Notebook_bool_exp
    , notebookId : OptionalArgument Uuid_comparison_exp
    , refSituation : OptionalArgument Ref_situation_bool_exp
    , situationId : OptionalArgument Uuid_comparison_exp
    }


{-| Type for the Notebook\_situation\_bool\_exp input object.
-}
type Notebook_situation_bool_exp
    = Notebook_situation_bool_exp Notebook_situation_bool_expRaw


{-| Encode a Notebook\_situation\_bool\_exp into a value that can be used as an argument.
-}
encodeNotebook_situation_bool_exp : Notebook_situation_bool_exp -> Value
encodeNotebook_situation_bool_exp (Notebook_situation_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeNotebook_situation_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeNotebook_situation_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeNotebook_situation_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "createdAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.createdAt ), ( "createdBy", encodeUuid_comparison_exp |> Encode.optional input____.createdBy ), ( "creator", encodeAccount_bool_exp |> Encode.optional input____.creator ), ( "deletedAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.deletedAt ), ( "deletedBy", encodeUuid_comparison_exp |> Encode.optional input____.deletedBy ), ( "deletor", encodeAccount_bool_exp |> Encode.optional input____.deletor ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "notebook", encodeNotebook_bool_exp |> Encode.optional input____.notebook ), ( "notebookId", encodeUuid_comparison_exp |> Encode.optional input____.notebookId ), ( "refSituation", encodeRef_situation_bool_exp |> Encode.optional input____.refSituation ), ( "situationId", encodeUuid_comparison_exp |> Encode.optional input____.situationId ) ]


buildNotebook_situation_insert_input :
    (Notebook_situation_insert_inputOptionalFields -> Notebook_situation_insert_inputOptionalFields)
    -> Notebook_situation_insert_input
buildNotebook_situation_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, createdBy = Absent, creator = Absent, deletedAt = Absent, deletedBy = Absent, deletor = Absent, id = Absent, notebook = Absent, notebookId = Absent, refSituation = Absent, situationId = Absent }
    in
    Notebook_situation_insert_input { createdAt = optionals____.createdAt, createdBy = optionals____.createdBy, creator = optionals____.creator, deletedAt = optionals____.deletedAt, deletedBy = optionals____.deletedBy, deletor = optionals____.deletor, id = optionals____.id, notebook = optionals____.notebook, notebookId = optionals____.notebookId, refSituation = optionals____.refSituation, situationId = optionals____.situationId }


type alias Notebook_situation_insert_inputOptionalFields =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , createdBy : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , creator : OptionalArgument Account_obj_rel_insert_input
    , deletedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deletedBy : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , deletor : OptionalArgument Account_obj_rel_insert_input
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , notebook : OptionalArgument Notebook_obj_rel_insert_input
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , refSituation : OptionalArgument Ref_situation_obj_rel_insert_input
    , situationId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Type alias for the `Notebook_situation_insert_input` attributes. Note that this type
needs to use the `Notebook_situation_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_situation_insert_inputRaw =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , createdBy : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , creator : OptionalArgument Account_obj_rel_insert_input
    , deletedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deletedBy : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , deletor : OptionalArgument Account_obj_rel_insert_input
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , notebook : OptionalArgument Notebook_obj_rel_insert_input
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , refSituation : OptionalArgument Ref_situation_obj_rel_insert_input
    , situationId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Type for the Notebook\_situation\_insert\_input input object.
-}
type Notebook_situation_insert_input
    = Notebook_situation_insert_input Notebook_situation_insert_inputRaw


{-| Encode a Notebook\_situation\_insert\_input into a value that can be used as an argument.
-}
encodeNotebook_situation_insert_input : Notebook_situation_insert_input -> Value
encodeNotebook_situation_insert_input (Notebook_situation_insert_input input____) =
    Encode.maybeObject
        [ ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "createdBy", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.createdBy ), ( "creator", encodeAccount_obj_rel_insert_input |> Encode.optional input____.creator ), ( "deletedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.deletedAt ), ( "deletedBy", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.deletedBy ), ( "deletor", encodeAccount_obj_rel_insert_input |> Encode.optional input____.deletor ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "notebook", encodeNotebook_obj_rel_insert_input |> Encode.optional input____.notebook ), ( "notebookId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.notebookId ), ( "refSituation", encodeRef_situation_obj_rel_insert_input |> Encode.optional input____.refSituation ), ( "situationId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.situationId ) ]


buildNotebook_situation_max_order_by :
    (Notebook_situation_max_order_byOptionalFields -> Notebook_situation_max_order_byOptionalFields)
    -> Notebook_situation_max_order_by
buildNotebook_situation_max_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, createdBy = Absent, deletedAt = Absent, deletedBy = Absent, id = Absent, notebookId = Absent, situationId = Absent }
    in
    { createdAt = optionals____.createdAt, createdBy = optionals____.createdBy, deletedAt = optionals____.deletedAt, deletedBy = optionals____.deletedBy, id = optionals____.id, notebookId = optionals____.notebookId, situationId = optionals____.situationId }


type alias Notebook_situation_max_order_byOptionalFields =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdBy : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deletedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deletedBy : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , situationId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Notebook\_situation\_max\_order\_by input object.
-}
type alias Notebook_situation_max_order_by =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdBy : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deletedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deletedBy : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , situationId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Notebook\_situation\_max\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_situation_max_order_by : Notebook_situation_max_order_by -> Value
encodeNotebook_situation_max_order_by input____ =
    Encode.maybeObject
        [ ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "createdBy", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdBy ), ( "deletedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deletedAt ), ( "deletedBy", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deletedBy ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "notebookId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.notebookId ), ( "situationId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.situationId ) ]


buildNotebook_situation_min_order_by :
    (Notebook_situation_min_order_byOptionalFields -> Notebook_situation_min_order_byOptionalFields)
    -> Notebook_situation_min_order_by
buildNotebook_situation_min_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, createdBy = Absent, deletedAt = Absent, deletedBy = Absent, id = Absent, notebookId = Absent, situationId = Absent }
    in
    { createdAt = optionals____.createdAt, createdBy = optionals____.createdBy, deletedAt = optionals____.deletedAt, deletedBy = optionals____.deletedBy, id = optionals____.id, notebookId = optionals____.notebookId, situationId = optionals____.situationId }


type alias Notebook_situation_min_order_byOptionalFields =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdBy : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deletedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deletedBy : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , situationId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Notebook\_situation\_min\_order\_by input object.
-}
type alias Notebook_situation_min_order_by =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdBy : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deletedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deletedBy : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , situationId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Notebook\_situation\_min\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_situation_min_order_by : Notebook_situation_min_order_by -> Value
encodeNotebook_situation_min_order_by input____ =
    Encode.maybeObject
        [ ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "createdBy", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdBy ), ( "deletedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deletedAt ), ( "deletedBy", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deletedBy ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "notebookId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.notebookId ), ( "situationId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.situationId ) ]


buildNotebook_situation_on_conflict :
    Notebook_situation_on_conflictRequiredFields
    -> (Notebook_situation_on_conflictOptionalFields -> Notebook_situation_on_conflictOptionalFields)
    -> Notebook_situation_on_conflict
buildNotebook_situation_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Notebook_situation_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Notebook_situation_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Notebook_situation_constraint.Notebook_situation_constraint
    , update_columns : List CdbGQL.Enum.Notebook_situation_update_column.Notebook_situation_update_column
    }


type alias Notebook_situation_on_conflictOptionalFields =
    { where_ : OptionalArgument Notebook_situation_bool_exp }


{-| Type alias for the `Notebook_situation_on_conflict` attributes. Note that this type
needs to use the `Notebook_situation_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_situation_on_conflictRaw =
    { constraint : CdbGQL.Enum.Notebook_situation_constraint.Notebook_situation_constraint
    , update_columns : List CdbGQL.Enum.Notebook_situation_update_column.Notebook_situation_update_column
    , where_ : OptionalArgument Notebook_situation_bool_exp
    }


{-| Type for the Notebook\_situation\_on\_conflict input object.
-}
type Notebook_situation_on_conflict
    = Notebook_situation_on_conflict Notebook_situation_on_conflictRaw


{-| Encode a Notebook\_situation\_on\_conflict into a value that can be used as an argument.
-}
encodeNotebook_situation_on_conflict : Notebook_situation_on_conflict -> Value
encodeNotebook_situation_on_conflict (Notebook_situation_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Notebook_situation_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Notebook_situation_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeNotebook_situation_bool_exp |> Encode.optional input____.where_ ) ]


buildNotebook_situation_order_by :
    (Notebook_situation_order_byOptionalFields -> Notebook_situation_order_byOptionalFields)
    -> Notebook_situation_order_by
buildNotebook_situation_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, createdBy = Absent, creator = Absent, deletedAt = Absent, deletedBy = Absent, deletor = Absent, id = Absent, notebook = Absent, notebookId = Absent, refSituation = Absent, situationId = Absent }
    in
    Notebook_situation_order_by { createdAt = optionals____.createdAt, createdBy = optionals____.createdBy, creator = optionals____.creator, deletedAt = optionals____.deletedAt, deletedBy = optionals____.deletedBy, deletor = optionals____.deletor, id = optionals____.id, notebook = optionals____.notebook, notebookId = optionals____.notebookId, refSituation = optionals____.refSituation, situationId = optionals____.situationId }


type alias Notebook_situation_order_byOptionalFields =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdBy : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creator : OptionalArgument Account_order_by
    , deletedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deletedBy : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deletor : OptionalArgument Account_order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebook : OptionalArgument Notebook_order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , refSituation : OptionalArgument Ref_situation_order_by
    , situationId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type alias for the `Notebook_situation_order_by` attributes. Note that this type
needs to use the `Notebook_situation_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_situation_order_byRaw =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdBy : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creator : OptionalArgument Account_order_by
    , deletedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deletedBy : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deletor : OptionalArgument Account_order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebook : OptionalArgument Notebook_order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , refSituation : OptionalArgument Ref_situation_order_by
    , situationId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Notebook\_situation\_order\_by input object.
-}
type Notebook_situation_order_by
    = Notebook_situation_order_by Notebook_situation_order_byRaw


{-| Encode a Notebook\_situation\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_situation_order_by : Notebook_situation_order_by -> Value
encodeNotebook_situation_order_by (Notebook_situation_order_by input____) =
    Encode.maybeObject
        [ ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "createdBy", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdBy ), ( "creator", encodeAccount_order_by |> Encode.optional input____.creator ), ( "deletedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deletedAt ), ( "deletedBy", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deletedBy ), ( "deletor", encodeAccount_order_by |> Encode.optional input____.deletor ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "notebook", encodeNotebook_order_by |> Encode.optional input____.notebook ), ( "notebookId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.notebookId ), ( "refSituation", encodeRef_situation_order_by |> Encode.optional input____.refSituation ), ( "situationId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.situationId ) ]


buildNotebook_situation_pk_columns_input :
    Notebook_situation_pk_columns_inputRequiredFields
    -> Notebook_situation_pk_columns_input
buildNotebook_situation_pk_columns_input required____ =
    { id = required____.id }


type alias Notebook_situation_pk_columns_inputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the Notebook\_situation\_pk\_columns\_input input object.
-}
type alias Notebook_situation_pk_columns_input =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a Notebook\_situation\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeNotebook_situation_pk_columns_input : Notebook_situation_pk_columns_input -> Value
encodeNotebook_situation_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildNotebook_situation_set_input :
    (Notebook_situation_set_inputOptionalFields -> Notebook_situation_set_inputOptionalFields)
    -> Notebook_situation_set_input
buildNotebook_situation_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, createdBy = Absent, deletedAt = Absent, deletedBy = Absent, id = Absent, notebookId = Absent, situationId = Absent }
    in
    { createdAt = optionals____.createdAt, createdBy = optionals____.createdBy, deletedAt = optionals____.deletedAt, deletedBy = optionals____.deletedBy, id = optionals____.id, notebookId = optionals____.notebookId, situationId = optionals____.situationId }


type alias Notebook_situation_set_inputOptionalFields =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , createdBy : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , deletedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deletedBy : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , situationId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Type for the Notebook\_situation\_set\_input input object.
-}
type alias Notebook_situation_set_input =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , createdBy : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , deletedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deletedBy : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , situationId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Encode a Notebook\_situation\_set\_input into a value that can be used as an argument.
-}
encodeNotebook_situation_set_input : Notebook_situation_set_input -> Value
encodeNotebook_situation_set_input input____ =
    Encode.maybeObject
        [ ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "createdBy", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.createdBy ), ( "deletedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.deletedAt ), ( "deletedBy", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.deletedBy ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "notebookId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.notebookId ), ( "situationId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.situationId ) ]


buildNotebook_situation_stream_cursor_input :
    Notebook_situation_stream_cursor_inputRequiredFields
    -> (Notebook_situation_stream_cursor_inputOptionalFields -> Notebook_situation_stream_cursor_inputOptionalFields)
    -> Notebook_situation_stream_cursor_input
buildNotebook_situation_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Notebook_situation_stream_cursor_inputRequiredFields =
    { initial_value : Notebook_situation_stream_cursor_value_input }


type alias Notebook_situation_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Notebook\_situation\_stream\_cursor\_input input object.
-}
type alias Notebook_situation_stream_cursor_input =
    { initial_value : Notebook_situation_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Notebook\_situation\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeNotebook_situation_stream_cursor_input : Notebook_situation_stream_cursor_input -> Value
encodeNotebook_situation_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeNotebook_situation_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildNotebook_situation_stream_cursor_value_input :
    (Notebook_situation_stream_cursor_value_inputOptionalFields -> Notebook_situation_stream_cursor_value_inputOptionalFields)
    -> Notebook_situation_stream_cursor_value_input
buildNotebook_situation_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, createdBy = Absent, deletedAt = Absent, deletedBy = Absent, id = Absent, notebookId = Absent, situationId = Absent }
    in
    { createdAt = optionals____.createdAt, createdBy = optionals____.createdBy, deletedAt = optionals____.deletedAt, deletedBy = optionals____.deletedBy, id = optionals____.id, notebookId = optionals____.notebookId, situationId = optionals____.situationId }


type alias Notebook_situation_stream_cursor_value_inputOptionalFields =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , createdBy : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , deletedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deletedBy : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , situationId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Type for the Notebook\_situation\_stream\_cursor\_value\_input input object.
-}
type alias Notebook_situation_stream_cursor_value_input =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , createdBy : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , deletedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deletedBy : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , situationId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Encode a Notebook\_situation\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeNotebook_situation_stream_cursor_value_input : Notebook_situation_stream_cursor_value_input -> Value
encodeNotebook_situation_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "createdBy", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.createdBy ), ( "deletedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.deletedAt ), ( "deletedBy", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.deletedBy ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "notebookId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.notebookId ), ( "situationId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.situationId ) ]


buildNotebook_situation_updates :
    Notebook_situation_updatesRequiredFields
    -> (Notebook_situation_updatesOptionalFields -> Notebook_situation_updatesOptionalFields)
    -> Notebook_situation_updates
buildNotebook_situation_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Notebook_situation_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Notebook_situation_updatesRequiredFields =
    { where_ : Notebook_situation_bool_exp }


type alias Notebook_situation_updatesOptionalFields =
    { set_ : OptionalArgument Notebook_situation_set_input }


{-| Type alias for the `Notebook_situation_updates` attributes. Note that this type
needs to use the `Notebook_situation_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_situation_updatesRaw =
    { set_ : OptionalArgument Notebook_situation_set_input
    , where_ : Notebook_situation_bool_exp
    }


{-| Type for the Notebook\_situation\_updates input object.
-}
type Notebook_situation_updates
    = Notebook_situation_updates Notebook_situation_updatesRaw


{-| Encode a Notebook\_situation\_updates into a value that can be used as an argument.
-}
encodeNotebook_situation_updates : Notebook_situation_updates -> Value
encodeNotebook_situation_updates (Notebook_situation_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeNotebook_situation_set_input |> Encode.optional input____.set_ ), ( "where", encodeNotebook_situation_bool_exp input____.where_ |> Just ) ]


buildNotebook_stream_cursor_input :
    Notebook_stream_cursor_inputRequiredFields
    -> (Notebook_stream_cursor_inputOptionalFields -> Notebook_stream_cursor_inputOptionalFields)
    -> Notebook_stream_cursor_input
buildNotebook_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Notebook_stream_cursor_inputRequiredFields =
    { initial_value : Notebook_stream_cursor_value_input }


type alias Notebook_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Notebook\_stream\_cursor\_input input object.
-}
type alias Notebook_stream_cursor_input =
    { initial_value : Notebook_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Notebook\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeNotebook_stream_cursor_input : Notebook_stream_cursor_input -> Value
encodeNotebook_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeNotebook_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildNotebook_stream_cursor_value_input :
    (Notebook_stream_cursor_value_inputOptionalFields -> Notebook_stream_cursor_value_inputOptionalFields)
    -> Notebook_stream_cursor_value_input
buildNotebook_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { beneficiaryId = Absent, contractEndDate = Absent, contractSignDate = Absent, contractStartDate = Absent, contractType = Absent, createdAt = Absent, educationLevel = Absent, id = Absent, lastJobEndedAt = Absent, rightRqth = Absent, updatedAt = Absent, workSituation = Absent, workSituationDate = Absent, workSituationEndDate = Absent }
    in
    { beneficiaryId = optionals____.beneficiaryId, contractEndDate = optionals____.contractEndDate, contractSignDate = optionals____.contractSignDate, contractStartDate = optionals____.contractStartDate, contractType = optionals____.contractType, createdAt = optionals____.createdAt, educationLevel = optionals____.educationLevel, id = optionals____.id, lastJobEndedAt = optionals____.lastJobEndedAt, rightRqth = optionals____.rightRqth, updatedAt = optionals____.updatedAt, workSituation = optionals____.workSituation, workSituationDate = optionals____.workSituationDate, workSituationEndDate = optionals____.workSituationEndDate }


type alias Notebook_stream_cursor_value_inputOptionalFields =
    { beneficiaryId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , contractEndDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    , contractSignDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    , contractStartDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    , contractType : OptionalArgument String
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , educationLevel : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastJobEndedAt : OptionalArgument CdbGQL.ScalarCodecs.Date
    , rightRqth : OptionalArgument Bool
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , workSituation : OptionalArgument String
    , workSituationDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    , workSituationEndDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    }


{-| Type for the Notebook\_stream\_cursor\_value\_input input object.
-}
type alias Notebook_stream_cursor_value_input =
    { beneficiaryId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , contractEndDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    , contractSignDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    , contractStartDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    , contractType : OptionalArgument String
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , educationLevel : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastJobEndedAt : OptionalArgument CdbGQL.ScalarCodecs.Date
    , rightRqth : OptionalArgument Bool
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , workSituation : OptionalArgument String
    , workSituationDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    , workSituationEndDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    }


{-| Encode a Notebook\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeNotebook_stream_cursor_value_input : Notebook_stream_cursor_value_input -> Value
encodeNotebook_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "beneficiaryId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.beneficiaryId ), ( "contractEndDate", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.contractEndDate ), ( "contractSignDate", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.contractSignDate ), ( "contractStartDate", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.contractStartDate ), ( "contractType", Encode.string |> Encode.optional input____.contractType ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "educationLevel", Encode.string |> Encode.optional input____.educationLevel ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "lastJobEndedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.lastJobEndedAt ), ( "rightRqth", Encode.bool |> Encode.optional input____.rightRqth ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ), ( "workSituation", Encode.string |> Encode.optional input____.workSituation ), ( "workSituationDate", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.workSituationDate ), ( "workSituationEndDate", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.workSituationEndDate ) ]


buildNotebook_target_aggregate_bool_exp :
    (Notebook_target_aggregate_bool_expOptionalFields -> Notebook_target_aggregate_bool_expOptionalFields)
    -> Notebook_target_aggregate_bool_exp
buildNotebook_target_aggregate_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent }
    in
    Notebook_target_aggregate_bool_exp { count = optionals____.count }


type alias Notebook_target_aggregate_bool_expOptionalFields =
    { count : OptionalArgument Notebook_target_aggregate_bool_exp_count }


{-| Type alias for the `Notebook_target_aggregate_bool_exp` attributes. Note that this type
needs to use the `Notebook_target_aggregate_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_target_aggregate_bool_expRaw =
    { count : OptionalArgument Notebook_target_aggregate_bool_exp_count }


{-| Type for the Notebook\_target\_aggregate\_bool\_exp input object.
-}
type Notebook_target_aggregate_bool_exp
    = Notebook_target_aggregate_bool_exp Notebook_target_aggregate_bool_expRaw


{-| Encode a Notebook\_target\_aggregate\_bool\_exp into a value that can be used as an argument.
-}
encodeNotebook_target_aggregate_bool_exp : Notebook_target_aggregate_bool_exp -> Value
encodeNotebook_target_aggregate_bool_exp (Notebook_target_aggregate_bool_exp input____) =
    Encode.maybeObject
        [ ( "count", encodeNotebook_target_aggregate_bool_exp_count |> Encode.optional input____.count ) ]


buildNotebook_target_aggregate_bool_exp_count :
    Notebook_target_aggregate_bool_exp_countRequiredFields
    -> (Notebook_target_aggregate_bool_exp_countOptionalFields -> Notebook_target_aggregate_bool_exp_countOptionalFields)
    -> Notebook_target_aggregate_bool_exp_count
buildNotebook_target_aggregate_bool_exp_count required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { arguments = Absent, distinct = Absent, filter = Absent }
    in
    Notebook_target_aggregate_bool_exp_count { arguments = optionals____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Notebook_target_aggregate_bool_exp_countRequiredFields =
    { predicate : Int_comparison_exp }


type alias Notebook_target_aggregate_bool_exp_countOptionalFields =
    { arguments : OptionalArgument (List CdbGQL.Enum.Notebook_target_select_column.Notebook_target_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Notebook_target_bool_exp
    }


{-| Type alias for the `Notebook_target_aggregate_bool_exp_count` attributes. Note that this type
needs to use the `Notebook_target_aggregate_bool_exp_count` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_target_aggregate_bool_exp_countRaw =
    { arguments : OptionalArgument (List CdbGQL.Enum.Notebook_target_select_column.Notebook_target_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Notebook_target_bool_exp
    , predicate : Int_comparison_exp
    }


{-| Type for the Notebook\_target\_aggregate\_bool\_exp\_count input object.
-}
type Notebook_target_aggregate_bool_exp_count
    = Notebook_target_aggregate_bool_exp_count Notebook_target_aggregate_bool_exp_countRaw


{-| Encode a Notebook\_target\_aggregate\_bool\_exp\_count into a value that can be used as an argument.
-}
encodeNotebook_target_aggregate_bool_exp_count : Notebook_target_aggregate_bool_exp_count -> Value
encodeNotebook_target_aggregate_bool_exp_count (Notebook_target_aggregate_bool_exp_count input____) =
    Encode.maybeObject
        [ ( "arguments", (Encode.enum CdbGQL.Enum.Notebook_target_select_column.toString |> Encode.list) |> Encode.optional input____.arguments ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeNotebook_target_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeInt_comparison_exp input____.predicate |> Just ) ]


buildNotebook_target_aggregate_order_by :
    (Notebook_target_aggregate_order_byOptionalFields -> Notebook_target_aggregate_order_byOptionalFields)
    -> Notebook_target_aggregate_order_by
buildNotebook_target_aggregate_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals____.count, max = optionals____.max, min = optionals____.min }


type alias Notebook_target_aggregate_order_byOptionalFields =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Notebook_target_max_order_by
    , min : OptionalArgument Notebook_target_min_order_by
    }


{-| Type for the Notebook\_target\_aggregate\_order\_by input object.
-}
type alias Notebook_target_aggregate_order_by =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Notebook_target_max_order_by
    , min : OptionalArgument Notebook_target_min_order_by
    }


{-| Encode a Notebook\_target\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_target_aggregate_order_by : Notebook_target_aggregate_order_by -> Value
encodeNotebook_target_aggregate_order_by input____ =
    Encode.maybeObject
        [ ( "count", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.count ), ( "max", encodeNotebook_target_max_order_by |> Encode.optional input____.max ), ( "min", encodeNotebook_target_min_order_by |> Encode.optional input____.min ) ]


buildNotebook_target_arr_rel_insert_input :
    Notebook_target_arr_rel_insert_inputRequiredFields
    -> (Notebook_target_arr_rel_insert_inputOptionalFields -> Notebook_target_arr_rel_insert_inputOptionalFields)
    -> Notebook_target_arr_rel_insert_input
buildNotebook_target_arr_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Notebook_target_arr_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Notebook_target_arr_rel_insert_inputRequiredFields =
    { data : List Notebook_target_insert_input }


type alias Notebook_target_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Notebook_target_on_conflict }


{-| Type alias for the `Notebook_target_arr_rel_insert_input` attributes. Note that this type
needs to use the `Notebook_target_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_target_arr_rel_insert_inputRaw =
    { data : List Notebook_target_insert_input
    , on_conflict : OptionalArgument Notebook_target_on_conflict
    }


{-| Type for the Notebook\_target\_arr\_rel\_insert\_input input object.
-}
type Notebook_target_arr_rel_insert_input
    = Notebook_target_arr_rel_insert_input Notebook_target_arr_rel_insert_inputRaw


{-| Encode a Notebook\_target\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeNotebook_target_arr_rel_insert_input : Notebook_target_arr_rel_insert_input -> Value
encodeNotebook_target_arr_rel_insert_input (Notebook_target_arr_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", (encodeNotebook_target_insert_input |> Encode.list) input____.data |> Just ), ( "on_conflict", encodeNotebook_target_on_conflict |> Encode.optional input____.on_conflict ) ]


buildNotebook_target_bool_exp :
    (Notebook_target_bool_expOptionalFields -> Notebook_target_bool_expOptionalFields)
    -> Notebook_target_bool_exp
buildNotebook_target_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, actions = Absent, actions_aggregate = Absent, createdAt = Absent, creator = Absent, creatorId = Absent, focus = Absent, focusId = Absent, id = Absent, status = Absent, target = Absent, updatedAt = Absent }
    in
    Notebook_target_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, actions = optionals____.actions, actions_aggregate = optionals____.actions_aggregate, createdAt = optionals____.createdAt, creator = optionals____.creator, creatorId = optionals____.creatorId, focus = optionals____.focus, focusId = optionals____.focusId, id = optionals____.id, status = optionals____.status, target = optionals____.target, updatedAt = optionals____.updatedAt }


type alias Notebook_target_bool_expOptionalFields =
    { and_ : OptionalArgument (List Notebook_target_bool_exp)
    , not_ : OptionalArgument Notebook_target_bool_exp
    , or_ : OptionalArgument (List Notebook_target_bool_exp)
    , actions : OptionalArgument Notebook_action_bool_exp
    , actions_aggregate : OptionalArgument Notebook_action_aggregate_bool_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , creator : OptionalArgument Account_bool_exp
    , creatorId : OptionalArgument Uuid_comparison_exp
    , focus : OptionalArgument Notebook_focus_bool_exp
    , focusId : OptionalArgument Uuid_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , status : OptionalArgument String_comparison_exp
    , target : OptionalArgument String_comparison_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type alias for the `Notebook_target_bool_exp` attributes. Note that this type
needs to use the `Notebook_target_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_target_bool_expRaw =
    { and_ : OptionalArgument (List Notebook_target_bool_exp)
    , not_ : OptionalArgument Notebook_target_bool_exp
    , or_ : OptionalArgument (List Notebook_target_bool_exp)
    , actions : OptionalArgument Notebook_action_bool_exp
    , actions_aggregate : OptionalArgument Notebook_action_aggregate_bool_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , creator : OptionalArgument Account_bool_exp
    , creatorId : OptionalArgument Uuid_comparison_exp
    , focus : OptionalArgument Notebook_focus_bool_exp
    , focusId : OptionalArgument Uuid_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , status : OptionalArgument String_comparison_exp
    , target : OptionalArgument String_comparison_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type for the Notebook\_target\_bool\_exp input object.
-}
type Notebook_target_bool_exp
    = Notebook_target_bool_exp Notebook_target_bool_expRaw


{-| Encode a Notebook\_target\_bool\_exp into a value that can be used as an argument.
-}
encodeNotebook_target_bool_exp : Notebook_target_bool_exp -> Value
encodeNotebook_target_bool_exp (Notebook_target_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeNotebook_target_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeNotebook_target_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeNotebook_target_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "actions", encodeNotebook_action_bool_exp |> Encode.optional input____.actions ), ( "actions_aggregate", encodeNotebook_action_aggregate_bool_exp |> Encode.optional input____.actions_aggregate ), ( "createdAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.createdAt ), ( "creator", encodeAccount_bool_exp |> Encode.optional input____.creator ), ( "creatorId", encodeUuid_comparison_exp |> Encode.optional input____.creatorId ), ( "focus", encodeNotebook_focus_bool_exp |> Encode.optional input____.focus ), ( "focusId", encodeUuid_comparison_exp |> Encode.optional input____.focusId ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "status", encodeString_comparison_exp |> Encode.optional input____.status ), ( "target", encodeString_comparison_exp |> Encode.optional input____.target ), ( "updatedAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.updatedAt ) ]


buildNotebook_target_insert_input :
    (Notebook_target_insert_inputOptionalFields -> Notebook_target_insert_inputOptionalFields)
    -> Notebook_target_insert_input
buildNotebook_target_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { actions = Absent, createdAt = Absent, creator = Absent, creatorId = Absent, focus = Absent, focusId = Absent, id = Absent, status = Absent, target = Absent, updatedAt = Absent }
    in
    Notebook_target_insert_input { actions = optionals____.actions, createdAt = optionals____.createdAt, creator = optionals____.creator, creatorId = optionals____.creatorId, focus = optionals____.focus, focusId = optionals____.focusId, id = optionals____.id, status = optionals____.status, target = optionals____.target, updatedAt = optionals____.updatedAt }


type alias Notebook_target_insert_inputOptionalFields =
    { actions : OptionalArgument Notebook_action_arr_rel_insert_input
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , creator : OptionalArgument Account_obj_rel_insert_input
    , creatorId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , focus : OptionalArgument Notebook_focus_obj_rel_insert_input
    , focusId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , status : OptionalArgument String
    , target : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type alias for the `Notebook_target_insert_input` attributes. Note that this type
needs to use the `Notebook_target_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_target_insert_inputRaw =
    { actions : OptionalArgument Notebook_action_arr_rel_insert_input
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , creator : OptionalArgument Account_obj_rel_insert_input
    , creatorId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , focus : OptionalArgument Notebook_focus_obj_rel_insert_input
    , focusId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , status : OptionalArgument String
    , target : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Notebook\_target\_insert\_input input object.
-}
type Notebook_target_insert_input
    = Notebook_target_insert_input Notebook_target_insert_inputRaw


{-| Encode a Notebook\_target\_insert\_input into a value that can be used as an argument.
-}
encodeNotebook_target_insert_input : Notebook_target_insert_input -> Value
encodeNotebook_target_insert_input (Notebook_target_insert_input input____) =
    Encode.maybeObject
        [ ( "actions", encodeNotebook_action_arr_rel_insert_input |> Encode.optional input____.actions ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "creator", encodeAccount_obj_rel_insert_input |> Encode.optional input____.creator ), ( "creatorId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.creatorId ), ( "focus", encodeNotebook_focus_obj_rel_insert_input |> Encode.optional input____.focus ), ( "focusId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.focusId ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "status", Encode.string |> Encode.optional input____.status ), ( "target", Encode.string |> Encode.optional input____.target ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildNotebook_target_max_order_by :
    (Notebook_target_max_order_byOptionalFields -> Notebook_target_max_order_byOptionalFields)
    -> Notebook_target_max_order_by
buildNotebook_target_max_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, creatorId = Absent, focusId = Absent, id = Absent, status = Absent, target = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, creatorId = optionals____.creatorId, focusId = optionals____.focusId, id = optionals____.id, status = optionals____.status, target = optionals____.target, updatedAt = optionals____.updatedAt }


type alias Notebook_target_max_order_byOptionalFields =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creatorId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , focusId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , status : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , target : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Notebook\_target\_max\_order\_by input object.
-}
type alias Notebook_target_max_order_by =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creatorId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , focusId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , status : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , target : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Notebook\_target\_max\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_target_max_order_by : Notebook_target_max_order_by -> Value
encodeNotebook_target_max_order_by input____ =
    Encode.maybeObject
        [ ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "creatorId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.creatorId ), ( "focusId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.focusId ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "status", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.status ), ( "target", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.target ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildNotebook_target_min_order_by :
    (Notebook_target_min_order_byOptionalFields -> Notebook_target_min_order_byOptionalFields)
    -> Notebook_target_min_order_by
buildNotebook_target_min_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, creatorId = Absent, focusId = Absent, id = Absent, status = Absent, target = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, creatorId = optionals____.creatorId, focusId = optionals____.focusId, id = optionals____.id, status = optionals____.status, target = optionals____.target, updatedAt = optionals____.updatedAt }


type alias Notebook_target_min_order_byOptionalFields =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creatorId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , focusId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , status : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , target : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Notebook\_target\_min\_order\_by input object.
-}
type alias Notebook_target_min_order_by =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creatorId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , focusId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , status : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , target : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Notebook\_target\_min\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_target_min_order_by : Notebook_target_min_order_by -> Value
encodeNotebook_target_min_order_by input____ =
    Encode.maybeObject
        [ ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "creatorId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.creatorId ), ( "focusId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.focusId ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "status", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.status ), ( "target", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.target ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildNotebook_target_obj_rel_insert_input :
    Notebook_target_obj_rel_insert_inputRequiredFields
    -> (Notebook_target_obj_rel_insert_inputOptionalFields -> Notebook_target_obj_rel_insert_inputOptionalFields)
    -> Notebook_target_obj_rel_insert_input
buildNotebook_target_obj_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Notebook_target_obj_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Notebook_target_obj_rel_insert_inputRequiredFields =
    { data : Notebook_target_insert_input }


type alias Notebook_target_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Notebook_target_on_conflict }


{-| Type alias for the `Notebook_target_obj_rel_insert_input` attributes. Note that this type
needs to use the `Notebook_target_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_target_obj_rel_insert_inputRaw =
    { data : Notebook_target_insert_input
    , on_conflict : OptionalArgument Notebook_target_on_conflict
    }


{-| Type for the Notebook\_target\_obj\_rel\_insert\_input input object.
-}
type Notebook_target_obj_rel_insert_input
    = Notebook_target_obj_rel_insert_input Notebook_target_obj_rel_insert_inputRaw


{-| Encode a Notebook\_target\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeNotebook_target_obj_rel_insert_input : Notebook_target_obj_rel_insert_input -> Value
encodeNotebook_target_obj_rel_insert_input (Notebook_target_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeNotebook_target_insert_input input____.data |> Just ), ( "on_conflict", encodeNotebook_target_on_conflict |> Encode.optional input____.on_conflict ) ]


buildNotebook_target_on_conflict :
    Notebook_target_on_conflictRequiredFields
    -> (Notebook_target_on_conflictOptionalFields -> Notebook_target_on_conflictOptionalFields)
    -> Notebook_target_on_conflict
buildNotebook_target_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Notebook_target_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Notebook_target_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Notebook_target_constraint.Notebook_target_constraint
    , update_columns : List CdbGQL.Enum.Notebook_target_update_column.Notebook_target_update_column
    }


type alias Notebook_target_on_conflictOptionalFields =
    { where_ : OptionalArgument Notebook_target_bool_exp }


{-| Type alias for the `Notebook_target_on_conflict` attributes. Note that this type
needs to use the `Notebook_target_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_target_on_conflictRaw =
    { constraint : CdbGQL.Enum.Notebook_target_constraint.Notebook_target_constraint
    , update_columns : List CdbGQL.Enum.Notebook_target_update_column.Notebook_target_update_column
    , where_ : OptionalArgument Notebook_target_bool_exp
    }


{-| Type for the Notebook\_target\_on\_conflict input object.
-}
type Notebook_target_on_conflict
    = Notebook_target_on_conflict Notebook_target_on_conflictRaw


{-| Encode a Notebook\_target\_on\_conflict into a value that can be used as an argument.
-}
encodeNotebook_target_on_conflict : Notebook_target_on_conflict -> Value
encodeNotebook_target_on_conflict (Notebook_target_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Notebook_target_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Notebook_target_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeNotebook_target_bool_exp |> Encode.optional input____.where_ ) ]


buildNotebook_target_order_by :
    (Notebook_target_order_byOptionalFields -> Notebook_target_order_byOptionalFields)
    -> Notebook_target_order_by
buildNotebook_target_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { actions_aggregate = Absent, createdAt = Absent, creator = Absent, creatorId = Absent, focus = Absent, focusId = Absent, id = Absent, status = Absent, target = Absent, updatedAt = Absent }
    in
    Notebook_target_order_by { actions_aggregate = optionals____.actions_aggregate, createdAt = optionals____.createdAt, creator = optionals____.creator, creatorId = optionals____.creatorId, focus = optionals____.focus, focusId = optionals____.focusId, id = optionals____.id, status = optionals____.status, target = optionals____.target, updatedAt = optionals____.updatedAt }


type alias Notebook_target_order_byOptionalFields =
    { actions_aggregate : OptionalArgument Notebook_action_aggregate_order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creator : OptionalArgument Account_order_by
    , creatorId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , focus : OptionalArgument Notebook_focus_order_by
    , focusId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , status : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , target : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type alias for the `Notebook_target_order_by` attributes. Note that this type
needs to use the `Notebook_target_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_target_order_byRaw =
    { actions_aggregate : OptionalArgument Notebook_action_aggregate_order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , creator : OptionalArgument Account_order_by
    , creatorId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , focus : OptionalArgument Notebook_focus_order_by
    , focusId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , status : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , target : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Notebook\_target\_order\_by input object.
-}
type Notebook_target_order_by
    = Notebook_target_order_by Notebook_target_order_byRaw


{-| Encode a Notebook\_target\_order\_by into a value that can be used as an argument.
-}
encodeNotebook_target_order_by : Notebook_target_order_by -> Value
encodeNotebook_target_order_by (Notebook_target_order_by input____) =
    Encode.maybeObject
        [ ( "actions_aggregate", encodeNotebook_action_aggregate_order_by |> Encode.optional input____.actions_aggregate ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "creator", encodeAccount_order_by |> Encode.optional input____.creator ), ( "creatorId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.creatorId ), ( "focus", encodeNotebook_focus_order_by |> Encode.optional input____.focus ), ( "focusId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.focusId ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "status", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.status ), ( "target", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.target ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildNotebook_target_pk_columns_input :
    Notebook_target_pk_columns_inputRequiredFields
    -> Notebook_target_pk_columns_input
buildNotebook_target_pk_columns_input required____ =
    { id = required____.id }


type alias Notebook_target_pk_columns_inputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the Notebook\_target\_pk\_columns\_input input object.
-}
type alias Notebook_target_pk_columns_input =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a Notebook\_target\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeNotebook_target_pk_columns_input : Notebook_target_pk_columns_input -> Value
encodeNotebook_target_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildNotebook_target_set_input :
    (Notebook_target_set_inputOptionalFields -> Notebook_target_set_inputOptionalFields)
    -> Notebook_target_set_input
buildNotebook_target_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, creatorId = Absent, focusId = Absent, id = Absent, status = Absent, target = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, creatorId = optionals____.creatorId, focusId = optionals____.focusId, id = optionals____.id, status = optionals____.status, target = optionals____.target, updatedAt = optionals____.updatedAt }


type alias Notebook_target_set_inputOptionalFields =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , creatorId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , focusId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , status : OptionalArgument String
    , target : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Notebook\_target\_set\_input input object.
-}
type alias Notebook_target_set_input =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , creatorId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , focusId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , status : OptionalArgument String
    , target : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Notebook\_target\_set\_input into a value that can be used as an argument.
-}
encodeNotebook_target_set_input : Notebook_target_set_input -> Value
encodeNotebook_target_set_input input____ =
    Encode.maybeObject
        [ ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "creatorId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.creatorId ), ( "focusId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.focusId ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "status", Encode.string |> Encode.optional input____.status ), ( "target", Encode.string |> Encode.optional input____.target ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildNotebook_target_stream_cursor_input :
    Notebook_target_stream_cursor_inputRequiredFields
    -> (Notebook_target_stream_cursor_inputOptionalFields -> Notebook_target_stream_cursor_inputOptionalFields)
    -> Notebook_target_stream_cursor_input
buildNotebook_target_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Notebook_target_stream_cursor_inputRequiredFields =
    { initial_value : Notebook_target_stream_cursor_value_input }


type alias Notebook_target_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Notebook\_target\_stream\_cursor\_input input object.
-}
type alias Notebook_target_stream_cursor_input =
    { initial_value : Notebook_target_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Notebook\_target\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeNotebook_target_stream_cursor_input : Notebook_target_stream_cursor_input -> Value
encodeNotebook_target_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeNotebook_target_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildNotebook_target_stream_cursor_value_input :
    (Notebook_target_stream_cursor_value_inputOptionalFields -> Notebook_target_stream_cursor_value_inputOptionalFields)
    -> Notebook_target_stream_cursor_value_input
buildNotebook_target_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, creatorId = Absent, focusId = Absent, id = Absent, status = Absent, target = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, creatorId = optionals____.creatorId, focusId = optionals____.focusId, id = optionals____.id, status = optionals____.status, target = optionals____.target, updatedAt = optionals____.updatedAt }


type alias Notebook_target_stream_cursor_value_inputOptionalFields =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , creatorId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , focusId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , status : OptionalArgument String
    , target : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Notebook\_target\_stream\_cursor\_value\_input input object.
-}
type alias Notebook_target_stream_cursor_value_input =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , creatorId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , focusId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , status : OptionalArgument String
    , target : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Notebook\_target\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeNotebook_target_stream_cursor_value_input : Notebook_target_stream_cursor_value_input -> Value
encodeNotebook_target_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "creatorId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.creatorId ), ( "focusId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.focusId ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "status", Encode.string |> Encode.optional input____.status ), ( "target", Encode.string |> Encode.optional input____.target ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildNotebook_target_updates :
    Notebook_target_updatesRequiredFields
    -> (Notebook_target_updatesOptionalFields -> Notebook_target_updatesOptionalFields)
    -> Notebook_target_updates
buildNotebook_target_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Notebook_target_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Notebook_target_updatesRequiredFields =
    { where_ : Notebook_target_bool_exp }


type alias Notebook_target_updatesOptionalFields =
    { set_ : OptionalArgument Notebook_target_set_input }


{-| Type alias for the `Notebook_target_updates` attributes. Note that this type
needs to use the `Notebook_target_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_target_updatesRaw =
    { set_ : OptionalArgument Notebook_target_set_input
    , where_ : Notebook_target_bool_exp
    }


{-| Type for the Notebook\_target\_updates input object.
-}
type Notebook_target_updates
    = Notebook_target_updates Notebook_target_updatesRaw


{-| Encode a Notebook\_target\_updates into a value that can be used as an argument.
-}
encodeNotebook_target_updates : Notebook_target_updates -> Value
encodeNotebook_target_updates (Notebook_target_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeNotebook_target_set_input |> Encode.optional input____.set_ ), ( "where", encodeNotebook_target_bool_exp input____.where_ |> Just ) ]


buildNotebook_updates :
    Notebook_updatesRequiredFields
    -> (Notebook_updatesOptionalFields -> Notebook_updatesOptionalFields)
    -> Notebook_updates
buildNotebook_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Notebook_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Notebook_updatesRequiredFields =
    { where_ : Notebook_bool_exp }


type alias Notebook_updatesOptionalFields =
    { set_ : OptionalArgument Notebook_set_input }


{-| Type alias for the `Notebook_updates` attributes. Note that this type
needs to use the `Notebook_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Notebook_updatesRaw =
    { set_ : OptionalArgument Notebook_set_input
    , where_ : Notebook_bool_exp
    }


{-| Type for the Notebook\_updates input object.
-}
type Notebook_updates
    = Notebook_updates Notebook_updatesRaw


{-| Encode a Notebook\_updates into a value that can be used as an argument.
-}
encodeNotebook_updates : Notebook_updates -> Value
encodeNotebook_updates (Notebook_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeNotebook_set_input |> Encode.optional input____.set_ ), ( "where", encodeNotebook_bool_exp input____.where_ |> Just ) ]


buildNps_rating_bool_exp :
    (Nps_rating_bool_expOptionalFields -> Nps_rating_bool_expOptionalFields)
    -> Nps_rating_bool_exp
buildNps_rating_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, accountId = Absent, createdAt = Absent, created_at_posix_ms = Absent, id = Absent, score = Absent }
    in
    Nps_rating_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, accountId = optionals____.accountId, createdAt = optionals____.createdAt, created_at_posix_ms = optionals____.created_at_posix_ms, id = optionals____.id, score = optionals____.score }


type alias Nps_rating_bool_expOptionalFields =
    { and_ : OptionalArgument (List Nps_rating_bool_exp)
    , not_ : OptionalArgument Nps_rating_bool_exp
    , or_ : OptionalArgument (List Nps_rating_bool_exp)
    , accountId : OptionalArgument Uuid_comparison_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , created_at_posix_ms : OptionalArgument Float8_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , score : OptionalArgument Int_comparison_exp
    }


{-| Type alias for the `Nps_rating_bool_exp` attributes. Note that this type
needs to use the `Nps_rating_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Nps_rating_bool_expRaw =
    { and_ : OptionalArgument (List Nps_rating_bool_exp)
    , not_ : OptionalArgument Nps_rating_bool_exp
    , or_ : OptionalArgument (List Nps_rating_bool_exp)
    , accountId : OptionalArgument Uuid_comparison_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , created_at_posix_ms : OptionalArgument Float8_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , score : OptionalArgument Int_comparison_exp
    }


{-| Type for the Nps\_rating\_bool\_exp input object.
-}
type Nps_rating_bool_exp
    = Nps_rating_bool_exp Nps_rating_bool_expRaw


{-| Encode a Nps\_rating\_bool\_exp into a value that can be used as an argument.
-}
encodeNps_rating_bool_exp : Nps_rating_bool_exp -> Value
encodeNps_rating_bool_exp (Nps_rating_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeNps_rating_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeNps_rating_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeNps_rating_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "accountId", encodeUuid_comparison_exp |> Encode.optional input____.accountId ), ( "createdAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.createdAt ), ( "created_at_posix_ms", encodeFloat8_comparison_exp |> Encode.optional input____.created_at_posix_ms ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "score", encodeInt_comparison_exp |> Encode.optional input____.score ) ]


buildNps_rating_dismissal_bool_exp :
    (Nps_rating_dismissal_bool_expOptionalFields -> Nps_rating_dismissal_bool_expOptionalFields)
    -> Nps_rating_dismissal_bool_exp
buildNps_rating_dismissal_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, accountId = Absent, dismissedAt = Absent, dismissed_at_posix_ms = Absent, id = Absent }
    in
    Nps_rating_dismissal_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, accountId = optionals____.accountId, dismissedAt = optionals____.dismissedAt, dismissed_at_posix_ms = optionals____.dismissed_at_posix_ms, id = optionals____.id }


type alias Nps_rating_dismissal_bool_expOptionalFields =
    { and_ : OptionalArgument (List Nps_rating_dismissal_bool_exp)
    , not_ : OptionalArgument Nps_rating_dismissal_bool_exp
    , or_ : OptionalArgument (List Nps_rating_dismissal_bool_exp)
    , accountId : OptionalArgument Uuid_comparison_exp
    , dismissedAt : OptionalArgument Timestamptz_comparison_exp
    , dismissed_at_posix_ms : OptionalArgument Float8_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    }


{-| Type alias for the `Nps_rating_dismissal_bool_exp` attributes. Note that this type
needs to use the `Nps_rating_dismissal_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Nps_rating_dismissal_bool_expRaw =
    { and_ : OptionalArgument (List Nps_rating_dismissal_bool_exp)
    , not_ : OptionalArgument Nps_rating_dismissal_bool_exp
    , or_ : OptionalArgument (List Nps_rating_dismissal_bool_exp)
    , accountId : OptionalArgument Uuid_comparison_exp
    , dismissedAt : OptionalArgument Timestamptz_comparison_exp
    , dismissed_at_posix_ms : OptionalArgument Float8_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    }


{-| Type for the Nps\_rating\_dismissal\_bool\_exp input object.
-}
type Nps_rating_dismissal_bool_exp
    = Nps_rating_dismissal_bool_exp Nps_rating_dismissal_bool_expRaw


{-| Encode a Nps\_rating\_dismissal\_bool\_exp into a value that can be used as an argument.
-}
encodeNps_rating_dismissal_bool_exp : Nps_rating_dismissal_bool_exp -> Value
encodeNps_rating_dismissal_bool_exp (Nps_rating_dismissal_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeNps_rating_dismissal_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeNps_rating_dismissal_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeNps_rating_dismissal_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "accountId", encodeUuid_comparison_exp |> Encode.optional input____.accountId ), ( "dismissedAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.dismissedAt ), ( "dismissed_at_posix_ms", encodeFloat8_comparison_exp |> Encode.optional input____.dismissed_at_posix_ms ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ) ]


buildNps_rating_dismissal_insert_input :
    (Nps_rating_dismissal_insert_inputOptionalFields -> Nps_rating_dismissal_insert_inputOptionalFields)
    -> Nps_rating_dismissal_insert_input
buildNps_rating_dismissal_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { accountId = Absent, dismissedAt = Absent, id = Absent }
    in
    { accountId = optionals____.accountId, dismissedAt = optionals____.dismissedAt, id = optionals____.id }


type alias Nps_rating_dismissal_insert_inputOptionalFields =
    { accountId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , dismissedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Type for the Nps\_rating\_dismissal\_insert\_input input object.
-}
type alias Nps_rating_dismissal_insert_input =
    { accountId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , dismissedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Encode a Nps\_rating\_dismissal\_insert\_input into a value that can be used as an argument.
-}
encodeNps_rating_dismissal_insert_input : Nps_rating_dismissal_insert_input -> Value
encodeNps_rating_dismissal_insert_input input____ =
    Encode.maybeObject
        [ ( "accountId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.accountId ), ( "dismissedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.dismissedAt ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ) ]


buildNps_rating_dismissal_on_conflict :
    Nps_rating_dismissal_on_conflictRequiredFields
    -> (Nps_rating_dismissal_on_conflictOptionalFields -> Nps_rating_dismissal_on_conflictOptionalFields)
    -> Nps_rating_dismissal_on_conflict
buildNps_rating_dismissal_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Nps_rating_dismissal_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Nps_rating_dismissal_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Nps_rating_dismissal_constraint.Nps_rating_dismissal_constraint
    , update_columns : List CdbGQL.Enum.Nps_rating_dismissal_update_column.Nps_rating_dismissal_update_column
    }


type alias Nps_rating_dismissal_on_conflictOptionalFields =
    { where_ : OptionalArgument Nps_rating_dismissal_bool_exp }


{-| Type alias for the `Nps_rating_dismissal_on_conflict` attributes. Note that this type
needs to use the `Nps_rating_dismissal_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Nps_rating_dismissal_on_conflictRaw =
    { constraint : CdbGQL.Enum.Nps_rating_dismissal_constraint.Nps_rating_dismissal_constraint
    , update_columns : List CdbGQL.Enum.Nps_rating_dismissal_update_column.Nps_rating_dismissal_update_column
    , where_ : OptionalArgument Nps_rating_dismissal_bool_exp
    }


{-| Type for the Nps\_rating\_dismissal\_on\_conflict input object.
-}
type Nps_rating_dismissal_on_conflict
    = Nps_rating_dismissal_on_conflict Nps_rating_dismissal_on_conflictRaw


{-| Encode a Nps\_rating\_dismissal\_on\_conflict into a value that can be used as an argument.
-}
encodeNps_rating_dismissal_on_conflict : Nps_rating_dismissal_on_conflict -> Value
encodeNps_rating_dismissal_on_conflict (Nps_rating_dismissal_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Nps_rating_dismissal_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Nps_rating_dismissal_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeNps_rating_dismissal_bool_exp |> Encode.optional input____.where_ ) ]


buildNps_rating_dismissal_order_by :
    (Nps_rating_dismissal_order_byOptionalFields -> Nps_rating_dismissal_order_byOptionalFields)
    -> Nps_rating_dismissal_order_by
buildNps_rating_dismissal_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { accountId = Absent, dismissedAt = Absent, dismissed_at_posix_ms = Absent, id = Absent }
    in
    { accountId = optionals____.accountId, dismissedAt = optionals____.dismissedAt, dismissed_at_posix_ms = optionals____.dismissed_at_posix_ms, id = optionals____.id }


type alias Nps_rating_dismissal_order_byOptionalFields =
    { accountId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , dismissedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , dismissed_at_posix_ms : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Nps\_rating\_dismissal\_order\_by input object.
-}
type alias Nps_rating_dismissal_order_by =
    { accountId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , dismissedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , dismissed_at_posix_ms : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Nps\_rating\_dismissal\_order\_by into a value that can be used as an argument.
-}
encodeNps_rating_dismissal_order_by : Nps_rating_dismissal_order_by -> Value
encodeNps_rating_dismissal_order_by input____ =
    Encode.maybeObject
        [ ( "accountId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.accountId ), ( "dismissedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.dismissedAt ), ( "dismissed_at_posix_ms", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.dismissed_at_posix_ms ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ) ]


buildNps_rating_dismissal_pk_columns_input :
    Nps_rating_dismissal_pk_columns_inputRequiredFields
    -> Nps_rating_dismissal_pk_columns_input
buildNps_rating_dismissal_pk_columns_input required____ =
    { id = required____.id }


type alias Nps_rating_dismissal_pk_columns_inputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the Nps\_rating\_dismissal\_pk\_columns\_input input object.
-}
type alias Nps_rating_dismissal_pk_columns_input =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a Nps\_rating\_dismissal\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeNps_rating_dismissal_pk_columns_input : Nps_rating_dismissal_pk_columns_input -> Value
encodeNps_rating_dismissal_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildNps_rating_dismissal_set_input :
    (Nps_rating_dismissal_set_inputOptionalFields -> Nps_rating_dismissal_set_inputOptionalFields)
    -> Nps_rating_dismissal_set_input
buildNps_rating_dismissal_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { accountId = Absent, dismissedAt = Absent, id = Absent }
    in
    { accountId = optionals____.accountId, dismissedAt = optionals____.dismissedAt, id = optionals____.id }


type alias Nps_rating_dismissal_set_inputOptionalFields =
    { accountId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , dismissedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Type for the Nps\_rating\_dismissal\_set\_input input object.
-}
type alias Nps_rating_dismissal_set_input =
    { accountId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , dismissedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Encode a Nps\_rating\_dismissal\_set\_input into a value that can be used as an argument.
-}
encodeNps_rating_dismissal_set_input : Nps_rating_dismissal_set_input -> Value
encodeNps_rating_dismissal_set_input input____ =
    Encode.maybeObject
        [ ( "accountId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.accountId ), ( "dismissedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.dismissedAt ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ) ]


buildNps_rating_dismissal_stream_cursor_input :
    Nps_rating_dismissal_stream_cursor_inputRequiredFields
    -> (Nps_rating_dismissal_stream_cursor_inputOptionalFields -> Nps_rating_dismissal_stream_cursor_inputOptionalFields)
    -> Nps_rating_dismissal_stream_cursor_input
buildNps_rating_dismissal_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Nps_rating_dismissal_stream_cursor_inputRequiredFields =
    { initial_value : Nps_rating_dismissal_stream_cursor_value_input }


type alias Nps_rating_dismissal_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Nps\_rating\_dismissal\_stream\_cursor\_input input object.
-}
type alias Nps_rating_dismissal_stream_cursor_input =
    { initial_value : Nps_rating_dismissal_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Nps\_rating\_dismissal\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeNps_rating_dismissal_stream_cursor_input : Nps_rating_dismissal_stream_cursor_input -> Value
encodeNps_rating_dismissal_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeNps_rating_dismissal_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildNps_rating_dismissal_stream_cursor_value_input :
    (Nps_rating_dismissal_stream_cursor_value_inputOptionalFields -> Nps_rating_dismissal_stream_cursor_value_inputOptionalFields)
    -> Nps_rating_dismissal_stream_cursor_value_input
buildNps_rating_dismissal_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { accountId = Absent, dismissedAt = Absent, id = Absent }
    in
    { accountId = optionals____.accountId, dismissedAt = optionals____.dismissedAt, id = optionals____.id }


type alias Nps_rating_dismissal_stream_cursor_value_inputOptionalFields =
    { accountId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , dismissedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Type for the Nps\_rating\_dismissal\_stream\_cursor\_value\_input input object.
-}
type alias Nps_rating_dismissal_stream_cursor_value_input =
    { accountId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , dismissedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Encode a Nps\_rating\_dismissal\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeNps_rating_dismissal_stream_cursor_value_input : Nps_rating_dismissal_stream_cursor_value_input -> Value
encodeNps_rating_dismissal_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "accountId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.accountId ), ( "dismissedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.dismissedAt ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ) ]


buildNps_rating_dismissal_updates :
    Nps_rating_dismissal_updatesRequiredFields
    -> (Nps_rating_dismissal_updatesOptionalFields -> Nps_rating_dismissal_updatesOptionalFields)
    -> Nps_rating_dismissal_updates
buildNps_rating_dismissal_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Nps_rating_dismissal_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Nps_rating_dismissal_updatesRequiredFields =
    { where_ : Nps_rating_dismissal_bool_exp }


type alias Nps_rating_dismissal_updatesOptionalFields =
    { set_ : OptionalArgument Nps_rating_dismissal_set_input }


{-| Type alias for the `Nps_rating_dismissal_updates` attributes. Note that this type
needs to use the `Nps_rating_dismissal_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Nps_rating_dismissal_updatesRaw =
    { set_ : OptionalArgument Nps_rating_dismissal_set_input
    , where_ : Nps_rating_dismissal_bool_exp
    }


{-| Type for the Nps\_rating\_dismissal\_updates input object.
-}
type Nps_rating_dismissal_updates
    = Nps_rating_dismissal_updates Nps_rating_dismissal_updatesRaw


{-| Encode a Nps\_rating\_dismissal\_updates into a value that can be used as an argument.
-}
encodeNps_rating_dismissal_updates : Nps_rating_dismissal_updates -> Value
encodeNps_rating_dismissal_updates (Nps_rating_dismissal_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeNps_rating_dismissal_set_input |> Encode.optional input____.set_ ), ( "where", encodeNps_rating_dismissal_bool_exp input____.where_ |> Just ) ]


buildNps_rating_inc_input :
    (Nps_rating_inc_inputOptionalFields -> Nps_rating_inc_inputOptionalFields)
    -> Nps_rating_inc_input
buildNps_rating_inc_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { score = Absent }
    in
    { score = optionals____.score }


type alias Nps_rating_inc_inputOptionalFields =
    { score : OptionalArgument Int }


{-| Type for the Nps\_rating\_inc\_input input object.
-}
type alias Nps_rating_inc_input =
    { score : OptionalArgument Int }


{-| Encode a Nps\_rating\_inc\_input into a value that can be used as an argument.
-}
encodeNps_rating_inc_input : Nps_rating_inc_input -> Value
encodeNps_rating_inc_input input____ =
    Encode.maybeObject
        [ ( "score", Encode.int |> Encode.optional input____.score ) ]


buildNps_rating_insert_input :
    (Nps_rating_insert_inputOptionalFields -> Nps_rating_insert_inputOptionalFields)
    -> Nps_rating_insert_input
buildNps_rating_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { accountId = Absent, createdAt = Absent, id = Absent, score = Absent }
    in
    { accountId = optionals____.accountId, createdAt = optionals____.createdAt, id = optionals____.id, score = optionals____.score }


type alias Nps_rating_insert_inputOptionalFields =
    { accountId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , score : OptionalArgument Int
    }


{-| Type for the Nps\_rating\_insert\_input input object.
-}
type alias Nps_rating_insert_input =
    { accountId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , score : OptionalArgument Int
    }


{-| Encode a Nps\_rating\_insert\_input into a value that can be used as an argument.
-}
encodeNps_rating_insert_input : Nps_rating_insert_input -> Value
encodeNps_rating_insert_input input____ =
    Encode.maybeObject
        [ ( "accountId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.accountId ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "score", Encode.int |> Encode.optional input____.score ) ]


buildNps_rating_on_conflict :
    Nps_rating_on_conflictRequiredFields
    -> (Nps_rating_on_conflictOptionalFields -> Nps_rating_on_conflictOptionalFields)
    -> Nps_rating_on_conflict
buildNps_rating_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Nps_rating_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Nps_rating_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Nps_rating_constraint.Nps_rating_constraint
    , update_columns : List CdbGQL.Enum.Nps_rating_update_column.Nps_rating_update_column
    }


type alias Nps_rating_on_conflictOptionalFields =
    { where_ : OptionalArgument Nps_rating_bool_exp }


{-| Type alias for the `Nps_rating_on_conflict` attributes. Note that this type
needs to use the `Nps_rating_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Nps_rating_on_conflictRaw =
    { constraint : CdbGQL.Enum.Nps_rating_constraint.Nps_rating_constraint
    , update_columns : List CdbGQL.Enum.Nps_rating_update_column.Nps_rating_update_column
    , where_ : OptionalArgument Nps_rating_bool_exp
    }


{-| Type for the Nps\_rating\_on\_conflict input object.
-}
type Nps_rating_on_conflict
    = Nps_rating_on_conflict Nps_rating_on_conflictRaw


{-| Encode a Nps\_rating\_on\_conflict into a value that can be used as an argument.
-}
encodeNps_rating_on_conflict : Nps_rating_on_conflict -> Value
encodeNps_rating_on_conflict (Nps_rating_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Nps_rating_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Nps_rating_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeNps_rating_bool_exp |> Encode.optional input____.where_ ) ]


buildNps_rating_order_by :
    (Nps_rating_order_byOptionalFields -> Nps_rating_order_byOptionalFields)
    -> Nps_rating_order_by
buildNps_rating_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { accountId = Absent, createdAt = Absent, created_at_posix_ms = Absent, id = Absent, score = Absent }
    in
    { accountId = optionals____.accountId, createdAt = optionals____.createdAt, created_at_posix_ms = optionals____.created_at_posix_ms, id = optionals____.id, score = optionals____.score }


type alias Nps_rating_order_byOptionalFields =
    { accountId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , created_at_posix_ms : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , score : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Nps\_rating\_order\_by input object.
-}
type alias Nps_rating_order_by =
    { accountId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , created_at_posix_ms : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , score : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Nps\_rating\_order\_by into a value that can be used as an argument.
-}
encodeNps_rating_order_by : Nps_rating_order_by -> Value
encodeNps_rating_order_by input____ =
    Encode.maybeObject
        [ ( "accountId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.accountId ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "created_at_posix_ms", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.created_at_posix_ms ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "score", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.score ) ]


buildNps_rating_pk_columns_input :
    Nps_rating_pk_columns_inputRequiredFields
    -> Nps_rating_pk_columns_input
buildNps_rating_pk_columns_input required____ =
    { id = required____.id }


type alias Nps_rating_pk_columns_inputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the Nps\_rating\_pk\_columns\_input input object.
-}
type alias Nps_rating_pk_columns_input =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a Nps\_rating\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeNps_rating_pk_columns_input : Nps_rating_pk_columns_input -> Value
encodeNps_rating_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildNps_rating_set_input :
    (Nps_rating_set_inputOptionalFields -> Nps_rating_set_inputOptionalFields)
    -> Nps_rating_set_input
buildNps_rating_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { accountId = Absent, createdAt = Absent, id = Absent, score = Absent }
    in
    { accountId = optionals____.accountId, createdAt = optionals____.createdAt, id = optionals____.id, score = optionals____.score }


type alias Nps_rating_set_inputOptionalFields =
    { accountId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , score : OptionalArgument Int
    }


{-| Type for the Nps\_rating\_set\_input input object.
-}
type alias Nps_rating_set_input =
    { accountId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , score : OptionalArgument Int
    }


{-| Encode a Nps\_rating\_set\_input into a value that can be used as an argument.
-}
encodeNps_rating_set_input : Nps_rating_set_input -> Value
encodeNps_rating_set_input input____ =
    Encode.maybeObject
        [ ( "accountId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.accountId ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "score", Encode.int |> Encode.optional input____.score ) ]


buildNps_rating_stream_cursor_input :
    Nps_rating_stream_cursor_inputRequiredFields
    -> (Nps_rating_stream_cursor_inputOptionalFields -> Nps_rating_stream_cursor_inputOptionalFields)
    -> Nps_rating_stream_cursor_input
buildNps_rating_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Nps_rating_stream_cursor_inputRequiredFields =
    { initial_value : Nps_rating_stream_cursor_value_input }


type alias Nps_rating_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Nps\_rating\_stream\_cursor\_input input object.
-}
type alias Nps_rating_stream_cursor_input =
    { initial_value : Nps_rating_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Nps\_rating\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeNps_rating_stream_cursor_input : Nps_rating_stream_cursor_input -> Value
encodeNps_rating_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeNps_rating_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildNps_rating_stream_cursor_value_input :
    (Nps_rating_stream_cursor_value_inputOptionalFields -> Nps_rating_stream_cursor_value_inputOptionalFields)
    -> Nps_rating_stream_cursor_value_input
buildNps_rating_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { accountId = Absent, createdAt = Absent, id = Absent, score = Absent }
    in
    { accountId = optionals____.accountId, createdAt = optionals____.createdAt, id = optionals____.id, score = optionals____.score }


type alias Nps_rating_stream_cursor_value_inputOptionalFields =
    { accountId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , score : OptionalArgument Int
    }


{-| Type for the Nps\_rating\_stream\_cursor\_value\_input input object.
-}
type alias Nps_rating_stream_cursor_value_input =
    { accountId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , score : OptionalArgument Int
    }


{-| Encode a Nps\_rating\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeNps_rating_stream_cursor_value_input : Nps_rating_stream_cursor_value_input -> Value
encodeNps_rating_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "accountId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.accountId ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "score", Encode.int |> Encode.optional input____.score ) ]


buildNps_rating_updates :
    Nps_rating_updatesRequiredFields
    -> (Nps_rating_updatesOptionalFields -> Nps_rating_updatesOptionalFields)
    -> Nps_rating_updates
buildNps_rating_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { inc_ = Absent, set_ = Absent }
    in
    Nps_rating_updates { inc_ = optionals____.inc_, set_ = optionals____.set_, where_ = required____.where_ }


type alias Nps_rating_updatesRequiredFields =
    { where_ : Nps_rating_bool_exp }


type alias Nps_rating_updatesOptionalFields =
    { inc_ : OptionalArgument Nps_rating_inc_input
    , set_ : OptionalArgument Nps_rating_set_input
    }


{-| Type alias for the `Nps_rating_updates` attributes. Note that this type
needs to use the `Nps_rating_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Nps_rating_updatesRaw =
    { inc_ : OptionalArgument Nps_rating_inc_input
    , set_ : OptionalArgument Nps_rating_set_input
    , where_ : Nps_rating_bool_exp
    }


{-| Type for the Nps\_rating\_updates input object.
-}
type Nps_rating_updates
    = Nps_rating_updates Nps_rating_updatesRaw


{-| Encode a Nps\_rating\_updates into a value that can be used as an argument.
-}
encodeNps_rating_updates : Nps_rating_updates -> Value
encodeNps_rating_updates (Nps_rating_updates input____) =
    Encode.maybeObject
        [ ( "_inc", encodeNps_rating_inc_input |> Encode.optional input____.inc_ ), ( "_set", encodeNps_rating_set_input |> Encode.optional input____.set_ ), ( "where", encodeNps_rating_bool_exp input____.where_ |> Just ) ]


buildOrientation_manager_aggregate_bool_exp :
    (Orientation_manager_aggregate_bool_expOptionalFields -> Orientation_manager_aggregate_bool_expOptionalFields)
    -> Orientation_manager_aggregate_bool_exp
buildOrientation_manager_aggregate_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent }
    in
    Orientation_manager_aggregate_bool_exp { count = optionals____.count }


type alias Orientation_manager_aggregate_bool_expOptionalFields =
    { count : OptionalArgument Orientation_manager_aggregate_bool_exp_count }


{-| Type alias for the `Orientation_manager_aggregate_bool_exp` attributes. Note that this type
needs to use the `Orientation_manager_aggregate_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Orientation_manager_aggregate_bool_expRaw =
    { count : OptionalArgument Orientation_manager_aggregate_bool_exp_count }


{-| Type for the Orientation\_manager\_aggregate\_bool\_exp input object.
-}
type Orientation_manager_aggregate_bool_exp
    = Orientation_manager_aggregate_bool_exp Orientation_manager_aggregate_bool_expRaw


{-| Encode a Orientation\_manager\_aggregate\_bool\_exp into a value that can be used as an argument.
-}
encodeOrientation_manager_aggregate_bool_exp : Orientation_manager_aggregate_bool_exp -> Value
encodeOrientation_manager_aggregate_bool_exp (Orientation_manager_aggregate_bool_exp input____) =
    Encode.maybeObject
        [ ( "count", encodeOrientation_manager_aggregate_bool_exp_count |> Encode.optional input____.count ) ]


buildOrientation_manager_aggregate_bool_exp_count :
    Orientation_manager_aggregate_bool_exp_countRequiredFields
    -> (Orientation_manager_aggregate_bool_exp_countOptionalFields -> Orientation_manager_aggregate_bool_exp_countOptionalFields)
    -> Orientation_manager_aggregate_bool_exp_count
buildOrientation_manager_aggregate_bool_exp_count required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { arguments = Absent, distinct = Absent, filter = Absent }
    in
    Orientation_manager_aggregate_bool_exp_count { arguments = optionals____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Orientation_manager_aggregate_bool_exp_countRequiredFields =
    { predicate : Int_comparison_exp }


type alias Orientation_manager_aggregate_bool_exp_countOptionalFields =
    { arguments : OptionalArgument (List CdbGQL.Enum.Orientation_manager_select_column.Orientation_manager_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Orientation_manager_bool_exp
    }


{-| Type alias for the `Orientation_manager_aggregate_bool_exp_count` attributes. Note that this type
needs to use the `Orientation_manager_aggregate_bool_exp_count` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Orientation_manager_aggregate_bool_exp_countRaw =
    { arguments : OptionalArgument (List CdbGQL.Enum.Orientation_manager_select_column.Orientation_manager_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Orientation_manager_bool_exp
    , predicate : Int_comparison_exp
    }


{-| Type for the Orientation\_manager\_aggregate\_bool\_exp\_count input object.
-}
type Orientation_manager_aggregate_bool_exp_count
    = Orientation_manager_aggregate_bool_exp_count Orientation_manager_aggregate_bool_exp_countRaw


{-| Encode a Orientation\_manager\_aggregate\_bool\_exp\_count into a value that can be used as an argument.
-}
encodeOrientation_manager_aggregate_bool_exp_count : Orientation_manager_aggregate_bool_exp_count -> Value
encodeOrientation_manager_aggregate_bool_exp_count (Orientation_manager_aggregate_bool_exp_count input____) =
    Encode.maybeObject
        [ ( "arguments", (Encode.enum CdbGQL.Enum.Orientation_manager_select_column.toString |> Encode.list) |> Encode.optional input____.arguments ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeOrientation_manager_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeInt_comparison_exp input____.predicate |> Just ) ]


buildOrientation_manager_aggregate_order_by :
    (Orientation_manager_aggregate_order_byOptionalFields -> Orientation_manager_aggregate_order_byOptionalFields)
    -> Orientation_manager_aggregate_order_by
buildOrientation_manager_aggregate_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals____.count, max = optionals____.max, min = optionals____.min }


type alias Orientation_manager_aggregate_order_byOptionalFields =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Orientation_manager_max_order_by
    , min : OptionalArgument Orientation_manager_min_order_by
    }


{-| Type for the Orientation\_manager\_aggregate\_order\_by input object.
-}
type alias Orientation_manager_aggregate_order_by =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Orientation_manager_max_order_by
    , min : OptionalArgument Orientation_manager_min_order_by
    }


{-| Encode a Orientation\_manager\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeOrientation_manager_aggregate_order_by : Orientation_manager_aggregate_order_by -> Value
encodeOrientation_manager_aggregate_order_by input____ =
    Encode.maybeObject
        [ ( "count", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.count ), ( "max", encodeOrientation_manager_max_order_by |> Encode.optional input____.max ), ( "min", encodeOrientation_manager_min_order_by |> Encode.optional input____.min ) ]


buildOrientation_manager_arr_rel_insert_input :
    Orientation_manager_arr_rel_insert_inputRequiredFields
    -> (Orientation_manager_arr_rel_insert_inputOptionalFields -> Orientation_manager_arr_rel_insert_inputOptionalFields)
    -> Orientation_manager_arr_rel_insert_input
buildOrientation_manager_arr_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Orientation_manager_arr_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Orientation_manager_arr_rel_insert_inputRequiredFields =
    { data : List Orientation_manager_insert_input }


type alias Orientation_manager_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Orientation_manager_on_conflict }


{-| Type alias for the `Orientation_manager_arr_rel_insert_input` attributes. Note that this type
needs to use the `Orientation_manager_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Orientation_manager_arr_rel_insert_inputRaw =
    { data : List Orientation_manager_insert_input
    , on_conflict : OptionalArgument Orientation_manager_on_conflict
    }


{-| Type for the Orientation\_manager\_arr\_rel\_insert\_input input object.
-}
type Orientation_manager_arr_rel_insert_input
    = Orientation_manager_arr_rel_insert_input Orientation_manager_arr_rel_insert_inputRaw


{-| Encode a Orientation\_manager\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeOrientation_manager_arr_rel_insert_input : Orientation_manager_arr_rel_insert_input -> Value
encodeOrientation_manager_arr_rel_insert_input (Orientation_manager_arr_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", (encodeOrientation_manager_insert_input |> Encode.list) input____.data |> Just ), ( "on_conflict", encodeOrientation_manager_on_conflict |> Encode.optional input____.on_conflict ) ]


buildOrientation_manager_bool_exp :
    (Orientation_manager_bool_expOptionalFields -> Orientation_manager_bool_expOptionalFields)
    -> Orientation_manager_bool_exp
buildOrientation_manager_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, account = Absent, accounts = Absent, accounts_aggregate = Absent, createdAt = Absent, deployment = Absent, deploymentId = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, phoneNumbers = Absent, updatedAt = Absent }
    in
    Orientation_manager_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, account = optionals____.account, accounts = optionals____.accounts, accounts_aggregate = optionals____.accounts_aggregate, createdAt = optionals____.createdAt, deployment = optionals____.deployment, deploymentId = optionals____.deploymentId, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, phoneNumbers = optionals____.phoneNumbers, updatedAt = optionals____.updatedAt }


type alias Orientation_manager_bool_expOptionalFields =
    { and_ : OptionalArgument (List Orientation_manager_bool_exp)
    , not_ : OptionalArgument Orientation_manager_bool_exp
    , or_ : OptionalArgument (List Orientation_manager_bool_exp)
    , account : OptionalArgument Account_bool_exp
    , accounts : OptionalArgument Account_bool_exp
    , accounts_aggregate : OptionalArgument Account_aggregate_bool_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , deployment : OptionalArgument Deployment_bool_exp
    , deploymentId : OptionalArgument Uuid_comparison_exp
    , email : OptionalArgument Citext_comparison_exp
    , firstname : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , lastname : OptionalArgument String_comparison_exp
    , phoneNumbers : OptionalArgument String_comparison_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type alias for the `Orientation_manager_bool_exp` attributes. Note that this type
needs to use the `Orientation_manager_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Orientation_manager_bool_expRaw =
    { and_ : OptionalArgument (List Orientation_manager_bool_exp)
    , not_ : OptionalArgument Orientation_manager_bool_exp
    , or_ : OptionalArgument (List Orientation_manager_bool_exp)
    , account : OptionalArgument Account_bool_exp
    , accounts : OptionalArgument Account_bool_exp
    , accounts_aggregate : OptionalArgument Account_aggregate_bool_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , deployment : OptionalArgument Deployment_bool_exp
    , deploymentId : OptionalArgument Uuid_comparison_exp
    , email : OptionalArgument Citext_comparison_exp
    , firstname : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , lastname : OptionalArgument String_comparison_exp
    , phoneNumbers : OptionalArgument String_comparison_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type for the Orientation\_manager\_bool\_exp input object.
-}
type Orientation_manager_bool_exp
    = Orientation_manager_bool_exp Orientation_manager_bool_expRaw


{-| Encode a Orientation\_manager\_bool\_exp into a value that can be used as an argument.
-}
encodeOrientation_manager_bool_exp : Orientation_manager_bool_exp -> Value
encodeOrientation_manager_bool_exp (Orientation_manager_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeOrientation_manager_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeOrientation_manager_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeOrientation_manager_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "account", encodeAccount_bool_exp |> Encode.optional input____.account ), ( "accounts", encodeAccount_bool_exp |> Encode.optional input____.accounts ), ( "accounts_aggregate", encodeAccount_aggregate_bool_exp |> Encode.optional input____.accounts_aggregate ), ( "createdAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.createdAt ), ( "deployment", encodeDeployment_bool_exp |> Encode.optional input____.deployment ), ( "deploymentId", encodeUuid_comparison_exp |> Encode.optional input____.deploymentId ), ( "email", encodeCitext_comparison_exp |> Encode.optional input____.email ), ( "firstname", encodeString_comparison_exp |> Encode.optional input____.firstname ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "lastname", encodeString_comparison_exp |> Encode.optional input____.lastname ), ( "phoneNumbers", encodeString_comparison_exp |> Encode.optional input____.phoneNumbers ), ( "updatedAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.updatedAt ) ]


buildOrientation_manager_insert_input :
    (Orientation_manager_insert_inputOptionalFields -> Orientation_manager_insert_inputOptionalFields)
    -> Orientation_manager_insert_input
buildOrientation_manager_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { account = Absent, accounts = Absent, createdAt = Absent, deployment = Absent, deploymentId = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, phoneNumbers = Absent, updatedAt = Absent }
    in
    Orientation_manager_insert_input { account = optionals____.account, accounts = optionals____.accounts, createdAt = optionals____.createdAt, deployment = optionals____.deployment, deploymentId = optionals____.deploymentId, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, phoneNumbers = optionals____.phoneNumbers, updatedAt = optionals____.updatedAt }


type alias Orientation_manager_insert_inputOptionalFields =
    { account : OptionalArgument Account_obj_rel_insert_input
    , accounts : OptionalArgument Account_arr_rel_insert_input
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deployment : OptionalArgument Deployment_obj_rel_insert_input
    , deploymentId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastname : OptionalArgument String
    , phoneNumbers : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type alias for the `Orientation_manager_insert_input` attributes. Note that this type
needs to use the `Orientation_manager_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Orientation_manager_insert_inputRaw =
    { account : OptionalArgument Account_obj_rel_insert_input
    , accounts : OptionalArgument Account_arr_rel_insert_input
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deployment : OptionalArgument Deployment_obj_rel_insert_input
    , deploymentId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastname : OptionalArgument String
    , phoneNumbers : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Orientation\_manager\_insert\_input input object.
-}
type Orientation_manager_insert_input
    = Orientation_manager_insert_input Orientation_manager_insert_inputRaw


{-| Encode a Orientation\_manager\_insert\_input into a value that can be used as an argument.
-}
encodeOrientation_manager_insert_input : Orientation_manager_insert_input -> Value
encodeOrientation_manager_insert_input (Orientation_manager_insert_input input____) =
    Encode.maybeObject
        [ ( "account", encodeAccount_obj_rel_insert_input |> Encode.optional input____.account ), ( "accounts", encodeAccount_arr_rel_insert_input |> Encode.optional input____.accounts ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "deployment", encodeDeployment_obj_rel_insert_input |> Encode.optional input____.deployment ), ( "deploymentId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.deploymentId ), ( "email", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.email ), ( "firstname", Encode.string |> Encode.optional input____.firstname ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "lastname", Encode.string |> Encode.optional input____.lastname ), ( "phoneNumbers", Encode.string |> Encode.optional input____.phoneNumbers ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildOrientation_manager_max_order_by :
    (Orientation_manager_max_order_byOptionalFields -> Orientation_manager_max_order_byOptionalFields)
    -> Orientation_manager_max_order_by
buildOrientation_manager_max_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, deploymentId = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, phoneNumbers = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, deploymentId = optionals____.deploymentId, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, phoneNumbers = optionals____.phoneNumbers, updatedAt = optionals____.updatedAt }


type alias Orientation_manager_max_order_byOptionalFields =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deploymentId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , phoneNumbers : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Orientation\_manager\_max\_order\_by input object.
-}
type alias Orientation_manager_max_order_by =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deploymentId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , phoneNumbers : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Orientation\_manager\_max\_order\_by into a value that can be used as an argument.
-}
encodeOrientation_manager_max_order_by : Orientation_manager_max_order_by -> Value
encodeOrientation_manager_max_order_by input____ =
    Encode.maybeObject
        [ ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "deploymentId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deploymentId ), ( "email", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.email ), ( "firstname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.firstname ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "lastname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.lastname ), ( "phoneNumbers", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.phoneNumbers ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildOrientation_manager_min_order_by :
    (Orientation_manager_min_order_byOptionalFields -> Orientation_manager_min_order_byOptionalFields)
    -> Orientation_manager_min_order_by
buildOrientation_manager_min_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, deploymentId = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, phoneNumbers = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, deploymentId = optionals____.deploymentId, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, phoneNumbers = optionals____.phoneNumbers, updatedAt = optionals____.updatedAt }


type alias Orientation_manager_min_order_byOptionalFields =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deploymentId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , phoneNumbers : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Orientation\_manager\_min\_order\_by input object.
-}
type alias Orientation_manager_min_order_by =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deploymentId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , phoneNumbers : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Orientation\_manager\_min\_order\_by into a value that can be used as an argument.
-}
encodeOrientation_manager_min_order_by : Orientation_manager_min_order_by -> Value
encodeOrientation_manager_min_order_by input____ =
    Encode.maybeObject
        [ ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "deploymentId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deploymentId ), ( "email", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.email ), ( "firstname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.firstname ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "lastname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.lastname ), ( "phoneNumbers", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.phoneNumbers ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildOrientation_manager_obj_rel_insert_input :
    Orientation_manager_obj_rel_insert_inputRequiredFields
    -> (Orientation_manager_obj_rel_insert_inputOptionalFields -> Orientation_manager_obj_rel_insert_inputOptionalFields)
    -> Orientation_manager_obj_rel_insert_input
buildOrientation_manager_obj_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Orientation_manager_obj_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Orientation_manager_obj_rel_insert_inputRequiredFields =
    { data : Orientation_manager_insert_input }


type alias Orientation_manager_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Orientation_manager_on_conflict }


{-| Type alias for the `Orientation_manager_obj_rel_insert_input` attributes. Note that this type
needs to use the `Orientation_manager_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Orientation_manager_obj_rel_insert_inputRaw =
    { data : Orientation_manager_insert_input
    , on_conflict : OptionalArgument Orientation_manager_on_conflict
    }


{-| Type for the Orientation\_manager\_obj\_rel\_insert\_input input object.
-}
type Orientation_manager_obj_rel_insert_input
    = Orientation_manager_obj_rel_insert_input Orientation_manager_obj_rel_insert_inputRaw


{-| Encode a Orientation\_manager\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeOrientation_manager_obj_rel_insert_input : Orientation_manager_obj_rel_insert_input -> Value
encodeOrientation_manager_obj_rel_insert_input (Orientation_manager_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeOrientation_manager_insert_input input____.data |> Just ), ( "on_conflict", encodeOrientation_manager_on_conflict |> Encode.optional input____.on_conflict ) ]


buildOrientation_manager_on_conflict :
    Orientation_manager_on_conflictRequiredFields
    -> (Orientation_manager_on_conflictOptionalFields -> Orientation_manager_on_conflictOptionalFields)
    -> Orientation_manager_on_conflict
buildOrientation_manager_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Orientation_manager_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Orientation_manager_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Orientation_manager_constraint.Orientation_manager_constraint
    , update_columns : List CdbGQL.Enum.Orientation_manager_update_column.Orientation_manager_update_column
    }


type alias Orientation_manager_on_conflictOptionalFields =
    { where_ : OptionalArgument Orientation_manager_bool_exp }


{-| Type alias for the `Orientation_manager_on_conflict` attributes. Note that this type
needs to use the `Orientation_manager_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Orientation_manager_on_conflictRaw =
    { constraint : CdbGQL.Enum.Orientation_manager_constraint.Orientation_manager_constraint
    , update_columns : List CdbGQL.Enum.Orientation_manager_update_column.Orientation_manager_update_column
    , where_ : OptionalArgument Orientation_manager_bool_exp
    }


{-| Type for the Orientation\_manager\_on\_conflict input object.
-}
type Orientation_manager_on_conflict
    = Orientation_manager_on_conflict Orientation_manager_on_conflictRaw


{-| Encode a Orientation\_manager\_on\_conflict into a value that can be used as an argument.
-}
encodeOrientation_manager_on_conflict : Orientation_manager_on_conflict -> Value
encodeOrientation_manager_on_conflict (Orientation_manager_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Orientation_manager_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Orientation_manager_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeOrientation_manager_bool_exp |> Encode.optional input____.where_ ) ]


buildOrientation_manager_order_by :
    (Orientation_manager_order_byOptionalFields -> Orientation_manager_order_byOptionalFields)
    -> Orientation_manager_order_by
buildOrientation_manager_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { account = Absent, accounts_aggregate = Absent, createdAt = Absent, deployment = Absent, deploymentId = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, phoneNumbers = Absent, updatedAt = Absent }
    in
    Orientation_manager_order_by { account = optionals____.account, accounts_aggregate = optionals____.accounts_aggregate, createdAt = optionals____.createdAt, deployment = optionals____.deployment, deploymentId = optionals____.deploymentId, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, phoneNumbers = optionals____.phoneNumbers, updatedAt = optionals____.updatedAt }


type alias Orientation_manager_order_byOptionalFields =
    { account : OptionalArgument Account_order_by
    , accounts_aggregate : OptionalArgument Account_aggregate_order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deployment : OptionalArgument Deployment_order_by
    , deploymentId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , phoneNumbers : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type alias for the `Orientation_manager_order_by` attributes. Note that this type
needs to use the `Orientation_manager_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Orientation_manager_order_byRaw =
    { account : OptionalArgument Account_order_by
    , accounts_aggregate : OptionalArgument Account_aggregate_order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deployment : OptionalArgument Deployment_order_by
    , deploymentId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , phoneNumbers : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Orientation\_manager\_order\_by input object.
-}
type Orientation_manager_order_by
    = Orientation_manager_order_by Orientation_manager_order_byRaw


{-| Encode a Orientation\_manager\_order\_by into a value that can be used as an argument.
-}
encodeOrientation_manager_order_by : Orientation_manager_order_by -> Value
encodeOrientation_manager_order_by (Orientation_manager_order_by input____) =
    Encode.maybeObject
        [ ( "account", encodeAccount_order_by |> Encode.optional input____.account ), ( "accounts_aggregate", encodeAccount_aggregate_order_by |> Encode.optional input____.accounts_aggregate ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "deployment", encodeDeployment_order_by |> Encode.optional input____.deployment ), ( "deploymentId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deploymentId ), ( "email", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.email ), ( "firstname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.firstname ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "lastname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.lastname ), ( "phoneNumbers", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.phoneNumbers ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildOrientation_manager_pk_columns_input :
    Orientation_manager_pk_columns_inputRequiredFields
    -> Orientation_manager_pk_columns_input
buildOrientation_manager_pk_columns_input required____ =
    { id = required____.id }


type alias Orientation_manager_pk_columns_inputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the Orientation\_manager\_pk\_columns\_input input object.
-}
type alias Orientation_manager_pk_columns_input =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a Orientation\_manager\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeOrientation_manager_pk_columns_input : Orientation_manager_pk_columns_input -> Value
encodeOrientation_manager_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildOrientation_manager_set_input :
    (Orientation_manager_set_inputOptionalFields -> Orientation_manager_set_inputOptionalFields)
    -> Orientation_manager_set_input
buildOrientation_manager_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, deploymentId = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, phoneNumbers = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, deploymentId = optionals____.deploymentId, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, phoneNumbers = optionals____.phoneNumbers, updatedAt = optionals____.updatedAt }


type alias Orientation_manager_set_inputOptionalFields =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deploymentId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastname : OptionalArgument String
    , phoneNumbers : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Orientation\_manager\_set\_input input object.
-}
type alias Orientation_manager_set_input =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deploymentId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastname : OptionalArgument String
    , phoneNumbers : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Orientation\_manager\_set\_input into a value that can be used as an argument.
-}
encodeOrientation_manager_set_input : Orientation_manager_set_input -> Value
encodeOrientation_manager_set_input input____ =
    Encode.maybeObject
        [ ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "deploymentId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.deploymentId ), ( "email", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.email ), ( "firstname", Encode.string |> Encode.optional input____.firstname ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "lastname", Encode.string |> Encode.optional input____.lastname ), ( "phoneNumbers", Encode.string |> Encode.optional input____.phoneNumbers ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildOrientation_manager_stream_cursor_input :
    Orientation_manager_stream_cursor_inputRequiredFields
    -> (Orientation_manager_stream_cursor_inputOptionalFields -> Orientation_manager_stream_cursor_inputOptionalFields)
    -> Orientation_manager_stream_cursor_input
buildOrientation_manager_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Orientation_manager_stream_cursor_inputRequiredFields =
    { initial_value : Orientation_manager_stream_cursor_value_input }


type alias Orientation_manager_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Orientation\_manager\_stream\_cursor\_input input object.
-}
type alias Orientation_manager_stream_cursor_input =
    { initial_value : Orientation_manager_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Orientation\_manager\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeOrientation_manager_stream_cursor_input : Orientation_manager_stream_cursor_input -> Value
encodeOrientation_manager_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeOrientation_manager_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildOrientation_manager_stream_cursor_value_input :
    (Orientation_manager_stream_cursor_value_inputOptionalFields -> Orientation_manager_stream_cursor_value_inputOptionalFields)
    -> Orientation_manager_stream_cursor_value_input
buildOrientation_manager_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, deploymentId = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, phoneNumbers = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, deploymentId = optionals____.deploymentId, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, phoneNumbers = optionals____.phoneNumbers, updatedAt = optionals____.updatedAt }


type alias Orientation_manager_stream_cursor_value_inputOptionalFields =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deploymentId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastname : OptionalArgument String
    , phoneNumbers : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Orientation\_manager\_stream\_cursor\_value\_input input object.
-}
type alias Orientation_manager_stream_cursor_value_input =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deploymentId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastname : OptionalArgument String
    , phoneNumbers : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Orientation\_manager\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeOrientation_manager_stream_cursor_value_input : Orientation_manager_stream_cursor_value_input -> Value
encodeOrientation_manager_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "deploymentId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.deploymentId ), ( "email", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.email ), ( "firstname", Encode.string |> Encode.optional input____.firstname ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "lastname", Encode.string |> Encode.optional input____.lastname ), ( "phoneNumbers", Encode.string |> Encode.optional input____.phoneNumbers ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildOrientation_manager_updates :
    Orientation_manager_updatesRequiredFields
    -> (Orientation_manager_updatesOptionalFields -> Orientation_manager_updatesOptionalFields)
    -> Orientation_manager_updates
buildOrientation_manager_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Orientation_manager_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Orientation_manager_updatesRequiredFields =
    { where_ : Orientation_manager_bool_exp }


type alias Orientation_manager_updatesOptionalFields =
    { set_ : OptionalArgument Orientation_manager_set_input }


{-| Type alias for the `Orientation_manager_updates` attributes. Note that this type
needs to use the `Orientation_manager_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Orientation_manager_updatesRaw =
    { set_ : OptionalArgument Orientation_manager_set_input
    , where_ : Orientation_manager_bool_exp
    }


{-| Type for the Orientation\_manager\_updates input object.
-}
type Orientation_manager_updates
    = Orientation_manager_updates Orientation_manager_updatesRaw


{-| Encode a Orientation\_manager\_updates into a value that can be used as an argument.
-}
encodeOrientation_manager_updates : Orientation_manager_updates -> Value
encodeOrientation_manager_updates (Orientation_manager_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeOrientation_manager_set_input |> Encode.optional input____.set_ ), ( "where", encodeOrientation_manager_bool_exp input____.where_ |> Just ) ]


buildOrientation_request_aggregate_bool_exp :
    (Orientation_request_aggregate_bool_expOptionalFields -> Orientation_request_aggregate_bool_expOptionalFields)
    -> Orientation_request_aggregate_bool_exp
buildOrientation_request_aggregate_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent }
    in
    Orientation_request_aggregate_bool_exp { count = optionals____.count }


type alias Orientation_request_aggregate_bool_expOptionalFields =
    { count : OptionalArgument Orientation_request_aggregate_bool_exp_count }


{-| Type alias for the `Orientation_request_aggregate_bool_exp` attributes. Note that this type
needs to use the `Orientation_request_aggregate_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Orientation_request_aggregate_bool_expRaw =
    { count : OptionalArgument Orientation_request_aggregate_bool_exp_count }


{-| Type for the Orientation\_request\_aggregate\_bool\_exp input object.
-}
type Orientation_request_aggregate_bool_exp
    = Orientation_request_aggregate_bool_exp Orientation_request_aggregate_bool_expRaw


{-| Encode a Orientation\_request\_aggregate\_bool\_exp into a value that can be used as an argument.
-}
encodeOrientation_request_aggregate_bool_exp : Orientation_request_aggregate_bool_exp -> Value
encodeOrientation_request_aggregate_bool_exp (Orientation_request_aggregate_bool_exp input____) =
    Encode.maybeObject
        [ ( "count", encodeOrientation_request_aggregate_bool_exp_count |> Encode.optional input____.count ) ]


buildOrientation_request_aggregate_bool_exp_count :
    Orientation_request_aggregate_bool_exp_countRequiredFields
    -> (Orientation_request_aggregate_bool_exp_countOptionalFields -> Orientation_request_aggregate_bool_exp_countOptionalFields)
    -> Orientation_request_aggregate_bool_exp_count
buildOrientation_request_aggregate_bool_exp_count required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { arguments = Absent, distinct = Absent, filter = Absent }
    in
    Orientation_request_aggregate_bool_exp_count { arguments = optionals____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Orientation_request_aggregate_bool_exp_countRequiredFields =
    { predicate : Int_comparison_exp }


type alias Orientation_request_aggregate_bool_exp_countOptionalFields =
    { arguments : OptionalArgument (List CdbGQL.Enum.Orientation_request_select_column.Orientation_request_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Orientation_request_bool_exp
    }


{-| Type alias for the `Orientation_request_aggregate_bool_exp_count` attributes. Note that this type
needs to use the `Orientation_request_aggregate_bool_exp_count` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Orientation_request_aggregate_bool_exp_countRaw =
    { arguments : OptionalArgument (List CdbGQL.Enum.Orientation_request_select_column.Orientation_request_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Orientation_request_bool_exp
    , predicate : Int_comparison_exp
    }


{-| Type for the Orientation\_request\_aggregate\_bool\_exp\_count input object.
-}
type Orientation_request_aggregate_bool_exp_count
    = Orientation_request_aggregate_bool_exp_count Orientation_request_aggregate_bool_exp_countRaw


{-| Encode a Orientation\_request\_aggregate\_bool\_exp\_count into a value that can be used as an argument.
-}
encodeOrientation_request_aggregate_bool_exp_count : Orientation_request_aggregate_bool_exp_count -> Value
encodeOrientation_request_aggregate_bool_exp_count (Orientation_request_aggregate_bool_exp_count input____) =
    Encode.maybeObject
        [ ( "arguments", (Encode.enum CdbGQL.Enum.Orientation_request_select_column.toString |> Encode.list) |> Encode.optional input____.arguments ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeOrientation_request_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeInt_comparison_exp input____.predicate |> Just ) ]


buildOrientation_request_aggregate_order_by :
    (Orientation_request_aggregate_order_byOptionalFields -> Orientation_request_aggregate_order_byOptionalFields)
    -> Orientation_request_aggregate_order_by
buildOrientation_request_aggregate_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals____.count, max = optionals____.max, min = optionals____.min }


type alias Orientation_request_aggregate_order_byOptionalFields =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Orientation_request_max_order_by
    , min : OptionalArgument Orientation_request_min_order_by
    }


{-| Type for the Orientation\_request\_aggregate\_order\_by input object.
-}
type alias Orientation_request_aggregate_order_by =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Orientation_request_max_order_by
    , min : OptionalArgument Orientation_request_min_order_by
    }


{-| Encode a Orientation\_request\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeOrientation_request_aggregate_order_by : Orientation_request_aggregate_order_by -> Value
encodeOrientation_request_aggregate_order_by input____ =
    Encode.maybeObject
        [ ( "count", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.count ), ( "max", encodeOrientation_request_max_order_by |> Encode.optional input____.max ), ( "min", encodeOrientation_request_min_order_by |> Encode.optional input____.min ) ]


buildOrientation_request_arr_rel_insert_input :
    Orientation_request_arr_rel_insert_inputRequiredFields
    -> (Orientation_request_arr_rel_insert_inputOptionalFields -> Orientation_request_arr_rel_insert_inputOptionalFields)
    -> Orientation_request_arr_rel_insert_input
buildOrientation_request_arr_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Orientation_request_arr_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Orientation_request_arr_rel_insert_inputRequiredFields =
    { data : List Orientation_request_insert_input }


type alias Orientation_request_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Orientation_request_on_conflict }


{-| Type alias for the `Orientation_request_arr_rel_insert_input` attributes. Note that this type
needs to use the `Orientation_request_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Orientation_request_arr_rel_insert_inputRaw =
    { data : List Orientation_request_insert_input
    , on_conflict : OptionalArgument Orientation_request_on_conflict
    }


{-| Type for the Orientation\_request\_arr\_rel\_insert\_input input object.
-}
type Orientation_request_arr_rel_insert_input
    = Orientation_request_arr_rel_insert_input Orientation_request_arr_rel_insert_inputRaw


{-| Encode a Orientation\_request\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeOrientation_request_arr_rel_insert_input : Orientation_request_arr_rel_insert_input -> Value
encodeOrientation_request_arr_rel_insert_input (Orientation_request_arr_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", (encodeOrientation_request_insert_input |> Encode.list) input____.data |> Just ), ( "on_conflict", encodeOrientation_request_on_conflict |> Encode.optional input____.on_conflict ) ]


buildOrientation_request_bool_exp :
    (Orientation_request_bool_expOptionalFields -> Orientation_request_bool_expOptionalFields)
    -> Orientation_request_bool_exp
buildOrientation_request_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, beneficiary = Absent, beneficiaryId = Absent, createdAt = Absent, decidedAt = Absent, decidedOrientationSystem = Absent, decidedOrientationSystemId = Absent, id = Absent, reason = Absent, requestedOrientationSystem = Absent, requestedOrientationSystemId = Absent, requestor = Absent, requestor_account_id = Absent, status = Absent, updatedAt = Absent }
    in
    Orientation_request_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, beneficiary = optionals____.beneficiary, beneficiaryId = optionals____.beneficiaryId, createdAt = optionals____.createdAt, decidedAt = optionals____.decidedAt, decidedOrientationSystem = optionals____.decidedOrientationSystem, decidedOrientationSystemId = optionals____.decidedOrientationSystemId, id = optionals____.id, reason = optionals____.reason, requestedOrientationSystem = optionals____.requestedOrientationSystem, requestedOrientationSystemId = optionals____.requestedOrientationSystemId, requestor = optionals____.requestor, requestor_account_id = optionals____.requestor_account_id, status = optionals____.status, updatedAt = optionals____.updatedAt }


type alias Orientation_request_bool_expOptionalFields =
    { and_ : OptionalArgument (List Orientation_request_bool_exp)
    , not_ : OptionalArgument Orientation_request_bool_exp
    , or_ : OptionalArgument (List Orientation_request_bool_exp)
    , beneficiary : OptionalArgument Beneficiary_bool_exp
    , beneficiaryId : OptionalArgument Uuid_comparison_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , decidedAt : OptionalArgument Timestamptz_comparison_exp
    , decidedOrientationSystem : OptionalArgument Orientation_system_bool_exp
    , decidedOrientationSystemId : OptionalArgument Uuid_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , reason : OptionalArgument String_comparison_exp
    , requestedOrientationSystem : OptionalArgument Orientation_system_bool_exp
    , requestedOrientationSystemId : OptionalArgument Uuid_comparison_exp
    , requestor : OptionalArgument Account_bool_exp
    , requestor_account_id : OptionalArgument Uuid_comparison_exp
    , status : OptionalArgument String_comparison_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type alias for the `Orientation_request_bool_exp` attributes. Note that this type
needs to use the `Orientation_request_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Orientation_request_bool_expRaw =
    { and_ : OptionalArgument (List Orientation_request_bool_exp)
    , not_ : OptionalArgument Orientation_request_bool_exp
    , or_ : OptionalArgument (List Orientation_request_bool_exp)
    , beneficiary : OptionalArgument Beneficiary_bool_exp
    , beneficiaryId : OptionalArgument Uuid_comparison_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , decidedAt : OptionalArgument Timestamptz_comparison_exp
    , decidedOrientationSystem : OptionalArgument Orientation_system_bool_exp
    , decidedOrientationSystemId : OptionalArgument Uuid_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , reason : OptionalArgument String_comparison_exp
    , requestedOrientationSystem : OptionalArgument Orientation_system_bool_exp
    , requestedOrientationSystemId : OptionalArgument Uuid_comparison_exp
    , requestor : OptionalArgument Account_bool_exp
    , requestor_account_id : OptionalArgument Uuid_comparison_exp
    , status : OptionalArgument String_comparison_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type for the Orientation\_request\_bool\_exp input object.
-}
type Orientation_request_bool_exp
    = Orientation_request_bool_exp Orientation_request_bool_expRaw


{-| Encode a Orientation\_request\_bool\_exp into a value that can be used as an argument.
-}
encodeOrientation_request_bool_exp : Orientation_request_bool_exp -> Value
encodeOrientation_request_bool_exp (Orientation_request_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeOrientation_request_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeOrientation_request_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeOrientation_request_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "beneficiary", encodeBeneficiary_bool_exp |> Encode.optional input____.beneficiary ), ( "beneficiaryId", encodeUuid_comparison_exp |> Encode.optional input____.beneficiaryId ), ( "createdAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.createdAt ), ( "decidedAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.decidedAt ), ( "decidedOrientationSystem", encodeOrientation_system_bool_exp |> Encode.optional input____.decidedOrientationSystem ), ( "decidedOrientationSystemId", encodeUuid_comparison_exp |> Encode.optional input____.decidedOrientationSystemId ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "reason", encodeString_comparison_exp |> Encode.optional input____.reason ), ( "requestedOrientationSystem", encodeOrientation_system_bool_exp |> Encode.optional input____.requestedOrientationSystem ), ( "requestedOrientationSystemId", encodeUuid_comparison_exp |> Encode.optional input____.requestedOrientationSystemId ), ( "requestor", encodeAccount_bool_exp |> Encode.optional input____.requestor ), ( "requestor_account_id", encodeUuid_comparison_exp |> Encode.optional input____.requestor_account_id ), ( "status", encodeString_comparison_exp |> Encode.optional input____.status ), ( "updatedAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.updatedAt ) ]


buildOrientation_request_insert_input :
    (Orientation_request_insert_inputOptionalFields -> Orientation_request_insert_inputOptionalFields)
    -> Orientation_request_insert_input
buildOrientation_request_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { beneficiary = Absent, beneficiaryId = Absent, createdAt = Absent, decidedAt = Absent, decidedOrientationSystem = Absent, decidedOrientationSystemId = Absent, id = Absent, reason = Absent, requestedOrientationSystem = Absent, requestedOrientationSystemId = Absent, requestor = Absent, requestor_account_id = Absent, status = Absent, updatedAt = Absent }
    in
    Orientation_request_insert_input { beneficiary = optionals____.beneficiary, beneficiaryId = optionals____.beneficiaryId, createdAt = optionals____.createdAt, decidedAt = optionals____.decidedAt, decidedOrientationSystem = optionals____.decidedOrientationSystem, decidedOrientationSystemId = optionals____.decidedOrientationSystemId, id = optionals____.id, reason = optionals____.reason, requestedOrientationSystem = optionals____.requestedOrientationSystem, requestedOrientationSystemId = optionals____.requestedOrientationSystemId, requestor = optionals____.requestor, requestor_account_id = optionals____.requestor_account_id, status = optionals____.status, updatedAt = optionals____.updatedAt }


type alias Orientation_request_insert_inputOptionalFields =
    { beneficiary : OptionalArgument Beneficiary_obj_rel_insert_input
    , beneficiaryId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , decidedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , decidedOrientationSystem : OptionalArgument Orientation_system_obj_rel_insert_input
    , decidedOrientationSystemId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , reason : OptionalArgument String
    , requestedOrientationSystem : OptionalArgument Orientation_system_obj_rel_insert_input
    , requestedOrientationSystemId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , requestor : OptionalArgument Account_obj_rel_insert_input
    , requestor_account_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , status : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type alias for the `Orientation_request_insert_input` attributes. Note that this type
needs to use the `Orientation_request_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Orientation_request_insert_inputRaw =
    { beneficiary : OptionalArgument Beneficiary_obj_rel_insert_input
    , beneficiaryId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , decidedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , decidedOrientationSystem : OptionalArgument Orientation_system_obj_rel_insert_input
    , decidedOrientationSystemId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , reason : OptionalArgument String
    , requestedOrientationSystem : OptionalArgument Orientation_system_obj_rel_insert_input
    , requestedOrientationSystemId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , requestor : OptionalArgument Account_obj_rel_insert_input
    , requestor_account_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , status : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Orientation\_request\_insert\_input input object.
-}
type Orientation_request_insert_input
    = Orientation_request_insert_input Orientation_request_insert_inputRaw


{-| Encode a Orientation\_request\_insert\_input into a value that can be used as an argument.
-}
encodeOrientation_request_insert_input : Orientation_request_insert_input -> Value
encodeOrientation_request_insert_input (Orientation_request_insert_input input____) =
    Encode.maybeObject
        [ ( "beneficiary", encodeBeneficiary_obj_rel_insert_input |> Encode.optional input____.beneficiary ), ( "beneficiaryId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.beneficiaryId ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "decidedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.decidedAt ), ( "decidedOrientationSystem", encodeOrientation_system_obj_rel_insert_input |> Encode.optional input____.decidedOrientationSystem ), ( "decidedOrientationSystemId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.decidedOrientationSystemId ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "reason", Encode.string |> Encode.optional input____.reason ), ( "requestedOrientationSystem", encodeOrientation_system_obj_rel_insert_input |> Encode.optional input____.requestedOrientationSystem ), ( "requestedOrientationSystemId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.requestedOrientationSystemId ), ( "requestor", encodeAccount_obj_rel_insert_input |> Encode.optional input____.requestor ), ( "requestor_account_id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.requestor_account_id ), ( "status", Encode.string |> Encode.optional input____.status ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildOrientation_request_max_order_by :
    (Orientation_request_max_order_byOptionalFields -> Orientation_request_max_order_byOptionalFields)
    -> Orientation_request_max_order_by
buildOrientation_request_max_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { beneficiaryId = Absent, createdAt = Absent, decidedAt = Absent, decidedOrientationSystemId = Absent, id = Absent, reason = Absent, requestedOrientationSystemId = Absent, requestor_account_id = Absent, status = Absent, updatedAt = Absent }
    in
    { beneficiaryId = optionals____.beneficiaryId, createdAt = optionals____.createdAt, decidedAt = optionals____.decidedAt, decidedOrientationSystemId = optionals____.decidedOrientationSystemId, id = optionals____.id, reason = optionals____.reason, requestedOrientationSystemId = optionals____.requestedOrientationSystemId, requestor_account_id = optionals____.requestor_account_id, status = optionals____.status, updatedAt = optionals____.updatedAt }


type alias Orientation_request_max_order_byOptionalFields =
    { beneficiaryId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , decidedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , decidedOrientationSystemId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , reason : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , requestedOrientationSystemId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , requestor_account_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , status : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Orientation\_request\_max\_order\_by input object.
-}
type alias Orientation_request_max_order_by =
    { beneficiaryId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , decidedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , decidedOrientationSystemId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , reason : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , requestedOrientationSystemId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , requestor_account_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , status : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Orientation\_request\_max\_order\_by into a value that can be used as an argument.
-}
encodeOrientation_request_max_order_by : Orientation_request_max_order_by -> Value
encodeOrientation_request_max_order_by input____ =
    Encode.maybeObject
        [ ( "beneficiaryId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.beneficiaryId ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "decidedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.decidedAt ), ( "decidedOrientationSystemId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.decidedOrientationSystemId ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "reason", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.reason ), ( "requestedOrientationSystemId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.requestedOrientationSystemId ), ( "requestor_account_id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.requestor_account_id ), ( "status", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.status ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildOrientation_request_min_order_by :
    (Orientation_request_min_order_byOptionalFields -> Orientation_request_min_order_byOptionalFields)
    -> Orientation_request_min_order_by
buildOrientation_request_min_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { beneficiaryId = Absent, createdAt = Absent, decidedAt = Absent, decidedOrientationSystemId = Absent, id = Absent, reason = Absent, requestedOrientationSystemId = Absent, requestor_account_id = Absent, status = Absent, updatedAt = Absent }
    in
    { beneficiaryId = optionals____.beneficiaryId, createdAt = optionals____.createdAt, decidedAt = optionals____.decidedAt, decidedOrientationSystemId = optionals____.decidedOrientationSystemId, id = optionals____.id, reason = optionals____.reason, requestedOrientationSystemId = optionals____.requestedOrientationSystemId, requestor_account_id = optionals____.requestor_account_id, status = optionals____.status, updatedAt = optionals____.updatedAt }


type alias Orientation_request_min_order_byOptionalFields =
    { beneficiaryId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , decidedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , decidedOrientationSystemId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , reason : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , requestedOrientationSystemId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , requestor_account_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , status : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Orientation\_request\_min\_order\_by input object.
-}
type alias Orientation_request_min_order_by =
    { beneficiaryId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , decidedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , decidedOrientationSystemId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , reason : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , requestedOrientationSystemId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , requestor_account_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , status : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Orientation\_request\_min\_order\_by into a value that can be used as an argument.
-}
encodeOrientation_request_min_order_by : Orientation_request_min_order_by -> Value
encodeOrientation_request_min_order_by input____ =
    Encode.maybeObject
        [ ( "beneficiaryId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.beneficiaryId ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "decidedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.decidedAt ), ( "decidedOrientationSystemId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.decidedOrientationSystemId ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "reason", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.reason ), ( "requestedOrientationSystemId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.requestedOrientationSystemId ), ( "requestor_account_id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.requestor_account_id ), ( "status", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.status ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildOrientation_request_on_conflict :
    Orientation_request_on_conflictRequiredFields
    -> (Orientation_request_on_conflictOptionalFields -> Orientation_request_on_conflictOptionalFields)
    -> Orientation_request_on_conflict
buildOrientation_request_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Orientation_request_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Orientation_request_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Orientation_request_constraint.Orientation_request_constraint
    , update_columns : List CdbGQL.Enum.Orientation_request_update_column.Orientation_request_update_column
    }


type alias Orientation_request_on_conflictOptionalFields =
    { where_ : OptionalArgument Orientation_request_bool_exp }


{-| Type alias for the `Orientation_request_on_conflict` attributes. Note that this type
needs to use the `Orientation_request_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Orientation_request_on_conflictRaw =
    { constraint : CdbGQL.Enum.Orientation_request_constraint.Orientation_request_constraint
    , update_columns : List CdbGQL.Enum.Orientation_request_update_column.Orientation_request_update_column
    , where_ : OptionalArgument Orientation_request_bool_exp
    }


{-| Type for the Orientation\_request\_on\_conflict input object.
-}
type Orientation_request_on_conflict
    = Orientation_request_on_conflict Orientation_request_on_conflictRaw


{-| Encode a Orientation\_request\_on\_conflict into a value that can be used as an argument.
-}
encodeOrientation_request_on_conflict : Orientation_request_on_conflict -> Value
encodeOrientation_request_on_conflict (Orientation_request_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Orientation_request_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Orientation_request_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeOrientation_request_bool_exp |> Encode.optional input____.where_ ) ]


buildOrientation_request_order_by :
    (Orientation_request_order_byOptionalFields -> Orientation_request_order_byOptionalFields)
    -> Orientation_request_order_by
buildOrientation_request_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { beneficiary = Absent, beneficiaryId = Absent, createdAt = Absent, decidedAt = Absent, decidedOrientationSystem = Absent, decidedOrientationSystemId = Absent, id = Absent, reason = Absent, requestedOrientationSystem = Absent, requestedOrientationSystemId = Absent, requestor = Absent, requestor_account_id = Absent, status = Absent, updatedAt = Absent }
    in
    Orientation_request_order_by { beneficiary = optionals____.beneficiary, beneficiaryId = optionals____.beneficiaryId, createdAt = optionals____.createdAt, decidedAt = optionals____.decidedAt, decidedOrientationSystem = optionals____.decidedOrientationSystem, decidedOrientationSystemId = optionals____.decidedOrientationSystemId, id = optionals____.id, reason = optionals____.reason, requestedOrientationSystem = optionals____.requestedOrientationSystem, requestedOrientationSystemId = optionals____.requestedOrientationSystemId, requestor = optionals____.requestor, requestor_account_id = optionals____.requestor_account_id, status = optionals____.status, updatedAt = optionals____.updatedAt }


type alias Orientation_request_order_byOptionalFields =
    { beneficiary : OptionalArgument Beneficiary_order_by
    , beneficiaryId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , decidedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , decidedOrientationSystem : OptionalArgument Orientation_system_order_by
    , decidedOrientationSystemId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , reason : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , requestedOrientationSystem : OptionalArgument Orientation_system_order_by
    , requestedOrientationSystemId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , requestor : OptionalArgument Account_order_by
    , requestor_account_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , status : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type alias for the `Orientation_request_order_by` attributes. Note that this type
needs to use the `Orientation_request_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Orientation_request_order_byRaw =
    { beneficiary : OptionalArgument Beneficiary_order_by
    , beneficiaryId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , decidedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , decidedOrientationSystem : OptionalArgument Orientation_system_order_by
    , decidedOrientationSystemId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , reason : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , requestedOrientationSystem : OptionalArgument Orientation_system_order_by
    , requestedOrientationSystemId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , requestor : OptionalArgument Account_order_by
    , requestor_account_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , status : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Orientation\_request\_order\_by input object.
-}
type Orientation_request_order_by
    = Orientation_request_order_by Orientation_request_order_byRaw


{-| Encode a Orientation\_request\_order\_by into a value that can be used as an argument.
-}
encodeOrientation_request_order_by : Orientation_request_order_by -> Value
encodeOrientation_request_order_by (Orientation_request_order_by input____) =
    Encode.maybeObject
        [ ( "beneficiary", encodeBeneficiary_order_by |> Encode.optional input____.beneficiary ), ( "beneficiaryId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.beneficiaryId ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "decidedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.decidedAt ), ( "decidedOrientationSystem", encodeOrientation_system_order_by |> Encode.optional input____.decidedOrientationSystem ), ( "decidedOrientationSystemId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.decidedOrientationSystemId ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "reason", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.reason ), ( "requestedOrientationSystem", encodeOrientation_system_order_by |> Encode.optional input____.requestedOrientationSystem ), ( "requestedOrientationSystemId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.requestedOrientationSystemId ), ( "requestor", encodeAccount_order_by |> Encode.optional input____.requestor ), ( "requestor_account_id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.requestor_account_id ), ( "status", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.status ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildOrientation_request_pk_columns_input :
    Orientation_request_pk_columns_inputRequiredFields
    -> Orientation_request_pk_columns_input
buildOrientation_request_pk_columns_input required____ =
    { id = required____.id }


type alias Orientation_request_pk_columns_inputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the Orientation\_request\_pk\_columns\_input input object.
-}
type alias Orientation_request_pk_columns_input =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a Orientation\_request\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeOrientation_request_pk_columns_input : Orientation_request_pk_columns_input -> Value
encodeOrientation_request_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildOrientation_request_set_input :
    (Orientation_request_set_inputOptionalFields -> Orientation_request_set_inputOptionalFields)
    -> Orientation_request_set_input
buildOrientation_request_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { beneficiaryId = Absent, createdAt = Absent, decidedAt = Absent, decidedOrientationSystemId = Absent, id = Absent, reason = Absent, requestedOrientationSystemId = Absent, requestor_account_id = Absent, status = Absent, updatedAt = Absent }
    in
    { beneficiaryId = optionals____.beneficiaryId, createdAt = optionals____.createdAt, decidedAt = optionals____.decidedAt, decidedOrientationSystemId = optionals____.decidedOrientationSystemId, id = optionals____.id, reason = optionals____.reason, requestedOrientationSystemId = optionals____.requestedOrientationSystemId, requestor_account_id = optionals____.requestor_account_id, status = optionals____.status, updatedAt = optionals____.updatedAt }


type alias Orientation_request_set_inputOptionalFields =
    { beneficiaryId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , decidedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , decidedOrientationSystemId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , reason : OptionalArgument String
    , requestedOrientationSystemId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , requestor_account_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , status : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Orientation\_request\_set\_input input object.
-}
type alias Orientation_request_set_input =
    { beneficiaryId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , decidedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , decidedOrientationSystemId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , reason : OptionalArgument String
    , requestedOrientationSystemId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , requestor_account_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , status : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Orientation\_request\_set\_input into a value that can be used as an argument.
-}
encodeOrientation_request_set_input : Orientation_request_set_input -> Value
encodeOrientation_request_set_input input____ =
    Encode.maybeObject
        [ ( "beneficiaryId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.beneficiaryId ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "decidedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.decidedAt ), ( "decidedOrientationSystemId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.decidedOrientationSystemId ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "reason", Encode.string |> Encode.optional input____.reason ), ( "requestedOrientationSystemId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.requestedOrientationSystemId ), ( "requestor_account_id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.requestor_account_id ), ( "status", Encode.string |> Encode.optional input____.status ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildOrientation_request_stream_cursor_input :
    Orientation_request_stream_cursor_inputRequiredFields
    -> (Orientation_request_stream_cursor_inputOptionalFields -> Orientation_request_stream_cursor_inputOptionalFields)
    -> Orientation_request_stream_cursor_input
buildOrientation_request_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Orientation_request_stream_cursor_inputRequiredFields =
    { initial_value : Orientation_request_stream_cursor_value_input }


type alias Orientation_request_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Orientation\_request\_stream\_cursor\_input input object.
-}
type alias Orientation_request_stream_cursor_input =
    { initial_value : Orientation_request_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Orientation\_request\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeOrientation_request_stream_cursor_input : Orientation_request_stream_cursor_input -> Value
encodeOrientation_request_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeOrientation_request_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildOrientation_request_stream_cursor_value_input :
    (Orientation_request_stream_cursor_value_inputOptionalFields -> Orientation_request_stream_cursor_value_inputOptionalFields)
    -> Orientation_request_stream_cursor_value_input
buildOrientation_request_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { beneficiaryId = Absent, createdAt = Absent, decidedAt = Absent, decidedOrientationSystemId = Absent, id = Absent, reason = Absent, requestedOrientationSystemId = Absent, requestor_account_id = Absent, status = Absent, updatedAt = Absent }
    in
    { beneficiaryId = optionals____.beneficiaryId, createdAt = optionals____.createdAt, decidedAt = optionals____.decidedAt, decidedOrientationSystemId = optionals____.decidedOrientationSystemId, id = optionals____.id, reason = optionals____.reason, requestedOrientationSystemId = optionals____.requestedOrientationSystemId, requestor_account_id = optionals____.requestor_account_id, status = optionals____.status, updatedAt = optionals____.updatedAt }


type alias Orientation_request_stream_cursor_value_inputOptionalFields =
    { beneficiaryId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , decidedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , decidedOrientationSystemId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , reason : OptionalArgument String
    , requestedOrientationSystemId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , requestor_account_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , status : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Orientation\_request\_stream\_cursor\_value\_input input object.
-}
type alias Orientation_request_stream_cursor_value_input =
    { beneficiaryId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , decidedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , decidedOrientationSystemId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , reason : OptionalArgument String
    , requestedOrientationSystemId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , requestor_account_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , status : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Orientation\_request\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeOrientation_request_stream_cursor_value_input : Orientation_request_stream_cursor_value_input -> Value
encodeOrientation_request_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "beneficiaryId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.beneficiaryId ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "decidedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.decidedAt ), ( "decidedOrientationSystemId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.decidedOrientationSystemId ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "reason", Encode.string |> Encode.optional input____.reason ), ( "requestedOrientationSystemId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.requestedOrientationSystemId ), ( "requestor_account_id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.requestor_account_id ), ( "status", Encode.string |> Encode.optional input____.status ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildOrientation_request_updates :
    Orientation_request_updatesRequiredFields
    -> (Orientation_request_updatesOptionalFields -> Orientation_request_updatesOptionalFields)
    -> Orientation_request_updates
buildOrientation_request_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Orientation_request_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Orientation_request_updatesRequiredFields =
    { where_ : Orientation_request_bool_exp }


type alias Orientation_request_updatesOptionalFields =
    { set_ : OptionalArgument Orientation_request_set_input }


{-| Type alias for the `Orientation_request_updates` attributes. Note that this type
needs to use the `Orientation_request_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Orientation_request_updatesRaw =
    { set_ : OptionalArgument Orientation_request_set_input
    , where_ : Orientation_request_bool_exp
    }


{-| Type for the Orientation\_request\_updates input object.
-}
type Orientation_request_updates
    = Orientation_request_updates Orientation_request_updatesRaw


{-| Encode a Orientation\_request\_updates into a value that can be used as an argument.
-}
encodeOrientation_request_updates : Orientation_request_updates -> Value
encodeOrientation_request_updates (Orientation_request_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeOrientation_request_set_input |> Encode.optional input____.set_ ), ( "where", encodeOrientation_request_bool_exp input____.where_ |> Just ) ]


buildOrientation_system_aggregate_bool_exp :
    (Orientation_system_aggregate_bool_expOptionalFields -> Orientation_system_aggregate_bool_expOptionalFields)
    -> Orientation_system_aggregate_bool_exp
buildOrientation_system_aggregate_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent }
    in
    Orientation_system_aggregate_bool_exp { count = optionals____.count }


type alias Orientation_system_aggregate_bool_expOptionalFields =
    { count : OptionalArgument Orientation_system_aggregate_bool_exp_count }


{-| Type alias for the `Orientation_system_aggregate_bool_exp` attributes. Note that this type
needs to use the `Orientation_system_aggregate_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Orientation_system_aggregate_bool_expRaw =
    { count : OptionalArgument Orientation_system_aggregate_bool_exp_count }


{-| Type for the Orientation\_system\_aggregate\_bool\_exp input object.
-}
type Orientation_system_aggregate_bool_exp
    = Orientation_system_aggregate_bool_exp Orientation_system_aggregate_bool_expRaw


{-| Encode a Orientation\_system\_aggregate\_bool\_exp into a value that can be used as an argument.
-}
encodeOrientation_system_aggregate_bool_exp : Orientation_system_aggregate_bool_exp -> Value
encodeOrientation_system_aggregate_bool_exp (Orientation_system_aggregate_bool_exp input____) =
    Encode.maybeObject
        [ ( "count", encodeOrientation_system_aggregate_bool_exp_count |> Encode.optional input____.count ) ]


buildOrientation_system_aggregate_bool_exp_count :
    Orientation_system_aggregate_bool_exp_countRequiredFields
    -> (Orientation_system_aggregate_bool_exp_countOptionalFields -> Orientation_system_aggregate_bool_exp_countOptionalFields)
    -> Orientation_system_aggregate_bool_exp_count
buildOrientation_system_aggregate_bool_exp_count required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { arguments = Absent, distinct = Absent, filter = Absent }
    in
    Orientation_system_aggregate_bool_exp_count { arguments = optionals____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Orientation_system_aggregate_bool_exp_countRequiredFields =
    { predicate : Int_comparison_exp }


type alias Orientation_system_aggregate_bool_exp_countOptionalFields =
    { arguments : OptionalArgument (List CdbGQL.Enum.Orientation_system_select_column.Orientation_system_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Orientation_system_bool_exp
    }


{-| Type alias for the `Orientation_system_aggregate_bool_exp_count` attributes. Note that this type
needs to use the `Orientation_system_aggregate_bool_exp_count` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Orientation_system_aggregate_bool_exp_countRaw =
    { arguments : OptionalArgument (List CdbGQL.Enum.Orientation_system_select_column.Orientation_system_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Orientation_system_bool_exp
    , predicate : Int_comparison_exp
    }


{-| Type for the Orientation\_system\_aggregate\_bool\_exp\_count input object.
-}
type Orientation_system_aggregate_bool_exp_count
    = Orientation_system_aggregate_bool_exp_count Orientation_system_aggregate_bool_exp_countRaw


{-| Encode a Orientation\_system\_aggregate\_bool\_exp\_count into a value that can be used as an argument.
-}
encodeOrientation_system_aggregate_bool_exp_count : Orientation_system_aggregate_bool_exp_count -> Value
encodeOrientation_system_aggregate_bool_exp_count (Orientation_system_aggregate_bool_exp_count input____) =
    Encode.maybeObject
        [ ( "arguments", (Encode.enum CdbGQL.Enum.Orientation_system_select_column.toString |> Encode.list) |> Encode.optional input____.arguments ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeOrientation_system_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeInt_comparison_exp input____.predicate |> Just ) ]


buildOrientation_system_aggregate_order_by :
    (Orientation_system_aggregate_order_byOptionalFields -> Orientation_system_aggregate_order_byOptionalFields)
    -> Orientation_system_aggregate_order_by
buildOrientation_system_aggregate_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals____.count, max = optionals____.max, min = optionals____.min }


type alias Orientation_system_aggregate_order_byOptionalFields =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Orientation_system_max_order_by
    , min : OptionalArgument Orientation_system_min_order_by
    }


{-| Type for the Orientation\_system\_aggregate\_order\_by input object.
-}
type alias Orientation_system_aggregate_order_by =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Orientation_system_max_order_by
    , min : OptionalArgument Orientation_system_min_order_by
    }


{-| Encode a Orientation\_system\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeOrientation_system_aggregate_order_by : Orientation_system_aggregate_order_by -> Value
encodeOrientation_system_aggregate_order_by input____ =
    Encode.maybeObject
        [ ( "count", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.count ), ( "max", encodeOrientation_system_max_order_by |> Encode.optional input____.max ), ( "min", encodeOrientation_system_min_order_by |> Encode.optional input____.min ) ]


buildOrientation_system_arr_rel_insert_input :
    Orientation_system_arr_rel_insert_inputRequiredFields
    -> (Orientation_system_arr_rel_insert_inputOptionalFields -> Orientation_system_arr_rel_insert_inputOptionalFields)
    -> Orientation_system_arr_rel_insert_input
buildOrientation_system_arr_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Orientation_system_arr_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Orientation_system_arr_rel_insert_inputRequiredFields =
    { data : List Orientation_system_insert_input }


type alias Orientation_system_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Orientation_system_on_conflict }


{-| Type alias for the `Orientation_system_arr_rel_insert_input` attributes. Note that this type
needs to use the `Orientation_system_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Orientation_system_arr_rel_insert_inputRaw =
    { data : List Orientation_system_insert_input
    , on_conflict : OptionalArgument Orientation_system_on_conflict
    }


{-| Type for the Orientation\_system\_arr\_rel\_insert\_input input object.
-}
type Orientation_system_arr_rel_insert_input
    = Orientation_system_arr_rel_insert_input Orientation_system_arr_rel_insert_inputRaw


{-| Encode a Orientation\_system\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeOrientation_system_arr_rel_insert_input : Orientation_system_arr_rel_insert_input -> Value
encodeOrientation_system_arr_rel_insert_input (Orientation_system_arr_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", (encodeOrientation_system_insert_input |> Encode.list) input____.data |> Just ), ( "on_conflict", encodeOrientation_system_on_conflict |> Encode.optional input____.on_conflict ) ]


buildOrientation_system_bool_exp :
    (Orientation_system_bool_expOptionalFields -> Orientation_system_bool_expOptionalFields)
    -> Orientation_system_bool_exp
buildOrientation_system_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, beneficiaries = Absent, createdAt = Absent, deployment = Absent, deployment_id = Absent, id = Absent, name = Absent, orientationType = Absent, orientationTypeByOrientationType = Absent, professionalOrientationSystems = Absent, professionalOrientationSystems_aggregate = Absent, structureOrientationSystems = Absent, structureOrientationSystems_aggregate = Absent, updatedAt = Absent }
    in
    Orientation_system_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, beneficiaries = optionals____.beneficiaries, createdAt = optionals____.createdAt, deployment = optionals____.deployment, deployment_id = optionals____.deployment_id, id = optionals____.id, name = optionals____.name, orientationType = optionals____.orientationType, orientationTypeByOrientationType = optionals____.orientationTypeByOrientationType, professionalOrientationSystems = optionals____.professionalOrientationSystems, professionalOrientationSystems_aggregate = optionals____.professionalOrientationSystems_aggregate, structureOrientationSystems = optionals____.structureOrientationSystems, structureOrientationSystems_aggregate = optionals____.structureOrientationSystems_aggregate, updatedAt = optionals____.updatedAt }


type alias Orientation_system_bool_expOptionalFields =
    { and_ : OptionalArgument (List Orientation_system_bool_exp)
    , not_ : OptionalArgument Orientation_system_bool_exp
    , or_ : OptionalArgument (List Orientation_system_bool_exp)
    , beneficiaries : OptionalArgument Notebook_info_bool_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , deployment : OptionalArgument Deployment_bool_exp
    , deployment_id : OptionalArgument Uuid_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , name : OptionalArgument String_comparison_exp
    , orientationType : OptionalArgument Orientation_type_enum_comparison_exp
    , orientationTypeByOrientationType : OptionalArgument Orientation_type_bool_exp
    , professionalOrientationSystems : OptionalArgument Professional_orientation_system_bool_exp
    , professionalOrientationSystems_aggregate : OptionalArgument Professional_orientation_system_aggregate_bool_exp
    , structureOrientationSystems : OptionalArgument Structure_orientation_system_bool_exp
    , structureOrientationSystems_aggregate : OptionalArgument Structure_orientation_system_aggregate_bool_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type alias for the `Orientation_system_bool_exp` attributes. Note that this type
needs to use the `Orientation_system_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Orientation_system_bool_expRaw =
    { and_ : OptionalArgument (List Orientation_system_bool_exp)
    , not_ : OptionalArgument Orientation_system_bool_exp
    , or_ : OptionalArgument (List Orientation_system_bool_exp)
    , beneficiaries : OptionalArgument Notebook_info_bool_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , deployment : OptionalArgument Deployment_bool_exp
    , deployment_id : OptionalArgument Uuid_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , name : OptionalArgument String_comparison_exp
    , orientationType : OptionalArgument Orientation_type_enum_comparison_exp
    , orientationTypeByOrientationType : OptionalArgument Orientation_type_bool_exp
    , professionalOrientationSystems : OptionalArgument Professional_orientation_system_bool_exp
    , professionalOrientationSystems_aggregate : OptionalArgument Professional_orientation_system_aggregate_bool_exp
    , structureOrientationSystems : OptionalArgument Structure_orientation_system_bool_exp
    , structureOrientationSystems_aggregate : OptionalArgument Structure_orientation_system_aggregate_bool_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type for the Orientation\_system\_bool\_exp input object.
-}
type Orientation_system_bool_exp
    = Orientation_system_bool_exp Orientation_system_bool_expRaw


{-| Encode a Orientation\_system\_bool\_exp into a value that can be used as an argument.
-}
encodeOrientation_system_bool_exp : Orientation_system_bool_exp -> Value
encodeOrientation_system_bool_exp (Orientation_system_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeOrientation_system_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeOrientation_system_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeOrientation_system_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "beneficiaries", encodeNotebook_info_bool_exp |> Encode.optional input____.beneficiaries ), ( "createdAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.createdAt ), ( "deployment", encodeDeployment_bool_exp |> Encode.optional input____.deployment ), ( "deployment_id", encodeUuid_comparison_exp |> Encode.optional input____.deployment_id ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "name", encodeString_comparison_exp |> Encode.optional input____.name ), ( "orientationType", encodeOrientation_type_enum_comparison_exp |> Encode.optional input____.orientationType ), ( "orientationTypeByOrientationType", encodeOrientation_type_bool_exp |> Encode.optional input____.orientationTypeByOrientationType ), ( "professionalOrientationSystems", encodeProfessional_orientation_system_bool_exp |> Encode.optional input____.professionalOrientationSystems ), ( "professionalOrientationSystems_aggregate", encodeProfessional_orientation_system_aggregate_bool_exp |> Encode.optional input____.professionalOrientationSystems_aggregate ), ( "structureOrientationSystems", encodeStructure_orientation_system_bool_exp |> Encode.optional input____.structureOrientationSystems ), ( "structureOrientationSystems_aggregate", encodeStructure_orientation_system_aggregate_bool_exp |> Encode.optional input____.structureOrientationSystems_aggregate ), ( "updatedAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.updatedAt ) ]


buildOrientation_system_insert_input :
    (Orientation_system_insert_inputOptionalFields -> Orientation_system_insert_inputOptionalFields)
    -> Orientation_system_insert_input
buildOrientation_system_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { beneficiaries = Absent, createdAt = Absent, deployment = Absent, deployment_id = Absent, id = Absent, name = Absent, orientationType = Absent, orientationTypeByOrientationType = Absent, professionalOrientationSystems = Absent, structureOrientationSystems = Absent, updatedAt = Absent }
    in
    Orientation_system_insert_input { beneficiaries = optionals____.beneficiaries, createdAt = optionals____.createdAt, deployment = optionals____.deployment, deployment_id = optionals____.deployment_id, id = optionals____.id, name = optionals____.name, orientationType = optionals____.orientationType, orientationTypeByOrientationType = optionals____.orientationTypeByOrientationType, professionalOrientationSystems = optionals____.professionalOrientationSystems, structureOrientationSystems = optionals____.structureOrientationSystems, updatedAt = optionals____.updatedAt }


type alias Orientation_system_insert_inputOptionalFields =
    { beneficiaries : OptionalArgument Notebook_info_obj_rel_insert_input
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deployment : OptionalArgument Deployment_obj_rel_insert_input
    , deployment_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , name : OptionalArgument String
    , orientationType : OptionalArgument CdbGQL.Enum.Orientation_type_enum.Orientation_type_enum
    , orientationTypeByOrientationType : OptionalArgument Orientation_type_obj_rel_insert_input
    , professionalOrientationSystems : OptionalArgument Professional_orientation_system_arr_rel_insert_input
    , structureOrientationSystems : OptionalArgument Structure_orientation_system_arr_rel_insert_input
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type alias for the `Orientation_system_insert_input` attributes. Note that this type
needs to use the `Orientation_system_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Orientation_system_insert_inputRaw =
    { beneficiaries : OptionalArgument Notebook_info_obj_rel_insert_input
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deployment : OptionalArgument Deployment_obj_rel_insert_input
    , deployment_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , name : OptionalArgument String
    , orientationType : OptionalArgument CdbGQL.Enum.Orientation_type_enum.Orientation_type_enum
    , orientationTypeByOrientationType : OptionalArgument Orientation_type_obj_rel_insert_input
    , professionalOrientationSystems : OptionalArgument Professional_orientation_system_arr_rel_insert_input
    , structureOrientationSystems : OptionalArgument Structure_orientation_system_arr_rel_insert_input
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Orientation\_system\_insert\_input input object.
-}
type Orientation_system_insert_input
    = Orientation_system_insert_input Orientation_system_insert_inputRaw


{-| Encode a Orientation\_system\_insert\_input into a value that can be used as an argument.
-}
encodeOrientation_system_insert_input : Orientation_system_insert_input -> Value
encodeOrientation_system_insert_input (Orientation_system_insert_input input____) =
    Encode.maybeObject
        [ ( "beneficiaries", encodeNotebook_info_obj_rel_insert_input |> Encode.optional input____.beneficiaries ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "deployment", encodeDeployment_obj_rel_insert_input |> Encode.optional input____.deployment ), ( "deployment_id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.deployment_id ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "name", Encode.string |> Encode.optional input____.name ), ( "orientationType", Encode.enum CdbGQL.Enum.Orientation_type_enum.toString |> Encode.optional input____.orientationType ), ( "orientationTypeByOrientationType", encodeOrientation_type_obj_rel_insert_input |> Encode.optional input____.orientationTypeByOrientationType ), ( "professionalOrientationSystems", encodeProfessional_orientation_system_arr_rel_insert_input |> Encode.optional input____.professionalOrientationSystems ), ( "structureOrientationSystems", encodeStructure_orientation_system_arr_rel_insert_input |> Encode.optional input____.structureOrientationSystems ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildOrientation_system_max_order_by :
    (Orientation_system_max_order_byOptionalFields -> Orientation_system_max_order_byOptionalFields)
    -> Orientation_system_max_order_by
buildOrientation_system_max_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, deployment_id = Absent, id = Absent, name = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, deployment_id = optionals____.deployment_id, id = optionals____.id, name = optionals____.name, updatedAt = optionals____.updatedAt }


type alias Orientation_system_max_order_byOptionalFields =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deployment_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , name : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Orientation\_system\_max\_order\_by input object.
-}
type alias Orientation_system_max_order_by =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deployment_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , name : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Orientation\_system\_max\_order\_by into a value that can be used as an argument.
-}
encodeOrientation_system_max_order_by : Orientation_system_max_order_by -> Value
encodeOrientation_system_max_order_by input____ =
    Encode.maybeObject
        [ ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "deployment_id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deployment_id ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "name", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.name ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildOrientation_system_min_order_by :
    (Orientation_system_min_order_byOptionalFields -> Orientation_system_min_order_byOptionalFields)
    -> Orientation_system_min_order_by
buildOrientation_system_min_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, deployment_id = Absent, id = Absent, name = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, deployment_id = optionals____.deployment_id, id = optionals____.id, name = optionals____.name, updatedAt = optionals____.updatedAt }


type alias Orientation_system_min_order_byOptionalFields =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deployment_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , name : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Orientation\_system\_min\_order\_by input object.
-}
type alias Orientation_system_min_order_by =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deployment_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , name : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Orientation\_system\_min\_order\_by into a value that can be used as an argument.
-}
encodeOrientation_system_min_order_by : Orientation_system_min_order_by -> Value
encodeOrientation_system_min_order_by input____ =
    Encode.maybeObject
        [ ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "deployment_id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deployment_id ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "name", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.name ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildOrientation_system_obj_rel_insert_input :
    Orientation_system_obj_rel_insert_inputRequiredFields
    -> (Orientation_system_obj_rel_insert_inputOptionalFields -> Orientation_system_obj_rel_insert_inputOptionalFields)
    -> Orientation_system_obj_rel_insert_input
buildOrientation_system_obj_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Orientation_system_obj_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Orientation_system_obj_rel_insert_inputRequiredFields =
    { data : Orientation_system_insert_input }


type alias Orientation_system_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Orientation_system_on_conflict }


{-| Type alias for the `Orientation_system_obj_rel_insert_input` attributes. Note that this type
needs to use the `Orientation_system_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Orientation_system_obj_rel_insert_inputRaw =
    { data : Orientation_system_insert_input
    , on_conflict : OptionalArgument Orientation_system_on_conflict
    }


{-| Type for the Orientation\_system\_obj\_rel\_insert\_input input object.
-}
type Orientation_system_obj_rel_insert_input
    = Orientation_system_obj_rel_insert_input Orientation_system_obj_rel_insert_inputRaw


{-| Encode a Orientation\_system\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeOrientation_system_obj_rel_insert_input : Orientation_system_obj_rel_insert_input -> Value
encodeOrientation_system_obj_rel_insert_input (Orientation_system_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeOrientation_system_insert_input input____.data |> Just ), ( "on_conflict", encodeOrientation_system_on_conflict |> Encode.optional input____.on_conflict ) ]


buildOrientation_system_on_conflict :
    Orientation_system_on_conflictRequiredFields
    -> (Orientation_system_on_conflictOptionalFields -> Orientation_system_on_conflictOptionalFields)
    -> Orientation_system_on_conflict
buildOrientation_system_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Orientation_system_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Orientation_system_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Orientation_system_constraint.Orientation_system_constraint
    , update_columns : List CdbGQL.Enum.Orientation_system_update_column.Orientation_system_update_column
    }


type alias Orientation_system_on_conflictOptionalFields =
    { where_ : OptionalArgument Orientation_system_bool_exp }


{-| Type alias for the `Orientation_system_on_conflict` attributes. Note that this type
needs to use the `Orientation_system_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Orientation_system_on_conflictRaw =
    { constraint : CdbGQL.Enum.Orientation_system_constraint.Orientation_system_constraint
    , update_columns : List CdbGQL.Enum.Orientation_system_update_column.Orientation_system_update_column
    , where_ : OptionalArgument Orientation_system_bool_exp
    }


{-| Type for the Orientation\_system\_on\_conflict input object.
-}
type Orientation_system_on_conflict
    = Orientation_system_on_conflict Orientation_system_on_conflictRaw


{-| Encode a Orientation\_system\_on\_conflict into a value that can be used as an argument.
-}
encodeOrientation_system_on_conflict : Orientation_system_on_conflict -> Value
encodeOrientation_system_on_conflict (Orientation_system_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Orientation_system_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Orientation_system_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeOrientation_system_bool_exp |> Encode.optional input____.where_ ) ]


buildOrientation_system_order_by :
    (Orientation_system_order_byOptionalFields -> Orientation_system_order_byOptionalFields)
    -> Orientation_system_order_by
buildOrientation_system_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { beneficiaries = Absent, createdAt = Absent, deployment = Absent, deployment_id = Absent, id = Absent, name = Absent, orientationType = Absent, orientationTypeByOrientationType = Absent, professionalOrientationSystems_aggregate = Absent, structureOrientationSystems_aggregate = Absent, updatedAt = Absent }
    in
    Orientation_system_order_by { beneficiaries = optionals____.beneficiaries, createdAt = optionals____.createdAt, deployment = optionals____.deployment, deployment_id = optionals____.deployment_id, id = optionals____.id, name = optionals____.name, orientationType = optionals____.orientationType, orientationTypeByOrientationType = optionals____.orientationTypeByOrientationType, professionalOrientationSystems_aggregate = optionals____.professionalOrientationSystems_aggregate, structureOrientationSystems_aggregate = optionals____.structureOrientationSystems_aggregate, updatedAt = optionals____.updatedAt }


type alias Orientation_system_order_byOptionalFields =
    { beneficiaries : OptionalArgument Notebook_info_order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deployment : OptionalArgument Deployment_order_by
    , deployment_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , name : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationType : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationTypeByOrientationType : OptionalArgument Orientation_type_order_by
    , professionalOrientationSystems_aggregate : OptionalArgument Professional_orientation_system_aggregate_order_by
    , structureOrientationSystems_aggregate : OptionalArgument Structure_orientation_system_aggregate_order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type alias for the `Orientation_system_order_by` attributes. Note that this type
needs to use the `Orientation_system_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Orientation_system_order_byRaw =
    { beneficiaries : OptionalArgument Notebook_info_order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deployment : OptionalArgument Deployment_order_by
    , deployment_id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , name : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationType : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationTypeByOrientationType : OptionalArgument Orientation_type_order_by
    , professionalOrientationSystems_aggregate : OptionalArgument Professional_orientation_system_aggregate_order_by
    , structureOrientationSystems_aggregate : OptionalArgument Structure_orientation_system_aggregate_order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Orientation\_system\_order\_by input object.
-}
type Orientation_system_order_by
    = Orientation_system_order_by Orientation_system_order_byRaw


{-| Encode a Orientation\_system\_order\_by into a value that can be used as an argument.
-}
encodeOrientation_system_order_by : Orientation_system_order_by -> Value
encodeOrientation_system_order_by (Orientation_system_order_by input____) =
    Encode.maybeObject
        [ ( "beneficiaries", encodeNotebook_info_order_by |> Encode.optional input____.beneficiaries ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "deployment", encodeDeployment_order_by |> Encode.optional input____.deployment ), ( "deployment_id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deployment_id ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "name", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.name ), ( "orientationType", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.orientationType ), ( "orientationTypeByOrientationType", encodeOrientation_type_order_by |> Encode.optional input____.orientationTypeByOrientationType ), ( "professionalOrientationSystems_aggregate", encodeProfessional_orientation_system_aggregate_order_by |> Encode.optional input____.professionalOrientationSystems_aggregate ), ( "structureOrientationSystems_aggregate", encodeStructure_orientation_system_aggregate_order_by |> Encode.optional input____.structureOrientationSystems_aggregate ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildOrientation_system_pk_columns_input :
    Orientation_system_pk_columns_inputRequiredFields
    -> Orientation_system_pk_columns_input
buildOrientation_system_pk_columns_input required____ =
    { id = required____.id }


type alias Orientation_system_pk_columns_inputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the Orientation\_system\_pk\_columns\_input input object.
-}
type alias Orientation_system_pk_columns_input =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a Orientation\_system\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeOrientation_system_pk_columns_input : Orientation_system_pk_columns_input -> Value
encodeOrientation_system_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildOrientation_system_set_input :
    (Orientation_system_set_inputOptionalFields -> Orientation_system_set_inputOptionalFields)
    -> Orientation_system_set_input
buildOrientation_system_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, deployment_id = Absent, id = Absent, name = Absent, orientationType = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, deployment_id = optionals____.deployment_id, id = optionals____.id, name = optionals____.name, orientationType = optionals____.orientationType, updatedAt = optionals____.updatedAt }


type alias Orientation_system_set_inputOptionalFields =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deployment_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , name : OptionalArgument String
    , orientationType : OptionalArgument CdbGQL.Enum.Orientation_type_enum.Orientation_type_enum
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Orientation\_system\_set\_input input object.
-}
type alias Orientation_system_set_input =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deployment_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , name : OptionalArgument String
    , orientationType : OptionalArgument CdbGQL.Enum.Orientation_type_enum.Orientation_type_enum
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Orientation\_system\_set\_input into a value that can be used as an argument.
-}
encodeOrientation_system_set_input : Orientation_system_set_input -> Value
encodeOrientation_system_set_input input____ =
    Encode.maybeObject
        [ ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "deployment_id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.deployment_id ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "name", Encode.string |> Encode.optional input____.name ), ( "orientationType", Encode.enum CdbGQL.Enum.Orientation_type_enum.toString |> Encode.optional input____.orientationType ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildOrientation_system_stream_cursor_input :
    Orientation_system_stream_cursor_inputRequiredFields
    -> (Orientation_system_stream_cursor_inputOptionalFields -> Orientation_system_stream_cursor_inputOptionalFields)
    -> Orientation_system_stream_cursor_input
buildOrientation_system_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Orientation_system_stream_cursor_inputRequiredFields =
    { initial_value : Orientation_system_stream_cursor_value_input }


type alias Orientation_system_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Orientation\_system\_stream\_cursor\_input input object.
-}
type alias Orientation_system_stream_cursor_input =
    { initial_value : Orientation_system_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Orientation\_system\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeOrientation_system_stream_cursor_input : Orientation_system_stream_cursor_input -> Value
encodeOrientation_system_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeOrientation_system_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildOrientation_system_stream_cursor_value_input :
    (Orientation_system_stream_cursor_value_inputOptionalFields -> Orientation_system_stream_cursor_value_inputOptionalFields)
    -> Orientation_system_stream_cursor_value_input
buildOrientation_system_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, deployment_id = Absent, id = Absent, name = Absent, orientationType = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, deployment_id = optionals____.deployment_id, id = optionals____.id, name = optionals____.name, orientationType = optionals____.orientationType, updatedAt = optionals____.updatedAt }


type alias Orientation_system_stream_cursor_value_inputOptionalFields =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deployment_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , name : OptionalArgument String
    , orientationType : OptionalArgument CdbGQL.Enum.Orientation_type_enum.Orientation_type_enum
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Orientation\_system\_stream\_cursor\_value\_input input object.
-}
type alias Orientation_system_stream_cursor_value_input =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deployment_id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , name : OptionalArgument String
    , orientationType : OptionalArgument CdbGQL.Enum.Orientation_type_enum.Orientation_type_enum
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Orientation\_system\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeOrientation_system_stream_cursor_value_input : Orientation_system_stream_cursor_value_input -> Value
encodeOrientation_system_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "deployment_id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.deployment_id ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "name", Encode.string |> Encode.optional input____.name ), ( "orientationType", Encode.enum CdbGQL.Enum.Orientation_type_enum.toString |> Encode.optional input____.orientationType ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildOrientation_system_updates :
    Orientation_system_updatesRequiredFields
    -> (Orientation_system_updatesOptionalFields -> Orientation_system_updatesOptionalFields)
    -> Orientation_system_updates
buildOrientation_system_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Orientation_system_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Orientation_system_updatesRequiredFields =
    { where_ : Orientation_system_bool_exp }


type alias Orientation_system_updatesOptionalFields =
    { set_ : OptionalArgument Orientation_system_set_input }


{-| Type alias for the `Orientation_system_updates` attributes. Note that this type
needs to use the `Orientation_system_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Orientation_system_updatesRaw =
    { set_ : OptionalArgument Orientation_system_set_input
    , where_ : Orientation_system_bool_exp
    }


{-| Type for the Orientation\_system\_updates input object.
-}
type Orientation_system_updates
    = Orientation_system_updates Orientation_system_updatesRaw


{-| Encode a Orientation\_system\_updates into a value that can be used as an argument.
-}
encodeOrientation_system_updates : Orientation_system_updates -> Value
encodeOrientation_system_updates (Orientation_system_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeOrientation_system_set_input |> Encode.optional input____.set_ ), ( "where", encodeOrientation_system_bool_exp input____.where_ |> Just ) ]


buildOrientation_type_bool_exp :
    (Orientation_type_bool_expOptionalFields -> Orientation_type_bool_expOptionalFields)
    -> Orientation_type_bool_exp
buildOrientation_type_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, id = Absent, label = Absent, orientationType = Absent, orientationType_aggregate = Absent }
    in
    Orientation_type_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, id = optionals____.id, label = optionals____.label, orientationType = optionals____.orientationType, orientationType_aggregate = optionals____.orientationType_aggregate }


type alias Orientation_type_bool_expOptionalFields =
    { and_ : OptionalArgument (List Orientation_type_bool_exp)
    , not_ : OptionalArgument Orientation_type_bool_exp
    , or_ : OptionalArgument (List Orientation_type_bool_exp)
    , id : OptionalArgument String_comparison_exp
    , label : OptionalArgument String_comparison_exp
    , orientationType : OptionalArgument Orientation_system_bool_exp
    , orientationType_aggregate : OptionalArgument Orientation_system_aggregate_bool_exp
    }


{-| Type alias for the `Orientation_type_bool_exp` attributes. Note that this type
needs to use the `Orientation_type_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Orientation_type_bool_expRaw =
    { and_ : OptionalArgument (List Orientation_type_bool_exp)
    , not_ : OptionalArgument Orientation_type_bool_exp
    , or_ : OptionalArgument (List Orientation_type_bool_exp)
    , id : OptionalArgument String_comparison_exp
    , label : OptionalArgument String_comparison_exp
    , orientationType : OptionalArgument Orientation_system_bool_exp
    , orientationType_aggregate : OptionalArgument Orientation_system_aggregate_bool_exp
    }


{-| Type for the Orientation\_type\_bool\_exp input object.
-}
type Orientation_type_bool_exp
    = Orientation_type_bool_exp Orientation_type_bool_expRaw


{-| Encode a Orientation\_type\_bool\_exp into a value that can be used as an argument.
-}
encodeOrientation_type_bool_exp : Orientation_type_bool_exp -> Value
encodeOrientation_type_bool_exp (Orientation_type_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeOrientation_type_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeOrientation_type_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeOrientation_type_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "id", encodeString_comparison_exp |> Encode.optional input____.id ), ( "label", encodeString_comparison_exp |> Encode.optional input____.label ), ( "orientationType", encodeOrientation_system_bool_exp |> Encode.optional input____.orientationType ), ( "orientationType_aggregate", encodeOrientation_system_aggregate_bool_exp |> Encode.optional input____.orientationType_aggregate ) ]


buildOrientation_type_enum_comparison_exp :
    (Orientation_type_enum_comparison_expOptionalFields -> Orientation_type_enum_comparison_expOptionalFields)
    -> Orientation_type_enum_comparison_exp
buildOrientation_type_enum_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, in_ = Absent, is_null_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals____.eq_, in_ = optionals____.in_, is_null_ = optionals____.is_null_, neq_ = optionals____.neq_, nin_ = optionals____.nin_ }


type alias Orientation_type_enum_comparison_expOptionalFields =
    { eq_ : OptionalArgument CdbGQL.Enum.Orientation_type_enum.Orientation_type_enum
    , in_ : OptionalArgument (List CdbGQL.Enum.Orientation_type_enum.Orientation_type_enum)
    , is_null_ : OptionalArgument Bool
    , neq_ : OptionalArgument CdbGQL.Enum.Orientation_type_enum.Orientation_type_enum
    , nin_ : OptionalArgument (List CdbGQL.Enum.Orientation_type_enum.Orientation_type_enum)
    }


{-| Type for the Orientation\_type\_enum\_comparison\_exp input object.
-}
type alias Orientation_type_enum_comparison_exp =
    { eq_ : OptionalArgument CdbGQL.Enum.Orientation_type_enum.Orientation_type_enum
    , in_ : OptionalArgument (List CdbGQL.Enum.Orientation_type_enum.Orientation_type_enum)
    , is_null_ : OptionalArgument Bool
    , neq_ : OptionalArgument CdbGQL.Enum.Orientation_type_enum.Orientation_type_enum
    , nin_ : OptionalArgument (List CdbGQL.Enum.Orientation_type_enum.Orientation_type_enum)
    }


{-| Encode a Orientation\_type\_enum\_comparison\_exp into a value that can be used as an argument.
-}
encodeOrientation_type_enum_comparison_exp : Orientation_type_enum_comparison_exp -> Value
encodeOrientation_type_enum_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", Encode.enum CdbGQL.Enum.Orientation_type_enum.toString |> Encode.optional input____.eq_ ), ( "_in", (Encode.enum CdbGQL.Enum.Orientation_type_enum.toString |> Encode.list) |> Encode.optional input____.in_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_neq", Encode.enum CdbGQL.Enum.Orientation_type_enum.toString |> Encode.optional input____.neq_ ), ( "_nin", (Encode.enum CdbGQL.Enum.Orientation_type_enum.toString |> Encode.list) |> Encode.optional input____.nin_ ) ]


buildOrientation_type_insert_input :
    (Orientation_type_insert_inputOptionalFields -> Orientation_type_insert_inputOptionalFields)
    -> Orientation_type_insert_input
buildOrientation_type_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, label = Absent, orientationType = Absent }
    in
    Orientation_type_insert_input { id = optionals____.id, label = optionals____.label, orientationType = optionals____.orientationType }


type alias Orientation_type_insert_inputOptionalFields =
    { id : OptionalArgument String
    , label : OptionalArgument String
    , orientationType : OptionalArgument Orientation_system_arr_rel_insert_input
    }


{-| Type alias for the `Orientation_type_insert_input` attributes. Note that this type
needs to use the `Orientation_type_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Orientation_type_insert_inputRaw =
    { id : OptionalArgument String
    , label : OptionalArgument String
    , orientationType : OptionalArgument Orientation_system_arr_rel_insert_input
    }


{-| Type for the Orientation\_type\_insert\_input input object.
-}
type Orientation_type_insert_input
    = Orientation_type_insert_input Orientation_type_insert_inputRaw


{-| Encode a Orientation\_type\_insert\_input into a value that can be used as an argument.
-}
encodeOrientation_type_insert_input : Orientation_type_insert_input -> Value
encodeOrientation_type_insert_input (Orientation_type_insert_input input____) =
    Encode.maybeObject
        [ ( "id", Encode.string |> Encode.optional input____.id ), ( "label", Encode.string |> Encode.optional input____.label ), ( "orientationType", encodeOrientation_system_arr_rel_insert_input |> Encode.optional input____.orientationType ) ]


buildOrientation_type_obj_rel_insert_input :
    Orientation_type_obj_rel_insert_inputRequiredFields
    -> (Orientation_type_obj_rel_insert_inputOptionalFields -> Orientation_type_obj_rel_insert_inputOptionalFields)
    -> Orientation_type_obj_rel_insert_input
buildOrientation_type_obj_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Orientation_type_obj_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Orientation_type_obj_rel_insert_inputRequiredFields =
    { data : Orientation_type_insert_input }


type alias Orientation_type_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Orientation_type_on_conflict }


{-| Type alias for the `Orientation_type_obj_rel_insert_input` attributes. Note that this type
needs to use the `Orientation_type_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Orientation_type_obj_rel_insert_inputRaw =
    { data : Orientation_type_insert_input
    , on_conflict : OptionalArgument Orientation_type_on_conflict
    }


{-| Type for the Orientation\_type\_obj\_rel\_insert\_input input object.
-}
type Orientation_type_obj_rel_insert_input
    = Orientation_type_obj_rel_insert_input Orientation_type_obj_rel_insert_inputRaw


{-| Encode a Orientation\_type\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeOrientation_type_obj_rel_insert_input : Orientation_type_obj_rel_insert_input -> Value
encodeOrientation_type_obj_rel_insert_input (Orientation_type_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeOrientation_type_insert_input input____.data |> Just ), ( "on_conflict", encodeOrientation_type_on_conflict |> Encode.optional input____.on_conflict ) ]


buildOrientation_type_on_conflict :
    Orientation_type_on_conflictRequiredFields
    -> (Orientation_type_on_conflictOptionalFields -> Orientation_type_on_conflictOptionalFields)
    -> Orientation_type_on_conflict
buildOrientation_type_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Orientation_type_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Orientation_type_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Orientation_type_constraint.Orientation_type_constraint
    , update_columns : List CdbGQL.Enum.Orientation_type_update_column.Orientation_type_update_column
    }


type alias Orientation_type_on_conflictOptionalFields =
    { where_ : OptionalArgument Orientation_type_bool_exp }


{-| Type alias for the `Orientation_type_on_conflict` attributes. Note that this type
needs to use the `Orientation_type_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Orientation_type_on_conflictRaw =
    { constraint : CdbGQL.Enum.Orientation_type_constraint.Orientation_type_constraint
    , update_columns : List CdbGQL.Enum.Orientation_type_update_column.Orientation_type_update_column
    , where_ : OptionalArgument Orientation_type_bool_exp
    }


{-| Type for the Orientation\_type\_on\_conflict input object.
-}
type Orientation_type_on_conflict
    = Orientation_type_on_conflict Orientation_type_on_conflictRaw


{-| Encode a Orientation\_type\_on\_conflict into a value that can be used as an argument.
-}
encodeOrientation_type_on_conflict : Orientation_type_on_conflict -> Value
encodeOrientation_type_on_conflict (Orientation_type_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Orientation_type_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Orientation_type_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeOrientation_type_bool_exp |> Encode.optional input____.where_ ) ]


buildOrientation_type_order_by :
    (Orientation_type_order_byOptionalFields -> Orientation_type_order_byOptionalFields)
    -> Orientation_type_order_by
buildOrientation_type_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, label = Absent, orientationType_aggregate = Absent }
    in
    { id = optionals____.id, label = optionals____.label, orientationType_aggregate = optionals____.orientationType_aggregate }


type alias Orientation_type_order_byOptionalFields =
    { id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , label : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationType_aggregate : OptionalArgument Orientation_system_aggregate_order_by
    }


{-| Type for the Orientation\_type\_order\_by input object.
-}
type alias Orientation_type_order_by =
    { id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , label : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationType_aggregate : OptionalArgument Orientation_system_aggregate_order_by
    }


{-| Encode a Orientation\_type\_order\_by into a value that can be used as an argument.
-}
encodeOrientation_type_order_by : Orientation_type_order_by -> Value
encodeOrientation_type_order_by input____ =
    Encode.maybeObject
        [ ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "label", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.label ), ( "orientationType_aggregate", encodeOrientation_system_aggregate_order_by |> Encode.optional input____.orientationType_aggregate ) ]


buildOrientation_type_pk_columns_input :
    Orientation_type_pk_columns_inputRequiredFields
    -> Orientation_type_pk_columns_input
buildOrientation_type_pk_columns_input required____ =
    { id = required____.id }


type alias Orientation_type_pk_columns_inputRequiredFields =
    { id : String }


{-| Type for the Orientation\_type\_pk\_columns\_input input object.
-}
type alias Orientation_type_pk_columns_input =
    { id : String }


{-| Encode a Orientation\_type\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeOrientation_type_pk_columns_input : Orientation_type_pk_columns_input -> Value
encodeOrientation_type_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", Encode.string input____.id |> Just ) ]


buildOrientation_type_set_input :
    (Orientation_type_set_inputOptionalFields -> Orientation_type_set_inputOptionalFields)
    -> Orientation_type_set_input
buildOrientation_type_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, label = Absent }
    in
    { id = optionals____.id, label = optionals____.label }


type alias Orientation_type_set_inputOptionalFields =
    { id : OptionalArgument String
    , label : OptionalArgument String
    }


{-| Type for the Orientation\_type\_set\_input input object.
-}
type alias Orientation_type_set_input =
    { id : OptionalArgument String
    , label : OptionalArgument String
    }


{-| Encode a Orientation\_type\_set\_input into a value that can be used as an argument.
-}
encodeOrientation_type_set_input : Orientation_type_set_input -> Value
encodeOrientation_type_set_input input____ =
    Encode.maybeObject
        [ ( "id", Encode.string |> Encode.optional input____.id ), ( "label", Encode.string |> Encode.optional input____.label ) ]


buildOrientation_type_stream_cursor_input :
    Orientation_type_stream_cursor_inputRequiredFields
    -> (Orientation_type_stream_cursor_inputOptionalFields -> Orientation_type_stream_cursor_inputOptionalFields)
    -> Orientation_type_stream_cursor_input
buildOrientation_type_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Orientation_type_stream_cursor_inputRequiredFields =
    { initial_value : Orientation_type_stream_cursor_value_input }


type alias Orientation_type_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Orientation\_type\_stream\_cursor\_input input object.
-}
type alias Orientation_type_stream_cursor_input =
    { initial_value : Orientation_type_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Orientation\_type\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeOrientation_type_stream_cursor_input : Orientation_type_stream_cursor_input -> Value
encodeOrientation_type_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeOrientation_type_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildOrientation_type_stream_cursor_value_input :
    (Orientation_type_stream_cursor_value_inputOptionalFields -> Orientation_type_stream_cursor_value_inputOptionalFields)
    -> Orientation_type_stream_cursor_value_input
buildOrientation_type_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, label = Absent }
    in
    { id = optionals____.id, label = optionals____.label }


type alias Orientation_type_stream_cursor_value_inputOptionalFields =
    { id : OptionalArgument String
    , label : OptionalArgument String
    }


{-| Type for the Orientation\_type\_stream\_cursor\_value\_input input object.
-}
type alias Orientation_type_stream_cursor_value_input =
    { id : OptionalArgument String
    , label : OptionalArgument String
    }


{-| Encode a Orientation\_type\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeOrientation_type_stream_cursor_value_input : Orientation_type_stream_cursor_value_input -> Value
encodeOrientation_type_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "id", Encode.string |> Encode.optional input____.id ), ( "label", Encode.string |> Encode.optional input____.label ) ]


buildOrientation_type_updates :
    Orientation_type_updatesRequiredFields
    -> (Orientation_type_updatesOptionalFields -> Orientation_type_updatesOptionalFields)
    -> Orientation_type_updates
buildOrientation_type_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Orientation_type_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Orientation_type_updatesRequiredFields =
    { where_ : Orientation_type_bool_exp }


type alias Orientation_type_updatesOptionalFields =
    { set_ : OptionalArgument Orientation_type_set_input }


{-| Type alias for the `Orientation_type_updates` attributes. Note that this type
needs to use the `Orientation_type_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Orientation_type_updatesRaw =
    { set_ : OptionalArgument Orientation_type_set_input
    , where_ : Orientation_type_bool_exp
    }


{-| Type for the Orientation\_type\_updates input object.
-}
type Orientation_type_updates
    = Orientation_type_updates Orientation_type_updatesRaw


{-| Encode a Orientation\_type\_updates into a value that can be used as an argument.
-}
encodeOrientation_type_updates : Orientation_type_updates -> Value
encodeOrientation_type_updates (Orientation_type_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeOrientation_type_set_input |> Encode.optional input____.set_ ), ( "where", encodeOrientation_type_bool_exp input____.where_ |> Just ) ]


buildProfessional_aggregate_bool_exp :
    (Professional_aggregate_bool_expOptionalFields -> Professional_aggregate_bool_expOptionalFields)
    -> Professional_aggregate_bool_exp
buildProfessional_aggregate_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent }
    in
    Professional_aggregate_bool_exp { count = optionals____.count }


type alias Professional_aggregate_bool_expOptionalFields =
    { count : OptionalArgument Professional_aggregate_bool_exp_count }


{-| Type alias for the `Professional_aggregate_bool_exp` attributes. Note that this type
needs to use the `Professional_aggregate_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Professional_aggregate_bool_expRaw =
    { count : OptionalArgument Professional_aggregate_bool_exp_count }


{-| Type for the Professional\_aggregate\_bool\_exp input object.
-}
type Professional_aggregate_bool_exp
    = Professional_aggregate_bool_exp Professional_aggregate_bool_expRaw


{-| Encode a Professional\_aggregate\_bool\_exp into a value that can be used as an argument.
-}
encodeProfessional_aggregate_bool_exp : Professional_aggregate_bool_exp -> Value
encodeProfessional_aggregate_bool_exp (Professional_aggregate_bool_exp input____) =
    Encode.maybeObject
        [ ( "count", encodeProfessional_aggregate_bool_exp_count |> Encode.optional input____.count ) ]


buildProfessional_aggregate_bool_exp_count :
    Professional_aggregate_bool_exp_countRequiredFields
    -> (Professional_aggregate_bool_exp_countOptionalFields -> Professional_aggregate_bool_exp_countOptionalFields)
    -> Professional_aggregate_bool_exp_count
buildProfessional_aggregate_bool_exp_count required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { arguments = Absent, distinct = Absent, filter = Absent }
    in
    Professional_aggregate_bool_exp_count { arguments = optionals____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Professional_aggregate_bool_exp_countRequiredFields =
    { predicate : Int_comparison_exp }


type alias Professional_aggregate_bool_exp_countOptionalFields =
    { arguments : OptionalArgument (List CdbGQL.Enum.Professional_select_column.Professional_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Professional_bool_exp
    }


{-| Type alias for the `Professional_aggregate_bool_exp_count` attributes. Note that this type
needs to use the `Professional_aggregate_bool_exp_count` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Professional_aggregate_bool_exp_countRaw =
    { arguments : OptionalArgument (List CdbGQL.Enum.Professional_select_column.Professional_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Professional_bool_exp
    , predicate : Int_comparison_exp
    }


{-| Type for the Professional\_aggregate\_bool\_exp\_count input object.
-}
type Professional_aggregate_bool_exp_count
    = Professional_aggregate_bool_exp_count Professional_aggregate_bool_exp_countRaw


{-| Encode a Professional\_aggregate\_bool\_exp\_count into a value that can be used as an argument.
-}
encodeProfessional_aggregate_bool_exp_count : Professional_aggregate_bool_exp_count -> Value
encodeProfessional_aggregate_bool_exp_count (Professional_aggregate_bool_exp_count input____) =
    Encode.maybeObject
        [ ( "arguments", (Encode.enum CdbGQL.Enum.Professional_select_column.toString |> Encode.list) |> Encode.optional input____.arguments ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeProfessional_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeInt_comparison_exp input____.predicate |> Just ) ]


buildProfessional_aggregate_order_by :
    (Professional_aggregate_order_byOptionalFields -> Professional_aggregate_order_byOptionalFields)
    -> Professional_aggregate_order_by
buildProfessional_aggregate_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals____.count, max = optionals____.max, min = optionals____.min }


type alias Professional_aggregate_order_byOptionalFields =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Professional_max_order_by
    , min : OptionalArgument Professional_min_order_by
    }


{-| Type for the Professional\_aggregate\_order\_by input object.
-}
type alias Professional_aggregate_order_by =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Professional_max_order_by
    , min : OptionalArgument Professional_min_order_by
    }


{-| Encode a Professional\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeProfessional_aggregate_order_by : Professional_aggregate_order_by -> Value
encodeProfessional_aggregate_order_by input____ =
    Encode.maybeObject
        [ ( "count", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.count ), ( "max", encodeProfessional_max_order_by |> Encode.optional input____.max ), ( "min", encodeProfessional_min_order_by |> Encode.optional input____.min ) ]


buildProfessional_arr_rel_insert_input :
    Professional_arr_rel_insert_inputRequiredFields
    -> (Professional_arr_rel_insert_inputOptionalFields -> Professional_arr_rel_insert_inputOptionalFields)
    -> Professional_arr_rel_insert_input
buildProfessional_arr_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Professional_arr_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Professional_arr_rel_insert_inputRequiredFields =
    { data : List Professional_insert_input }


type alias Professional_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Professional_on_conflict }


{-| Type alias for the `Professional_arr_rel_insert_input` attributes. Note that this type
needs to use the `Professional_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Professional_arr_rel_insert_inputRaw =
    { data : List Professional_insert_input
    , on_conflict : OptionalArgument Professional_on_conflict
    }


{-| Type for the Professional\_arr\_rel\_insert\_input input object.
-}
type Professional_arr_rel_insert_input
    = Professional_arr_rel_insert_input Professional_arr_rel_insert_inputRaw


{-| Encode a Professional\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeProfessional_arr_rel_insert_input : Professional_arr_rel_insert_input -> Value
encodeProfessional_arr_rel_insert_input (Professional_arr_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", (encodeProfessional_insert_input |> Encode.list) input____.data |> Just ), ( "on_conflict", encodeProfessional_on_conflict |> Encode.optional input____.on_conflict ) ]


buildProfessional_bool_exp :
    (Professional_bool_expOptionalFields -> Professional_bool_expOptionalFields)
    -> Professional_bool_exp
buildProfessional_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, account = Absent, createdAt = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, mobileNumber = Absent, orientationSystems = Absent, orientationSystems_aggregate = Absent, position = Absent, structure = Absent, structureId = Absent, updatedAt = Absent }
    in
    Professional_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, account = optionals____.account, createdAt = optionals____.createdAt, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, mobileNumber = optionals____.mobileNumber, orientationSystems = optionals____.orientationSystems, orientationSystems_aggregate = optionals____.orientationSystems_aggregate, position = optionals____.position, structure = optionals____.structure, structureId = optionals____.structureId, updatedAt = optionals____.updatedAt }


type alias Professional_bool_expOptionalFields =
    { and_ : OptionalArgument (List Professional_bool_exp)
    , not_ : OptionalArgument Professional_bool_exp
    , or_ : OptionalArgument (List Professional_bool_exp)
    , account : OptionalArgument Account_bool_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , email : OptionalArgument Citext_comparison_exp
    , firstname : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , lastname : OptionalArgument String_comparison_exp
    , mobileNumber : OptionalArgument String_comparison_exp
    , orientationSystems : OptionalArgument Professional_orientation_system_bool_exp
    , orientationSystems_aggregate : OptionalArgument Professional_orientation_system_aggregate_bool_exp
    , position : OptionalArgument String_comparison_exp
    , structure : OptionalArgument Structure_bool_exp
    , structureId : OptionalArgument Uuid_comparison_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type alias for the `Professional_bool_exp` attributes. Note that this type
needs to use the `Professional_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Professional_bool_expRaw =
    { and_ : OptionalArgument (List Professional_bool_exp)
    , not_ : OptionalArgument Professional_bool_exp
    , or_ : OptionalArgument (List Professional_bool_exp)
    , account : OptionalArgument Account_bool_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , email : OptionalArgument Citext_comparison_exp
    , firstname : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , lastname : OptionalArgument String_comparison_exp
    , mobileNumber : OptionalArgument String_comparison_exp
    , orientationSystems : OptionalArgument Professional_orientation_system_bool_exp
    , orientationSystems_aggregate : OptionalArgument Professional_orientation_system_aggregate_bool_exp
    , position : OptionalArgument String_comparison_exp
    , structure : OptionalArgument Structure_bool_exp
    , structureId : OptionalArgument Uuid_comparison_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    }


{-| Type for the Professional\_bool\_exp input object.
-}
type Professional_bool_exp
    = Professional_bool_exp Professional_bool_expRaw


{-| Encode a Professional\_bool\_exp into a value that can be used as an argument.
-}
encodeProfessional_bool_exp : Professional_bool_exp -> Value
encodeProfessional_bool_exp (Professional_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeProfessional_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeProfessional_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeProfessional_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "account", encodeAccount_bool_exp |> Encode.optional input____.account ), ( "createdAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.createdAt ), ( "email", encodeCitext_comparison_exp |> Encode.optional input____.email ), ( "firstname", encodeString_comparison_exp |> Encode.optional input____.firstname ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "lastname", encodeString_comparison_exp |> Encode.optional input____.lastname ), ( "mobileNumber", encodeString_comparison_exp |> Encode.optional input____.mobileNumber ), ( "orientationSystems", encodeProfessional_orientation_system_bool_exp |> Encode.optional input____.orientationSystems ), ( "orientationSystems_aggregate", encodeProfessional_orientation_system_aggregate_bool_exp |> Encode.optional input____.orientationSystems_aggregate ), ( "position", encodeString_comparison_exp |> Encode.optional input____.position ), ( "structure", encodeStructure_bool_exp |> Encode.optional input____.structure ), ( "structureId", encodeUuid_comparison_exp |> Encode.optional input____.structureId ), ( "updatedAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.updatedAt ) ]


buildProfessional_insert_input :
    (Professional_insert_inputOptionalFields -> Professional_insert_inputOptionalFields)
    -> Professional_insert_input
buildProfessional_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { account = Absent, createdAt = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, mobileNumber = Absent, orientationSystems = Absent, position = Absent, structure = Absent, structureId = Absent, updatedAt = Absent }
    in
    Professional_insert_input { account = optionals____.account, createdAt = optionals____.createdAt, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, mobileNumber = optionals____.mobileNumber, orientationSystems = optionals____.orientationSystems, position = optionals____.position, structure = optionals____.structure, structureId = optionals____.structureId, updatedAt = optionals____.updatedAt }


type alias Professional_insert_inputOptionalFields =
    { account : OptionalArgument Account_obj_rel_insert_input
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastname : OptionalArgument String
    , mobileNumber : OptionalArgument String
    , orientationSystems : OptionalArgument Professional_orientation_system_arr_rel_insert_input
    , position : OptionalArgument String
    , structure : OptionalArgument Structure_obj_rel_insert_input
    , structureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type alias for the `Professional_insert_input` attributes. Note that this type
needs to use the `Professional_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Professional_insert_inputRaw =
    { account : OptionalArgument Account_obj_rel_insert_input
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastname : OptionalArgument String
    , mobileNumber : OptionalArgument String
    , orientationSystems : OptionalArgument Professional_orientation_system_arr_rel_insert_input
    , position : OptionalArgument String
    , structure : OptionalArgument Structure_obj_rel_insert_input
    , structureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Professional\_insert\_input input object.
-}
type Professional_insert_input
    = Professional_insert_input Professional_insert_inputRaw


{-| Encode a Professional\_insert\_input into a value that can be used as an argument.
-}
encodeProfessional_insert_input : Professional_insert_input -> Value
encodeProfessional_insert_input (Professional_insert_input input____) =
    Encode.maybeObject
        [ ( "account", encodeAccount_obj_rel_insert_input |> Encode.optional input____.account ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "email", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.email ), ( "firstname", Encode.string |> Encode.optional input____.firstname ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "lastname", Encode.string |> Encode.optional input____.lastname ), ( "mobileNumber", Encode.string |> Encode.optional input____.mobileNumber ), ( "orientationSystems", encodeProfessional_orientation_system_arr_rel_insert_input |> Encode.optional input____.orientationSystems ), ( "position", Encode.string |> Encode.optional input____.position ), ( "structure", encodeStructure_obj_rel_insert_input |> Encode.optional input____.structure ), ( "structureId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.structureId ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildProfessional_max_order_by :
    (Professional_max_order_byOptionalFields -> Professional_max_order_byOptionalFields)
    -> Professional_max_order_by
buildProfessional_max_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, mobileNumber = Absent, position = Absent, structureId = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, mobileNumber = optionals____.mobileNumber, position = optionals____.position, structureId = optionals____.structureId, updatedAt = optionals____.updatedAt }


type alias Professional_max_order_byOptionalFields =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobileNumber : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , position : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , structureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Professional\_max\_order\_by input object.
-}
type alias Professional_max_order_by =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobileNumber : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , position : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , structureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Professional\_max\_order\_by into a value that can be used as an argument.
-}
encodeProfessional_max_order_by : Professional_max_order_by -> Value
encodeProfessional_max_order_by input____ =
    Encode.maybeObject
        [ ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "email", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.email ), ( "firstname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.firstname ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "lastname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.lastname ), ( "mobileNumber", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.mobileNumber ), ( "position", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.position ), ( "structureId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.structureId ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildProfessional_min_order_by :
    (Professional_min_order_byOptionalFields -> Professional_min_order_byOptionalFields)
    -> Professional_min_order_by
buildProfessional_min_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, mobileNumber = Absent, position = Absent, structureId = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, mobileNumber = optionals____.mobileNumber, position = optionals____.position, structureId = optionals____.structureId, updatedAt = optionals____.updatedAt }


type alias Professional_min_order_byOptionalFields =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobileNumber : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , position : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , structureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Professional\_min\_order\_by input object.
-}
type alias Professional_min_order_by =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobileNumber : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , position : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , structureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Professional\_min\_order\_by into a value that can be used as an argument.
-}
encodeProfessional_min_order_by : Professional_min_order_by -> Value
encodeProfessional_min_order_by input____ =
    Encode.maybeObject
        [ ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "email", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.email ), ( "firstname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.firstname ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "lastname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.lastname ), ( "mobileNumber", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.mobileNumber ), ( "position", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.position ), ( "structureId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.structureId ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildProfessional_obj_rel_insert_input :
    Professional_obj_rel_insert_inputRequiredFields
    -> (Professional_obj_rel_insert_inputOptionalFields -> Professional_obj_rel_insert_inputOptionalFields)
    -> Professional_obj_rel_insert_input
buildProfessional_obj_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Professional_obj_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Professional_obj_rel_insert_inputRequiredFields =
    { data : Professional_insert_input }


type alias Professional_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Professional_on_conflict }


{-| Type alias for the `Professional_obj_rel_insert_input` attributes. Note that this type
needs to use the `Professional_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Professional_obj_rel_insert_inputRaw =
    { data : Professional_insert_input
    , on_conflict : OptionalArgument Professional_on_conflict
    }


{-| Type for the Professional\_obj\_rel\_insert\_input input object.
-}
type Professional_obj_rel_insert_input
    = Professional_obj_rel_insert_input Professional_obj_rel_insert_inputRaw


{-| Encode a Professional\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeProfessional_obj_rel_insert_input : Professional_obj_rel_insert_input -> Value
encodeProfessional_obj_rel_insert_input (Professional_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeProfessional_insert_input input____.data |> Just ), ( "on_conflict", encodeProfessional_on_conflict |> Encode.optional input____.on_conflict ) ]


buildProfessional_on_conflict :
    Professional_on_conflictRequiredFields
    -> (Professional_on_conflictOptionalFields -> Professional_on_conflictOptionalFields)
    -> Professional_on_conflict
buildProfessional_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Professional_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Professional_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Professional_constraint.Professional_constraint
    , update_columns : List CdbGQL.Enum.Professional_update_column.Professional_update_column
    }


type alias Professional_on_conflictOptionalFields =
    { where_ : OptionalArgument Professional_bool_exp }


{-| Type alias for the `Professional_on_conflict` attributes. Note that this type
needs to use the `Professional_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Professional_on_conflictRaw =
    { constraint : CdbGQL.Enum.Professional_constraint.Professional_constraint
    , update_columns : List CdbGQL.Enum.Professional_update_column.Professional_update_column
    , where_ : OptionalArgument Professional_bool_exp
    }


{-| Type for the Professional\_on\_conflict input object.
-}
type Professional_on_conflict
    = Professional_on_conflict Professional_on_conflictRaw


{-| Encode a Professional\_on\_conflict into a value that can be used as an argument.
-}
encodeProfessional_on_conflict : Professional_on_conflict -> Value
encodeProfessional_on_conflict (Professional_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Professional_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Professional_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeProfessional_bool_exp |> Encode.optional input____.where_ ) ]


buildProfessional_order_by :
    (Professional_order_byOptionalFields -> Professional_order_byOptionalFields)
    -> Professional_order_by
buildProfessional_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { account = Absent, createdAt = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, mobileNumber = Absent, orientationSystems_aggregate = Absent, position = Absent, structure = Absent, structureId = Absent, updatedAt = Absent }
    in
    Professional_order_by { account = optionals____.account, createdAt = optionals____.createdAt, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, mobileNumber = optionals____.mobileNumber, orientationSystems_aggregate = optionals____.orientationSystems_aggregate, position = optionals____.position, structure = optionals____.structure, structureId = optionals____.structureId, updatedAt = optionals____.updatedAt }


type alias Professional_order_byOptionalFields =
    { account : OptionalArgument Account_order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobileNumber : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationSystems_aggregate : OptionalArgument Professional_orientation_system_aggregate_order_by
    , position : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , structure : OptionalArgument Structure_order_by
    , structureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type alias for the `Professional_order_by` attributes. Note that this type
needs to use the `Professional_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Professional_order_byRaw =
    { account : OptionalArgument Account_order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , firstname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , lastname : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobileNumber : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationSystems_aggregate : OptionalArgument Professional_orientation_system_aggregate_order_by
    , position : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , structure : OptionalArgument Structure_order_by
    , structureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Professional\_order\_by input object.
-}
type Professional_order_by
    = Professional_order_by Professional_order_byRaw


{-| Encode a Professional\_order\_by into a value that can be used as an argument.
-}
encodeProfessional_order_by : Professional_order_by -> Value
encodeProfessional_order_by (Professional_order_by input____) =
    Encode.maybeObject
        [ ( "account", encodeAccount_order_by |> Encode.optional input____.account ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "email", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.email ), ( "firstname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.firstname ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "lastname", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.lastname ), ( "mobileNumber", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.mobileNumber ), ( "orientationSystems_aggregate", encodeProfessional_orientation_system_aggregate_order_by |> Encode.optional input____.orientationSystems_aggregate ), ( "position", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.position ), ( "structure", encodeStructure_order_by |> Encode.optional input____.structure ), ( "structureId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.structureId ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ) ]


buildProfessional_orientation_system_aggregate_bool_exp :
    (Professional_orientation_system_aggregate_bool_expOptionalFields -> Professional_orientation_system_aggregate_bool_expOptionalFields)
    -> Professional_orientation_system_aggregate_bool_exp
buildProfessional_orientation_system_aggregate_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent }
    in
    Professional_orientation_system_aggregate_bool_exp { count = optionals____.count }


type alias Professional_orientation_system_aggregate_bool_expOptionalFields =
    { count : OptionalArgument Professional_orientation_system_aggregate_bool_exp_count }


{-| Type alias for the `Professional_orientation_system_aggregate_bool_exp` attributes. Note that this type
needs to use the `Professional_orientation_system_aggregate_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Professional_orientation_system_aggregate_bool_expRaw =
    { count : OptionalArgument Professional_orientation_system_aggregate_bool_exp_count }


{-| Type for the Professional\_orientation\_system\_aggregate\_bool\_exp input object.
-}
type Professional_orientation_system_aggregate_bool_exp
    = Professional_orientation_system_aggregate_bool_exp Professional_orientation_system_aggregate_bool_expRaw


{-| Encode a Professional\_orientation\_system\_aggregate\_bool\_exp into a value that can be used as an argument.
-}
encodeProfessional_orientation_system_aggregate_bool_exp : Professional_orientation_system_aggregate_bool_exp -> Value
encodeProfessional_orientation_system_aggregate_bool_exp (Professional_orientation_system_aggregate_bool_exp input____) =
    Encode.maybeObject
        [ ( "count", encodeProfessional_orientation_system_aggregate_bool_exp_count |> Encode.optional input____.count ) ]


buildProfessional_orientation_system_aggregate_bool_exp_count :
    Professional_orientation_system_aggregate_bool_exp_countRequiredFields
    -> (Professional_orientation_system_aggregate_bool_exp_countOptionalFields -> Professional_orientation_system_aggregate_bool_exp_countOptionalFields)
    -> Professional_orientation_system_aggregate_bool_exp_count
buildProfessional_orientation_system_aggregate_bool_exp_count required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { arguments = Absent, distinct = Absent, filter = Absent }
    in
    Professional_orientation_system_aggregate_bool_exp_count { arguments = optionals____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Professional_orientation_system_aggregate_bool_exp_countRequiredFields =
    { predicate : Int_comparison_exp }


type alias Professional_orientation_system_aggregate_bool_exp_countOptionalFields =
    { arguments : OptionalArgument (List CdbGQL.Enum.Professional_orientation_system_select_column.Professional_orientation_system_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Professional_orientation_system_bool_exp
    }


{-| Type alias for the `Professional_orientation_system_aggregate_bool_exp_count` attributes. Note that this type
needs to use the `Professional_orientation_system_aggregate_bool_exp_count` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Professional_orientation_system_aggregate_bool_exp_countRaw =
    { arguments : OptionalArgument (List CdbGQL.Enum.Professional_orientation_system_select_column.Professional_orientation_system_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Professional_orientation_system_bool_exp
    , predicate : Int_comparison_exp
    }


{-| Type for the Professional\_orientation\_system\_aggregate\_bool\_exp\_count input object.
-}
type Professional_orientation_system_aggregate_bool_exp_count
    = Professional_orientation_system_aggregate_bool_exp_count Professional_orientation_system_aggregate_bool_exp_countRaw


{-| Encode a Professional\_orientation\_system\_aggregate\_bool\_exp\_count into a value that can be used as an argument.
-}
encodeProfessional_orientation_system_aggregate_bool_exp_count : Professional_orientation_system_aggregate_bool_exp_count -> Value
encodeProfessional_orientation_system_aggregate_bool_exp_count (Professional_orientation_system_aggregate_bool_exp_count input____) =
    Encode.maybeObject
        [ ( "arguments", (Encode.enum CdbGQL.Enum.Professional_orientation_system_select_column.toString |> Encode.list) |> Encode.optional input____.arguments ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeProfessional_orientation_system_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeInt_comparison_exp input____.predicate |> Just ) ]


buildProfessional_orientation_system_aggregate_order_by :
    (Professional_orientation_system_aggregate_order_byOptionalFields -> Professional_orientation_system_aggregate_order_byOptionalFields)
    -> Professional_orientation_system_aggregate_order_by
buildProfessional_orientation_system_aggregate_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals____.count, max = optionals____.max, min = optionals____.min }


type alias Professional_orientation_system_aggregate_order_byOptionalFields =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Professional_orientation_system_max_order_by
    , min : OptionalArgument Professional_orientation_system_min_order_by
    }


{-| Type for the Professional\_orientation\_system\_aggregate\_order\_by input object.
-}
type alias Professional_orientation_system_aggregate_order_by =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Professional_orientation_system_max_order_by
    , min : OptionalArgument Professional_orientation_system_min_order_by
    }


{-| Encode a Professional\_orientation\_system\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeProfessional_orientation_system_aggregate_order_by : Professional_orientation_system_aggregate_order_by -> Value
encodeProfessional_orientation_system_aggregate_order_by input____ =
    Encode.maybeObject
        [ ( "count", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.count ), ( "max", encodeProfessional_orientation_system_max_order_by |> Encode.optional input____.max ), ( "min", encodeProfessional_orientation_system_min_order_by |> Encode.optional input____.min ) ]


buildProfessional_orientation_system_arr_rel_insert_input :
    Professional_orientation_system_arr_rel_insert_inputRequiredFields
    -> (Professional_orientation_system_arr_rel_insert_inputOptionalFields -> Professional_orientation_system_arr_rel_insert_inputOptionalFields)
    -> Professional_orientation_system_arr_rel_insert_input
buildProfessional_orientation_system_arr_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Professional_orientation_system_arr_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Professional_orientation_system_arr_rel_insert_inputRequiredFields =
    { data : List Professional_orientation_system_insert_input }


type alias Professional_orientation_system_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Professional_orientation_system_on_conflict }


{-| Type alias for the `Professional_orientation_system_arr_rel_insert_input` attributes. Note that this type
needs to use the `Professional_orientation_system_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Professional_orientation_system_arr_rel_insert_inputRaw =
    { data : List Professional_orientation_system_insert_input
    , on_conflict : OptionalArgument Professional_orientation_system_on_conflict
    }


{-| Type for the Professional\_orientation\_system\_arr\_rel\_insert\_input input object.
-}
type Professional_orientation_system_arr_rel_insert_input
    = Professional_orientation_system_arr_rel_insert_input Professional_orientation_system_arr_rel_insert_inputRaw


{-| Encode a Professional\_orientation\_system\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeProfessional_orientation_system_arr_rel_insert_input : Professional_orientation_system_arr_rel_insert_input -> Value
encodeProfessional_orientation_system_arr_rel_insert_input (Professional_orientation_system_arr_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", (encodeProfessional_orientation_system_insert_input |> Encode.list) input____.data |> Just ), ( "on_conflict", encodeProfessional_orientation_system_on_conflict |> Encode.optional input____.on_conflict ) ]


buildProfessional_orientation_system_bool_exp :
    (Professional_orientation_system_bool_expOptionalFields -> Professional_orientation_system_bool_expOptionalFields)
    -> Professional_orientation_system_bool_exp
buildProfessional_orientation_system_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, createdAt = Absent, id = Absent, orientationSystem = Absent, orientationSystemId = Absent, professional = Absent, professionalId = Absent }
    in
    Professional_orientation_system_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, createdAt = optionals____.createdAt, id = optionals____.id, orientationSystem = optionals____.orientationSystem, orientationSystemId = optionals____.orientationSystemId, professional = optionals____.professional, professionalId = optionals____.professionalId }


type alias Professional_orientation_system_bool_expOptionalFields =
    { and_ : OptionalArgument (List Professional_orientation_system_bool_exp)
    , not_ : OptionalArgument Professional_orientation_system_bool_exp
    , or_ : OptionalArgument (List Professional_orientation_system_bool_exp)
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , orientationSystem : OptionalArgument Orientation_system_bool_exp
    , orientationSystemId : OptionalArgument Uuid_comparison_exp
    , professional : OptionalArgument Professional_bool_exp
    , professionalId : OptionalArgument Uuid_comparison_exp
    }


{-| Type alias for the `Professional_orientation_system_bool_exp` attributes. Note that this type
needs to use the `Professional_orientation_system_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Professional_orientation_system_bool_expRaw =
    { and_ : OptionalArgument (List Professional_orientation_system_bool_exp)
    , not_ : OptionalArgument Professional_orientation_system_bool_exp
    , or_ : OptionalArgument (List Professional_orientation_system_bool_exp)
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , orientationSystem : OptionalArgument Orientation_system_bool_exp
    , orientationSystemId : OptionalArgument Uuid_comparison_exp
    , professional : OptionalArgument Professional_bool_exp
    , professionalId : OptionalArgument Uuid_comparison_exp
    }


{-| Type for the Professional\_orientation\_system\_bool\_exp input object.
-}
type Professional_orientation_system_bool_exp
    = Professional_orientation_system_bool_exp Professional_orientation_system_bool_expRaw


{-| Encode a Professional\_orientation\_system\_bool\_exp into a value that can be used as an argument.
-}
encodeProfessional_orientation_system_bool_exp : Professional_orientation_system_bool_exp -> Value
encodeProfessional_orientation_system_bool_exp (Professional_orientation_system_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeProfessional_orientation_system_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeProfessional_orientation_system_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeProfessional_orientation_system_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "createdAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.createdAt ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "orientationSystem", encodeOrientation_system_bool_exp |> Encode.optional input____.orientationSystem ), ( "orientationSystemId", encodeUuid_comparison_exp |> Encode.optional input____.orientationSystemId ), ( "professional", encodeProfessional_bool_exp |> Encode.optional input____.professional ), ( "professionalId", encodeUuid_comparison_exp |> Encode.optional input____.professionalId ) ]


buildProfessional_orientation_system_insert_input :
    (Professional_orientation_system_insert_inputOptionalFields -> Professional_orientation_system_insert_inputOptionalFields)
    -> Professional_orientation_system_insert_input
buildProfessional_orientation_system_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, id = Absent, orientationSystem = Absent, orientationSystemId = Absent, professional = Absent, professionalId = Absent }
    in
    Professional_orientation_system_insert_input { createdAt = optionals____.createdAt, id = optionals____.id, orientationSystem = optionals____.orientationSystem, orientationSystemId = optionals____.orientationSystemId, professional = optionals____.professional, professionalId = optionals____.professionalId }


type alias Professional_orientation_system_insert_inputOptionalFields =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , orientationSystem : OptionalArgument Orientation_system_obj_rel_insert_input
    , orientationSystemId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , professional : OptionalArgument Professional_obj_rel_insert_input
    , professionalId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Type alias for the `Professional_orientation_system_insert_input` attributes. Note that this type
needs to use the `Professional_orientation_system_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Professional_orientation_system_insert_inputRaw =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , orientationSystem : OptionalArgument Orientation_system_obj_rel_insert_input
    , orientationSystemId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , professional : OptionalArgument Professional_obj_rel_insert_input
    , professionalId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Type for the Professional\_orientation\_system\_insert\_input input object.
-}
type Professional_orientation_system_insert_input
    = Professional_orientation_system_insert_input Professional_orientation_system_insert_inputRaw


{-| Encode a Professional\_orientation\_system\_insert\_input into a value that can be used as an argument.
-}
encodeProfessional_orientation_system_insert_input : Professional_orientation_system_insert_input -> Value
encodeProfessional_orientation_system_insert_input (Professional_orientation_system_insert_input input____) =
    Encode.maybeObject
        [ ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "orientationSystem", encodeOrientation_system_obj_rel_insert_input |> Encode.optional input____.orientationSystem ), ( "orientationSystemId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.orientationSystemId ), ( "professional", encodeProfessional_obj_rel_insert_input |> Encode.optional input____.professional ), ( "professionalId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.professionalId ) ]


buildProfessional_orientation_system_max_order_by :
    (Professional_orientation_system_max_order_byOptionalFields -> Professional_orientation_system_max_order_byOptionalFields)
    -> Professional_orientation_system_max_order_by
buildProfessional_orientation_system_max_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, id = Absent, orientationSystemId = Absent, professionalId = Absent }
    in
    { createdAt = optionals____.createdAt, id = optionals____.id, orientationSystemId = optionals____.orientationSystemId, professionalId = optionals____.professionalId }


type alias Professional_orientation_system_max_order_byOptionalFields =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationSystemId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , professionalId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Professional\_orientation\_system\_max\_order\_by input object.
-}
type alias Professional_orientation_system_max_order_by =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationSystemId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , professionalId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Professional\_orientation\_system\_max\_order\_by into a value that can be used as an argument.
-}
encodeProfessional_orientation_system_max_order_by : Professional_orientation_system_max_order_by -> Value
encodeProfessional_orientation_system_max_order_by input____ =
    Encode.maybeObject
        [ ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "orientationSystemId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.orientationSystemId ), ( "professionalId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.professionalId ) ]


buildProfessional_orientation_system_min_order_by :
    (Professional_orientation_system_min_order_byOptionalFields -> Professional_orientation_system_min_order_byOptionalFields)
    -> Professional_orientation_system_min_order_by
buildProfessional_orientation_system_min_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, id = Absent, orientationSystemId = Absent, professionalId = Absent }
    in
    { createdAt = optionals____.createdAt, id = optionals____.id, orientationSystemId = optionals____.orientationSystemId, professionalId = optionals____.professionalId }


type alias Professional_orientation_system_min_order_byOptionalFields =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationSystemId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , professionalId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Professional\_orientation\_system\_min\_order\_by input object.
-}
type alias Professional_orientation_system_min_order_by =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationSystemId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , professionalId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Professional\_orientation\_system\_min\_order\_by into a value that can be used as an argument.
-}
encodeProfessional_orientation_system_min_order_by : Professional_orientation_system_min_order_by -> Value
encodeProfessional_orientation_system_min_order_by input____ =
    Encode.maybeObject
        [ ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "orientationSystemId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.orientationSystemId ), ( "professionalId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.professionalId ) ]


buildProfessional_orientation_system_on_conflict :
    Professional_orientation_system_on_conflictRequiredFields
    -> (Professional_orientation_system_on_conflictOptionalFields -> Professional_orientation_system_on_conflictOptionalFields)
    -> Professional_orientation_system_on_conflict
buildProfessional_orientation_system_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Professional_orientation_system_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Professional_orientation_system_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Professional_orientation_system_constraint.Professional_orientation_system_constraint
    , update_columns : List CdbGQL.Enum.Professional_orientation_system_update_column.Professional_orientation_system_update_column
    }


type alias Professional_orientation_system_on_conflictOptionalFields =
    { where_ : OptionalArgument Professional_orientation_system_bool_exp }


{-| Type alias for the `Professional_orientation_system_on_conflict` attributes. Note that this type
needs to use the `Professional_orientation_system_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Professional_orientation_system_on_conflictRaw =
    { constraint : CdbGQL.Enum.Professional_orientation_system_constraint.Professional_orientation_system_constraint
    , update_columns : List CdbGQL.Enum.Professional_orientation_system_update_column.Professional_orientation_system_update_column
    , where_ : OptionalArgument Professional_orientation_system_bool_exp
    }


{-| Type for the Professional\_orientation\_system\_on\_conflict input object.
-}
type Professional_orientation_system_on_conflict
    = Professional_orientation_system_on_conflict Professional_orientation_system_on_conflictRaw


{-| Encode a Professional\_orientation\_system\_on\_conflict into a value that can be used as an argument.
-}
encodeProfessional_orientation_system_on_conflict : Professional_orientation_system_on_conflict -> Value
encodeProfessional_orientation_system_on_conflict (Professional_orientation_system_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Professional_orientation_system_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Professional_orientation_system_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeProfessional_orientation_system_bool_exp |> Encode.optional input____.where_ ) ]


buildProfessional_orientation_system_order_by :
    (Professional_orientation_system_order_byOptionalFields -> Professional_orientation_system_order_byOptionalFields)
    -> Professional_orientation_system_order_by
buildProfessional_orientation_system_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, id = Absent, orientationSystem = Absent, orientationSystemId = Absent, professional = Absent, professionalId = Absent }
    in
    Professional_orientation_system_order_by { createdAt = optionals____.createdAt, id = optionals____.id, orientationSystem = optionals____.orientationSystem, orientationSystemId = optionals____.orientationSystemId, professional = optionals____.professional, professionalId = optionals____.professionalId }


type alias Professional_orientation_system_order_byOptionalFields =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationSystem : OptionalArgument Orientation_system_order_by
    , orientationSystemId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , professional : OptionalArgument Professional_order_by
    , professionalId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type alias for the `Professional_orientation_system_order_by` attributes. Note that this type
needs to use the `Professional_orientation_system_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Professional_orientation_system_order_byRaw =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationSystem : OptionalArgument Orientation_system_order_by
    , orientationSystemId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , professional : OptionalArgument Professional_order_by
    , professionalId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Professional\_orientation\_system\_order\_by input object.
-}
type Professional_orientation_system_order_by
    = Professional_orientation_system_order_by Professional_orientation_system_order_byRaw


{-| Encode a Professional\_orientation\_system\_order\_by into a value that can be used as an argument.
-}
encodeProfessional_orientation_system_order_by : Professional_orientation_system_order_by -> Value
encodeProfessional_orientation_system_order_by (Professional_orientation_system_order_by input____) =
    Encode.maybeObject
        [ ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "orientationSystem", encodeOrientation_system_order_by |> Encode.optional input____.orientationSystem ), ( "orientationSystemId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.orientationSystemId ), ( "professional", encodeProfessional_order_by |> Encode.optional input____.professional ), ( "professionalId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.professionalId ) ]


buildProfessional_orientation_system_pk_columns_input :
    Professional_orientation_system_pk_columns_inputRequiredFields
    -> Professional_orientation_system_pk_columns_input
buildProfessional_orientation_system_pk_columns_input required____ =
    { id = required____.id }


type alias Professional_orientation_system_pk_columns_inputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the Professional\_orientation\_system\_pk\_columns\_input input object.
-}
type alias Professional_orientation_system_pk_columns_input =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a Professional\_orientation\_system\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeProfessional_orientation_system_pk_columns_input : Professional_orientation_system_pk_columns_input -> Value
encodeProfessional_orientation_system_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildProfessional_orientation_system_set_input :
    (Professional_orientation_system_set_inputOptionalFields -> Professional_orientation_system_set_inputOptionalFields)
    -> Professional_orientation_system_set_input
buildProfessional_orientation_system_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, id = Absent, orientationSystemId = Absent, professionalId = Absent }
    in
    { createdAt = optionals____.createdAt, id = optionals____.id, orientationSystemId = optionals____.orientationSystemId, professionalId = optionals____.professionalId }


type alias Professional_orientation_system_set_inputOptionalFields =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , orientationSystemId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , professionalId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Type for the Professional\_orientation\_system\_set\_input input object.
-}
type alias Professional_orientation_system_set_input =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , orientationSystemId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , professionalId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Encode a Professional\_orientation\_system\_set\_input into a value that can be used as an argument.
-}
encodeProfessional_orientation_system_set_input : Professional_orientation_system_set_input -> Value
encodeProfessional_orientation_system_set_input input____ =
    Encode.maybeObject
        [ ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "orientationSystemId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.orientationSystemId ), ( "professionalId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.professionalId ) ]


buildProfessional_orientation_system_stream_cursor_input :
    Professional_orientation_system_stream_cursor_inputRequiredFields
    -> (Professional_orientation_system_stream_cursor_inputOptionalFields -> Professional_orientation_system_stream_cursor_inputOptionalFields)
    -> Professional_orientation_system_stream_cursor_input
buildProfessional_orientation_system_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Professional_orientation_system_stream_cursor_inputRequiredFields =
    { initial_value : Professional_orientation_system_stream_cursor_value_input }


type alias Professional_orientation_system_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Professional\_orientation\_system\_stream\_cursor\_input input object.
-}
type alias Professional_orientation_system_stream_cursor_input =
    { initial_value : Professional_orientation_system_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Professional\_orientation\_system\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeProfessional_orientation_system_stream_cursor_input : Professional_orientation_system_stream_cursor_input -> Value
encodeProfessional_orientation_system_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeProfessional_orientation_system_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildProfessional_orientation_system_stream_cursor_value_input :
    (Professional_orientation_system_stream_cursor_value_inputOptionalFields -> Professional_orientation_system_stream_cursor_value_inputOptionalFields)
    -> Professional_orientation_system_stream_cursor_value_input
buildProfessional_orientation_system_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, id = Absent, orientationSystemId = Absent, professionalId = Absent }
    in
    { createdAt = optionals____.createdAt, id = optionals____.id, orientationSystemId = optionals____.orientationSystemId, professionalId = optionals____.professionalId }


type alias Professional_orientation_system_stream_cursor_value_inputOptionalFields =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , orientationSystemId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , professionalId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Type for the Professional\_orientation\_system\_stream\_cursor\_value\_input input object.
-}
type alias Professional_orientation_system_stream_cursor_value_input =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , orientationSystemId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , professionalId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Encode a Professional\_orientation\_system\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeProfessional_orientation_system_stream_cursor_value_input : Professional_orientation_system_stream_cursor_value_input -> Value
encodeProfessional_orientation_system_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "orientationSystemId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.orientationSystemId ), ( "professionalId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.professionalId ) ]


buildProfessional_orientation_system_updates :
    Professional_orientation_system_updatesRequiredFields
    -> (Professional_orientation_system_updatesOptionalFields -> Professional_orientation_system_updatesOptionalFields)
    -> Professional_orientation_system_updates
buildProfessional_orientation_system_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Professional_orientation_system_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Professional_orientation_system_updatesRequiredFields =
    { where_ : Professional_orientation_system_bool_exp }


type alias Professional_orientation_system_updatesOptionalFields =
    { set_ : OptionalArgument Professional_orientation_system_set_input }


{-| Type alias for the `Professional_orientation_system_updates` attributes. Note that this type
needs to use the `Professional_orientation_system_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Professional_orientation_system_updatesRaw =
    { set_ : OptionalArgument Professional_orientation_system_set_input
    , where_ : Professional_orientation_system_bool_exp
    }


{-| Type for the Professional\_orientation\_system\_updates input object.
-}
type Professional_orientation_system_updates
    = Professional_orientation_system_updates Professional_orientation_system_updatesRaw


{-| Encode a Professional\_orientation\_system\_updates into a value that can be used as an argument.
-}
encodeProfessional_orientation_system_updates : Professional_orientation_system_updates -> Value
encodeProfessional_orientation_system_updates (Professional_orientation_system_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeProfessional_orientation_system_set_input |> Encode.optional input____.set_ ), ( "where", encodeProfessional_orientation_system_bool_exp input____.where_ |> Just ) ]


buildProfessional_pk_columns_input :
    Professional_pk_columns_inputRequiredFields
    -> Professional_pk_columns_input
buildProfessional_pk_columns_input required____ =
    { id = required____.id }


type alias Professional_pk_columns_inputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the Professional\_pk\_columns\_input input object.
-}
type alias Professional_pk_columns_input =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a Professional\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeProfessional_pk_columns_input : Professional_pk_columns_input -> Value
encodeProfessional_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildProfessional_project_aggregate_bool_exp :
    (Professional_project_aggregate_bool_expOptionalFields -> Professional_project_aggregate_bool_expOptionalFields)
    -> Professional_project_aggregate_bool_exp
buildProfessional_project_aggregate_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent }
    in
    Professional_project_aggregate_bool_exp { count = optionals____.count }


type alias Professional_project_aggregate_bool_expOptionalFields =
    { count : OptionalArgument Professional_project_aggregate_bool_exp_count }


{-| Type alias for the `Professional_project_aggregate_bool_exp` attributes. Note that this type
needs to use the `Professional_project_aggregate_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Professional_project_aggregate_bool_expRaw =
    { count : OptionalArgument Professional_project_aggregate_bool_exp_count }


{-| Type for the Professional\_project\_aggregate\_bool\_exp input object.
-}
type Professional_project_aggregate_bool_exp
    = Professional_project_aggregate_bool_exp Professional_project_aggregate_bool_expRaw


{-| Encode a Professional\_project\_aggregate\_bool\_exp into a value that can be used as an argument.
-}
encodeProfessional_project_aggregate_bool_exp : Professional_project_aggregate_bool_exp -> Value
encodeProfessional_project_aggregate_bool_exp (Professional_project_aggregate_bool_exp input____) =
    Encode.maybeObject
        [ ( "count", encodeProfessional_project_aggregate_bool_exp_count |> Encode.optional input____.count ) ]


buildProfessional_project_aggregate_bool_exp_count :
    Professional_project_aggregate_bool_exp_countRequiredFields
    -> (Professional_project_aggregate_bool_exp_countOptionalFields -> Professional_project_aggregate_bool_exp_countOptionalFields)
    -> Professional_project_aggregate_bool_exp_count
buildProfessional_project_aggregate_bool_exp_count required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { arguments = Absent, distinct = Absent, filter = Absent }
    in
    Professional_project_aggregate_bool_exp_count { arguments = optionals____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Professional_project_aggregate_bool_exp_countRequiredFields =
    { predicate : Int_comparison_exp }


type alias Professional_project_aggregate_bool_exp_countOptionalFields =
    { arguments : OptionalArgument (List CdbGQL.Enum.Professional_project_select_column.Professional_project_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Professional_project_bool_exp
    }


{-| Type alias for the `Professional_project_aggregate_bool_exp_count` attributes. Note that this type
needs to use the `Professional_project_aggregate_bool_exp_count` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Professional_project_aggregate_bool_exp_countRaw =
    { arguments : OptionalArgument (List CdbGQL.Enum.Professional_project_select_column.Professional_project_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Professional_project_bool_exp
    , predicate : Int_comparison_exp
    }


{-| Type for the Professional\_project\_aggregate\_bool\_exp\_count input object.
-}
type Professional_project_aggregate_bool_exp_count
    = Professional_project_aggregate_bool_exp_count Professional_project_aggregate_bool_exp_countRaw


{-| Encode a Professional\_project\_aggregate\_bool\_exp\_count into a value that can be used as an argument.
-}
encodeProfessional_project_aggregate_bool_exp_count : Professional_project_aggregate_bool_exp_count -> Value
encodeProfessional_project_aggregate_bool_exp_count (Professional_project_aggregate_bool_exp_count input____) =
    Encode.maybeObject
        [ ( "arguments", (Encode.enum CdbGQL.Enum.Professional_project_select_column.toString |> Encode.list) |> Encode.optional input____.arguments ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeProfessional_project_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeInt_comparison_exp input____.predicate |> Just ) ]


buildProfessional_project_aggregate_order_by :
    (Professional_project_aggregate_order_byOptionalFields -> Professional_project_aggregate_order_byOptionalFields)
    -> Professional_project_aggregate_order_by
buildProfessional_project_aggregate_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { avg = Absent, count = Absent, max = Absent, min = Absent, stddev = Absent, stddev_pop = Absent, stddev_samp = Absent, sum = Absent, var_pop = Absent, var_samp = Absent, variance = Absent }
    in
    { avg = optionals____.avg, count = optionals____.count, max = optionals____.max, min = optionals____.min, stddev = optionals____.stddev, stddev_pop = optionals____.stddev_pop, stddev_samp = optionals____.stddev_samp, sum = optionals____.sum, var_pop = optionals____.var_pop, var_samp = optionals____.var_samp, variance = optionals____.variance }


type alias Professional_project_aggregate_order_byOptionalFields =
    { avg : OptionalArgument Professional_project_avg_order_by
    , count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Professional_project_max_order_by
    , min : OptionalArgument Professional_project_min_order_by
    , stddev : OptionalArgument Professional_project_stddev_order_by
    , stddev_pop : OptionalArgument Professional_project_stddev_pop_order_by
    , stddev_samp : OptionalArgument Professional_project_stddev_samp_order_by
    , sum : OptionalArgument Professional_project_sum_order_by
    , var_pop : OptionalArgument Professional_project_var_pop_order_by
    , var_samp : OptionalArgument Professional_project_var_samp_order_by
    , variance : OptionalArgument Professional_project_variance_order_by
    }


{-| Type for the Professional\_project\_aggregate\_order\_by input object.
-}
type alias Professional_project_aggregate_order_by =
    { avg : OptionalArgument Professional_project_avg_order_by
    , count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Professional_project_max_order_by
    , min : OptionalArgument Professional_project_min_order_by
    , stddev : OptionalArgument Professional_project_stddev_order_by
    , stddev_pop : OptionalArgument Professional_project_stddev_pop_order_by
    , stddev_samp : OptionalArgument Professional_project_stddev_samp_order_by
    , sum : OptionalArgument Professional_project_sum_order_by
    , var_pop : OptionalArgument Professional_project_var_pop_order_by
    , var_samp : OptionalArgument Professional_project_var_samp_order_by
    , variance : OptionalArgument Professional_project_variance_order_by
    }


{-| Encode a Professional\_project\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeProfessional_project_aggregate_order_by : Professional_project_aggregate_order_by -> Value
encodeProfessional_project_aggregate_order_by input____ =
    Encode.maybeObject
        [ ( "avg", encodeProfessional_project_avg_order_by |> Encode.optional input____.avg ), ( "count", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.count ), ( "max", encodeProfessional_project_max_order_by |> Encode.optional input____.max ), ( "min", encodeProfessional_project_min_order_by |> Encode.optional input____.min ), ( "stddev", encodeProfessional_project_stddev_order_by |> Encode.optional input____.stddev ), ( "stddev_pop", encodeProfessional_project_stddev_pop_order_by |> Encode.optional input____.stddev_pop ), ( "stddev_samp", encodeProfessional_project_stddev_samp_order_by |> Encode.optional input____.stddev_samp ), ( "sum", encodeProfessional_project_sum_order_by |> Encode.optional input____.sum ), ( "var_pop", encodeProfessional_project_var_pop_order_by |> Encode.optional input____.var_pop ), ( "var_samp", encodeProfessional_project_var_samp_order_by |> Encode.optional input____.var_samp ), ( "variance", encodeProfessional_project_variance_order_by |> Encode.optional input____.variance ) ]


buildProfessional_project_arr_rel_insert_input :
    Professional_project_arr_rel_insert_inputRequiredFields
    -> (Professional_project_arr_rel_insert_inputOptionalFields -> Professional_project_arr_rel_insert_inputOptionalFields)
    -> Professional_project_arr_rel_insert_input
buildProfessional_project_arr_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Professional_project_arr_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Professional_project_arr_rel_insert_inputRequiredFields =
    { data : List Professional_project_insert_input }


type alias Professional_project_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Professional_project_on_conflict }


{-| Type alias for the `Professional_project_arr_rel_insert_input` attributes. Note that this type
needs to use the `Professional_project_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Professional_project_arr_rel_insert_inputRaw =
    { data : List Professional_project_insert_input
    , on_conflict : OptionalArgument Professional_project_on_conflict
    }


{-| Type for the Professional\_project\_arr\_rel\_insert\_input input object.
-}
type Professional_project_arr_rel_insert_input
    = Professional_project_arr_rel_insert_input Professional_project_arr_rel_insert_inputRaw


{-| Encode a Professional\_project\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeProfessional_project_arr_rel_insert_input : Professional_project_arr_rel_insert_input -> Value
encodeProfessional_project_arr_rel_insert_input (Professional_project_arr_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", (encodeProfessional_project_insert_input |> Encode.list) input____.data |> Just ), ( "on_conflict", encodeProfessional_project_on_conflict |> Encode.optional input____.on_conflict ) ]


buildProfessional_project_avg_order_by :
    (Professional_project_avg_order_byOptionalFields -> Professional_project_avg_order_byOptionalFields)
    -> Professional_project_avg_order_by
buildProfessional_project_avg_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { hourlyRate = Absent, mobilityRadius = Absent }
    in
    { hourlyRate = optionals____.hourlyRate, mobilityRadius = optionals____.mobilityRadius }


type alias Professional_project_avg_order_byOptionalFields =
    { hourlyRate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobilityRadius : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Professional\_project\_avg\_order\_by input object.
-}
type alias Professional_project_avg_order_by =
    { hourlyRate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobilityRadius : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Professional\_project\_avg\_order\_by into a value that can be used as an argument.
-}
encodeProfessional_project_avg_order_by : Professional_project_avg_order_by -> Value
encodeProfessional_project_avg_order_by input____ =
    Encode.maybeObject
        [ ( "hourlyRate", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.hourlyRate ), ( "mobilityRadius", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.mobilityRadius ) ]


buildProfessional_project_bool_exp :
    (Professional_project_bool_expOptionalFields -> Professional_project_bool_expOptionalFields)
    -> Professional_project_bool_exp
buildProfessional_project_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, contractTypeId = Absent, contract_type = Absent, createdAt = Absent, employmentTypeId = Absent, employment_type = Absent, hourlyRate = Absent, id = Absent, mobilityRadius = Absent, notebook = Absent, notebookId = Absent, romeCodeId = Absent, rome_code = Absent, updatedAt = Absent, updatedBy = Absent, updater = Absent }
    in
    Professional_project_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, contractTypeId = optionals____.contractTypeId, contract_type = optionals____.contract_type, createdAt = optionals____.createdAt, employmentTypeId = optionals____.employmentTypeId, employment_type = optionals____.employment_type, hourlyRate = optionals____.hourlyRate, id = optionals____.id, mobilityRadius = optionals____.mobilityRadius, notebook = optionals____.notebook, notebookId = optionals____.notebookId, romeCodeId = optionals____.romeCodeId, rome_code = optionals____.rome_code, updatedAt = optionals____.updatedAt, updatedBy = optionals____.updatedBy, updater = optionals____.updater }


type alias Professional_project_bool_expOptionalFields =
    { and_ : OptionalArgument (List Professional_project_bool_exp)
    , not_ : OptionalArgument Professional_project_bool_exp
    , or_ : OptionalArgument (List Professional_project_bool_exp)
    , contractTypeId : OptionalArgument Contract_type_enum_comparison_exp
    , contract_type : OptionalArgument Contract_type_bool_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , employmentTypeId : OptionalArgument Employment_type_enum_comparison_exp
    , employment_type : OptionalArgument Employment_type_bool_exp
    , hourlyRate : OptionalArgument Int_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , mobilityRadius : OptionalArgument Int_comparison_exp
    , notebook : OptionalArgument Notebook_bool_exp
    , notebookId : OptionalArgument Uuid_comparison_exp
    , romeCodeId : OptionalArgument Uuid_comparison_exp
    , rome_code : OptionalArgument Rome_code_bool_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    , updatedBy : OptionalArgument Uuid_comparison_exp
    , updater : OptionalArgument Account_bool_exp
    }


{-| Type alias for the `Professional_project_bool_exp` attributes. Note that this type
needs to use the `Professional_project_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Professional_project_bool_expRaw =
    { and_ : OptionalArgument (List Professional_project_bool_exp)
    , not_ : OptionalArgument Professional_project_bool_exp
    , or_ : OptionalArgument (List Professional_project_bool_exp)
    , contractTypeId : OptionalArgument Contract_type_enum_comparison_exp
    , contract_type : OptionalArgument Contract_type_bool_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , employmentTypeId : OptionalArgument Employment_type_enum_comparison_exp
    , employment_type : OptionalArgument Employment_type_bool_exp
    , hourlyRate : OptionalArgument Int_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , mobilityRadius : OptionalArgument Int_comparison_exp
    , notebook : OptionalArgument Notebook_bool_exp
    , notebookId : OptionalArgument Uuid_comparison_exp
    , romeCodeId : OptionalArgument Uuid_comparison_exp
    , rome_code : OptionalArgument Rome_code_bool_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    , updatedBy : OptionalArgument Uuid_comparison_exp
    , updater : OptionalArgument Account_bool_exp
    }


{-| Type for the Professional\_project\_bool\_exp input object.
-}
type Professional_project_bool_exp
    = Professional_project_bool_exp Professional_project_bool_expRaw


{-| Encode a Professional\_project\_bool\_exp into a value that can be used as an argument.
-}
encodeProfessional_project_bool_exp : Professional_project_bool_exp -> Value
encodeProfessional_project_bool_exp (Professional_project_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeProfessional_project_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeProfessional_project_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeProfessional_project_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "contractTypeId", encodeContract_type_enum_comparison_exp |> Encode.optional input____.contractTypeId ), ( "contract_type", encodeContract_type_bool_exp |> Encode.optional input____.contract_type ), ( "createdAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.createdAt ), ( "employmentTypeId", encodeEmployment_type_enum_comparison_exp |> Encode.optional input____.employmentTypeId ), ( "employment_type", encodeEmployment_type_bool_exp |> Encode.optional input____.employment_type ), ( "hourlyRate", encodeInt_comparison_exp |> Encode.optional input____.hourlyRate ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "mobilityRadius", encodeInt_comparison_exp |> Encode.optional input____.mobilityRadius ), ( "notebook", encodeNotebook_bool_exp |> Encode.optional input____.notebook ), ( "notebookId", encodeUuid_comparison_exp |> Encode.optional input____.notebookId ), ( "romeCodeId", encodeUuid_comparison_exp |> Encode.optional input____.romeCodeId ), ( "rome_code", encodeRome_code_bool_exp |> Encode.optional input____.rome_code ), ( "updatedAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.updatedAt ), ( "updatedBy", encodeUuid_comparison_exp |> Encode.optional input____.updatedBy ), ( "updater", encodeAccount_bool_exp |> Encode.optional input____.updater ) ]


buildProfessional_project_inc_input :
    (Professional_project_inc_inputOptionalFields -> Professional_project_inc_inputOptionalFields)
    -> Professional_project_inc_input
buildProfessional_project_inc_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { hourlyRate = Absent, mobilityRadius = Absent }
    in
    { hourlyRate = optionals____.hourlyRate, mobilityRadius = optionals____.mobilityRadius }


type alias Professional_project_inc_inputOptionalFields =
    { hourlyRate : OptionalArgument Int
    , mobilityRadius : OptionalArgument Int
    }


{-| Type for the Professional\_project\_inc\_input input object.
-}
type alias Professional_project_inc_input =
    { hourlyRate : OptionalArgument Int
    , mobilityRadius : OptionalArgument Int
    }


{-| Encode a Professional\_project\_inc\_input into a value that can be used as an argument.
-}
encodeProfessional_project_inc_input : Professional_project_inc_input -> Value
encodeProfessional_project_inc_input input____ =
    Encode.maybeObject
        [ ( "hourlyRate", Encode.int |> Encode.optional input____.hourlyRate ), ( "mobilityRadius", Encode.int |> Encode.optional input____.mobilityRadius ) ]


buildProfessional_project_insert_input :
    (Professional_project_insert_inputOptionalFields -> Professional_project_insert_inputOptionalFields)
    -> Professional_project_insert_input
buildProfessional_project_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { contractTypeId = Absent, contract_type = Absent, createdAt = Absent, employmentTypeId = Absent, employment_type = Absent, hourlyRate = Absent, id = Absent, mobilityRadius = Absent, notebook = Absent, notebookId = Absent, romeCodeId = Absent, rome_code = Absent, updatedAt = Absent, updatedBy = Absent, updater = Absent }
    in
    Professional_project_insert_input { contractTypeId = optionals____.contractTypeId, contract_type = optionals____.contract_type, createdAt = optionals____.createdAt, employmentTypeId = optionals____.employmentTypeId, employment_type = optionals____.employment_type, hourlyRate = optionals____.hourlyRate, id = optionals____.id, mobilityRadius = optionals____.mobilityRadius, notebook = optionals____.notebook, notebookId = optionals____.notebookId, romeCodeId = optionals____.romeCodeId, rome_code = optionals____.rome_code, updatedAt = optionals____.updatedAt, updatedBy = optionals____.updatedBy, updater = optionals____.updater }


type alias Professional_project_insert_inputOptionalFields =
    { contractTypeId : OptionalArgument CdbGQL.Enum.Contract_type_enum.Contract_type_enum
    , contract_type : OptionalArgument Contract_type_obj_rel_insert_input
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , employmentTypeId : OptionalArgument CdbGQL.Enum.Employment_type_enum.Employment_type_enum
    , employment_type : OptionalArgument Employment_type_obj_rel_insert_input
    , hourlyRate : OptionalArgument Int
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , mobilityRadius : OptionalArgument Int
    , notebook : OptionalArgument Notebook_obj_rel_insert_input
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , romeCodeId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , rome_code : OptionalArgument Rome_code_obj_rel_insert_input
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , updatedBy : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updater : OptionalArgument Account_obj_rel_insert_input
    }


{-| Type alias for the `Professional_project_insert_input` attributes. Note that this type
needs to use the `Professional_project_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Professional_project_insert_inputRaw =
    { contractTypeId : OptionalArgument CdbGQL.Enum.Contract_type_enum.Contract_type_enum
    , contract_type : OptionalArgument Contract_type_obj_rel_insert_input
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , employmentTypeId : OptionalArgument CdbGQL.Enum.Employment_type_enum.Employment_type_enum
    , employment_type : OptionalArgument Employment_type_obj_rel_insert_input
    , hourlyRate : OptionalArgument Int
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , mobilityRadius : OptionalArgument Int
    , notebook : OptionalArgument Notebook_obj_rel_insert_input
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , romeCodeId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , rome_code : OptionalArgument Rome_code_obj_rel_insert_input
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , updatedBy : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updater : OptionalArgument Account_obj_rel_insert_input
    }


{-| Type for the Professional\_project\_insert\_input input object.
-}
type Professional_project_insert_input
    = Professional_project_insert_input Professional_project_insert_inputRaw


{-| Encode a Professional\_project\_insert\_input into a value that can be used as an argument.
-}
encodeProfessional_project_insert_input : Professional_project_insert_input -> Value
encodeProfessional_project_insert_input (Professional_project_insert_input input____) =
    Encode.maybeObject
        [ ( "contractTypeId", Encode.enum CdbGQL.Enum.Contract_type_enum.toString |> Encode.optional input____.contractTypeId ), ( "contract_type", encodeContract_type_obj_rel_insert_input |> Encode.optional input____.contract_type ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "employmentTypeId", Encode.enum CdbGQL.Enum.Employment_type_enum.toString |> Encode.optional input____.employmentTypeId ), ( "employment_type", encodeEmployment_type_obj_rel_insert_input |> Encode.optional input____.employment_type ), ( "hourlyRate", Encode.int |> Encode.optional input____.hourlyRate ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "mobilityRadius", Encode.int |> Encode.optional input____.mobilityRadius ), ( "notebook", encodeNotebook_obj_rel_insert_input |> Encode.optional input____.notebook ), ( "notebookId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.notebookId ), ( "romeCodeId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.romeCodeId ), ( "rome_code", encodeRome_code_obj_rel_insert_input |> Encode.optional input____.rome_code ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ), ( "updatedBy", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.updatedBy ), ( "updater", encodeAccount_obj_rel_insert_input |> Encode.optional input____.updater ) ]


buildProfessional_project_max_order_by :
    (Professional_project_max_order_byOptionalFields -> Professional_project_max_order_byOptionalFields)
    -> Professional_project_max_order_by
buildProfessional_project_max_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, hourlyRate = Absent, id = Absent, mobilityRadius = Absent, notebookId = Absent, romeCodeId = Absent, updatedAt = Absent, updatedBy = Absent }
    in
    { createdAt = optionals____.createdAt, hourlyRate = optionals____.hourlyRate, id = optionals____.id, mobilityRadius = optionals____.mobilityRadius, notebookId = optionals____.notebookId, romeCodeId = optionals____.romeCodeId, updatedAt = optionals____.updatedAt, updatedBy = optionals____.updatedBy }


type alias Professional_project_max_order_byOptionalFields =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , hourlyRate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobilityRadius : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , romeCodeId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedBy : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Professional\_project\_max\_order\_by input object.
-}
type alias Professional_project_max_order_by =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , hourlyRate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobilityRadius : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , romeCodeId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedBy : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Professional\_project\_max\_order\_by into a value that can be used as an argument.
-}
encodeProfessional_project_max_order_by : Professional_project_max_order_by -> Value
encodeProfessional_project_max_order_by input____ =
    Encode.maybeObject
        [ ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "hourlyRate", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.hourlyRate ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "mobilityRadius", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.mobilityRadius ), ( "notebookId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.notebookId ), ( "romeCodeId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.romeCodeId ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ), ( "updatedBy", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedBy ) ]


buildProfessional_project_min_order_by :
    (Professional_project_min_order_byOptionalFields -> Professional_project_min_order_byOptionalFields)
    -> Professional_project_min_order_by
buildProfessional_project_min_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, hourlyRate = Absent, id = Absent, mobilityRadius = Absent, notebookId = Absent, romeCodeId = Absent, updatedAt = Absent, updatedBy = Absent }
    in
    { createdAt = optionals____.createdAt, hourlyRate = optionals____.hourlyRate, id = optionals____.id, mobilityRadius = optionals____.mobilityRadius, notebookId = optionals____.notebookId, romeCodeId = optionals____.romeCodeId, updatedAt = optionals____.updatedAt, updatedBy = optionals____.updatedBy }


type alias Professional_project_min_order_byOptionalFields =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , hourlyRate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobilityRadius : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , romeCodeId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedBy : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Professional\_project\_min\_order\_by input object.
-}
type alias Professional_project_min_order_by =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , hourlyRate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobilityRadius : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , romeCodeId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedBy : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Professional\_project\_min\_order\_by into a value that can be used as an argument.
-}
encodeProfessional_project_min_order_by : Professional_project_min_order_by -> Value
encodeProfessional_project_min_order_by input____ =
    Encode.maybeObject
        [ ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "hourlyRate", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.hourlyRate ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "mobilityRadius", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.mobilityRadius ), ( "notebookId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.notebookId ), ( "romeCodeId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.romeCodeId ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ), ( "updatedBy", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedBy ) ]


buildProfessional_project_on_conflict :
    Professional_project_on_conflictRequiredFields
    -> (Professional_project_on_conflictOptionalFields -> Professional_project_on_conflictOptionalFields)
    -> Professional_project_on_conflict
buildProfessional_project_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Professional_project_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Professional_project_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Professional_project_constraint.Professional_project_constraint
    , update_columns : List CdbGQL.Enum.Professional_project_update_column.Professional_project_update_column
    }


type alias Professional_project_on_conflictOptionalFields =
    { where_ : OptionalArgument Professional_project_bool_exp }


{-| Type alias for the `Professional_project_on_conflict` attributes. Note that this type
needs to use the `Professional_project_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Professional_project_on_conflictRaw =
    { constraint : CdbGQL.Enum.Professional_project_constraint.Professional_project_constraint
    , update_columns : List CdbGQL.Enum.Professional_project_update_column.Professional_project_update_column
    , where_ : OptionalArgument Professional_project_bool_exp
    }


{-| Type for the Professional\_project\_on\_conflict input object.
-}
type Professional_project_on_conflict
    = Professional_project_on_conflict Professional_project_on_conflictRaw


{-| Encode a Professional\_project\_on\_conflict into a value that can be used as an argument.
-}
encodeProfessional_project_on_conflict : Professional_project_on_conflict -> Value
encodeProfessional_project_on_conflict (Professional_project_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Professional_project_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Professional_project_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeProfessional_project_bool_exp |> Encode.optional input____.where_ ) ]


buildProfessional_project_order_by :
    (Professional_project_order_byOptionalFields -> Professional_project_order_byOptionalFields)
    -> Professional_project_order_by
buildProfessional_project_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { contractTypeId = Absent, contract_type = Absent, createdAt = Absent, employmentTypeId = Absent, employment_type = Absent, hourlyRate = Absent, id = Absent, mobilityRadius = Absent, notebook = Absent, notebookId = Absent, romeCodeId = Absent, rome_code = Absent, updatedAt = Absent, updatedBy = Absent, updater = Absent }
    in
    Professional_project_order_by { contractTypeId = optionals____.contractTypeId, contract_type = optionals____.contract_type, createdAt = optionals____.createdAt, employmentTypeId = optionals____.employmentTypeId, employment_type = optionals____.employment_type, hourlyRate = optionals____.hourlyRate, id = optionals____.id, mobilityRadius = optionals____.mobilityRadius, notebook = optionals____.notebook, notebookId = optionals____.notebookId, romeCodeId = optionals____.romeCodeId, rome_code = optionals____.rome_code, updatedAt = optionals____.updatedAt, updatedBy = optionals____.updatedBy, updater = optionals____.updater }


type alias Professional_project_order_byOptionalFields =
    { contractTypeId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , contract_type : OptionalArgument Contract_type_order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , employmentTypeId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , employment_type : OptionalArgument Employment_type_order_by
    , hourlyRate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobilityRadius : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebook : OptionalArgument Notebook_order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , romeCodeId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , rome_code : OptionalArgument Rome_code_order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedBy : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updater : OptionalArgument Account_order_by
    }


{-| Type alias for the `Professional_project_order_by` attributes. Note that this type
needs to use the `Professional_project_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Professional_project_order_byRaw =
    { contractTypeId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , contract_type : OptionalArgument Contract_type_order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , employmentTypeId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , employment_type : OptionalArgument Employment_type_order_by
    , hourlyRate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobilityRadius : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , notebook : OptionalArgument Notebook_order_by
    , notebookId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , romeCodeId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , rome_code : OptionalArgument Rome_code_order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedBy : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updater : OptionalArgument Account_order_by
    }


{-| Type for the Professional\_project\_order\_by input object.
-}
type Professional_project_order_by
    = Professional_project_order_by Professional_project_order_byRaw


{-| Encode a Professional\_project\_order\_by into a value that can be used as an argument.
-}
encodeProfessional_project_order_by : Professional_project_order_by -> Value
encodeProfessional_project_order_by (Professional_project_order_by input____) =
    Encode.maybeObject
        [ ( "contractTypeId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.contractTypeId ), ( "contract_type", encodeContract_type_order_by |> Encode.optional input____.contract_type ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "employmentTypeId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.employmentTypeId ), ( "employment_type", encodeEmployment_type_order_by |> Encode.optional input____.employment_type ), ( "hourlyRate", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.hourlyRate ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "mobilityRadius", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.mobilityRadius ), ( "notebook", encodeNotebook_order_by |> Encode.optional input____.notebook ), ( "notebookId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.notebookId ), ( "romeCodeId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.romeCodeId ), ( "rome_code", encodeRome_code_order_by |> Encode.optional input____.rome_code ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ), ( "updatedBy", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedBy ), ( "updater", encodeAccount_order_by |> Encode.optional input____.updater ) ]


buildProfessional_project_pk_columns_input :
    Professional_project_pk_columns_inputRequiredFields
    -> Professional_project_pk_columns_input
buildProfessional_project_pk_columns_input required____ =
    { id = required____.id }


type alias Professional_project_pk_columns_inputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the Professional\_project\_pk\_columns\_input input object.
-}
type alias Professional_project_pk_columns_input =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a Professional\_project\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeProfessional_project_pk_columns_input : Professional_project_pk_columns_input -> Value
encodeProfessional_project_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildProfessional_project_set_input :
    (Professional_project_set_inputOptionalFields -> Professional_project_set_inputOptionalFields)
    -> Professional_project_set_input
buildProfessional_project_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { contractTypeId = Absent, createdAt = Absent, employmentTypeId = Absent, hourlyRate = Absent, id = Absent, mobilityRadius = Absent, notebookId = Absent, romeCodeId = Absent, updatedAt = Absent, updatedBy = Absent }
    in
    { contractTypeId = optionals____.contractTypeId, createdAt = optionals____.createdAt, employmentTypeId = optionals____.employmentTypeId, hourlyRate = optionals____.hourlyRate, id = optionals____.id, mobilityRadius = optionals____.mobilityRadius, notebookId = optionals____.notebookId, romeCodeId = optionals____.romeCodeId, updatedAt = optionals____.updatedAt, updatedBy = optionals____.updatedBy }


type alias Professional_project_set_inputOptionalFields =
    { contractTypeId : OptionalArgument CdbGQL.Enum.Contract_type_enum.Contract_type_enum
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , employmentTypeId : OptionalArgument CdbGQL.Enum.Employment_type_enum.Employment_type_enum
    , hourlyRate : OptionalArgument Int
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , mobilityRadius : OptionalArgument Int
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , romeCodeId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , updatedBy : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Type for the Professional\_project\_set\_input input object.
-}
type alias Professional_project_set_input =
    { contractTypeId : OptionalArgument CdbGQL.Enum.Contract_type_enum.Contract_type_enum
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , employmentTypeId : OptionalArgument CdbGQL.Enum.Employment_type_enum.Employment_type_enum
    , hourlyRate : OptionalArgument Int
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , mobilityRadius : OptionalArgument Int
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , romeCodeId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , updatedBy : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Encode a Professional\_project\_set\_input into a value that can be used as an argument.
-}
encodeProfessional_project_set_input : Professional_project_set_input -> Value
encodeProfessional_project_set_input input____ =
    Encode.maybeObject
        [ ( "contractTypeId", Encode.enum CdbGQL.Enum.Contract_type_enum.toString |> Encode.optional input____.contractTypeId ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "employmentTypeId", Encode.enum CdbGQL.Enum.Employment_type_enum.toString |> Encode.optional input____.employmentTypeId ), ( "hourlyRate", Encode.int |> Encode.optional input____.hourlyRate ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "mobilityRadius", Encode.int |> Encode.optional input____.mobilityRadius ), ( "notebookId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.notebookId ), ( "romeCodeId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.romeCodeId ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ), ( "updatedBy", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.updatedBy ) ]


buildProfessional_project_stddev_order_by :
    (Professional_project_stddev_order_byOptionalFields -> Professional_project_stddev_order_byOptionalFields)
    -> Professional_project_stddev_order_by
buildProfessional_project_stddev_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { hourlyRate = Absent, mobilityRadius = Absent }
    in
    { hourlyRate = optionals____.hourlyRate, mobilityRadius = optionals____.mobilityRadius }


type alias Professional_project_stddev_order_byOptionalFields =
    { hourlyRate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobilityRadius : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Professional\_project\_stddev\_order\_by input object.
-}
type alias Professional_project_stddev_order_by =
    { hourlyRate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobilityRadius : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Professional\_project\_stddev\_order\_by into a value that can be used as an argument.
-}
encodeProfessional_project_stddev_order_by : Professional_project_stddev_order_by -> Value
encodeProfessional_project_stddev_order_by input____ =
    Encode.maybeObject
        [ ( "hourlyRate", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.hourlyRate ), ( "mobilityRadius", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.mobilityRadius ) ]


buildProfessional_project_stddev_pop_order_by :
    (Professional_project_stddev_pop_order_byOptionalFields -> Professional_project_stddev_pop_order_byOptionalFields)
    -> Professional_project_stddev_pop_order_by
buildProfessional_project_stddev_pop_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { hourlyRate = Absent, mobilityRadius = Absent }
    in
    { hourlyRate = optionals____.hourlyRate, mobilityRadius = optionals____.mobilityRadius }


type alias Professional_project_stddev_pop_order_byOptionalFields =
    { hourlyRate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobilityRadius : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Professional\_project\_stddev\_pop\_order\_by input object.
-}
type alias Professional_project_stddev_pop_order_by =
    { hourlyRate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobilityRadius : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Professional\_project\_stddev\_pop\_order\_by into a value that can be used as an argument.
-}
encodeProfessional_project_stddev_pop_order_by : Professional_project_stddev_pop_order_by -> Value
encodeProfessional_project_stddev_pop_order_by input____ =
    Encode.maybeObject
        [ ( "hourlyRate", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.hourlyRate ), ( "mobilityRadius", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.mobilityRadius ) ]


buildProfessional_project_stddev_samp_order_by :
    (Professional_project_stddev_samp_order_byOptionalFields -> Professional_project_stddev_samp_order_byOptionalFields)
    -> Professional_project_stddev_samp_order_by
buildProfessional_project_stddev_samp_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { hourlyRate = Absent, mobilityRadius = Absent }
    in
    { hourlyRate = optionals____.hourlyRate, mobilityRadius = optionals____.mobilityRadius }


type alias Professional_project_stddev_samp_order_byOptionalFields =
    { hourlyRate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobilityRadius : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Professional\_project\_stddev\_samp\_order\_by input object.
-}
type alias Professional_project_stddev_samp_order_by =
    { hourlyRate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobilityRadius : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Professional\_project\_stddev\_samp\_order\_by into a value that can be used as an argument.
-}
encodeProfessional_project_stddev_samp_order_by : Professional_project_stddev_samp_order_by -> Value
encodeProfessional_project_stddev_samp_order_by input____ =
    Encode.maybeObject
        [ ( "hourlyRate", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.hourlyRate ), ( "mobilityRadius", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.mobilityRadius ) ]


buildProfessional_project_stream_cursor_input :
    Professional_project_stream_cursor_inputRequiredFields
    -> (Professional_project_stream_cursor_inputOptionalFields -> Professional_project_stream_cursor_inputOptionalFields)
    -> Professional_project_stream_cursor_input
buildProfessional_project_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Professional_project_stream_cursor_inputRequiredFields =
    { initial_value : Professional_project_stream_cursor_value_input }


type alias Professional_project_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Professional\_project\_stream\_cursor\_input input object.
-}
type alias Professional_project_stream_cursor_input =
    { initial_value : Professional_project_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Professional\_project\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeProfessional_project_stream_cursor_input : Professional_project_stream_cursor_input -> Value
encodeProfessional_project_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeProfessional_project_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildProfessional_project_stream_cursor_value_input :
    (Professional_project_stream_cursor_value_inputOptionalFields -> Professional_project_stream_cursor_value_inputOptionalFields)
    -> Professional_project_stream_cursor_value_input
buildProfessional_project_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { contractTypeId = Absent, createdAt = Absent, employmentTypeId = Absent, hourlyRate = Absent, id = Absent, mobilityRadius = Absent, notebookId = Absent, romeCodeId = Absent, updatedAt = Absent, updatedBy = Absent }
    in
    { contractTypeId = optionals____.contractTypeId, createdAt = optionals____.createdAt, employmentTypeId = optionals____.employmentTypeId, hourlyRate = optionals____.hourlyRate, id = optionals____.id, mobilityRadius = optionals____.mobilityRadius, notebookId = optionals____.notebookId, romeCodeId = optionals____.romeCodeId, updatedAt = optionals____.updatedAt, updatedBy = optionals____.updatedBy }


type alias Professional_project_stream_cursor_value_inputOptionalFields =
    { contractTypeId : OptionalArgument CdbGQL.Enum.Contract_type_enum.Contract_type_enum
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , employmentTypeId : OptionalArgument CdbGQL.Enum.Employment_type_enum.Employment_type_enum
    , hourlyRate : OptionalArgument Int
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , mobilityRadius : OptionalArgument Int
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , romeCodeId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , updatedBy : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Type for the Professional\_project\_stream\_cursor\_value\_input input object.
-}
type alias Professional_project_stream_cursor_value_input =
    { contractTypeId : OptionalArgument CdbGQL.Enum.Contract_type_enum.Contract_type_enum
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , employmentTypeId : OptionalArgument CdbGQL.Enum.Employment_type_enum.Employment_type_enum
    , hourlyRate : OptionalArgument Int
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , mobilityRadius : OptionalArgument Int
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , romeCodeId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , updatedBy : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Encode a Professional\_project\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeProfessional_project_stream_cursor_value_input : Professional_project_stream_cursor_value_input -> Value
encodeProfessional_project_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "contractTypeId", Encode.enum CdbGQL.Enum.Contract_type_enum.toString |> Encode.optional input____.contractTypeId ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "employmentTypeId", Encode.enum CdbGQL.Enum.Employment_type_enum.toString |> Encode.optional input____.employmentTypeId ), ( "hourlyRate", Encode.int |> Encode.optional input____.hourlyRate ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "mobilityRadius", Encode.int |> Encode.optional input____.mobilityRadius ), ( "notebookId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.notebookId ), ( "romeCodeId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.romeCodeId ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ), ( "updatedBy", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.updatedBy ) ]


buildProfessional_project_sum_order_by :
    (Professional_project_sum_order_byOptionalFields -> Professional_project_sum_order_byOptionalFields)
    -> Professional_project_sum_order_by
buildProfessional_project_sum_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { hourlyRate = Absent, mobilityRadius = Absent }
    in
    { hourlyRate = optionals____.hourlyRate, mobilityRadius = optionals____.mobilityRadius }


type alias Professional_project_sum_order_byOptionalFields =
    { hourlyRate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobilityRadius : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Professional\_project\_sum\_order\_by input object.
-}
type alias Professional_project_sum_order_by =
    { hourlyRate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobilityRadius : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Professional\_project\_sum\_order\_by into a value that can be used as an argument.
-}
encodeProfessional_project_sum_order_by : Professional_project_sum_order_by -> Value
encodeProfessional_project_sum_order_by input____ =
    Encode.maybeObject
        [ ( "hourlyRate", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.hourlyRate ), ( "mobilityRadius", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.mobilityRadius ) ]


buildProfessional_project_updates :
    Professional_project_updatesRequiredFields
    -> (Professional_project_updatesOptionalFields -> Professional_project_updatesOptionalFields)
    -> Professional_project_updates
buildProfessional_project_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { inc_ = Absent, set_ = Absent }
    in
    Professional_project_updates { inc_ = optionals____.inc_, set_ = optionals____.set_, where_ = required____.where_ }


type alias Professional_project_updatesRequiredFields =
    { where_ : Professional_project_bool_exp }


type alias Professional_project_updatesOptionalFields =
    { inc_ : OptionalArgument Professional_project_inc_input
    , set_ : OptionalArgument Professional_project_set_input
    }


{-| Type alias for the `Professional_project_updates` attributes. Note that this type
needs to use the `Professional_project_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Professional_project_updatesRaw =
    { inc_ : OptionalArgument Professional_project_inc_input
    , set_ : OptionalArgument Professional_project_set_input
    , where_ : Professional_project_bool_exp
    }


{-| Type for the Professional\_project\_updates input object.
-}
type Professional_project_updates
    = Professional_project_updates Professional_project_updatesRaw


{-| Encode a Professional\_project\_updates into a value that can be used as an argument.
-}
encodeProfessional_project_updates : Professional_project_updates -> Value
encodeProfessional_project_updates (Professional_project_updates input____) =
    Encode.maybeObject
        [ ( "_inc", encodeProfessional_project_inc_input |> Encode.optional input____.inc_ ), ( "_set", encodeProfessional_project_set_input |> Encode.optional input____.set_ ), ( "where", encodeProfessional_project_bool_exp input____.where_ |> Just ) ]


buildProfessional_project_var_pop_order_by :
    (Professional_project_var_pop_order_byOptionalFields -> Professional_project_var_pop_order_byOptionalFields)
    -> Professional_project_var_pop_order_by
buildProfessional_project_var_pop_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { hourlyRate = Absent, mobilityRadius = Absent }
    in
    { hourlyRate = optionals____.hourlyRate, mobilityRadius = optionals____.mobilityRadius }


type alias Professional_project_var_pop_order_byOptionalFields =
    { hourlyRate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobilityRadius : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Professional\_project\_var\_pop\_order\_by input object.
-}
type alias Professional_project_var_pop_order_by =
    { hourlyRate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobilityRadius : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Professional\_project\_var\_pop\_order\_by into a value that can be used as an argument.
-}
encodeProfessional_project_var_pop_order_by : Professional_project_var_pop_order_by -> Value
encodeProfessional_project_var_pop_order_by input____ =
    Encode.maybeObject
        [ ( "hourlyRate", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.hourlyRate ), ( "mobilityRadius", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.mobilityRadius ) ]


buildProfessional_project_var_samp_order_by :
    (Professional_project_var_samp_order_byOptionalFields -> Professional_project_var_samp_order_byOptionalFields)
    -> Professional_project_var_samp_order_by
buildProfessional_project_var_samp_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { hourlyRate = Absent, mobilityRadius = Absent }
    in
    { hourlyRate = optionals____.hourlyRate, mobilityRadius = optionals____.mobilityRadius }


type alias Professional_project_var_samp_order_byOptionalFields =
    { hourlyRate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobilityRadius : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Professional\_project\_var\_samp\_order\_by input object.
-}
type alias Professional_project_var_samp_order_by =
    { hourlyRate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobilityRadius : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Professional\_project\_var\_samp\_order\_by into a value that can be used as an argument.
-}
encodeProfessional_project_var_samp_order_by : Professional_project_var_samp_order_by -> Value
encodeProfessional_project_var_samp_order_by input____ =
    Encode.maybeObject
        [ ( "hourlyRate", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.hourlyRate ), ( "mobilityRadius", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.mobilityRadius ) ]


buildProfessional_project_variance_order_by :
    (Professional_project_variance_order_byOptionalFields -> Professional_project_variance_order_byOptionalFields)
    -> Professional_project_variance_order_by
buildProfessional_project_variance_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { hourlyRate = Absent, mobilityRadius = Absent }
    in
    { hourlyRate = optionals____.hourlyRate, mobilityRadius = optionals____.mobilityRadius }


type alias Professional_project_variance_order_byOptionalFields =
    { hourlyRate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobilityRadius : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Professional\_project\_variance\_order\_by input object.
-}
type alias Professional_project_variance_order_by =
    { hourlyRate : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , mobilityRadius : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Professional\_project\_variance\_order\_by into a value that can be used as an argument.
-}
encodeProfessional_project_variance_order_by : Professional_project_variance_order_by -> Value
encodeProfessional_project_variance_order_by input____ =
    Encode.maybeObject
        [ ( "hourlyRate", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.hourlyRate ), ( "mobilityRadius", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.mobilityRadius ) ]


buildProfessional_set_input :
    (Professional_set_inputOptionalFields -> Professional_set_inputOptionalFields)
    -> Professional_set_input
buildProfessional_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, mobileNumber = Absent, position = Absent, structureId = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, mobileNumber = optionals____.mobileNumber, position = optionals____.position, structureId = optionals____.structureId, updatedAt = optionals____.updatedAt }


type alias Professional_set_inputOptionalFields =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastname : OptionalArgument String
    , mobileNumber : OptionalArgument String
    , position : OptionalArgument String
    , structureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Professional\_set\_input input object.
-}
type alias Professional_set_input =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastname : OptionalArgument String
    , mobileNumber : OptionalArgument String
    , position : OptionalArgument String
    , structureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Professional\_set\_input into a value that can be used as an argument.
-}
encodeProfessional_set_input : Professional_set_input -> Value
encodeProfessional_set_input input____ =
    Encode.maybeObject
        [ ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "email", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.email ), ( "firstname", Encode.string |> Encode.optional input____.firstname ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "lastname", Encode.string |> Encode.optional input____.lastname ), ( "mobileNumber", Encode.string |> Encode.optional input____.mobileNumber ), ( "position", Encode.string |> Encode.optional input____.position ), ( "structureId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.structureId ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildProfessional_stream_cursor_input :
    Professional_stream_cursor_inputRequiredFields
    -> (Professional_stream_cursor_inputOptionalFields -> Professional_stream_cursor_inputOptionalFields)
    -> Professional_stream_cursor_input
buildProfessional_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Professional_stream_cursor_inputRequiredFields =
    { initial_value : Professional_stream_cursor_value_input }


type alias Professional_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Professional\_stream\_cursor\_input input object.
-}
type alias Professional_stream_cursor_input =
    { initial_value : Professional_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Professional\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeProfessional_stream_cursor_input : Professional_stream_cursor_input -> Value
encodeProfessional_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeProfessional_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildProfessional_stream_cursor_value_input :
    (Professional_stream_cursor_value_inputOptionalFields -> Professional_stream_cursor_value_inputOptionalFields)
    -> Professional_stream_cursor_value_input
buildProfessional_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, email = Absent, firstname = Absent, id = Absent, lastname = Absent, mobileNumber = Absent, position = Absent, structureId = Absent, updatedAt = Absent }
    in
    { createdAt = optionals____.createdAt, email = optionals____.email, firstname = optionals____.firstname, id = optionals____.id, lastname = optionals____.lastname, mobileNumber = optionals____.mobileNumber, position = optionals____.position, structureId = optionals____.structureId, updatedAt = optionals____.updatedAt }


type alias Professional_stream_cursor_value_inputOptionalFields =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastname : OptionalArgument String
    , mobileNumber : OptionalArgument String
    , position : OptionalArgument String
    , structureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Type for the Professional\_stream\_cursor\_value\_input input object.
-}
type alias Professional_stream_cursor_value_input =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , email : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , firstname : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lastname : OptionalArgument String
    , mobileNumber : OptionalArgument String
    , position : OptionalArgument String
    , structureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    }


{-| Encode a Professional\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeProfessional_stream_cursor_value_input : Professional_stream_cursor_value_input -> Value
encodeProfessional_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "email", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.email ), ( "firstname", Encode.string |> Encode.optional input____.firstname ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "lastname", Encode.string |> Encode.optional input____.lastname ), ( "mobileNumber", Encode.string |> Encode.optional input____.mobileNumber ), ( "position", Encode.string |> Encode.optional input____.position ), ( "structureId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.structureId ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ) ]


buildProfessional_updates :
    Professional_updatesRequiredFields
    -> (Professional_updatesOptionalFields -> Professional_updatesOptionalFields)
    -> Professional_updates
buildProfessional_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Professional_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Professional_updatesRequiredFields =
    { where_ : Professional_bool_exp }


type alias Professional_updatesOptionalFields =
    { set_ : OptionalArgument Professional_set_input }


{-| Type alias for the `Professional_updates` attributes. Note that this type
needs to use the `Professional_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Professional_updatesRaw =
    { set_ : OptionalArgument Professional_set_input
    , where_ : Professional_bool_exp
    }


{-| Type for the Professional\_updates input object.
-}
type Professional_updates
    = Professional_updates Professional_updatesRaw


{-| Encode a Professional\_updates into a value that can be used as an argument.
-}
encodeProfessional_updates : Professional_updates -> Value
encodeProfessional_updates (Professional_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeProfessional_set_input |> Encode.optional input____.set_ ), ( "where", encodeProfessional_bool_exp input____.where_ |> Just ) ]


buildRef_action_bool_exp :
    (Ref_action_bool_expOptionalFields -> Ref_action_bool_expOptionalFields)
    -> Ref_action_bool_exp
buildRef_action_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, description = Absent, id = Absent, refTheme = Absent, theme = Absent }
    in
    Ref_action_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, description = optionals____.description, id = optionals____.id, refTheme = optionals____.refTheme, theme = optionals____.theme }


type alias Ref_action_bool_expOptionalFields =
    { and_ : OptionalArgument (List Ref_action_bool_exp)
    , not_ : OptionalArgument Ref_action_bool_exp
    , or_ : OptionalArgument (List Ref_action_bool_exp)
    , description : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , refTheme : OptionalArgument Ref_theme_bool_exp
    , theme : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Ref_action_bool_exp` attributes. Note that this type
needs to use the `Ref_action_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Ref_action_bool_expRaw =
    { and_ : OptionalArgument (List Ref_action_bool_exp)
    , not_ : OptionalArgument Ref_action_bool_exp
    , or_ : OptionalArgument (List Ref_action_bool_exp)
    , description : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , refTheme : OptionalArgument Ref_theme_bool_exp
    , theme : OptionalArgument String_comparison_exp
    }


{-| Type for the Ref\_action\_bool\_exp input object.
-}
type Ref_action_bool_exp
    = Ref_action_bool_exp Ref_action_bool_expRaw


{-| Encode a Ref\_action\_bool\_exp into a value that can be used as an argument.
-}
encodeRef_action_bool_exp : Ref_action_bool_exp -> Value
encodeRef_action_bool_exp (Ref_action_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeRef_action_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeRef_action_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeRef_action_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "description", encodeString_comparison_exp |> Encode.optional input____.description ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "refTheme", encodeRef_theme_bool_exp |> Encode.optional input____.refTheme ), ( "theme", encodeString_comparison_exp |> Encode.optional input____.theme ) ]


buildRef_action_insert_input :
    (Ref_action_insert_inputOptionalFields -> Ref_action_insert_inputOptionalFields)
    -> Ref_action_insert_input
buildRef_action_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { description = Absent, id = Absent, refTheme = Absent, theme = Absent }
    in
    Ref_action_insert_input { description = optionals____.description, id = optionals____.id, refTheme = optionals____.refTheme, theme = optionals____.theme }


type alias Ref_action_insert_inputOptionalFields =
    { description : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , refTheme : OptionalArgument Ref_theme_obj_rel_insert_input
    , theme : OptionalArgument String
    }


{-| Type alias for the `Ref_action_insert_input` attributes. Note that this type
needs to use the `Ref_action_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Ref_action_insert_inputRaw =
    { description : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , refTheme : OptionalArgument Ref_theme_obj_rel_insert_input
    , theme : OptionalArgument String
    }


{-| Type for the Ref\_action\_insert\_input input object.
-}
type Ref_action_insert_input
    = Ref_action_insert_input Ref_action_insert_inputRaw


{-| Encode a Ref\_action\_insert\_input into a value that can be used as an argument.
-}
encodeRef_action_insert_input : Ref_action_insert_input -> Value
encodeRef_action_insert_input (Ref_action_insert_input input____) =
    Encode.maybeObject
        [ ( "description", Encode.string |> Encode.optional input____.description ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "refTheme", encodeRef_theme_obj_rel_insert_input |> Encode.optional input____.refTheme ), ( "theme", Encode.string |> Encode.optional input____.theme ) ]


buildRef_action_on_conflict :
    Ref_action_on_conflictRequiredFields
    -> (Ref_action_on_conflictOptionalFields -> Ref_action_on_conflictOptionalFields)
    -> Ref_action_on_conflict
buildRef_action_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Ref_action_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Ref_action_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Ref_action_constraint.Ref_action_constraint
    , update_columns : List CdbGQL.Enum.Ref_action_update_column.Ref_action_update_column
    }


type alias Ref_action_on_conflictOptionalFields =
    { where_ : OptionalArgument Ref_action_bool_exp }


{-| Type alias for the `Ref_action_on_conflict` attributes. Note that this type
needs to use the `Ref_action_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Ref_action_on_conflictRaw =
    { constraint : CdbGQL.Enum.Ref_action_constraint.Ref_action_constraint
    , update_columns : List CdbGQL.Enum.Ref_action_update_column.Ref_action_update_column
    , where_ : OptionalArgument Ref_action_bool_exp
    }


{-| Type for the Ref\_action\_on\_conflict input object.
-}
type Ref_action_on_conflict
    = Ref_action_on_conflict Ref_action_on_conflictRaw


{-| Encode a Ref\_action\_on\_conflict into a value that can be used as an argument.
-}
encodeRef_action_on_conflict : Ref_action_on_conflict -> Value
encodeRef_action_on_conflict (Ref_action_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Ref_action_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Ref_action_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeRef_action_bool_exp |> Encode.optional input____.where_ ) ]


buildRef_action_order_by :
    (Ref_action_order_byOptionalFields -> Ref_action_order_byOptionalFields)
    -> Ref_action_order_by
buildRef_action_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { description = Absent, id = Absent, refTheme = Absent, theme = Absent }
    in
    { description = optionals____.description, id = optionals____.id, refTheme = optionals____.refTheme, theme = optionals____.theme }


type alias Ref_action_order_byOptionalFields =
    { description : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , refTheme : OptionalArgument Ref_theme_order_by
    , theme : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Ref\_action\_order\_by input object.
-}
type alias Ref_action_order_by =
    { description : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , refTheme : OptionalArgument Ref_theme_order_by
    , theme : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Ref\_action\_order\_by into a value that can be used as an argument.
-}
encodeRef_action_order_by : Ref_action_order_by -> Value
encodeRef_action_order_by input____ =
    Encode.maybeObject
        [ ( "description", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.description ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "refTheme", encodeRef_theme_order_by |> Encode.optional input____.refTheme ), ( "theme", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.theme ) ]


buildRef_action_pk_columns_input :
    Ref_action_pk_columns_inputRequiredFields
    -> Ref_action_pk_columns_input
buildRef_action_pk_columns_input required____ =
    { id = required____.id }


type alias Ref_action_pk_columns_inputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the Ref\_action\_pk\_columns\_input input object.
-}
type alias Ref_action_pk_columns_input =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a Ref\_action\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeRef_action_pk_columns_input : Ref_action_pk_columns_input -> Value
encodeRef_action_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildRef_action_set_input :
    (Ref_action_set_inputOptionalFields -> Ref_action_set_inputOptionalFields)
    -> Ref_action_set_input
buildRef_action_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { description = Absent, id = Absent, theme = Absent }
    in
    { description = optionals____.description, id = optionals____.id, theme = optionals____.theme }


type alias Ref_action_set_inputOptionalFields =
    { description : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , theme : OptionalArgument String
    }


{-| Type for the Ref\_action\_set\_input input object.
-}
type alias Ref_action_set_input =
    { description : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , theme : OptionalArgument String
    }


{-| Encode a Ref\_action\_set\_input into a value that can be used as an argument.
-}
encodeRef_action_set_input : Ref_action_set_input -> Value
encodeRef_action_set_input input____ =
    Encode.maybeObject
        [ ( "description", Encode.string |> Encode.optional input____.description ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "theme", Encode.string |> Encode.optional input____.theme ) ]


buildRef_action_stream_cursor_input :
    Ref_action_stream_cursor_inputRequiredFields
    -> (Ref_action_stream_cursor_inputOptionalFields -> Ref_action_stream_cursor_inputOptionalFields)
    -> Ref_action_stream_cursor_input
buildRef_action_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Ref_action_stream_cursor_inputRequiredFields =
    { initial_value : Ref_action_stream_cursor_value_input }


type alias Ref_action_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Ref\_action\_stream\_cursor\_input input object.
-}
type alias Ref_action_stream_cursor_input =
    { initial_value : Ref_action_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Ref\_action\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeRef_action_stream_cursor_input : Ref_action_stream_cursor_input -> Value
encodeRef_action_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeRef_action_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildRef_action_stream_cursor_value_input :
    (Ref_action_stream_cursor_value_inputOptionalFields -> Ref_action_stream_cursor_value_inputOptionalFields)
    -> Ref_action_stream_cursor_value_input
buildRef_action_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { description = Absent, id = Absent, theme = Absent }
    in
    { description = optionals____.description, id = optionals____.id, theme = optionals____.theme }


type alias Ref_action_stream_cursor_value_inputOptionalFields =
    { description : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , theme : OptionalArgument String
    }


{-| Type for the Ref\_action\_stream\_cursor\_value\_input input object.
-}
type alias Ref_action_stream_cursor_value_input =
    { description : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , theme : OptionalArgument String
    }


{-| Encode a Ref\_action\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeRef_action_stream_cursor_value_input : Ref_action_stream_cursor_value_input -> Value
encodeRef_action_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "description", Encode.string |> Encode.optional input____.description ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "theme", Encode.string |> Encode.optional input____.theme ) ]


buildRef_action_updates :
    Ref_action_updatesRequiredFields
    -> (Ref_action_updatesOptionalFields -> Ref_action_updatesOptionalFields)
    -> Ref_action_updates
buildRef_action_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Ref_action_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Ref_action_updatesRequiredFields =
    { where_ : Ref_action_bool_exp }


type alias Ref_action_updatesOptionalFields =
    { set_ : OptionalArgument Ref_action_set_input }


{-| Type alias for the `Ref_action_updates` attributes. Note that this type
needs to use the `Ref_action_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Ref_action_updatesRaw =
    { set_ : OptionalArgument Ref_action_set_input
    , where_ : Ref_action_bool_exp
    }


{-| Type for the Ref\_action\_updates input object.
-}
type Ref_action_updates
    = Ref_action_updates Ref_action_updatesRaw


{-| Encode a Ref\_action\_updates into a value that can be used as an argument.
-}
encodeRef_action_updates : Ref_action_updates -> Value
encodeRef_action_updates (Ref_action_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeRef_action_set_input |> Encode.optional input____.set_ ), ( "where", encodeRef_action_bool_exp input____.where_ |> Just ) ]


buildRef_situation_bool_exp :
    (Ref_situation_bool_expOptionalFields -> Ref_situation_bool_expOptionalFields)
    -> Ref_situation_bool_exp
buildRef_situation_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, description = Absent, id = Absent, refTheme = Absent, theme = Absent }
    in
    Ref_situation_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, description = optionals____.description, id = optionals____.id, refTheme = optionals____.refTheme, theme = optionals____.theme }


type alias Ref_situation_bool_expOptionalFields =
    { and_ : OptionalArgument (List Ref_situation_bool_exp)
    , not_ : OptionalArgument Ref_situation_bool_exp
    , or_ : OptionalArgument (List Ref_situation_bool_exp)
    , description : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , refTheme : OptionalArgument Ref_theme_bool_exp
    , theme : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Ref_situation_bool_exp` attributes. Note that this type
needs to use the `Ref_situation_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Ref_situation_bool_expRaw =
    { and_ : OptionalArgument (List Ref_situation_bool_exp)
    , not_ : OptionalArgument Ref_situation_bool_exp
    , or_ : OptionalArgument (List Ref_situation_bool_exp)
    , description : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , refTheme : OptionalArgument Ref_theme_bool_exp
    , theme : OptionalArgument String_comparison_exp
    }


{-| Type for the Ref\_situation\_bool\_exp input object.
-}
type Ref_situation_bool_exp
    = Ref_situation_bool_exp Ref_situation_bool_expRaw


{-| Encode a Ref\_situation\_bool\_exp into a value that can be used as an argument.
-}
encodeRef_situation_bool_exp : Ref_situation_bool_exp -> Value
encodeRef_situation_bool_exp (Ref_situation_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeRef_situation_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeRef_situation_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeRef_situation_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "description", encodeString_comparison_exp |> Encode.optional input____.description ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "refTheme", encodeRef_theme_bool_exp |> Encode.optional input____.refTheme ), ( "theme", encodeString_comparison_exp |> Encode.optional input____.theme ) ]


buildRef_situation_insert_input :
    (Ref_situation_insert_inputOptionalFields -> Ref_situation_insert_inputOptionalFields)
    -> Ref_situation_insert_input
buildRef_situation_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { description = Absent, id = Absent, refTheme = Absent, theme = Absent }
    in
    Ref_situation_insert_input { description = optionals____.description, id = optionals____.id, refTheme = optionals____.refTheme, theme = optionals____.theme }


type alias Ref_situation_insert_inputOptionalFields =
    { description : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , refTheme : OptionalArgument Ref_theme_obj_rel_insert_input
    , theme : OptionalArgument String
    }


{-| Type alias for the `Ref_situation_insert_input` attributes. Note that this type
needs to use the `Ref_situation_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Ref_situation_insert_inputRaw =
    { description : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , refTheme : OptionalArgument Ref_theme_obj_rel_insert_input
    , theme : OptionalArgument String
    }


{-| Type for the Ref\_situation\_insert\_input input object.
-}
type Ref_situation_insert_input
    = Ref_situation_insert_input Ref_situation_insert_inputRaw


{-| Encode a Ref\_situation\_insert\_input into a value that can be used as an argument.
-}
encodeRef_situation_insert_input : Ref_situation_insert_input -> Value
encodeRef_situation_insert_input (Ref_situation_insert_input input____) =
    Encode.maybeObject
        [ ( "description", Encode.string |> Encode.optional input____.description ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "refTheme", encodeRef_theme_obj_rel_insert_input |> Encode.optional input____.refTheme ), ( "theme", Encode.string |> Encode.optional input____.theme ) ]


buildRef_situation_obj_rel_insert_input :
    Ref_situation_obj_rel_insert_inputRequiredFields
    -> (Ref_situation_obj_rel_insert_inputOptionalFields -> Ref_situation_obj_rel_insert_inputOptionalFields)
    -> Ref_situation_obj_rel_insert_input
buildRef_situation_obj_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Ref_situation_obj_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Ref_situation_obj_rel_insert_inputRequiredFields =
    { data : Ref_situation_insert_input }


type alias Ref_situation_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Ref_situation_on_conflict }


{-| Type alias for the `Ref_situation_obj_rel_insert_input` attributes. Note that this type
needs to use the `Ref_situation_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Ref_situation_obj_rel_insert_inputRaw =
    { data : Ref_situation_insert_input
    , on_conflict : OptionalArgument Ref_situation_on_conflict
    }


{-| Type for the Ref\_situation\_obj\_rel\_insert\_input input object.
-}
type Ref_situation_obj_rel_insert_input
    = Ref_situation_obj_rel_insert_input Ref_situation_obj_rel_insert_inputRaw


{-| Encode a Ref\_situation\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeRef_situation_obj_rel_insert_input : Ref_situation_obj_rel_insert_input -> Value
encodeRef_situation_obj_rel_insert_input (Ref_situation_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeRef_situation_insert_input input____.data |> Just ), ( "on_conflict", encodeRef_situation_on_conflict |> Encode.optional input____.on_conflict ) ]


buildRef_situation_on_conflict :
    Ref_situation_on_conflictRequiredFields
    -> (Ref_situation_on_conflictOptionalFields -> Ref_situation_on_conflictOptionalFields)
    -> Ref_situation_on_conflict
buildRef_situation_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Ref_situation_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Ref_situation_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Ref_situation_constraint.Ref_situation_constraint
    , update_columns : List CdbGQL.Enum.Ref_situation_update_column.Ref_situation_update_column
    }


type alias Ref_situation_on_conflictOptionalFields =
    { where_ : OptionalArgument Ref_situation_bool_exp }


{-| Type alias for the `Ref_situation_on_conflict` attributes. Note that this type
needs to use the `Ref_situation_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Ref_situation_on_conflictRaw =
    { constraint : CdbGQL.Enum.Ref_situation_constraint.Ref_situation_constraint
    , update_columns : List CdbGQL.Enum.Ref_situation_update_column.Ref_situation_update_column
    , where_ : OptionalArgument Ref_situation_bool_exp
    }


{-| Type for the Ref\_situation\_on\_conflict input object.
-}
type Ref_situation_on_conflict
    = Ref_situation_on_conflict Ref_situation_on_conflictRaw


{-| Encode a Ref\_situation\_on\_conflict into a value that can be used as an argument.
-}
encodeRef_situation_on_conflict : Ref_situation_on_conflict -> Value
encodeRef_situation_on_conflict (Ref_situation_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Ref_situation_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Ref_situation_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeRef_situation_bool_exp |> Encode.optional input____.where_ ) ]


buildRef_situation_order_by :
    (Ref_situation_order_byOptionalFields -> Ref_situation_order_byOptionalFields)
    -> Ref_situation_order_by
buildRef_situation_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { description = Absent, id = Absent, refTheme = Absent, theme = Absent }
    in
    { description = optionals____.description, id = optionals____.id, refTheme = optionals____.refTheme, theme = optionals____.theme }


type alias Ref_situation_order_byOptionalFields =
    { description : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , refTheme : OptionalArgument Ref_theme_order_by
    , theme : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Ref\_situation\_order\_by input object.
-}
type alias Ref_situation_order_by =
    { description : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , refTheme : OptionalArgument Ref_theme_order_by
    , theme : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Ref\_situation\_order\_by into a value that can be used as an argument.
-}
encodeRef_situation_order_by : Ref_situation_order_by -> Value
encodeRef_situation_order_by input____ =
    Encode.maybeObject
        [ ( "description", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.description ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "refTheme", encodeRef_theme_order_by |> Encode.optional input____.refTheme ), ( "theme", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.theme ) ]


buildRef_situation_pk_columns_input :
    Ref_situation_pk_columns_inputRequiredFields
    -> Ref_situation_pk_columns_input
buildRef_situation_pk_columns_input required____ =
    { id = required____.id }


type alias Ref_situation_pk_columns_inputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the Ref\_situation\_pk\_columns\_input input object.
-}
type alias Ref_situation_pk_columns_input =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a Ref\_situation\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeRef_situation_pk_columns_input : Ref_situation_pk_columns_input -> Value
encodeRef_situation_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildRef_situation_set_input :
    (Ref_situation_set_inputOptionalFields -> Ref_situation_set_inputOptionalFields)
    -> Ref_situation_set_input
buildRef_situation_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { description = Absent, id = Absent, theme = Absent }
    in
    { description = optionals____.description, id = optionals____.id, theme = optionals____.theme }


type alias Ref_situation_set_inputOptionalFields =
    { description : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , theme : OptionalArgument String
    }


{-| Type for the Ref\_situation\_set\_input input object.
-}
type alias Ref_situation_set_input =
    { description : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , theme : OptionalArgument String
    }


{-| Encode a Ref\_situation\_set\_input into a value that can be used as an argument.
-}
encodeRef_situation_set_input : Ref_situation_set_input -> Value
encodeRef_situation_set_input input____ =
    Encode.maybeObject
        [ ( "description", Encode.string |> Encode.optional input____.description ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "theme", Encode.string |> Encode.optional input____.theme ) ]


buildRef_situation_stream_cursor_input :
    Ref_situation_stream_cursor_inputRequiredFields
    -> (Ref_situation_stream_cursor_inputOptionalFields -> Ref_situation_stream_cursor_inputOptionalFields)
    -> Ref_situation_stream_cursor_input
buildRef_situation_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Ref_situation_stream_cursor_inputRequiredFields =
    { initial_value : Ref_situation_stream_cursor_value_input }


type alias Ref_situation_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Ref\_situation\_stream\_cursor\_input input object.
-}
type alias Ref_situation_stream_cursor_input =
    { initial_value : Ref_situation_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Ref\_situation\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeRef_situation_stream_cursor_input : Ref_situation_stream_cursor_input -> Value
encodeRef_situation_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeRef_situation_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildRef_situation_stream_cursor_value_input :
    (Ref_situation_stream_cursor_value_inputOptionalFields -> Ref_situation_stream_cursor_value_inputOptionalFields)
    -> Ref_situation_stream_cursor_value_input
buildRef_situation_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { description = Absent, id = Absent, theme = Absent }
    in
    { description = optionals____.description, id = optionals____.id, theme = optionals____.theme }


type alias Ref_situation_stream_cursor_value_inputOptionalFields =
    { description : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , theme : OptionalArgument String
    }


{-| Type for the Ref\_situation\_stream\_cursor\_value\_input input object.
-}
type alias Ref_situation_stream_cursor_value_input =
    { description : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , theme : OptionalArgument String
    }


{-| Encode a Ref\_situation\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeRef_situation_stream_cursor_value_input : Ref_situation_stream_cursor_value_input -> Value
encodeRef_situation_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "description", Encode.string |> Encode.optional input____.description ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "theme", Encode.string |> Encode.optional input____.theme ) ]


buildRef_situation_updates :
    Ref_situation_updatesRequiredFields
    -> (Ref_situation_updatesOptionalFields -> Ref_situation_updatesOptionalFields)
    -> Ref_situation_updates
buildRef_situation_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Ref_situation_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Ref_situation_updatesRequiredFields =
    { where_ : Ref_situation_bool_exp }


type alias Ref_situation_updatesOptionalFields =
    { set_ : OptionalArgument Ref_situation_set_input }


{-| Type alias for the `Ref_situation_updates` attributes. Note that this type
needs to use the `Ref_situation_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Ref_situation_updatesRaw =
    { set_ : OptionalArgument Ref_situation_set_input
    , where_ : Ref_situation_bool_exp
    }


{-| Type for the Ref\_situation\_updates input object.
-}
type Ref_situation_updates
    = Ref_situation_updates Ref_situation_updatesRaw


{-| Encode a Ref\_situation\_updates into a value that can be used as an argument.
-}
encodeRef_situation_updates : Ref_situation_updates -> Value
encodeRef_situation_updates (Ref_situation_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeRef_situation_set_input |> Encode.optional input____.set_ ), ( "where", encodeRef_situation_bool_exp input____.where_ |> Just ) ]


buildRef_target_bool_exp :
    (Ref_target_bool_expOptionalFields -> Ref_target_bool_expOptionalFields)
    -> Ref_target_bool_exp
buildRef_target_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, description = Absent, id = Absent, refTheme = Absent, theme = Absent }
    in
    Ref_target_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, description = optionals____.description, id = optionals____.id, refTheme = optionals____.refTheme, theme = optionals____.theme }


type alias Ref_target_bool_expOptionalFields =
    { and_ : OptionalArgument (List Ref_target_bool_exp)
    , not_ : OptionalArgument Ref_target_bool_exp
    , or_ : OptionalArgument (List Ref_target_bool_exp)
    , description : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , refTheme : OptionalArgument Ref_theme_bool_exp
    , theme : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Ref_target_bool_exp` attributes. Note that this type
needs to use the `Ref_target_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Ref_target_bool_expRaw =
    { and_ : OptionalArgument (List Ref_target_bool_exp)
    , not_ : OptionalArgument Ref_target_bool_exp
    , or_ : OptionalArgument (List Ref_target_bool_exp)
    , description : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , refTheme : OptionalArgument Ref_theme_bool_exp
    , theme : OptionalArgument String_comparison_exp
    }


{-| Type for the Ref\_target\_bool\_exp input object.
-}
type Ref_target_bool_exp
    = Ref_target_bool_exp Ref_target_bool_expRaw


{-| Encode a Ref\_target\_bool\_exp into a value that can be used as an argument.
-}
encodeRef_target_bool_exp : Ref_target_bool_exp -> Value
encodeRef_target_bool_exp (Ref_target_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeRef_target_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeRef_target_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeRef_target_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "description", encodeString_comparison_exp |> Encode.optional input____.description ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "refTheme", encodeRef_theme_bool_exp |> Encode.optional input____.refTheme ), ( "theme", encodeString_comparison_exp |> Encode.optional input____.theme ) ]


buildRef_target_insert_input :
    (Ref_target_insert_inputOptionalFields -> Ref_target_insert_inputOptionalFields)
    -> Ref_target_insert_input
buildRef_target_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { description = Absent, id = Absent, refTheme = Absent, theme = Absent }
    in
    Ref_target_insert_input { description = optionals____.description, id = optionals____.id, refTheme = optionals____.refTheme, theme = optionals____.theme }


type alias Ref_target_insert_inputOptionalFields =
    { description : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , refTheme : OptionalArgument Ref_theme_obj_rel_insert_input
    , theme : OptionalArgument String
    }


{-| Type alias for the `Ref_target_insert_input` attributes. Note that this type
needs to use the `Ref_target_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Ref_target_insert_inputRaw =
    { description : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , refTheme : OptionalArgument Ref_theme_obj_rel_insert_input
    , theme : OptionalArgument String
    }


{-| Type for the Ref\_target\_insert\_input input object.
-}
type Ref_target_insert_input
    = Ref_target_insert_input Ref_target_insert_inputRaw


{-| Encode a Ref\_target\_insert\_input into a value that can be used as an argument.
-}
encodeRef_target_insert_input : Ref_target_insert_input -> Value
encodeRef_target_insert_input (Ref_target_insert_input input____) =
    Encode.maybeObject
        [ ( "description", Encode.string |> Encode.optional input____.description ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "refTheme", encodeRef_theme_obj_rel_insert_input |> Encode.optional input____.refTheme ), ( "theme", Encode.string |> Encode.optional input____.theme ) ]


buildRef_target_on_conflict :
    Ref_target_on_conflictRequiredFields
    -> (Ref_target_on_conflictOptionalFields -> Ref_target_on_conflictOptionalFields)
    -> Ref_target_on_conflict
buildRef_target_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Ref_target_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Ref_target_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Ref_target_constraint.Ref_target_constraint
    , update_columns : List CdbGQL.Enum.Ref_target_update_column.Ref_target_update_column
    }


type alias Ref_target_on_conflictOptionalFields =
    { where_ : OptionalArgument Ref_target_bool_exp }


{-| Type alias for the `Ref_target_on_conflict` attributes. Note that this type
needs to use the `Ref_target_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Ref_target_on_conflictRaw =
    { constraint : CdbGQL.Enum.Ref_target_constraint.Ref_target_constraint
    , update_columns : List CdbGQL.Enum.Ref_target_update_column.Ref_target_update_column
    , where_ : OptionalArgument Ref_target_bool_exp
    }


{-| Type for the Ref\_target\_on\_conflict input object.
-}
type Ref_target_on_conflict
    = Ref_target_on_conflict Ref_target_on_conflictRaw


{-| Encode a Ref\_target\_on\_conflict into a value that can be used as an argument.
-}
encodeRef_target_on_conflict : Ref_target_on_conflict -> Value
encodeRef_target_on_conflict (Ref_target_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Ref_target_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Ref_target_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeRef_target_bool_exp |> Encode.optional input____.where_ ) ]


buildRef_target_order_by :
    (Ref_target_order_byOptionalFields -> Ref_target_order_byOptionalFields)
    -> Ref_target_order_by
buildRef_target_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { description = Absent, id = Absent, refTheme = Absent, theme = Absent }
    in
    { description = optionals____.description, id = optionals____.id, refTheme = optionals____.refTheme, theme = optionals____.theme }


type alias Ref_target_order_byOptionalFields =
    { description : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , refTheme : OptionalArgument Ref_theme_order_by
    , theme : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Ref\_target\_order\_by input object.
-}
type alias Ref_target_order_by =
    { description : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , refTheme : OptionalArgument Ref_theme_order_by
    , theme : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Ref\_target\_order\_by into a value that can be used as an argument.
-}
encodeRef_target_order_by : Ref_target_order_by -> Value
encodeRef_target_order_by input____ =
    Encode.maybeObject
        [ ( "description", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.description ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "refTheme", encodeRef_theme_order_by |> Encode.optional input____.refTheme ), ( "theme", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.theme ) ]


buildRef_target_pk_columns_input :
    Ref_target_pk_columns_inputRequiredFields
    -> Ref_target_pk_columns_input
buildRef_target_pk_columns_input required____ =
    { id = required____.id }


type alias Ref_target_pk_columns_inputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the Ref\_target\_pk\_columns\_input input object.
-}
type alias Ref_target_pk_columns_input =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a Ref\_target\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeRef_target_pk_columns_input : Ref_target_pk_columns_input -> Value
encodeRef_target_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildRef_target_set_input :
    (Ref_target_set_inputOptionalFields -> Ref_target_set_inputOptionalFields)
    -> Ref_target_set_input
buildRef_target_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { description = Absent, id = Absent, theme = Absent }
    in
    { description = optionals____.description, id = optionals____.id, theme = optionals____.theme }


type alias Ref_target_set_inputOptionalFields =
    { description : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , theme : OptionalArgument String
    }


{-| Type for the Ref\_target\_set\_input input object.
-}
type alias Ref_target_set_input =
    { description : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , theme : OptionalArgument String
    }


{-| Encode a Ref\_target\_set\_input into a value that can be used as an argument.
-}
encodeRef_target_set_input : Ref_target_set_input -> Value
encodeRef_target_set_input input____ =
    Encode.maybeObject
        [ ( "description", Encode.string |> Encode.optional input____.description ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "theme", Encode.string |> Encode.optional input____.theme ) ]


buildRef_target_stream_cursor_input :
    Ref_target_stream_cursor_inputRequiredFields
    -> (Ref_target_stream_cursor_inputOptionalFields -> Ref_target_stream_cursor_inputOptionalFields)
    -> Ref_target_stream_cursor_input
buildRef_target_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Ref_target_stream_cursor_inputRequiredFields =
    { initial_value : Ref_target_stream_cursor_value_input }


type alias Ref_target_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Ref\_target\_stream\_cursor\_input input object.
-}
type alias Ref_target_stream_cursor_input =
    { initial_value : Ref_target_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Ref\_target\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeRef_target_stream_cursor_input : Ref_target_stream_cursor_input -> Value
encodeRef_target_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeRef_target_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildRef_target_stream_cursor_value_input :
    (Ref_target_stream_cursor_value_inputOptionalFields -> Ref_target_stream_cursor_value_inputOptionalFields)
    -> Ref_target_stream_cursor_value_input
buildRef_target_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { description = Absent, id = Absent, theme = Absent }
    in
    { description = optionals____.description, id = optionals____.id, theme = optionals____.theme }


type alias Ref_target_stream_cursor_value_inputOptionalFields =
    { description : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , theme : OptionalArgument String
    }


{-| Type for the Ref\_target\_stream\_cursor\_value\_input input object.
-}
type alias Ref_target_stream_cursor_value_input =
    { description : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , theme : OptionalArgument String
    }


{-| Encode a Ref\_target\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeRef_target_stream_cursor_value_input : Ref_target_stream_cursor_value_input -> Value
encodeRef_target_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "description", Encode.string |> Encode.optional input____.description ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "theme", Encode.string |> Encode.optional input____.theme ) ]


buildRef_target_updates :
    Ref_target_updatesRequiredFields
    -> (Ref_target_updatesOptionalFields -> Ref_target_updatesOptionalFields)
    -> Ref_target_updates
buildRef_target_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Ref_target_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Ref_target_updatesRequiredFields =
    { where_ : Ref_target_bool_exp }


type alias Ref_target_updatesOptionalFields =
    { set_ : OptionalArgument Ref_target_set_input }


{-| Type alias for the `Ref_target_updates` attributes. Note that this type
needs to use the `Ref_target_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Ref_target_updatesRaw =
    { set_ : OptionalArgument Ref_target_set_input
    , where_ : Ref_target_bool_exp
    }


{-| Type for the Ref\_target\_updates input object.
-}
type Ref_target_updates
    = Ref_target_updates Ref_target_updatesRaw


{-| Encode a Ref\_target\_updates into a value that can be used as an argument.
-}
encodeRef_target_updates : Ref_target_updates -> Value
encodeRef_target_updates (Ref_target_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeRef_target_set_input |> Encode.optional input____.set_ ), ( "where", encodeRef_target_bool_exp input____.where_ |> Just ) ]


buildRef_theme_bool_exp :
    (Ref_theme_bool_expOptionalFields -> Ref_theme_bool_expOptionalFields)
    -> Ref_theme_bool_exp
buildRef_theme_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, label = Absent, name = Absent }
    in
    Ref_theme_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, label = optionals____.label, name = optionals____.name }


type alias Ref_theme_bool_expOptionalFields =
    { and_ : OptionalArgument (List Ref_theme_bool_exp)
    , not_ : OptionalArgument Ref_theme_bool_exp
    , or_ : OptionalArgument (List Ref_theme_bool_exp)
    , label : OptionalArgument String_comparison_exp
    , name : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Ref_theme_bool_exp` attributes. Note that this type
needs to use the `Ref_theme_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Ref_theme_bool_expRaw =
    { and_ : OptionalArgument (List Ref_theme_bool_exp)
    , not_ : OptionalArgument Ref_theme_bool_exp
    , or_ : OptionalArgument (List Ref_theme_bool_exp)
    , label : OptionalArgument String_comparison_exp
    , name : OptionalArgument String_comparison_exp
    }


{-| Type for the Ref\_theme\_bool\_exp input object.
-}
type Ref_theme_bool_exp
    = Ref_theme_bool_exp Ref_theme_bool_expRaw


{-| Encode a Ref\_theme\_bool\_exp into a value that can be used as an argument.
-}
encodeRef_theme_bool_exp : Ref_theme_bool_exp -> Value
encodeRef_theme_bool_exp (Ref_theme_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeRef_theme_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeRef_theme_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeRef_theme_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "label", encodeString_comparison_exp |> Encode.optional input____.label ), ( "name", encodeString_comparison_exp |> Encode.optional input____.name ) ]


buildRef_theme_insert_input :
    (Ref_theme_insert_inputOptionalFields -> Ref_theme_insert_inputOptionalFields)
    -> Ref_theme_insert_input
buildRef_theme_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { label = Absent, name = Absent }
    in
    { label = optionals____.label, name = optionals____.name }


type alias Ref_theme_insert_inputOptionalFields =
    { label : OptionalArgument String
    , name : OptionalArgument String
    }


{-| Type for the Ref\_theme\_insert\_input input object.
-}
type alias Ref_theme_insert_input =
    { label : OptionalArgument String
    , name : OptionalArgument String
    }


{-| Encode a Ref\_theme\_insert\_input into a value that can be used as an argument.
-}
encodeRef_theme_insert_input : Ref_theme_insert_input -> Value
encodeRef_theme_insert_input input____ =
    Encode.maybeObject
        [ ( "label", Encode.string |> Encode.optional input____.label ), ( "name", Encode.string |> Encode.optional input____.name ) ]


buildRef_theme_obj_rel_insert_input :
    Ref_theme_obj_rel_insert_inputRequiredFields
    -> (Ref_theme_obj_rel_insert_inputOptionalFields -> Ref_theme_obj_rel_insert_inputOptionalFields)
    -> Ref_theme_obj_rel_insert_input
buildRef_theme_obj_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Ref_theme_obj_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Ref_theme_obj_rel_insert_inputRequiredFields =
    { data : Ref_theme_insert_input }


type alias Ref_theme_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Ref_theme_on_conflict }


{-| Type alias for the `Ref_theme_obj_rel_insert_input` attributes. Note that this type
needs to use the `Ref_theme_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Ref_theme_obj_rel_insert_inputRaw =
    { data : Ref_theme_insert_input
    , on_conflict : OptionalArgument Ref_theme_on_conflict
    }


{-| Type for the Ref\_theme\_obj\_rel\_insert\_input input object.
-}
type Ref_theme_obj_rel_insert_input
    = Ref_theme_obj_rel_insert_input Ref_theme_obj_rel_insert_inputRaw


{-| Encode a Ref\_theme\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeRef_theme_obj_rel_insert_input : Ref_theme_obj_rel_insert_input -> Value
encodeRef_theme_obj_rel_insert_input (Ref_theme_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeRef_theme_insert_input input____.data |> Just ), ( "on_conflict", encodeRef_theme_on_conflict |> Encode.optional input____.on_conflict ) ]


buildRef_theme_on_conflict :
    Ref_theme_on_conflictRequiredFields
    -> (Ref_theme_on_conflictOptionalFields -> Ref_theme_on_conflictOptionalFields)
    -> Ref_theme_on_conflict
buildRef_theme_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Ref_theme_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Ref_theme_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Ref_theme_constraint.Ref_theme_constraint
    , update_columns : List CdbGQL.Enum.Ref_theme_update_column.Ref_theme_update_column
    }


type alias Ref_theme_on_conflictOptionalFields =
    { where_ : OptionalArgument Ref_theme_bool_exp }


{-| Type alias for the `Ref_theme_on_conflict` attributes. Note that this type
needs to use the `Ref_theme_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Ref_theme_on_conflictRaw =
    { constraint : CdbGQL.Enum.Ref_theme_constraint.Ref_theme_constraint
    , update_columns : List CdbGQL.Enum.Ref_theme_update_column.Ref_theme_update_column
    , where_ : OptionalArgument Ref_theme_bool_exp
    }


{-| Type for the Ref\_theme\_on\_conflict input object.
-}
type Ref_theme_on_conflict
    = Ref_theme_on_conflict Ref_theme_on_conflictRaw


{-| Encode a Ref\_theme\_on\_conflict into a value that can be used as an argument.
-}
encodeRef_theme_on_conflict : Ref_theme_on_conflict -> Value
encodeRef_theme_on_conflict (Ref_theme_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Ref_theme_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Ref_theme_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeRef_theme_bool_exp |> Encode.optional input____.where_ ) ]


buildRef_theme_order_by :
    (Ref_theme_order_byOptionalFields -> Ref_theme_order_byOptionalFields)
    -> Ref_theme_order_by
buildRef_theme_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { label = Absent, name = Absent }
    in
    { label = optionals____.label, name = optionals____.name }


type alias Ref_theme_order_byOptionalFields =
    { label : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , name : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Ref\_theme\_order\_by input object.
-}
type alias Ref_theme_order_by =
    { label : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , name : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Ref\_theme\_order\_by into a value that can be used as an argument.
-}
encodeRef_theme_order_by : Ref_theme_order_by -> Value
encodeRef_theme_order_by input____ =
    Encode.maybeObject
        [ ( "label", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.label ), ( "name", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.name ) ]


buildRef_theme_pk_columns_input :
    Ref_theme_pk_columns_inputRequiredFields
    -> Ref_theme_pk_columns_input
buildRef_theme_pk_columns_input required____ =
    { name = required____.name }


type alias Ref_theme_pk_columns_inputRequiredFields =
    { name : String }


{-| Type for the Ref\_theme\_pk\_columns\_input input object.
-}
type alias Ref_theme_pk_columns_input =
    { name : String }


{-| Encode a Ref\_theme\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeRef_theme_pk_columns_input : Ref_theme_pk_columns_input -> Value
encodeRef_theme_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "name", Encode.string input____.name |> Just ) ]


buildRef_theme_set_input :
    (Ref_theme_set_inputOptionalFields -> Ref_theme_set_inputOptionalFields)
    -> Ref_theme_set_input
buildRef_theme_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { label = Absent, name = Absent }
    in
    { label = optionals____.label, name = optionals____.name }


type alias Ref_theme_set_inputOptionalFields =
    { label : OptionalArgument String
    , name : OptionalArgument String
    }


{-| Type for the Ref\_theme\_set\_input input object.
-}
type alias Ref_theme_set_input =
    { label : OptionalArgument String
    , name : OptionalArgument String
    }


{-| Encode a Ref\_theme\_set\_input into a value that can be used as an argument.
-}
encodeRef_theme_set_input : Ref_theme_set_input -> Value
encodeRef_theme_set_input input____ =
    Encode.maybeObject
        [ ( "label", Encode.string |> Encode.optional input____.label ), ( "name", Encode.string |> Encode.optional input____.name ) ]


buildRef_theme_stream_cursor_input :
    Ref_theme_stream_cursor_inputRequiredFields
    -> (Ref_theme_stream_cursor_inputOptionalFields -> Ref_theme_stream_cursor_inputOptionalFields)
    -> Ref_theme_stream_cursor_input
buildRef_theme_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Ref_theme_stream_cursor_inputRequiredFields =
    { initial_value : Ref_theme_stream_cursor_value_input }


type alias Ref_theme_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Ref\_theme\_stream\_cursor\_input input object.
-}
type alias Ref_theme_stream_cursor_input =
    { initial_value : Ref_theme_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Ref\_theme\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeRef_theme_stream_cursor_input : Ref_theme_stream_cursor_input -> Value
encodeRef_theme_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeRef_theme_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildRef_theme_stream_cursor_value_input :
    (Ref_theme_stream_cursor_value_inputOptionalFields -> Ref_theme_stream_cursor_value_inputOptionalFields)
    -> Ref_theme_stream_cursor_value_input
buildRef_theme_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { label = Absent, name = Absent }
    in
    { label = optionals____.label, name = optionals____.name }


type alias Ref_theme_stream_cursor_value_inputOptionalFields =
    { label : OptionalArgument String
    , name : OptionalArgument String
    }


{-| Type for the Ref\_theme\_stream\_cursor\_value\_input input object.
-}
type alias Ref_theme_stream_cursor_value_input =
    { label : OptionalArgument String
    , name : OptionalArgument String
    }


{-| Encode a Ref\_theme\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeRef_theme_stream_cursor_value_input : Ref_theme_stream_cursor_value_input -> Value
encodeRef_theme_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "label", Encode.string |> Encode.optional input____.label ), ( "name", Encode.string |> Encode.optional input____.name ) ]


buildRef_theme_updates :
    Ref_theme_updatesRequiredFields
    -> (Ref_theme_updatesOptionalFields -> Ref_theme_updatesOptionalFields)
    -> Ref_theme_updates
buildRef_theme_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Ref_theme_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Ref_theme_updatesRequiredFields =
    { where_ : Ref_theme_bool_exp }


type alias Ref_theme_updatesOptionalFields =
    { set_ : OptionalArgument Ref_theme_set_input }


{-| Type alias for the `Ref_theme_updates` attributes. Note that this type
needs to use the `Ref_theme_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Ref_theme_updatesRaw =
    { set_ : OptionalArgument Ref_theme_set_input
    , where_ : Ref_theme_bool_exp
    }


{-| Type for the Ref\_theme\_updates input object.
-}
type Ref_theme_updates
    = Ref_theme_updates Ref_theme_updatesRaw


{-| Encode a Ref\_theme\_updates into a value that can be used as an argument.
-}
encodeRef_theme_updates : Ref_theme_updates -> Value
encodeRef_theme_updates (Ref_theme_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeRef_theme_set_input |> Encode.optional input____.set_ ), ( "where", encodeRef_theme_bool_exp input____.where_ |> Just ) ]


buildRole_bool_exp :
    (Role_bool_expOptionalFields -> Role_bool_expOptionalFields)
    -> Role_bool_exp
buildRole_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, accounts = Absent, accounts_aggregate = Absent, label = Absent }
    in
    Role_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, accounts = optionals____.accounts, accounts_aggregate = optionals____.accounts_aggregate, label = optionals____.label }


type alias Role_bool_expOptionalFields =
    { and_ : OptionalArgument (List Role_bool_exp)
    , not_ : OptionalArgument Role_bool_exp
    , or_ : OptionalArgument (List Role_bool_exp)
    , accounts : OptionalArgument Account_bool_exp
    , accounts_aggregate : OptionalArgument Account_aggregate_bool_exp
    , label : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Role_bool_exp` attributes. Note that this type
needs to use the `Role_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Role_bool_expRaw =
    { and_ : OptionalArgument (List Role_bool_exp)
    , not_ : OptionalArgument Role_bool_exp
    , or_ : OptionalArgument (List Role_bool_exp)
    , accounts : OptionalArgument Account_bool_exp
    , accounts_aggregate : OptionalArgument Account_aggregate_bool_exp
    , label : OptionalArgument String_comparison_exp
    }


{-| Type for the Role\_bool\_exp input object.
-}
type Role_bool_exp
    = Role_bool_exp Role_bool_expRaw


{-| Encode a Role\_bool\_exp into a value that can be used as an argument.
-}
encodeRole_bool_exp : Role_bool_exp -> Value
encodeRole_bool_exp (Role_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeRole_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeRole_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeRole_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "accounts", encodeAccount_bool_exp |> Encode.optional input____.accounts ), ( "accounts_aggregate", encodeAccount_aggregate_bool_exp |> Encode.optional input____.accounts_aggregate ), ( "label", encodeString_comparison_exp |> Encode.optional input____.label ) ]


buildRole_enum_comparison_exp :
    (Role_enum_comparison_expOptionalFields -> Role_enum_comparison_expOptionalFields)
    -> Role_enum_comparison_exp
buildRole_enum_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, in_ = Absent, is_null_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals____.eq_, in_ = optionals____.in_, is_null_ = optionals____.is_null_, neq_ = optionals____.neq_, nin_ = optionals____.nin_ }


type alias Role_enum_comparison_expOptionalFields =
    { eq_ : OptionalArgument CdbGQL.Enum.Role_enum.Role_enum
    , in_ : OptionalArgument (List CdbGQL.Enum.Role_enum.Role_enum)
    , is_null_ : OptionalArgument Bool
    , neq_ : OptionalArgument CdbGQL.Enum.Role_enum.Role_enum
    , nin_ : OptionalArgument (List CdbGQL.Enum.Role_enum.Role_enum)
    }


{-| Type for the Role\_enum\_comparison\_exp input object.
-}
type alias Role_enum_comparison_exp =
    { eq_ : OptionalArgument CdbGQL.Enum.Role_enum.Role_enum
    , in_ : OptionalArgument (List CdbGQL.Enum.Role_enum.Role_enum)
    , is_null_ : OptionalArgument Bool
    , neq_ : OptionalArgument CdbGQL.Enum.Role_enum.Role_enum
    , nin_ : OptionalArgument (List CdbGQL.Enum.Role_enum.Role_enum)
    }


{-| Encode a Role\_enum\_comparison\_exp into a value that can be used as an argument.
-}
encodeRole_enum_comparison_exp : Role_enum_comparison_exp -> Value
encodeRole_enum_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", Encode.enum CdbGQL.Enum.Role_enum.toString |> Encode.optional input____.eq_ ), ( "_in", (Encode.enum CdbGQL.Enum.Role_enum.toString |> Encode.list) |> Encode.optional input____.in_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_neq", Encode.enum CdbGQL.Enum.Role_enum.toString |> Encode.optional input____.neq_ ), ( "_nin", (Encode.enum CdbGQL.Enum.Role_enum.toString |> Encode.list) |> Encode.optional input____.nin_ ) ]


buildRole_insert_input :
    (Role_insert_inputOptionalFields -> Role_insert_inputOptionalFields)
    -> Role_insert_input
buildRole_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { accounts = Absent, label = Absent }
    in
    Role_insert_input { accounts = optionals____.accounts, label = optionals____.label }


type alias Role_insert_inputOptionalFields =
    { accounts : OptionalArgument Account_arr_rel_insert_input
    , label : OptionalArgument String
    }


{-| Type alias for the `Role_insert_input` attributes. Note that this type
needs to use the `Role_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Role_insert_inputRaw =
    { accounts : OptionalArgument Account_arr_rel_insert_input
    , label : OptionalArgument String
    }


{-| Type for the Role\_insert\_input input object.
-}
type Role_insert_input
    = Role_insert_input Role_insert_inputRaw


{-| Encode a Role\_insert\_input into a value that can be used as an argument.
-}
encodeRole_insert_input : Role_insert_input -> Value
encodeRole_insert_input (Role_insert_input input____) =
    Encode.maybeObject
        [ ( "accounts", encodeAccount_arr_rel_insert_input |> Encode.optional input____.accounts ), ( "label", Encode.string |> Encode.optional input____.label ) ]


buildRole_obj_rel_insert_input :
    Role_obj_rel_insert_inputRequiredFields
    -> (Role_obj_rel_insert_inputOptionalFields -> Role_obj_rel_insert_inputOptionalFields)
    -> Role_obj_rel_insert_input
buildRole_obj_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Role_obj_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Role_obj_rel_insert_inputRequiredFields =
    { data : Role_insert_input }


type alias Role_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Role_on_conflict }


{-| Type alias for the `Role_obj_rel_insert_input` attributes. Note that this type
needs to use the `Role_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Role_obj_rel_insert_inputRaw =
    { data : Role_insert_input
    , on_conflict : OptionalArgument Role_on_conflict
    }


{-| Type for the Role\_obj\_rel\_insert\_input input object.
-}
type Role_obj_rel_insert_input
    = Role_obj_rel_insert_input Role_obj_rel_insert_inputRaw


{-| Encode a Role\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeRole_obj_rel_insert_input : Role_obj_rel_insert_input -> Value
encodeRole_obj_rel_insert_input (Role_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeRole_insert_input input____.data |> Just ), ( "on_conflict", encodeRole_on_conflict |> Encode.optional input____.on_conflict ) ]


buildRole_on_conflict :
    Role_on_conflictRequiredFields
    -> (Role_on_conflictOptionalFields -> Role_on_conflictOptionalFields)
    -> Role_on_conflict
buildRole_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Role_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Role_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Role_constraint.Role_constraint
    , update_columns : List CdbGQL.Enum.Role_update_column.Role_update_column
    }


type alias Role_on_conflictOptionalFields =
    { where_ : OptionalArgument Role_bool_exp }


{-| Type alias for the `Role_on_conflict` attributes. Note that this type
needs to use the `Role_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Role_on_conflictRaw =
    { constraint : CdbGQL.Enum.Role_constraint.Role_constraint
    , update_columns : List CdbGQL.Enum.Role_update_column.Role_update_column
    , where_ : OptionalArgument Role_bool_exp
    }


{-| Type for the Role\_on\_conflict input object.
-}
type Role_on_conflict
    = Role_on_conflict Role_on_conflictRaw


{-| Encode a Role\_on\_conflict into a value that can be used as an argument.
-}
encodeRole_on_conflict : Role_on_conflict -> Value
encodeRole_on_conflict (Role_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Role_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Role_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeRole_bool_exp |> Encode.optional input____.where_ ) ]


buildRole_order_by :
    (Role_order_byOptionalFields -> Role_order_byOptionalFields)
    -> Role_order_by
buildRole_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { accounts_aggregate = Absent, label = Absent }
    in
    { accounts_aggregate = optionals____.accounts_aggregate, label = optionals____.label }


type alias Role_order_byOptionalFields =
    { accounts_aggregate : OptionalArgument Account_aggregate_order_by
    , label : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Role\_order\_by input object.
-}
type alias Role_order_by =
    { accounts_aggregate : OptionalArgument Account_aggregate_order_by
    , label : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Role\_order\_by into a value that can be used as an argument.
-}
encodeRole_order_by : Role_order_by -> Value
encodeRole_order_by input____ =
    Encode.maybeObject
        [ ( "accounts_aggregate", encodeAccount_aggregate_order_by |> Encode.optional input____.accounts_aggregate ), ( "label", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.label ) ]


buildRole_pk_columns_input :
    Role_pk_columns_inputRequiredFields
    -> Role_pk_columns_input
buildRole_pk_columns_input required____ =
    { label = required____.label }


type alias Role_pk_columns_inputRequiredFields =
    { label : String }


{-| Type for the Role\_pk\_columns\_input input object.
-}
type alias Role_pk_columns_input =
    { label : String }


{-| Encode a Role\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeRole_pk_columns_input : Role_pk_columns_input -> Value
encodeRole_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "label", Encode.string input____.label |> Just ) ]


buildRole_set_input :
    (Role_set_inputOptionalFields -> Role_set_inputOptionalFields)
    -> Role_set_input
buildRole_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { label = Absent }
    in
    { label = optionals____.label }


type alias Role_set_inputOptionalFields =
    { label : OptionalArgument String }


{-| Type for the Role\_set\_input input object.
-}
type alias Role_set_input =
    { label : OptionalArgument String }


{-| Encode a Role\_set\_input into a value that can be used as an argument.
-}
encodeRole_set_input : Role_set_input -> Value
encodeRole_set_input input____ =
    Encode.maybeObject
        [ ( "label", Encode.string |> Encode.optional input____.label ) ]


buildRole_stream_cursor_input :
    Role_stream_cursor_inputRequiredFields
    -> (Role_stream_cursor_inputOptionalFields -> Role_stream_cursor_inputOptionalFields)
    -> Role_stream_cursor_input
buildRole_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Role_stream_cursor_inputRequiredFields =
    { initial_value : Role_stream_cursor_value_input }


type alias Role_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Role\_stream\_cursor\_input input object.
-}
type alias Role_stream_cursor_input =
    { initial_value : Role_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Role\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeRole_stream_cursor_input : Role_stream_cursor_input -> Value
encodeRole_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeRole_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildRole_stream_cursor_value_input :
    (Role_stream_cursor_value_inputOptionalFields -> Role_stream_cursor_value_inputOptionalFields)
    -> Role_stream_cursor_value_input
buildRole_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { label = Absent }
    in
    { label = optionals____.label }


type alias Role_stream_cursor_value_inputOptionalFields =
    { label : OptionalArgument String }


{-| Type for the Role\_stream\_cursor\_value\_input input object.
-}
type alias Role_stream_cursor_value_input =
    { label : OptionalArgument String }


{-| Encode a Role\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeRole_stream_cursor_value_input : Role_stream_cursor_value_input -> Value
encodeRole_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "label", Encode.string |> Encode.optional input____.label ) ]


buildRole_updates :
    Role_updatesRequiredFields
    -> (Role_updatesOptionalFields -> Role_updatesOptionalFields)
    -> Role_updates
buildRole_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Role_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Role_updatesRequiredFields =
    { where_ : Role_bool_exp }


type alias Role_updatesOptionalFields =
    { set_ : OptionalArgument Role_set_input }


{-| Type alias for the `Role_updates` attributes. Note that this type
needs to use the `Role_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Role_updatesRaw =
    { set_ : OptionalArgument Role_set_input
    , where_ : Role_bool_exp
    }


{-| Type for the Role\_updates input object.
-}
type Role_updates
    = Role_updates Role_updatesRaw


{-| Encode a Role\_updates into a value that can be used as an argument.
-}
encodeRole_updates : Role_updates -> Value
encodeRole_updates (Role_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeRole_set_input |> Encode.optional input____.set_ ), ( "where", encodeRole_bool_exp input____.where_ |> Just ) ]


buildRome_code_bool_exp :
    (Rome_code_bool_expOptionalFields -> Rome_code_bool_expOptionalFields)
    -> Rome_code_bool_exp
buildRome_code_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, code = Absent, description = Absent, id = Absent, label = Absent, professionalProjects = Absent, professionalProjects_aggregate = Absent }
    in
    Rome_code_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, code = optionals____.code, description = optionals____.description, id = optionals____.id, label = optionals____.label, professionalProjects = optionals____.professionalProjects, professionalProjects_aggregate = optionals____.professionalProjects_aggregate }


type alias Rome_code_bool_expOptionalFields =
    { and_ : OptionalArgument (List Rome_code_bool_exp)
    , not_ : OptionalArgument Rome_code_bool_exp
    , or_ : OptionalArgument (List Rome_code_bool_exp)
    , code : OptionalArgument String_comparison_exp
    , description : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , label : OptionalArgument String_comparison_exp
    , professionalProjects : OptionalArgument Professional_project_bool_exp
    , professionalProjects_aggregate : OptionalArgument Professional_project_aggregate_bool_exp
    }


{-| Type alias for the `Rome_code_bool_exp` attributes. Note that this type
needs to use the `Rome_code_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Rome_code_bool_expRaw =
    { and_ : OptionalArgument (List Rome_code_bool_exp)
    , not_ : OptionalArgument Rome_code_bool_exp
    , or_ : OptionalArgument (List Rome_code_bool_exp)
    , code : OptionalArgument String_comparison_exp
    , description : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , label : OptionalArgument String_comparison_exp
    , professionalProjects : OptionalArgument Professional_project_bool_exp
    , professionalProjects_aggregate : OptionalArgument Professional_project_aggregate_bool_exp
    }


{-| Type for the Rome\_code\_bool\_exp input object.
-}
type Rome_code_bool_exp
    = Rome_code_bool_exp Rome_code_bool_expRaw


{-| Encode a Rome\_code\_bool\_exp into a value that can be used as an argument.
-}
encodeRome_code_bool_exp : Rome_code_bool_exp -> Value
encodeRome_code_bool_exp (Rome_code_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeRome_code_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeRome_code_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeRome_code_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "code", encodeString_comparison_exp |> Encode.optional input____.code ), ( "description", encodeString_comparison_exp |> Encode.optional input____.description ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "label", encodeString_comparison_exp |> Encode.optional input____.label ), ( "professionalProjects", encodeProfessional_project_bool_exp |> Encode.optional input____.professionalProjects ), ( "professionalProjects_aggregate", encodeProfessional_project_aggregate_bool_exp |> Encode.optional input____.professionalProjects_aggregate ) ]


buildRome_code_insert_input :
    (Rome_code_insert_inputOptionalFields -> Rome_code_insert_inputOptionalFields)
    -> Rome_code_insert_input
buildRome_code_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { code = Absent, description = Absent, id = Absent, label = Absent, professionalProjects = Absent }
    in
    Rome_code_insert_input { code = optionals____.code, description = optionals____.description, id = optionals____.id, label = optionals____.label, professionalProjects = optionals____.professionalProjects }


type alias Rome_code_insert_inputOptionalFields =
    { code : OptionalArgument String
    , description : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , label : OptionalArgument String
    , professionalProjects : OptionalArgument Professional_project_arr_rel_insert_input
    }


{-| Type alias for the `Rome_code_insert_input` attributes. Note that this type
needs to use the `Rome_code_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Rome_code_insert_inputRaw =
    { code : OptionalArgument String
    , description : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , label : OptionalArgument String
    , professionalProjects : OptionalArgument Professional_project_arr_rel_insert_input
    }


{-| Type for the Rome\_code\_insert\_input input object.
-}
type Rome_code_insert_input
    = Rome_code_insert_input Rome_code_insert_inputRaw


{-| Encode a Rome\_code\_insert\_input into a value that can be used as an argument.
-}
encodeRome_code_insert_input : Rome_code_insert_input -> Value
encodeRome_code_insert_input (Rome_code_insert_input input____) =
    Encode.maybeObject
        [ ( "code", Encode.string |> Encode.optional input____.code ), ( "description", Encode.string |> Encode.optional input____.description ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "label", Encode.string |> Encode.optional input____.label ), ( "professionalProjects", encodeProfessional_project_arr_rel_insert_input |> Encode.optional input____.professionalProjects ) ]


buildRome_code_obj_rel_insert_input :
    Rome_code_obj_rel_insert_inputRequiredFields
    -> (Rome_code_obj_rel_insert_inputOptionalFields -> Rome_code_obj_rel_insert_inputOptionalFields)
    -> Rome_code_obj_rel_insert_input
buildRome_code_obj_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Rome_code_obj_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Rome_code_obj_rel_insert_inputRequiredFields =
    { data : Rome_code_insert_input }


type alias Rome_code_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Rome_code_on_conflict }


{-| Type alias for the `Rome_code_obj_rel_insert_input` attributes. Note that this type
needs to use the `Rome_code_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Rome_code_obj_rel_insert_inputRaw =
    { data : Rome_code_insert_input
    , on_conflict : OptionalArgument Rome_code_on_conflict
    }


{-| Type for the Rome\_code\_obj\_rel\_insert\_input input object.
-}
type Rome_code_obj_rel_insert_input
    = Rome_code_obj_rel_insert_input Rome_code_obj_rel_insert_inputRaw


{-| Encode a Rome\_code\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeRome_code_obj_rel_insert_input : Rome_code_obj_rel_insert_input -> Value
encodeRome_code_obj_rel_insert_input (Rome_code_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeRome_code_insert_input input____.data |> Just ), ( "on_conflict", encodeRome_code_on_conflict |> Encode.optional input____.on_conflict ) ]


buildRome_code_on_conflict :
    Rome_code_on_conflictRequiredFields
    -> (Rome_code_on_conflictOptionalFields -> Rome_code_on_conflictOptionalFields)
    -> Rome_code_on_conflict
buildRome_code_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Rome_code_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Rome_code_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Rome_code_constraint.Rome_code_constraint
    , update_columns : List CdbGQL.Enum.Rome_code_update_column.Rome_code_update_column
    }


type alias Rome_code_on_conflictOptionalFields =
    { where_ : OptionalArgument Rome_code_bool_exp }


{-| Type alias for the `Rome_code_on_conflict` attributes. Note that this type
needs to use the `Rome_code_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Rome_code_on_conflictRaw =
    { constraint : CdbGQL.Enum.Rome_code_constraint.Rome_code_constraint
    , update_columns : List CdbGQL.Enum.Rome_code_update_column.Rome_code_update_column
    , where_ : OptionalArgument Rome_code_bool_exp
    }


{-| Type for the Rome\_code\_on\_conflict input object.
-}
type Rome_code_on_conflict
    = Rome_code_on_conflict Rome_code_on_conflictRaw


{-| Encode a Rome\_code\_on\_conflict into a value that can be used as an argument.
-}
encodeRome_code_on_conflict : Rome_code_on_conflict -> Value
encodeRome_code_on_conflict (Rome_code_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Rome_code_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Rome_code_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeRome_code_bool_exp |> Encode.optional input____.where_ ) ]


buildRome_code_order_by :
    (Rome_code_order_byOptionalFields -> Rome_code_order_byOptionalFields)
    -> Rome_code_order_by
buildRome_code_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { code = Absent, description = Absent, id = Absent, label = Absent, professionalProjects_aggregate = Absent }
    in
    { code = optionals____.code, description = optionals____.description, id = optionals____.id, label = optionals____.label, professionalProjects_aggregate = optionals____.professionalProjects_aggregate }


type alias Rome_code_order_byOptionalFields =
    { code : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , description : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , label : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , professionalProjects_aggregate : OptionalArgument Professional_project_aggregate_order_by
    }


{-| Type for the Rome\_code\_order\_by input object.
-}
type alias Rome_code_order_by =
    { code : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , description : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , label : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , professionalProjects_aggregate : OptionalArgument Professional_project_aggregate_order_by
    }


{-| Encode a Rome\_code\_order\_by into a value that can be used as an argument.
-}
encodeRome_code_order_by : Rome_code_order_by -> Value
encodeRome_code_order_by input____ =
    Encode.maybeObject
        [ ( "code", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.code ), ( "description", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.description ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "label", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.label ), ( "professionalProjects_aggregate", encodeProfessional_project_aggregate_order_by |> Encode.optional input____.professionalProjects_aggregate ) ]


buildRome_code_pk_columns_input :
    Rome_code_pk_columns_inputRequiredFields
    -> Rome_code_pk_columns_input
buildRome_code_pk_columns_input required____ =
    { id = required____.id }


type alias Rome_code_pk_columns_inputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the Rome\_code\_pk\_columns\_input input object.
-}
type alias Rome_code_pk_columns_input =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a Rome\_code\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeRome_code_pk_columns_input : Rome_code_pk_columns_input -> Value
encodeRome_code_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildRome_code_set_input :
    (Rome_code_set_inputOptionalFields -> Rome_code_set_inputOptionalFields)
    -> Rome_code_set_input
buildRome_code_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { code = Absent, description = Absent, id = Absent, label = Absent }
    in
    { code = optionals____.code, description = optionals____.description, id = optionals____.id, label = optionals____.label }


type alias Rome_code_set_inputOptionalFields =
    { code : OptionalArgument String
    , description : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , label : OptionalArgument String
    }


{-| Type for the Rome\_code\_set\_input input object.
-}
type alias Rome_code_set_input =
    { code : OptionalArgument String
    , description : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , label : OptionalArgument String
    }


{-| Encode a Rome\_code\_set\_input into a value that can be used as an argument.
-}
encodeRome_code_set_input : Rome_code_set_input -> Value
encodeRome_code_set_input input____ =
    Encode.maybeObject
        [ ( "code", Encode.string |> Encode.optional input____.code ), ( "description", Encode.string |> Encode.optional input____.description ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "label", Encode.string |> Encode.optional input____.label ) ]


buildRome_code_stream_cursor_input :
    Rome_code_stream_cursor_inputRequiredFields
    -> (Rome_code_stream_cursor_inputOptionalFields -> Rome_code_stream_cursor_inputOptionalFields)
    -> Rome_code_stream_cursor_input
buildRome_code_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Rome_code_stream_cursor_inputRequiredFields =
    { initial_value : Rome_code_stream_cursor_value_input }


type alias Rome_code_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Rome\_code\_stream\_cursor\_input input object.
-}
type alias Rome_code_stream_cursor_input =
    { initial_value : Rome_code_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Rome\_code\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeRome_code_stream_cursor_input : Rome_code_stream_cursor_input -> Value
encodeRome_code_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeRome_code_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildRome_code_stream_cursor_value_input :
    (Rome_code_stream_cursor_value_inputOptionalFields -> Rome_code_stream_cursor_value_inputOptionalFields)
    -> Rome_code_stream_cursor_value_input
buildRome_code_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { code = Absent, description = Absent, id = Absent, label = Absent }
    in
    { code = optionals____.code, description = optionals____.description, id = optionals____.id, label = optionals____.label }


type alias Rome_code_stream_cursor_value_inputOptionalFields =
    { code : OptionalArgument String
    , description : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , label : OptionalArgument String
    }


{-| Type for the Rome\_code\_stream\_cursor\_value\_input input object.
-}
type alias Rome_code_stream_cursor_value_input =
    { code : OptionalArgument String
    , description : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , label : OptionalArgument String
    }


{-| Encode a Rome\_code\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeRome_code_stream_cursor_value_input : Rome_code_stream_cursor_value_input -> Value
encodeRome_code_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "code", Encode.string |> Encode.optional input____.code ), ( "description", Encode.string |> Encode.optional input____.description ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "label", Encode.string |> Encode.optional input____.label ) ]


buildRome_code_updates :
    Rome_code_updatesRequiredFields
    -> (Rome_code_updatesOptionalFields -> Rome_code_updatesOptionalFields)
    -> Rome_code_updates
buildRome_code_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Rome_code_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Rome_code_updatesRequiredFields =
    { where_ : Rome_code_bool_exp }


type alias Rome_code_updatesOptionalFields =
    { set_ : OptionalArgument Rome_code_set_input }


{-| Type alias for the `Rome_code_updates` attributes. Note that this type
needs to use the `Rome_code_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Rome_code_updatesRaw =
    { set_ : OptionalArgument Rome_code_set_input
    , where_ : Rome_code_bool_exp
    }


{-| Type for the Rome\_code\_updates input object.
-}
type Rome_code_updates
    = Rome_code_updates Rome_code_updatesRaw


{-| Encode a Rome\_code\_updates into a value that can be used as an argument.
-}
encodeRome_code_updates : Rome_code_updates -> Value
encodeRome_code_updates (Rome_code_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeRome_code_set_input |> Encode.optional input____.set_ ), ( "where", encodeRome_code_bool_exp input____.where_ |> Just ) ]


buildRsa_closure_reason_bool_exp :
    (Rsa_closure_reason_bool_expOptionalFields -> Rsa_closure_reason_bool_expOptionalFields)
    -> Rsa_closure_reason_bool_exp
buildRsa_closure_reason_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, code = Absent, label = Absent }
    in
    Rsa_closure_reason_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, code = optionals____.code, label = optionals____.label }


type alias Rsa_closure_reason_bool_expOptionalFields =
    { and_ : OptionalArgument (List Rsa_closure_reason_bool_exp)
    , not_ : OptionalArgument Rsa_closure_reason_bool_exp
    , or_ : OptionalArgument (List Rsa_closure_reason_bool_exp)
    , code : OptionalArgument String_comparison_exp
    , label : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Rsa_closure_reason_bool_exp` attributes. Note that this type
needs to use the `Rsa_closure_reason_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Rsa_closure_reason_bool_expRaw =
    { and_ : OptionalArgument (List Rsa_closure_reason_bool_exp)
    , not_ : OptionalArgument Rsa_closure_reason_bool_exp
    , or_ : OptionalArgument (List Rsa_closure_reason_bool_exp)
    , code : OptionalArgument String_comparison_exp
    , label : OptionalArgument String_comparison_exp
    }


{-| Type for the Rsa\_closure\_reason\_bool\_exp input object.
-}
type Rsa_closure_reason_bool_exp
    = Rsa_closure_reason_bool_exp Rsa_closure_reason_bool_expRaw


{-| Encode a Rsa\_closure\_reason\_bool\_exp into a value that can be used as an argument.
-}
encodeRsa_closure_reason_bool_exp : Rsa_closure_reason_bool_exp -> Value
encodeRsa_closure_reason_bool_exp (Rsa_closure_reason_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeRsa_closure_reason_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeRsa_closure_reason_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeRsa_closure_reason_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "code", encodeString_comparison_exp |> Encode.optional input____.code ), ( "label", encodeString_comparison_exp |> Encode.optional input____.label ) ]


buildRsa_closure_reason_enum_comparison_exp :
    (Rsa_closure_reason_enum_comparison_expOptionalFields -> Rsa_closure_reason_enum_comparison_expOptionalFields)
    -> Rsa_closure_reason_enum_comparison_exp
buildRsa_closure_reason_enum_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, in_ = Absent, is_null_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals____.eq_, in_ = optionals____.in_, is_null_ = optionals____.is_null_, neq_ = optionals____.neq_, nin_ = optionals____.nin_ }


type alias Rsa_closure_reason_enum_comparison_expOptionalFields =
    { eq_ : OptionalArgument CdbGQL.Enum.Rsa_closure_reason_enum.Rsa_closure_reason_enum
    , in_ : OptionalArgument (List CdbGQL.Enum.Rsa_closure_reason_enum.Rsa_closure_reason_enum)
    , is_null_ : OptionalArgument Bool
    , neq_ : OptionalArgument CdbGQL.Enum.Rsa_closure_reason_enum.Rsa_closure_reason_enum
    , nin_ : OptionalArgument (List CdbGQL.Enum.Rsa_closure_reason_enum.Rsa_closure_reason_enum)
    }


{-| Type for the Rsa\_closure\_reason\_enum\_comparison\_exp input object.
-}
type alias Rsa_closure_reason_enum_comparison_exp =
    { eq_ : OptionalArgument CdbGQL.Enum.Rsa_closure_reason_enum.Rsa_closure_reason_enum
    , in_ : OptionalArgument (List CdbGQL.Enum.Rsa_closure_reason_enum.Rsa_closure_reason_enum)
    , is_null_ : OptionalArgument Bool
    , neq_ : OptionalArgument CdbGQL.Enum.Rsa_closure_reason_enum.Rsa_closure_reason_enum
    , nin_ : OptionalArgument (List CdbGQL.Enum.Rsa_closure_reason_enum.Rsa_closure_reason_enum)
    }


{-| Encode a Rsa\_closure\_reason\_enum\_comparison\_exp into a value that can be used as an argument.
-}
encodeRsa_closure_reason_enum_comparison_exp : Rsa_closure_reason_enum_comparison_exp -> Value
encodeRsa_closure_reason_enum_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", Encode.enum CdbGQL.Enum.Rsa_closure_reason_enum.toString |> Encode.optional input____.eq_ ), ( "_in", (Encode.enum CdbGQL.Enum.Rsa_closure_reason_enum.toString |> Encode.list) |> Encode.optional input____.in_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_neq", Encode.enum CdbGQL.Enum.Rsa_closure_reason_enum.toString |> Encode.optional input____.neq_ ), ( "_nin", (Encode.enum CdbGQL.Enum.Rsa_closure_reason_enum.toString |> Encode.list) |> Encode.optional input____.nin_ ) ]


buildRsa_closure_reason_insert_input :
    (Rsa_closure_reason_insert_inputOptionalFields -> Rsa_closure_reason_insert_inputOptionalFields)
    -> Rsa_closure_reason_insert_input
buildRsa_closure_reason_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { code = Absent, label = Absent }
    in
    { code = optionals____.code, label = optionals____.label }


type alias Rsa_closure_reason_insert_inputOptionalFields =
    { code : OptionalArgument String
    , label : OptionalArgument String
    }


{-| Type for the Rsa\_closure\_reason\_insert\_input input object.
-}
type alias Rsa_closure_reason_insert_input =
    { code : OptionalArgument String
    , label : OptionalArgument String
    }


{-| Encode a Rsa\_closure\_reason\_insert\_input into a value that can be used as an argument.
-}
encodeRsa_closure_reason_insert_input : Rsa_closure_reason_insert_input -> Value
encodeRsa_closure_reason_insert_input input____ =
    Encode.maybeObject
        [ ( "code", Encode.string |> Encode.optional input____.code ), ( "label", Encode.string |> Encode.optional input____.label ) ]


buildRsa_closure_reason_on_conflict :
    Rsa_closure_reason_on_conflictRequiredFields
    -> (Rsa_closure_reason_on_conflictOptionalFields -> Rsa_closure_reason_on_conflictOptionalFields)
    -> Rsa_closure_reason_on_conflict
buildRsa_closure_reason_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Rsa_closure_reason_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Rsa_closure_reason_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Rsa_closure_reason_constraint.Rsa_closure_reason_constraint
    , update_columns : List CdbGQL.Enum.Rsa_closure_reason_update_column.Rsa_closure_reason_update_column
    }


type alias Rsa_closure_reason_on_conflictOptionalFields =
    { where_ : OptionalArgument Rsa_closure_reason_bool_exp }


{-| Type alias for the `Rsa_closure_reason_on_conflict` attributes. Note that this type
needs to use the `Rsa_closure_reason_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Rsa_closure_reason_on_conflictRaw =
    { constraint : CdbGQL.Enum.Rsa_closure_reason_constraint.Rsa_closure_reason_constraint
    , update_columns : List CdbGQL.Enum.Rsa_closure_reason_update_column.Rsa_closure_reason_update_column
    , where_ : OptionalArgument Rsa_closure_reason_bool_exp
    }


{-| Type for the Rsa\_closure\_reason\_on\_conflict input object.
-}
type Rsa_closure_reason_on_conflict
    = Rsa_closure_reason_on_conflict Rsa_closure_reason_on_conflictRaw


{-| Encode a Rsa\_closure\_reason\_on\_conflict into a value that can be used as an argument.
-}
encodeRsa_closure_reason_on_conflict : Rsa_closure_reason_on_conflict -> Value
encodeRsa_closure_reason_on_conflict (Rsa_closure_reason_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Rsa_closure_reason_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Rsa_closure_reason_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeRsa_closure_reason_bool_exp |> Encode.optional input____.where_ ) ]


buildRsa_closure_reason_order_by :
    (Rsa_closure_reason_order_byOptionalFields -> Rsa_closure_reason_order_byOptionalFields)
    -> Rsa_closure_reason_order_by
buildRsa_closure_reason_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { code = Absent, label = Absent }
    in
    { code = optionals____.code, label = optionals____.label }


type alias Rsa_closure_reason_order_byOptionalFields =
    { code : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , label : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Rsa\_closure\_reason\_order\_by input object.
-}
type alias Rsa_closure_reason_order_by =
    { code : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , label : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Rsa\_closure\_reason\_order\_by into a value that can be used as an argument.
-}
encodeRsa_closure_reason_order_by : Rsa_closure_reason_order_by -> Value
encodeRsa_closure_reason_order_by input____ =
    Encode.maybeObject
        [ ( "code", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.code ), ( "label", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.label ) ]


buildRsa_closure_reason_pk_columns_input :
    Rsa_closure_reason_pk_columns_inputRequiredFields
    -> Rsa_closure_reason_pk_columns_input
buildRsa_closure_reason_pk_columns_input required____ =
    { code = required____.code }


type alias Rsa_closure_reason_pk_columns_inputRequiredFields =
    { code : String }


{-| Type for the Rsa\_closure\_reason\_pk\_columns\_input input object.
-}
type alias Rsa_closure_reason_pk_columns_input =
    { code : String }


{-| Encode a Rsa\_closure\_reason\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeRsa_closure_reason_pk_columns_input : Rsa_closure_reason_pk_columns_input -> Value
encodeRsa_closure_reason_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "code", Encode.string input____.code |> Just ) ]


buildRsa_closure_reason_set_input :
    (Rsa_closure_reason_set_inputOptionalFields -> Rsa_closure_reason_set_inputOptionalFields)
    -> Rsa_closure_reason_set_input
buildRsa_closure_reason_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { code = Absent, label = Absent }
    in
    { code = optionals____.code, label = optionals____.label }


type alias Rsa_closure_reason_set_inputOptionalFields =
    { code : OptionalArgument String
    , label : OptionalArgument String
    }


{-| Type for the Rsa\_closure\_reason\_set\_input input object.
-}
type alias Rsa_closure_reason_set_input =
    { code : OptionalArgument String
    , label : OptionalArgument String
    }


{-| Encode a Rsa\_closure\_reason\_set\_input into a value that can be used as an argument.
-}
encodeRsa_closure_reason_set_input : Rsa_closure_reason_set_input -> Value
encodeRsa_closure_reason_set_input input____ =
    Encode.maybeObject
        [ ( "code", Encode.string |> Encode.optional input____.code ), ( "label", Encode.string |> Encode.optional input____.label ) ]


buildRsa_closure_reason_stream_cursor_input :
    Rsa_closure_reason_stream_cursor_inputRequiredFields
    -> (Rsa_closure_reason_stream_cursor_inputOptionalFields -> Rsa_closure_reason_stream_cursor_inputOptionalFields)
    -> Rsa_closure_reason_stream_cursor_input
buildRsa_closure_reason_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Rsa_closure_reason_stream_cursor_inputRequiredFields =
    { initial_value : Rsa_closure_reason_stream_cursor_value_input }


type alias Rsa_closure_reason_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Rsa\_closure\_reason\_stream\_cursor\_input input object.
-}
type alias Rsa_closure_reason_stream_cursor_input =
    { initial_value : Rsa_closure_reason_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Rsa\_closure\_reason\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeRsa_closure_reason_stream_cursor_input : Rsa_closure_reason_stream_cursor_input -> Value
encodeRsa_closure_reason_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeRsa_closure_reason_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildRsa_closure_reason_stream_cursor_value_input :
    (Rsa_closure_reason_stream_cursor_value_inputOptionalFields -> Rsa_closure_reason_stream_cursor_value_inputOptionalFields)
    -> Rsa_closure_reason_stream_cursor_value_input
buildRsa_closure_reason_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { code = Absent, label = Absent }
    in
    { code = optionals____.code, label = optionals____.label }


type alias Rsa_closure_reason_stream_cursor_value_inputOptionalFields =
    { code : OptionalArgument String
    , label : OptionalArgument String
    }


{-| Type for the Rsa\_closure\_reason\_stream\_cursor\_value\_input input object.
-}
type alias Rsa_closure_reason_stream_cursor_value_input =
    { code : OptionalArgument String
    , label : OptionalArgument String
    }


{-| Encode a Rsa\_closure\_reason\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeRsa_closure_reason_stream_cursor_value_input : Rsa_closure_reason_stream_cursor_value_input -> Value
encodeRsa_closure_reason_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "code", Encode.string |> Encode.optional input____.code ), ( "label", Encode.string |> Encode.optional input____.label ) ]


buildRsa_closure_reason_updates :
    Rsa_closure_reason_updatesRequiredFields
    -> (Rsa_closure_reason_updatesOptionalFields -> Rsa_closure_reason_updatesOptionalFields)
    -> Rsa_closure_reason_updates
buildRsa_closure_reason_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Rsa_closure_reason_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Rsa_closure_reason_updatesRequiredFields =
    { where_ : Rsa_closure_reason_bool_exp }


type alias Rsa_closure_reason_updatesOptionalFields =
    { set_ : OptionalArgument Rsa_closure_reason_set_input }


{-| Type alias for the `Rsa_closure_reason_updates` attributes. Note that this type
needs to use the `Rsa_closure_reason_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Rsa_closure_reason_updatesRaw =
    { set_ : OptionalArgument Rsa_closure_reason_set_input
    , where_ : Rsa_closure_reason_bool_exp
    }


{-| Type for the Rsa\_closure\_reason\_updates input object.
-}
type Rsa_closure_reason_updates
    = Rsa_closure_reason_updates Rsa_closure_reason_updatesRaw


{-| Encode a Rsa\_closure\_reason\_updates into a value that can be used as an argument.
-}
encodeRsa_closure_reason_updates : Rsa_closure_reason_updates -> Value
encodeRsa_closure_reason_updates (Rsa_closure_reason_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeRsa_closure_reason_set_input |> Encode.optional input____.set_ ), ( "where", encodeRsa_closure_reason_bool_exp input____.where_ |> Just ) ]


buildRsa_suspension_reason_bool_exp :
    (Rsa_suspension_reason_bool_expOptionalFields -> Rsa_suspension_reason_bool_expOptionalFields)
    -> Rsa_suspension_reason_bool_exp
buildRsa_suspension_reason_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, code = Absent, label = Absent }
    in
    Rsa_suspension_reason_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, code = optionals____.code, label = optionals____.label }


type alias Rsa_suspension_reason_bool_expOptionalFields =
    { and_ : OptionalArgument (List Rsa_suspension_reason_bool_exp)
    , not_ : OptionalArgument Rsa_suspension_reason_bool_exp
    , or_ : OptionalArgument (List Rsa_suspension_reason_bool_exp)
    , code : OptionalArgument String_comparison_exp
    , label : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Rsa_suspension_reason_bool_exp` attributes. Note that this type
needs to use the `Rsa_suspension_reason_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Rsa_suspension_reason_bool_expRaw =
    { and_ : OptionalArgument (List Rsa_suspension_reason_bool_exp)
    , not_ : OptionalArgument Rsa_suspension_reason_bool_exp
    , or_ : OptionalArgument (List Rsa_suspension_reason_bool_exp)
    , code : OptionalArgument String_comparison_exp
    , label : OptionalArgument String_comparison_exp
    }


{-| Type for the Rsa\_suspension\_reason\_bool\_exp input object.
-}
type Rsa_suspension_reason_bool_exp
    = Rsa_suspension_reason_bool_exp Rsa_suspension_reason_bool_expRaw


{-| Encode a Rsa\_suspension\_reason\_bool\_exp into a value that can be used as an argument.
-}
encodeRsa_suspension_reason_bool_exp : Rsa_suspension_reason_bool_exp -> Value
encodeRsa_suspension_reason_bool_exp (Rsa_suspension_reason_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeRsa_suspension_reason_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeRsa_suspension_reason_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeRsa_suspension_reason_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "code", encodeString_comparison_exp |> Encode.optional input____.code ), ( "label", encodeString_comparison_exp |> Encode.optional input____.label ) ]


buildRsa_suspension_reason_enum_comparison_exp :
    (Rsa_suspension_reason_enum_comparison_expOptionalFields -> Rsa_suspension_reason_enum_comparison_expOptionalFields)
    -> Rsa_suspension_reason_enum_comparison_exp
buildRsa_suspension_reason_enum_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, in_ = Absent, is_null_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals____.eq_, in_ = optionals____.in_, is_null_ = optionals____.is_null_, neq_ = optionals____.neq_, nin_ = optionals____.nin_ }


type alias Rsa_suspension_reason_enum_comparison_expOptionalFields =
    { eq_ : OptionalArgument CdbGQL.Enum.Rsa_suspension_reason_enum.Rsa_suspension_reason_enum
    , in_ : OptionalArgument (List CdbGQL.Enum.Rsa_suspension_reason_enum.Rsa_suspension_reason_enum)
    , is_null_ : OptionalArgument Bool
    , neq_ : OptionalArgument CdbGQL.Enum.Rsa_suspension_reason_enum.Rsa_suspension_reason_enum
    , nin_ : OptionalArgument (List CdbGQL.Enum.Rsa_suspension_reason_enum.Rsa_suspension_reason_enum)
    }


{-| Type for the Rsa\_suspension\_reason\_enum\_comparison\_exp input object.
-}
type alias Rsa_suspension_reason_enum_comparison_exp =
    { eq_ : OptionalArgument CdbGQL.Enum.Rsa_suspension_reason_enum.Rsa_suspension_reason_enum
    , in_ : OptionalArgument (List CdbGQL.Enum.Rsa_suspension_reason_enum.Rsa_suspension_reason_enum)
    , is_null_ : OptionalArgument Bool
    , neq_ : OptionalArgument CdbGQL.Enum.Rsa_suspension_reason_enum.Rsa_suspension_reason_enum
    , nin_ : OptionalArgument (List CdbGQL.Enum.Rsa_suspension_reason_enum.Rsa_suspension_reason_enum)
    }


{-| Encode a Rsa\_suspension\_reason\_enum\_comparison\_exp into a value that can be used as an argument.
-}
encodeRsa_suspension_reason_enum_comparison_exp : Rsa_suspension_reason_enum_comparison_exp -> Value
encodeRsa_suspension_reason_enum_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", Encode.enum CdbGQL.Enum.Rsa_suspension_reason_enum.toString |> Encode.optional input____.eq_ ), ( "_in", (Encode.enum CdbGQL.Enum.Rsa_suspension_reason_enum.toString |> Encode.list) |> Encode.optional input____.in_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_neq", Encode.enum CdbGQL.Enum.Rsa_suspension_reason_enum.toString |> Encode.optional input____.neq_ ), ( "_nin", (Encode.enum CdbGQL.Enum.Rsa_suspension_reason_enum.toString |> Encode.list) |> Encode.optional input____.nin_ ) ]


buildRsa_suspension_reason_insert_input :
    (Rsa_suspension_reason_insert_inputOptionalFields -> Rsa_suspension_reason_insert_inputOptionalFields)
    -> Rsa_suspension_reason_insert_input
buildRsa_suspension_reason_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { code = Absent, label = Absent }
    in
    { code = optionals____.code, label = optionals____.label }


type alias Rsa_suspension_reason_insert_inputOptionalFields =
    { code : OptionalArgument String
    , label : OptionalArgument String
    }


{-| Type for the Rsa\_suspension\_reason\_insert\_input input object.
-}
type alias Rsa_suspension_reason_insert_input =
    { code : OptionalArgument String
    , label : OptionalArgument String
    }


{-| Encode a Rsa\_suspension\_reason\_insert\_input into a value that can be used as an argument.
-}
encodeRsa_suspension_reason_insert_input : Rsa_suspension_reason_insert_input -> Value
encodeRsa_suspension_reason_insert_input input____ =
    Encode.maybeObject
        [ ( "code", Encode.string |> Encode.optional input____.code ), ( "label", Encode.string |> Encode.optional input____.label ) ]


buildRsa_suspension_reason_on_conflict :
    Rsa_suspension_reason_on_conflictRequiredFields
    -> (Rsa_suspension_reason_on_conflictOptionalFields -> Rsa_suspension_reason_on_conflictOptionalFields)
    -> Rsa_suspension_reason_on_conflict
buildRsa_suspension_reason_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Rsa_suspension_reason_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Rsa_suspension_reason_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Rsa_suspension_reason_constraint.Rsa_suspension_reason_constraint
    , update_columns : List CdbGQL.Enum.Rsa_suspension_reason_update_column.Rsa_suspension_reason_update_column
    }


type alias Rsa_suspension_reason_on_conflictOptionalFields =
    { where_ : OptionalArgument Rsa_suspension_reason_bool_exp }


{-| Type alias for the `Rsa_suspension_reason_on_conflict` attributes. Note that this type
needs to use the `Rsa_suspension_reason_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Rsa_suspension_reason_on_conflictRaw =
    { constraint : CdbGQL.Enum.Rsa_suspension_reason_constraint.Rsa_suspension_reason_constraint
    , update_columns : List CdbGQL.Enum.Rsa_suspension_reason_update_column.Rsa_suspension_reason_update_column
    , where_ : OptionalArgument Rsa_suspension_reason_bool_exp
    }


{-| Type for the Rsa\_suspension\_reason\_on\_conflict input object.
-}
type Rsa_suspension_reason_on_conflict
    = Rsa_suspension_reason_on_conflict Rsa_suspension_reason_on_conflictRaw


{-| Encode a Rsa\_suspension\_reason\_on\_conflict into a value that can be used as an argument.
-}
encodeRsa_suspension_reason_on_conflict : Rsa_suspension_reason_on_conflict -> Value
encodeRsa_suspension_reason_on_conflict (Rsa_suspension_reason_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Rsa_suspension_reason_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Rsa_suspension_reason_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeRsa_suspension_reason_bool_exp |> Encode.optional input____.where_ ) ]


buildRsa_suspension_reason_order_by :
    (Rsa_suspension_reason_order_byOptionalFields -> Rsa_suspension_reason_order_byOptionalFields)
    -> Rsa_suspension_reason_order_by
buildRsa_suspension_reason_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { code = Absent, label = Absent }
    in
    { code = optionals____.code, label = optionals____.label }


type alias Rsa_suspension_reason_order_byOptionalFields =
    { code : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , label : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Rsa\_suspension\_reason\_order\_by input object.
-}
type alias Rsa_suspension_reason_order_by =
    { code : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , label : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Rsa\_suspension\_reason\_order\_by into a value that can be used as an argument.
-}
encodeRsa_suspension_reason_order_by : Rsa_suspension_reason_order_by -> Value
encodeRsa_suspension_reason_order_by input____ =
    Encode.maybeObject
        [ ( "code", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.code ), ( "label", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.label ) ]


buildRsa_suspension_reason_pk_columns_input :
    Rsa_suspension_reason_pk_columns_inputRequiredFields
    -> Rsa_suspension_reason_pk_columns_input
buildRsa_suspension_reason_pk_columns_input required____ =
    { code = required____.code }


type alias Rsa_suspension_reason_pk_columns_inputRequiredFields =
    { code : String }


{-| Type for the Rsa\_suspension\_reason\_pk\_columns\_input input object.
-}
type alias Rsa_suspension_reason_pk_columns_input =
    { code : String }


{-| Encode a Rsa\_suspension\_reason\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeRsa_suspension_reason_pk_columns_input : Rsa_suspension_reason_pk_columns_input -> Value
encodeRsa_suspension_reason_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "code", Encode.string input____.code |> Just ) ]


buildRsa_suspension_reason_set_input :
    (Rsa_suspension_reason_set_inputOptionalFields -> Rsa_suspension_reason_set_inputOptionalFields)
    -> Rsa_suspension_reason_set_input
buildRsa_suspension_reason_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { code = Absent, label = Absent }
    in
    { code = optionals____.code, label = optionals____.label }


type alias Rsa_suspension_reason_set_inputOptionalFields =
    { code : OptionalArgument String
    , label : OptionalArgument String
    }


{-| Type for the Rsa\_suspension\_reason\_set\_input input object.
-}
type alias Rsa_suspension_reason_set_input =
    { code : OptionalArgument String
    , label : OptionalArgument String
    }


{-| Encode a Rsa\_suspension\_reason\_set\_input into a value that can be used as an argument.
-}
encodeRsa_suspension_reason_set_input : Rsa_suspension_reason_set_input -> Value
encodeRsa_suspension_reason_set_input input____ =
    Encode.maybeObject
        [ ( "code", Encode.string |> Encode.optional input____.code ), ( "label", Encode.string |> Encode.optional input____.label ) ]


buildRsa_suspension_reason_stream_cursor_input :
    Rsa_suspension_reason_stream_cursor_inputRequiredFields
    -> (Rsa_suspension_reason_stream_cursor_inputOptionalFields -> Rsa_suspension_reason_stream_cursor_inputOptionalFields)
    -> Rsa_suspension_reason_stream_cursor_input
buildRsa_suspension_reason_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Rsa_suspension_reason_stream_cursor_inputRequiredFields =
    { initial_value : Rsa_suspension_reason_stream_cursor_value_input }


type alias Rsa_suspension_reason_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Rsa\_suspension\_reason\_stream\_cursor\_input input object.
-}
type alias Rsa_suspension_reason_stream_cursor_input =
    { initial_value : Rsa_suspension_reason_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Rsa\_suspension\_reason\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeRsa_suspension_reason_stream_cursor_input : Rsa_suspension_reason_stream_cursor_input -> Value
encodeRsa_suspension_reason_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeRsa_suspension_reason_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildRsa_suspension_reason_stream_cursor_value_input :
    (Rsa_suspension_reason_stream_cursor_value_inputOptionalFields -> Rsa_suspension_reason_stream_cursor_value_inputOptionalFields)
    -> Rsa_suspension_reason_stream_cursor_value_input
buildRsa_suspension_reason_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { code = Absent, label = Absent }
    in
    { code = optionals____.code, label = optionals____.label }


type alias Rsa_suspension_reason_stream_cursor_value_inputOptionalFields =
    { code : OptionalArgument String
    , label : OptionalArgument String
    }


{-| Type for the Rsa\_suspension\_reason\_stream\_cursor\_value\_input input object.
-}
type alias Rsa_suspension_reason_stream_cursor_value_input =
    { code : OptionalArgument String
    , label : OptionalArgument String
    }


{-| Encode a Rsa\_suspension\_reason\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeRsa_suspension_reason_stream_cursor_value_input : Rsa_suspension_reason_stream_cursor_value_input -> Value
encodeRsa_suspension_reason_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "code", Encode.string |> Encode.optional input____.code ), ( "label", Encode.string |> Encode.optional input____.label ) ]


buildRsa_suspension_reason_updates :
    Rsa_suspension_reason_updatesRequiredFields
    -> (Rsa_suspension_reason_updatesOptionalFields -> Rsa_suspension_reason_updatesOptionalFields)
    -> Rsa_suspension_reason_updates
buildRsa_suspension_reason_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Rsa_suspension_reason_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Rsa_suspension_reason_updatesRequiredFields =
    { where_ : Rsa_suspension_reason_bool_exp }


type alias Rsa_suspension_reason_updatesOptionalFields =
    { set_ : OptionalArgument Rsa_suspension_reason_set_input }


{-| Type alias for the `Rsa_suspension_reason_updates` attributes. Note that this type
needs to use the `Rsa_suspension_reason_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Rsa_suspension_reason_updatesRaw =
    { set_ : OptionalArgument Rsa_suspension_reason_set_input
    , where_ : Rsa_suspension_reason_bool_exp
    }


{-| Type for the Rsa\_suspension\_reason\_updates input object.
-}
type Rsa_suspension_reason_updates
    = Rsa_suspension_reason_updates Rsa_suspension_reason_updatesRaw


{-| Encode a Rsa\_suspension\_reason\_updates into a value that can be used as an argument.
-}
encodeRsa_suspension_reason_updates : Rsa_suspension_reason_updates -> Value
encodeRsa_suspension_reason_updates (Rsa_suspension_reason_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeRsa_suspension_reason_set_input |> Encode.optional input____.set_ ), ( "where", encodeRsa_suspension_reason_bool_exp input____.where_ |> Just ) ]


buildSearch_beneficiaries_args :
    (Search_beneficiaries_argsOptionalFields -> Search_beneficiaries_argsOptionalFields)
    -> Search_beneficiaries_args
buildSearch_beneficiaries_args fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { search = Absent }
    in
    { search = optionals____.search }


type alias Search_beneficiaries_argsOptionalFields =
    { search : OptionalArgument String }


{-| Type for the Search\_beneficiaries\_args input object.
-}
type alias Search_beneficiaries_args =
    { search : OptionalArgument String }


{-| Encode a Search\_beneficiaries\_args into a value that can be used as an argument.
-}
encodeSearch_beneficiaries_args : Search_beneficiaries_args -> Value
encodeSearch_beneficiaries_args input____ =
    Encode.maybeObject
        [ ( "search", Encode.string |> Encode.optional input____.search ) ]


buildSearch_notebook_members_args :
    (Search_notebook_members_argsOptionalFields -> Search_notebook_members_argsOptionalFields)
    -> Search_notebook_members_args
buildSearch_notebook_members_args fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { search = Absent }
    in
    { search = optionals____.search }


type alias Search_notebook_members_argsOptionalFields =
    { search : OptionalArgument String }


{-| Type for the Search\_notebook\_members\_args input object.
-}
type alias Search_notebook_members_args =
    { search : OptionalArgument String }


{-| Encode a Search\_notebook\_members\_args into a value that can be used as an argument.
-}
encodeSearch_notebook_members_args : Search_notebook_members_args -> Value
encodeSearch_notebook_members_args input____ =
    Encode.maybeObject
        [ ( "search", Encode.string |> Encode.optional input____.search ) ]


buildSearch_public_notebooks_args :
    (Search_public_notebooks_argsOptionalFields -> Search_public_notebooks_argsOptionalFields)
    -> Search_public_notebooks_args
buildSearch_public_notebooks_args fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { search = Absent }
    in
    { search = optionals____.search }


type alias Search_public_notebooks_argsOptionalFields =
    { search : OptionalArgument String }


{-| Type for the Search\_public\_notebooks\_args input object.
-}
type alias Search_public_notebooks_args =
    { search : OptionalArgument String }


{-| Encode a Search\_public\_notebooks\_args into a value that can be used as an argument.
-}
encodeSearch_public_notebooks_args : Search_public_notebooks_args -> Value
encodeSearch_public_notebooks_args input____ =
    Encode.maybeObject
        [ ( "search", Encode.string |> Encode.optional input____.search ) ]


buildSearch_ref_action_args :
    (Search_ref_action_argsOptionalFields -> Search_ref_action_argsOptionalFields)
    -> Search_ref_action_args
buildSearch_ref_action_args fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { search = Absent }
    in
    { search = optionals____.search }


type alias Search_ref_action_argsOptionalFields =
    { search : OptionalArgument String }


{-| Type for the Search\_ref\_action\_args input object.
-}
type alias Search_ref_action_args =
    { search : OptionalArgument String }


{-| Encode a Search\_ref\_action\_args into a value that can be used as an argument.
-}
encodeSearch_ref_action_args : Search_ref_action_args -> Value
encodeSearch_ref_action_args input____ =
    Encode.maybeObject
        [ ( "search", Encode.string |> Encode.optional input____.search ) ]


buildSearch_rome_codes_args :
    (Search_rome_codes_argsOptionalFields -> Search_rome_codes_argsOptionalFields)
    -> Search_rome_codes_args
buildSearch_rome_codes_args fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { search = Absent }
    in
    { search = optionals____.search }


type alias Search_rome_codes_argsOptionalFields =
    { search : OptionalArgument String }


{-| Type for the Search\_rome\_codes\_args input object.
-}
type alias Search_rome_codes_args =
    { search : OptionalArgument String }


{-| Encode a Search\_rome\_codes\_args into a value that can be used as an argument.
-}
encodeSearch_rome_codes_args : Search_rome_codes_args -> Value
encodeSearch_rome_codes_args input____ =
    Encode.maybeObject
        [ ( "search", Encode.string |> Encode.optional input____.search ) ]


buildString_comparison_exp :
    (String_comparison_expOptionalFields -> String_comparison_expOptionalFields)
    -> String_comparison_exp
buildString_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, ilike_ = Absent, in_ = Absent, iregex_ = Absent, is_null_ = Absent, like_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nilike_ = Absent, nin_ = Absent, niregex_ = Absent, nlike_ = Absent, nregex_ = Absent, nsimilar_ = Absent, regex_ = Absent, similar_ = Absent }
    in
    { eq_ = optionals____.eq_, gt_ = optionals____.gt_, gte_ = optionals____.gte_, ilike_ = optionals____.ilike_, in_ = optionals____.in_, iregex_ = optionals____.iregex_, is_null_ = optionals____.is_null_, like_ = optionals____.like_, lt_ = optionals____.lt_, lte_ = optionals____.lte_, neq_ = optionals____.neq_, nilike_ = optionals____.nilike_, nin_ = optionals____.nin_, niregex_ = optionals____.niregex_, nlike_ = optionals____.nlike_, nregex_ = optionals____.nregex_, nsimilar_ = optionals____.nsimilar_, regex_ = optionals____.regex_, similar_ = optionals____.similar_ }


type alias String_comparison_expOptionalFields =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , iregex_ : OptionalArgument String
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , niregex_ : OptionalArgument String
    , nlike_ : OptionalArgument String
    , nregex_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , regex_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Type for the String\_comparison\_exp input object.
-}
type alias String_comparison_exp =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , iregex_ : OptionalArgument String
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , niregex_ : OptionalArgument String
    , nlike_ : OptionalArgument String
    , nregex_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , regex_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Encode a String\_comparison\_exp into a value that can be used as an argument.
-}
encodeString_comparison_exp : String_comparison_exp -> Value
encodeString_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", Encode.string |> Encode.optional input____.eq_ ), ( "_gt", Encode.string |> Encode.optional input____.gt_ ), ( "_gte", Encode.string |> Encode.optional input____.gte_ ), ( "_ilike", Encode.string |> Encode.optional input____.ilike_ ), ( "_in", (Encode.string |> Encode.list) |> Encode.optional input____.in_ ), ( "_iregex", Encode.string |> Encode.optional input____.iregex_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_like", Encode.string |> Encode.optional input____.like_ ), ( "_lt", Encode.string |> Encode.optional input____.lt_ ), ( "_lte", Encode.string |> Encode.optional input____.lte_ ), ( "_neq", Encode.string |> Encode.optional input____.neq_ ), ( "_nilike", Encode.string |> Encode.optional input____.nilike_ ), ( "_nin", (Encode.string |> Encode.list) |> Encode.optional input____.nin_ ), ( "_niregex", Encode.string |> Encode.optional input____.niregex_ ), ( "_nlike", Encode.string |> Encode.optional input____.nlike_ ), ( "_nregex", Encode.string |> Encode.optional input____.nregex_ ), ( "_nsimilar", Encode.string |> Encode.optional input____.nsimilar_ ), ( "_regex", Encode.string |> Encode.optional input____.regex_ ), ( "_similar", Encode.string |> Encode.optional input____.similar_ ) ]


buildStructure_aggregate_bool_exp :
    (Structure_aggregate_bool_expOptionalFields -> Structure_aggregate_bool_expOptionalFields)
    -> Structure_aggregate_bool_exp
buildStructure_aggregate_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent }
    in
    Structure_aggregate_bool_exp { count = optionals____.count }


type alias Structure_aggregate_bool_expOptionalFields =
    { count : OptionalArgument Structure_aggregate_bool_exp_count }


{-| Type alias for the `Structure_aggregate_bool_exp` attributes. Note that this type
needs to use the `Structure_aggregate_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Structure_aggregate_bool_expRaw =
    { count : OptionalArgument Structure_aggregate_bool_exp_count }


{-| Type for the Structure\_aggregate\_bool\_exp input object.
-}
type Structure_aggregate_bool_exp
    = Structure_aggregate_bool_exp Structure_aggregate_bool_expRaw


{-| Encode a Structure\_aggregate\_bool\_exp into a value that can be used as an argument.
-}
encodeStructure_aggregate_bool_exp : Structure_aggregate_bool_exp -> Value
encodeStructure_aggregate_bool_exp (Structure_aggregate_bool_exp input____) =
    Encode.maybeObject
        [ ( "count", encodeStructure_aggregate_bool_exp_count |> Encode.optional input____.count ) ]


buildStructure_aggregate_bool_exp_count :
    Structure_aggregate_bool_exp_countRequiredFields
    -> (Structure_aggregate_bool_exp_countOptionalFields -> Structure_aggregate_bool_exp_countOptionalFields)
    -> Structure_aggregate_bool_exp_count
buildStructure_aggregate_bool_exp_count required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { arguments = Absent, distinct = Absent, filter = Absent }
    in
    Structure_aggregate_bool_exp_count { arguments = optionals____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Structure_aggregate_bool_exp_countRequiredFields =
    { predicate : Int_comparison_exp }


type alias Structure_aggregate_bool_exp_countOptionalFields =
    { arguments : OptionalArgument (List CdbGQL.Enum.Structure_select_column.Structure_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Structure_bool_exp
    }


{-| Type alias for the `Structure_aggregate_bool_exp_count` attributes. Note that this type
needs to use the `Structure_aggregate_bool_exp_count` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Structure_aggregate_bool_exp_countRaw =
    { arguments : OptionalArgument (List CdbGQL.Enum.Structure_select_column.Structure_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Structure_bool_exp
    , predicate : Int_comparison_exp
    }


{-| Type for the Structure\_aggregate\_bool\_exp\_count input object.
-}
type Structure_aggregate_bool_exp_count
    = Structure_aggregate_bool_exp_count Structure_aggregate_bool_exp_countRaw


{-| Encode a Structure\_aggregate\_bool\_exp\_count into a value that can be used as an argument.
-}
encodeStructure_aggregate_bool_exp_count : Structure_aggregate_bool_exp_count -> Value
encodeStructure_aggregate_bool_exp_count (Structure_aggregate_bool_exp_count input____) =
    Encode.maybeObject
        [ ( "arguments", (Encode.enum CdbGQL.Enum.Structure_select_column.toString |> Encode.list) |> Encode.optional input____.arguments ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeStructure_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeInt_comparison_exp input____.predicate |> Just ) ]


buildStructure_aggregate_order_by :
    (Structure_aggregate_order_byOptionalFields -> Structure_aggregate_order_byOptionalFields)
    -> Structure_aggregate_order_by
buildStructure_aggregate_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals____.count, max = optionals____.max, min = optionals____.min }


type alias Structure_aggregate_order_byOptionalFields =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Structure_max_order_by
    , min : OptionalArgument Structure_min_order_by
    }


{-| Type for the Structure\_aggregate\_order\_by input object.
-}
type alias Structure_aggregate_order_by =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Structure_max_order_by
    , min : OptionalArgument Structure_min_order_by
    }


{-| Encode a Structure\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeStructure_aggregate_order_by : Structure_aggregate_order_by -> Value
encodeStructure_aggregate_order_by input____ =
    Encode.maybeObject
        [ ( "count", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.count ), ( "max", encodeStructure_max_order_by |> Encode.optional input____.max ), ( "min", encodeStructure_min_order_by |> Encode.optional input____.min ) ]


buildStructure_arr_rel_insert_input :
    Structure_arr_rel_insert_inputRequiredFields
    -> (Structure_arr_rel_insert_inputOptionalFields -> Structure_arr_rel_insert_inputOptionalFields)
    -> Structure_arr_rel_insert_input
buildStructure_arr_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Structure_arr_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Structure_arr_rel_insert_inputRequiredFields =
    { data : List Structure_insert_input }


type alias Structure_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Structure_on_conflict }


{-| Type alias for the `Structure_arr_rel_insert_input` attributes. Note that this type
needs to use the `Structure_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Structure_arr_rel_insert_inputRaw =
    { data : List Structure_insert_input
    , on_conflict : OptionalArgument Structure_on_conflict
    }


{-| Type for the Structure\_arr\_rel\_insert\_input input object.
-}
type Structure_arr_rel_insert_input
    = Structure_arr_rel_insert_input Structure_arr_rel_insert_inputRaw


{-| Encode a Structure\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeStructure_arr_rel_insert_input : Structure_arr_rel_insert_input -> Value
encodeStructure_arr_rel_insert_input (Structure_arr_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", (encodeStructure_insert_input |> Encode.list) input____.data |> Just ), ( "on_conflict", encodeStructure_on_conflict |> Encode.optional input____.on_conflict ) ]


buildStructure_bool_exp :
    (Structure_bool_expOptionalFields -> Structure_bool_expOptionalFields)
    -> Structure_bool_exp
buildStructure_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, address1 = Absent, address2 = Absent, admins = Absent, admins_aggregate = Absent, beneficiaries = Absent, beneficiaries_aggregate = Absent, city = Absent, createdAt = Absent, deployment = Absent, deploymentId = Absent, email = Absent, id = Absent, name = Absent, orientationSystems = Absent, orientationSystems_aggregate = Absent, phone = Absent, postalCode = Absent, professionals = Absent, professionals_aggregate = Absent, shortDesc = Absent, siret = Absent, updatedAt = Absent, website = Absent }
    in
    Structure_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, address1 = optionals____.address1, address2 = optionals____.address2, admins = optionals____.admins, admins_aggregate = optionals____.admins_aggregate, beneficiaries = optionals____.beneficiaries, beneficiaries_aggregate = optionals____.beneficiaries_aggregate, city = optionals____.city, createdAt = optionals____.createdAt, deployment = optionals____.deployment, deploymentId = optionals____.deploymentId, email = optionals____.email, id = optionals____.id, name = optionals____.name, orientationSystems = optionals____.orientationSystems, orientationSystems_aggregate = optionals____.orientationSystems_aggregate, phone = optionals____.phone, postalCode = optionals____.postalCode, professionals = optionals____.professionals, professionals_aggregate = optionals____.professionals_aggregate, shortDesc = optionals____.shortDesc, siret = optionals____.siret, updatedAt = optionals____.updatedAt, website = optionals____.website }


type alias Structure_bool_expOptionalFields =
    { and_ : OptionalArgument (List Structure_bool_exp)
    , not_ : OptionalArgument Structure_bool_exp
    , or_ : OptionalArgument (List Structure_bool_exp)
    , address1 : OptionalArgument String_comparison_exp
    , address2 : OptionalArgument String_comparison_exp
    , admins : OptionalArgument Admin_structure_structure_bool_exp
    , admins_aggregate : OptionalArgument Admin_structure_structure_aggregate_bool_exp
    , beneficiaries : OptionalArgument Beneficiary_structure_bool_exp
    , beneficiaries_aggregate : OptionalArgument Beneficiary_structure_aggregate_bool_exp
    , city : OptionalArgument String_comparison_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , deployment : OptionalArgument Deployment_bool_exp
    , deploymentId : OptionalArgument Uuid_comparison_exp
    , email : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , name : OptionalArgument Citext_comparison_exp
    , orientationSystems : OptionalArgument Structure_orientation_system_bool_exp
    , orientationSystems_aggregate : OptionalArgument Structure_orientation_system_aggregate_bool_exp
    , phone : OptionalArgument String_comparison_exp
    , postalCode : OptionalArgument String_comparison_exp
    , professionals : OptionalArgument Professional_bool_exp
    , professionals_aggregate : OptionalArgument Professional_aggregate_bool_exp
    , shortDesc : OptionalArgument String_comparison_exp
    , siret : OptionalArgument String_comparison_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    , website : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Structure_bool_exp` attributes. Note that this type
needs to use the `Structure_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Structure_bool_expRaw =
    { and_ : OptionalArgument (List Structure_bool_exp)
    , not_ : OptionalArgument Structure_bool_exp
    , or_ : OptionalArgument (List Structure_bool_exp)
    , address1 : OptionalArgument String_comparison_exp
    , address2 : OptionalArgument String_comparison_exp
    , admins : OptionalArgument Admin_structure_structure_bool_exp
    , admins_aggregate : OptionalArgument Admin_structure_structure_aggregate_bool_exp
    , beneficiaries : OptionalArgument Beneficiary_structure_bool_exp
    , beneficiaries_aggregate : OptionalArgument Beneficiary_structure_aggregate_bool_exp
    , city : OptionalArgument String_comparison_exp
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , deployment : OptionalArgument Deployment_bool_exp
    , deploymentId : OptionalArgument Uuid_comparison_exp
    , email : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , name : OptionalArgument Citext_comparison_exp
    , orientationSystems : OptionalArgument Structure_orientation_system_bool_exp
    , orientationSystems_aggregate : OptionalArgument Structure_orientation_system_aggregate_bool_exp
    , phone : OptionalArgument String_comparison_exp
    , postalCode : OptionalArgument String_comparison_exp
    , professionals : OptionalArgument Professional_bool_exp
    , professionals_aggregate : OptionalArgument Professional_aggregate_bool_exp
    , shortDesc : OptionalArgument String_comparison_exp
    , siret : OptionalArgument String_comparison_exp
    , updatedAt : OptionalArgument Timestamptz_comparison_exp
    , website : OptionalArgument String_comparison_exp
    }


{-| Type for the Structure\_bool\_exp input object.
-}
type Structure_bool_exp
    = Structure_bool_exp Structure_bool_expRaw


{-| Encode a Structure\_bool\_exp into a value that can be used as an argument.
-}
encodeStructure_bool_exp : Structure_bool_exp -> Value
encodeStructure_bool_exp (Structure_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeStructure_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeStructure_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeStructure_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "address1", encodeString_comparison_exp |> Encode.optional input____.address1 ), ( "address2", encodeString_comparison_exp |> Encode.optional input____.address2 ), ( "admins", encodeAdmin_structure_structure_bool_exp |> Encode.optional input____.admins ), ( "admins_aggregate", encodeAdmin_structure_structure_aggregate_bool_exp |> Encode.optional input____.admins_aggregate ), ( "beneficiaries", encodeBeneficiary_structure_bool_exp |> Encode.optional input____.beneficiaries ), ( "beneficiaries_aggregate", encodeBeneficiary_structure_aggregate_bool_exp |> Encode.optional input____.beneficiaries_aggregate ), ( "city", encodeString_comparison_exp |> Encode.optional input____.city ), ( "createdAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.createdAt ), ( "deployment", encodeDeployment_bool_exp |> Encode.optional input____.deployment ), ( "deploymentId", encodeUuid_comparison_exp |> Encode.optional input____.deploymentId ), ( "email", encodeString_comparison_exp |> Encode.optional input____.email ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "name", encodeCitext_comparison_exp |> Encode.optional input____.name ), ( "orientationSystems", encodeStructure_orientation_system_bool_exp |> Encode.optional input____.orientationSystems ), ( "orientationSystems_aggregate", encodeStructure_orientation_system_aggregate_bool_exp |> Encode.optional input____.orientationSystems_aggregate ), ( "phone", encodeString_comparison_exp |> Encode.optional input____.phone ), ( "postalCode", encodeString_comparison_exp |> Encode.optional input____.postalCode ), ( "professionals", encodeProfessional_bool_exp |> Encode.optional input____.professionals ), ( "professionals_aggregate", encodeProfessional_aggregate_bool_exp |> Encode.optional input____.professionals_aggregate ), ( "shortDesc", encodeString_comparison_exp |> Encode.optional input____.shortDesc ), ( "siret", encodeString_comparison_exp |> Encode.optional input____.siret ), ( "updatedAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.updatedAt ), ( "website", encodeString_comparison_exp |> Encode.optional input____.website ) ]


buildStructure_insert_input :
    (Structure_insert_inputOptionalFields -> Structure_insert_inputOptionalFields)
    -> Structure_insert_input
buildStructure_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { address1 = Absent, address2 = Absent, admins = Absent, beneficiaries = Absent, city = Absent, createdAt = Absent, deployment = Absent, deploymentId = Absent, email = Absent, id = Absent, name = Absent, orientationSystems = Absent, phone = Absent, postalCode = Absent, professionals = Absent, shortDesc = Absent, siret = Absent, updatedAt = Absent, website = Absent }
    in
    Structure_insert_input { address1 = optionals____.address1, address2 = optionals____.address2, admins = optionals____.admins, beneficiaries = optionals____.beneficiaries, city = optionals____.city, createdAt = optionals____.createdAt, deployment = optionals____.deployment, deploymentId = optionals____.deploymentId, email = optionals____.email, id = optionals____.id, name = optionals____.name, orientationSystems = optionals____.orientationSystems, phone = optionals____.phone, postalCode = optionals____.postalCode, professionals = optionals____.professionals, shortDesc = optionals____.shortDesc, siret = optionals____.siret, updatedAt = optionals____.updatedAt, website = optionals____.website }


type alias Structure_insert_inputOptionalFields =
    { address1 : OptionalArgument String
    , address2 : OptionalArgument String
    , admins : OptionalArgument Admin_structure_structure_arr_rel_insert_input
    , beneficiaries : OptionalArgument Beneficiary_structure_arr_rel_insert_input
    , city : OptionalArgument String
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deployment : OptionalArgument Deployment_obj_rel_insert_input
    , deploymentId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , name : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , orientationSystems : OptionalArgument Structure_orientation_system_arr_rel_insert_input
    , phone : OptionalArgument String
    , postalCode : OptionalArgument String
    , professionals : OptionalArgument Professional_arr_rel_insert_input
    , shortDesc : OptionalArgument String
    , siret : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , website : OptionalArgument String
    }


{-| Type alias for the `Structure_insert_input` attributes. Note that this type
needs to use the `Structure_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Structure_insert_inputRaw =
    { address1 : OptionalArgument String
    , address2 : OptionalArgument String
    , admins : OptionalArgument Admin_structure_structure_arr_rel_insert_input
    , beneficiaries : OptionalArgument Beneficiary_structure_arr_rel_insert_input
    , city : OptionalArgument String
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deployment : OptionalArgument Deployment_obj_rel_insert_input
    , deploymentId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , name : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , orientationSystems : OptionalArgument Structure_orientation_system_arr_rel_insert_input
    , phone : OptionalArgument String
    , postalCode : OptionalArgument String
    , professionals : OptionalArgument Professional_arr_rel_insert_input
    , shortDesc : OptionalArgument String
    , siret : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , website : OptionalArgument String
    }


{-| Type for the Structure\_insert\_input input object.
-}
type Structure_insert_input
    = Structure_insert_input Structure_insert_inputRaw


{-| Encode a Structure\_insert\_input into a value that can be used as an argument.
-}
encodeStructure_insert_input : Structure_insert_input -> Value
encodeStructure_insert_input (Structure_insert_input input____) =
    Encode.maybeObject
        [ ( "address1", Encode.string |> Encode.optional input____.address1 ), ( "address2", Encode.string |> Encode.optional input____.address2 ), ( "admins", encodeAdmin_structure_structure_arr_rel_insert_input |> Encode.optional input____.admins ), ( "beneficiaries", encodeBeneficiary_structure_arr_rel_insert_input |> Encode.optional input____.beneficiaries ), ( "city", Encode.string |> Encode.optional input____.city ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "deployment", encodeDeployment_obj_rel_insert_input |> Encode.optional input____.deployment ), ( "deploymentId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.deploymentId ), ( "email", Encode.string |> Encode.optional input____.email ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "name", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.name ), ( "orientationSystems", encodeStructure_orientation_system_arr_rel_insert_input |> Encode.optional input____.orientationSystems ), ( "phone", Encode.string |> Encode.optional input____.phone ), ( "postalCode", Encode.string |> Encode.optional input____.postalCode ), ( "professionals", encodeProfessional_arr_rel_insert_input |> Encode.optional input____.professionals ), ( "shortDesc", Encode.string |> Encode.optional input____.shortDesc ), ( "siret", Encode.string |> Encode.optional input____.siret ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ), ( "website", Encode.string |> Encode.optional input____.website ) ]


buildStructure_max_order_by :
    (Structure_max_order_byOptionalFields -> Structure_max_order_byOptionalFields)
    -> Structure_max_order_by
buildStructure_max_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { address1 = Absent, address2 = Absent, city = Absent, createdAt = Absent, deploymentId = Absent, email = Absent, id = Absent, name = Absent, phone = Absent, postalCode = Absent, shortDesc = Absent, siret = Absent, updatedAt = Absent, website = Absent }
    in
    { address1 = optionals____.address1, address2 = optionals____.address2, city = optionals____.city, createdAt = optionals____.createdAt, deploymentId = optionals____.deploymentId, email = optionals____.email, id = optionals____.id, name = optionals____.name, phone = optionals____.phone, postalCode = optionals____.postalCode, shortDesc = optionals____.shortDesc, siret = optionals____.siret, updatedAt = optionals____.updatedAt, website = optionals____.website }


type alias Structure_max_order_byOptionalFields =
    { address1 : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , address2 : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , city : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deploymentId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , name : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , phone : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , postalCode : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , shortDesc : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , siret : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , website : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Structure\_max\_order\_by input object.
-}
type alias Structure_max_order_by =
    { address1 : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , address2 : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , city : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deploymentId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , name : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , phone : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , postalCode : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , shortDesc : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , siret : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , website : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Structure\_max\_order\_by into a value that can be used as an argument.
-}
encodeStructure_max_order_by : Structure_max_order_by -> Value
encodeStructure_max_order_by input____ =
    Encode.maybeObject
        [ ( "address1", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.address1 ), ( "address2", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.address2 ), ( "city", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.city ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "deploymentId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deploymentId ), ( "email", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.email ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "name", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.name ), ( "phone", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.phone ), ( "postalCode", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.postalCode ), ( "shortDesc", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.shortDesc ), ( "siret", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.siret ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ), ( "website", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.website ) ]


buildStructure_min_order_by :
    (Structure_min_order_byOptionalFields -> Structure_min_order_byOptionalFields)
    -> Structure_min_order_by
buildStructure_min_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { address1 = Absent, address2 = Absent, city = Absent, createdAt = Absent, deploymentId = Absent, email = Absent, id = Absent, name = Absent, phone = Absent, postalCode = Absent, shortDesc = Absent, siret = Absent, updatedAt = Absent, website = Absent }
    in
    { address1 = optionals____.address1, address2 = optionals____.address2, city = optionals____.city, createdAt = optionals____.createdAt, deploymentId = optionals____.deploymentId, email = optionals____.email, id = optionals____.id, name = optionals____.name, phone = optionals____.phone, postalCode = optionals____.postalCode, shortDesc = optionals____.shortDesc, siret = optionals____.siret, updatedAt = optionals____.updatedAt, website = optionals____.website }


type alias Structure_min_order_byOptionalFields =
    { address1 : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , address2 : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , city : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deploymentId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , name : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , phone : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , postalCode : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , shortDesc : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , siret : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , website : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Structure\_min\_order\_by input object.
-}
type alias Structure_min_order_by =
    { address1 : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , address2 : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , city : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deploymentId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , name : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , phone : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , postalCode : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , shortDesc : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , siret : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , website : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Structure\_min\_order\_by into a value that can be used as an argument.
-}
encodeStructure_min_order_by : Structure_min_order_by -> Value
encodeStructure_min_order_by input____ =
    Encode.maybeObject
        [ ( "address1", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.address1 ), ( "address2", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.address2 ), ( "city", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.city ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "deploymentId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deploymentId ), ( "email", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.email ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "name", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.name ), ( "phone", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.phone ), ( "postalCode", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.postalCode ), ( "shortDesc", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.shortDesc ), ( "siret", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.siret ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ), ( "website", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.website ) ]


buildStructure_obj_rel_insert_input :
    Structure_obj_rel_insert_inputRequiredFields
    -> (Structure_obj_rel_insert_inputOptionalFields -> Structure_obj_rel_insert_inputOptionalFields)
    -> Structure_obj_rel_insert_input
buildStructure_obj_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Structure_obj_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Structure_obj_rel_insert_inputRequiredFields =
    { data : Structure_insert_input }


type alias Structure_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Structure_on_conflict }


{-| Type alias for the `Structure_obj_rel_insert_input` attributes. Note that this type
needs to use the `Structure_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Structure_obj_rel_insert_inputRaw =
    { data : Structure_insert_input
    , on_conflict : OptionalArgument Structure_on_conflict
    }


{-| Type for the Structure\_obj\_rel\_insert\_input input object.
-}
type Structure_obj_rel_insert_input
    = Structure_obj_rel_insert_input Structure_obj_rel_insert_inputRaw


{-| Encode a Structure\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeStructure_obj_rel_insert_input : Structure_obj_rel_insert_input -> Value
encodeStructure_obj_rel_insert_input (Structure_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeStructure_insert_input input____.data |> Just ), ( "on_conflict", encodeStructure_on_conflict |> Encode.optional input____.on_conflict ) ]


buildStructure_on_conflict :
    Structure_on_conflictRequiredFields
    -> (Structure_on_conflictOptionalFields -> Structure_on_conflictOptionalFields)
    -> Structure_on_conflict
buildStructure_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Structure_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Structure_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Structure_constraint.Structure_constraint
    , update_columns : List CdbGQL.Enum.Structure_update_column.Structure_update_column
    }


type alias Structure_on_conflictOptionalFields =
    { where_ : OptionalArgument Structure_bool_exp }


{-| Type alias for the `Structure_on_conflict` attributes. Note that this type
needs to use the `Structure_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Structure_on_conflictRaw =
    { constraint : CdbGQL.Enum.Structure_constraint.Structure_constraint
    , update_columns : List CdbGQL.Enum.Structure_update_column.Structure_update_column
    , where_ : OptionalArgument Structure_bool_exp
    }


{-| Type for the Structure\_on\_conflict input object.
-}
type Structure_on_conflict
    = Structure_on_conflict Structure_on_conflictRaw


{-| Encode a Structure\_on\_conflict into a value that can be used as an argument.
-}
encodeStructure_on_conflict : Structure_on_conflict -> Value
encodeStructure_on_conflict (Structure_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Structure_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Structure_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeStructure_bool_exp |> Encode.optional input____.where_ ) ]


buildStructure_order_by :
    (Structure_order_byOptionalFields -> Structure_order_byOptionalFields)
    -> Structure_order_by
buildStructure_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { address1 = Absent, address2 = Absent, admins_aggregate = Absent, beneficiaries_aggregate = Absent, city = Absent, createdAt = Absent, deployment = Absent, deploymentId = Absent, email = Absent, id = Absent, name = Absent, orientationSystems_aggregate = Absent, phone = Absent, postalCode = Absent, professionals_aggregate = Absent, shortDesc = Absent, siret = Absent, updatedAt = Absent, website = Absent }
    in
    { address1 = optionals____.address1, address2 = optionals____.address2, admins_aggregate = optionals____.admins_aggregate, beneficiaries_aggregate = optionals____.beneficiaries_aggregate, city = optionals____.city, createdAt = optionals____.createdAt, deployment = optionals____.deployment, deploymentId = optionals____.deploymentId, email = optionals____.email, id = optionals____.id, name = optionals____.name, orientationSystems_aggregate = optionals____.orientationSystems_aggregate, phone = optionals____.phone, postalCode = optionals____.postalCode, professionals_aggregate = optionals____.professionals_aggregate, shortDesc = optionals____.shortDesc, siret = optionals____.siret, updatedAt = optionals____.updatedAt, website = optionals____.website }


type alias Structure_order_byOptionalFields =
    { address1 : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , address2 : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , admins_aggregate : OptionalArgument Admin_structure_structure_aggregate_order_by
    , beneficiaries_aggregate : OptionalArgument Beneficiary_structure_aggregate_order_by
    , city : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deployment : OptionalArgument Deployment_order_by
    , deploymentId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , name : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationSystems_aggregate : OptionalArgument Structure_orientation_system_aggregate_order_by
    , phone : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , postalCode : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , professionals_aggregate : OptionalArgument Professional_aggregate_order_by
    , shortDesc : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , siret : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , website : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Structure\_order\_by input object.
-}
type alias Structure_order_by =
    { address1 : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , address2 : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , admins_aggregate : OptionalArgument Admin_structure_structure_aggregate_order_by
    , beneficiaries_aggregate : OptionalArgument Beneficiary_structure_aggregate_order_by
    , city : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , deployment : OptionalArgument Deployment_order_by
    , deploymentId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , email : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , name : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationSystems_aggregate : OptionalArgument Structure_orientation_system_aggregate_order_by
    , phone : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , postalCode : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , professionals_aggregate : OptionalArgument Professional_aggregate_order_by
    , shortDesc : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , siret : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , updatedAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , website : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Structure\_order\_by into a value that can be used as an argument.
-}
encodeStructure_order_by : Structure_order_by -> Value
encodeStructure_order_by input____ =
    Encode.maybeObject
        [ ( "address1", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.address1 ), ( "address2", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.address2 ), ( "admins_aggregate", encodeAdmin_structure_structure_aggregate_order_by |> Encode.optional input____.admins_aggregate ), ( "beneficiaries_aggregate", encodeBeneficiary_structure_aggregate_order_by |> Encode.optional input____.beneficiaries_aggregate ), ( "city", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.city ), ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "deployment", encodeDeployment_order_by |> Encode.optional input____.deployment ), ( "deploymentId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.deploymentId ), ( "email", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.email ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "name", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.name ), ( "orientationSystems_aggregate", encodeStructure_orientation_system_aggregate_order_by |> Encode.optional input____.orientationSystems_aggregate ), ( "phone", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.phone ), ( "postalCode", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.postalCode ), ( "professionals_aggregate", encodeProfessional_aggregate_order_by |> Encode.optional input____.professionals_aggregate ), ( "shortDesc", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.shortDesc ), ( "siret", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.siret ), ( "updatedAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.updatedAt ), ( "website", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.website ) ]


buildStructure_orientation_system_aggregate_bool_exp :
    (Structure_orientation_system_aggregate_bool_expOptionalFields -> Structure_orientation_system_aggregate_bool_expOptionalFields)
    -> Structure_orientation_system_aggregate_bool_exp
buildStructure_orientation_system_aggregate_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent }
    in
    Structure_orientation_system_aggregate_bool_exp { count = optionals____.count }


type alias Structure_orientation_system_aggregate_bool_expOptionalFields =
    { count : OptionalArgument Structure_orientation_system_aggregate_bool_exp_count }


{-| Type alias for the `Structure_orientation_system_aggregate_bool_exp` attributes. Note that this type
needs to use the `Structure_orientation_system_aggregate_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Structure_orientation_system_aggregate_bool_expRaw =
    { count : OptionalArgument Structure_orientation_system_aggregate_bool_exp_count }


{-| Type for the Structure\_orientation\_system\_aggregate\_bool\_exp input object.
-}
type Structure_orientation_system_aggregate_bool_exp
    = Structure_orientation_system_aggregate_bool_exp Structure_orientation_system_aggregate_bool_expRaw


{-| Encode a Structure\_orientation\_system\_aggregate\_bool\_exp into a value that can be used as an argument.
-}
encodeStructure_orientation_system_aggregate_bool_exp : Structure_orientation_system_aggregate_bool_exp -> Value
encodeStructure_orientation_system_aggregate_bool_exp (Structure_orientation_system_aggregate_bool_exp input____) =
    Encode.maybeObject
        [ ( "count", encodeStructure_orientation_system_aggregate_bool_exp_count |> Encode.optional input____.count ) ]


buildStructure_orientation_system_aggregate_bool_exp_count :
    Structure_orientation_system_aggregate_bool_exp_countRequiredFields
    -> (Structure_orientation_system_aggregate_bool_exp_countOptionalFields -> Structure_orientation_system_aggregate_bool_exp_countOptionalFields)
    -> Structure_orientation_system_aggregate_bool_exp_count
buildStructure_orientation_system_aggregate_bool_exp_count required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { arguments = Absent, distinct = Absent, filter = Absent }
    in
    Structure_orientation_system_aggregate_bool_exp_count { arguments = optionals____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Structure_orientation_system_aggregate_bool_exp_countRequiredFields =
    { predicate : Int_comparison_exp }


type alias Structure_orientation_system_aggregate_bool_exp_countOptionalFields =
    { arguments : OptionalArgument (List CdbGQL.Enum.Structure_orientation_system_select_column.Structure_orientation_system_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Structure_orientation_system_bool_exp
    }


{-| Type alias for the `Structure_orientation_system_aggregate_bool_exp_count` attributes. Note that this type
needs to use the `Structure_orientation_system_aggregate_bool_exp_count` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Structure_orientation_system_aggregate_bool_exp_countRaw =
    { arguments : OptionalArgument (List CdbGQL.Enum.Structure_orientation_system_select_column.Structure_orientation_system_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Structure_orientation_system_bool_exp
    , predicate : Int_comparison_exp
    }


{-| Type for the Structure\_orientation\_system\_aggregate\_bool\_exp\_count input object.
-}
type Structure_orientation_system_aggregate_bool_exp_count
    = Structure_orientation_system_aggregate_bool_exp_count Structure_orientation_system_aggregate_bool_exp_countRaw


{-| Encode a Structure\_orientation\_system\_aggregate\_bool\_exp\_count into a value that can be used as an argument.
-}
encodeStructure_orientation_system_aggregate_bool_exp_count : Structure_orientation_system_aggregate_bool_exp_count -> Value
encodeStructure_orientation_system_aggregate_bool_exp_count (Structure_orientation_system_aggregate_bool_exp_count input____) =
    Encode.maybeObject
        [ ( "arguments", (Encode.enum CdbGQL.Enum.Structure_orientation_system_select_column.toString |> Encode.list) |> Encode.optional input____.arguments ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeStructure_orientation_system_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeInt_comparison_exp input____.predicate |> Just ) ]


buildStructure_orientation_system_aggregate_order_by :
    (Structure_orientation_system_aggregate_order_byOptionalFields -> Structure_orientation_system_aggregate_order_byOptionalFields)
    -> Structure_orientation_system_aggregate_order_by
buildStructure_orientation_system_aggregate_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals____.count, max = optionals____.max, min = optionals____.min }


type alias Structure_orientation_system_aggregate_order_byOptionalFields =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Structure_orientation_system_max_order_by
    , min : OptionalArgument Structure_orientation_system_min_order_by
    }


{-| Type for the Structure\_orientation\_system\_aggregate\_order\_by input object.
-}
type alias Structure_orientation_system_aggregate_order_by =
    { count : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , max : OptionalArgument Structure_orientation_system_max_order_by
    , min : OptionalArgument Structure_orientation_system_min_order_by
    }


{-| Encode a Structure\_orientation\_system\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeStructure_orientation_system_aggregate_order_by : Structure_orientation_system_aggregate_order_by -> Value
encodeStructure_orientation_system_aggregate_order_by input____ =
    Encode.maybeObject
        [ ( "count", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.count ), ( "max", encodeStructure_orientation_system_max_order_by |> Encode.optional input____.max ), ( "min", encodeStructure_orientation_system_min_order_by |> Encode.optional input____.min ) ]


buildStructure_orientation_system_arr_rel_insert_input :
    Structure_orientation_system_arr_rel_insert_inputRequiredFields
    -> (Structure_orientation_system_arr_rel_insert_inputOptionalFields -> Structure_orientation_system_arr_rel_insert_inputOptionalFields)
    -> Structure_orientation_system_arr_rel_insert_input
buildStructure_orientation_system_arr_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Structure_orientation_system_arr_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Structure_orientation_system_arr_rel_insert_inputRequiredFields =
    { data : List Structure_orientation_system_insert_input }


type alias Structure_orientation_system_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Structure_orientation_system_on_conflict }


{-| Type alias for the `Structure_orientation_system_arr_rel_insert_input` attributes. Note that this type
needs to use the `Structure_orientation_system_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Structure_orientation_system_arr_rel_insert_inputRaw =
    { data : List Structure_orientation_system_insert_input
    , on_conflict : OptionalArgument Structure_orientation_system_on_conflict
    }


{-| Type for the Structure\_orientation\_system\_arr\_rel\_insert\_input input object.
-}
type Structure_orientation_system_arr_rel_insert_input
    = Structure_orientation_system_arr_rel_insert_input Structure_orientation_system_arr_rel_insert_inputRaw


{-| Encode a Structure\_orientation\_system\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeStructure_orientation_system_arr_rel_insert_input : Structure_orientation_system_arr_rel_insert_input -> Value
encodeStructure_orientation_system_arr_rel_insert_input (Structure_orientation_system_arr_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", (encodeStructure_orientation_system_insert_input |> Encode.list) input____.data |> Just ), ( "on_conflict", encodeStructure_orientation_system_on_conflict |> Encode.optional input____.on_conflict ) ]


buildStructure_orientation_system_bool_exp :
    (Structure_orientation_system_bool_expOptionalFields -> Structure_orientation_system_bool_expOptionalFields)
    -> Structure_orientation_system_bool_exp
buildStructure_orientation_system_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, createdAt = Absent, id = Absent, orientationSystem = Absent, orientationSystemId = Absent, structure = Absent, structureId = Absent }
    in
    Structure_orientation_system_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, createdAt = optionals____.createdAt, id = optionals____.id, orientationSystem = optionals____.orientationSystem, orientationSystemId = optionals____.orientationSystemId, structure = optionals____.structure, structureId = optionals____.structureId }


type alias Structure_orientation_system_bool_expOptionalFields =
    { and_ : OptionalArgument (List Structure_orientation_system_bool_exp)
    , not_ : OptionalArgument Structure_orientation_system_bool_exp
    , or_ : OptionalArgument (List Structure_orientation_system_bool_exp)
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , orientationSystem : OptionalArgument Orientation_system_bool_exp
    , orientationSystemId : OptionalArgument Uuid_comparison_exp
    , structure : OptionalArgument Structure_bool_exp
    , structureId : OptionalArgument Uuid_comparison_exp
    }


{-| Type alias for the `Structure_orientation_system_bool_exp` attributes. Note that this type
needs to use the `Structure_orientation_system_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Structure_orientation_system_bool_expRaw =
    { and_ : OptionalArgument (List Structure_orientation_system_bool_exp)
    , not_ : OptionalArgument Structure_orientation_system_bool_exp
    , or_ : OptionalArgument (List Structure_orientation_system_bool_exp)
    , createdAt : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , orientationSystem : OptionalArgument Orientation_system_bool_exp
    , orientationSystemId : OptionalArgument Uuid_comparison_exp
    , structure : OptionalArgument Structure_bool_exp
    , structureId : OptionalArgument Uuid_comparison_exp
    }


{-| Type for the Structure\_orientation\_system\_bool\_exp input object.
-}
type Structure_orientation_system_bool_exp
    = Structure_orientation_system_bool_exp Structure_orientation_system_bool_expRaw


{-| Encode a Structure\_orientation\_system\_bool\_exp into a value that can be used as an argument.
-}
encodeStructure_orientation_system_bool_exp : Structure_orientation_system_bool_exp -> Value
encodeStructure_orientation_system_bool_exp (Structure_orientation_system_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeStructure_orientation_system_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeStructure_orientation_system_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeStructure_orientation_system_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "createdAt", encodeTimestamptz_comparison_exp |> Encode.optional input____.createdAt ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "orientationSystem", encodeOrientation_system_bool_exp |> Encode.optional input____.orientationSystem ), ( "orientationSystemId", encodeUuid_comparison_exp |> Encode.optional input____.orientationSystemId ), ( "structure", encodeStructure_bool_exp |> Encode.optional input____.structure ), ( "structureId", encodeUuid_comparison_exp |> Encode.optional input____.structureId ) ]


buildStructure_orientation_system_insert_input :
    (Structure_orientation_system_insert_inputOptionalFields -> Structure_orientation_system_insert_inputOptionalFields)
    -> Structure_orientation_system_insert_input
buildStructure_orientation_system_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, id = Absent, orientationSystem = Absent, orientationSystemId = Absent, structure = Absent, structureId = Absent }
    in
    Structure_orientation_system_insert_input { createdAt = optionals____.createdAt, id = optionals____.id, orientationSystem = optionals____.orientationSystem, orientationSystemId = optionals____.orientationSystemId, structure = optionals____.structure, structureId = optionals____.structureId }


type alias Structure_orientation_system_insert_inputOptionalFields =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , orientationSystem : OptionalArgument Orientation_system_obj_rel_insert_input
    , orientationSystemId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , structure : OptionalArgument Structure_obj_rel_insert_input
    , structureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Type alias for the `Structure_orientation_system_insert_input` attributes. Note that this type
needs to use the `Structure_orientation_system_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Structure_orientation_system_insert_inputRaw =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , orientationSystem : OptionalArgument Orientation_system_obj_rel_insert_input
    , orientationSystemId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , structure : OptionalArgument Structure_obj_rel_insert_input
    , structureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Type for the Structure\_orientation\_system\_insert\_input input object.
-}
type Structure_orientation_system_insert_input
    = Structure_orientation_system_insert_input Structure_orientation_system_insert_inputRaw


{-| Encode a Structure\_orientation\_system\_insert\_input into a value that can be used as an argument.
-}
encodeStructure_orientation_system_insert_input : Structure_orientation_system_insert_input -> Value
encodeStructure_orientation_system_insert_input (Structure_orientation_system_insert_input input____) =
    Encode.maybeObject
        [ ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "orientationSystem", encodeOrientation_system_obj_rel_insert_input |> Encode.optional input____.orientationSystem ), ( "orientationSystemId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.orientationSystemId ), ( "structure", encodeStructure_obj_rel_insert_input |> Encode.optional input____.structure ), ( "structureId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.structureId ) ]


buildStructure_orientation_system_max_order_by :
    (Structure_orientation_system_max_order_byOptionalFields -> Structure_orientation_system_max_order_byOptionalFields)
    -> Structure_orientation_system_max_order_by
buildStructure_orientation_system_max_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, id = Absent, orientationSystemId = Absent, structureId = Absent }
    in
    { createdAt = optionals____.createdAt, id = optionals____.id, orientationSystemId = optionals____.orientationSystemId, structureId = optionals____.structureId }


type alias Structure_orientation_system_max_order_byOptionalFields =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationSystemId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , structureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Structure\_orientation\_system\_max\_order\_by input object.
-}
type alias Structure_orientation_system_max_order_by =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationSystemId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , structureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Structure\_orientation\_system\_max\_order\_by into a value that can be used as an argument.
-}
encodeStructure_orientation_system_max_order_by : Structure_orientation_system_max_order_by -> Value
encodeStructure_orientation_system_max_order_by input____ =
    Encode.maybeObject
        [ ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "orientationSystemId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.orientationSystemId ), ( "structureId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.structureId ) ]


buildStructure_orientation_system_min_order_by :
    (Structure_orientation_system_min_order_byOptionalFields -> Structure_orientation_system_min_order_byOptionalFields)
    -> Structure_orientation_system_min_order_by
buildStructure_orientation_system_min_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, id = Absent, orientationSystemId = Absent, structureId = Absent }
    in
    { createdAt = optionals____.createdAt, id = optionals____.id, orientationSystemId = optionals____.orientationSystemId, structureId = optionals____.structureId }


type alias Structure_orientation_system_min_order_byOptionalFields =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationSystemId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , structureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Structure\_orientation\_system\_min\_order\_by input object.
-}
type alias Structure_orientation_system_min_order_by =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationSystemId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , structureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Encode a Structure\_orientation\_system\_min\_order\_by into a value that can be used as an argument.
-}
encodeStructure_orientation_system_min_order_by : Structure_orientation_system_min_order_by -> Value
encodeStructure_orientation_system_min_order_by input____ =
    Encode.maybeObject
        [ ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "orientationSystemId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.orientationSystemId ), ( "structureId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.structureId ) ]


buildStructure_orientation_system_on_conflict :
    Structure_orientation_system_on_conflictRequiredFields
    -> (Structure_orientation_system_on_conflictOptionalFields -> Structure_orientation_system_on_conflictOptionalFields)
    -> Structure_orientation_system_on_conflict
buildStructure_orientation_system_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Structure_orientation_system_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Structure_orientation_system_on_conflictRequiredFields =
    { constraint : CdbGQL.Enum.Structure_orientation_system_constraint.Structure_orientation_system_constraint
    , update_columns : List CdbGQL.Enum.Structure_orientation_system_update_column.Structure_orientation_system_update_column
    }


type alias Structure_orientation_system_on_conflictOptionalFields =
    { where_ : OptionalArgument Structure_orientation_system_bool_exp }


{-| Type alias for the `Structure_orientation_system_on_conflict` attributes. Note that this type
needs to use the `Structure_orientation_system_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Structure_orientation_system_on_conflictRaw =
    { constraint : CdbGQL.Enum.Structure_orientation_system_constraint.Structure_orientation_system_constraint
    , update_columns : List CdbGQL.Enum.Structure_orientation_system_update_column.Structure_orientation_system_update_column
    , where_ : OptionalArgument Structure_orientation_system_bool_exp
    }


{-| Type for the Structure\_orientation\_system\_on\_conflict input object.
-}
type Structure_orientation_system_on_conflict
    = Structure_orientation_system_on_conflict Structure_orientation_system_on_conflictRaw


{-| Encode a Structure\_orientation\_system\_on\_conflict into a value that can be used as an argument.
-}
encodeStructure_orientation_system_on_conflict : Structure_orientation_system_on_conflict -> Value
encodeStructure_orientation_system_on_conflict (Structure_orientation_system_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum CdbGQL.Enum.Structure_orientation_system_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum CdbGQL.Enum.Structure_orientation_system_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeStructure_orientation_system_bool_exp |> Encode.optional input____.where_ ) ]


buildStructure_orientation_system_order_by :
    (Structure_orientation_system_order_byOptionalFields -> Structure_orientation_system_order_byOptionalFields)
    -> Structure_orientation_system_order_by
buildStructure_orientation_system_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, id = Absent, orientationSystem = Absent, orientationSystemId = Absent, structure = Absent, structureId = Absent }
    in
    Structure_orientation_system_order_by { createdAt = optionals____.createdAt, id = optionals____.id, orientationSystem = optionals____.orientationSystem, orientationSystemId = optionals____.orientationSystemId, structure = optionals____.structure, structureId = optionals____.structureId }


type alias Structure_orientation_system_order_byOptionalFields =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationSystem : OptionalArgument Orientation_system_order_by
    , orientationSystemId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , structure : OptionalArgument Structure_order_by
    , structureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type alias for the `Structure_orientation_system_order_by` attributes. Note that this type
needs to use the `Structure_orientation_system_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Structure_orientation_system_order_byRaw =
    { createdAt : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , id : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , orientationSystem : OptionalArgument Orientation_system_order_by
    , orientationSystemId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    , structure : OptionalArgument Structure_order_by
    , structureId : OptionalArgument CdbGQL.Enum.Order_by.Order_by
    }


{-| Type for the Structure\_orientation\_system\_order\_by input object.
-}
type Structure_orientation_system_order_by
    = Structure_orientation_system_order_by Structure_orientation_system_order_byRaw


{-| Encode a Structure\_orientation\_system\_order\_by into a value that can be used as an argument.
-}
encodeStructure_orientation_system_order_by : Structure_orientation_system_order_by -> Value
encodeStructure_orientation_system_order_by (Structure_orientation_system_order_by input____) =
    Encode.maybeObject
        [ ( "createdAt", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.createdAt ), ( "id", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.id ), ( "orientationSystem", encodeOrientation_system_order_by |> Encode.optional input____.orientationSystem ), ( "orientationSystemId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.orientationSystemId ), ( "structure", encodeStructure_order_by |> Encode.optional input____.structure ), ( "structureId", Encode.enum CdbGQL.Enum.Order_by.toString |> Encode.optional input____.structureId ) ]


buildStructure_orientation_system_pk_columns_input :
    Structure_orientation_system_pk_columns_inputRequiredFields
    -> Structure_orientation_system_pk_columns_input
buildStructure_orientation_system_pk_columns_input required____ =
    { id = required____.id }


type alias Structure_orientation_system_pk_columns_inputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the Structure\_orientation\_system\_pk\_columns\_input input object.
-}
type alias Structure_orientation_system_pk_columns_input =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a Structure\_orientation\_system\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeStructure_orientation_system_pk_columns_input : Structure_orientation_system_pk_columns_input -> Value
encodeStructure_orientation_system_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildStructure_orientation_system_set_input :
    (Structure_orientation_system_set_inputOptionalFields -> Structure_orientation_system_set_inputOptionalFields)
    -> Structure_orientation_system_set_input
buildStructure_orientation_system_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, id = Absent, orientationSystemId = Absent, structureId = Absent }
    in
    { createdAt = optionals____.createdAt, id = optionals____.id, orientationSystemId = optionals____.orientationSystemId, structureId = optionals____.structureId }


type alias Structure_orientation_system_set_inputOptionalFields =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , orientationSystemId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , structureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Type for the Structure\_orientation\_system\_set\_input input object.
-}
type alias Structure_orientation_system_set_input =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , orientationSystemId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , structureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Encode a Structure\_orientation\_system\_set\_input into a value that can be used as an argument.
-}
encodeStructure_orientation_system_set_input : Structure_orientation_system_set_input -> Value
encodeStructure_orientation_system_set_input input____ =
    Encode.maybeObject
        [ ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "orientationSystemId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.orientationSystemId ), ( "structureId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.structureId ) ]


buildStructure_orientation_system_stream_cursor_input :
    Structure_orientation_system_stream_cursor_inputRequiredFields
    -> (Structure_orientation_system_stream_cursor_inputOptionalFields -> Structure_orientation_system_stream_cursor_inputOptionalFields)
    -> Structure_orientation_system_stream_cursor_input
buildStructure_orientation_system_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Structure_orientation_system_stream_cursor_inputRequiredFields =
    { initial_value : Structure_orientation_system_stream_cursor_value_input }


type alias Structure_orientation_system_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Structure\_orientation\_system\_stream\_cursor\_input input object.
-}
type alias Structure_orientation_system_stream_cursor_input =
    { initial_value : Structure_orientation_system_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Structure\_orientation\_system\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeStructure_orientation_system_stream_cursor_input : Structure_orientation_system_stream_cursor_input -> Value
encodeStructure_orientation_system_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeStructure_orientation_system_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildStructure_orientation_system_stream_cursor_value_input :
    (Structure_orientation_system_stream_cursor_value_inputOptionalFields -> Structure_orientation_system_stream_cursor_value_inputOptionalFields)
    -> Structure_orientation_system_stream_cursor_value_input
buildStructure_orientation_system_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, id = Absent, orientationSystemId = Absent, structureId = Absent }
    in
    { createdAt = optionals____.createdAt, id = optionals____.id, orientationSystemId = optionals____.orientationSystemId, structureId = optionals____.structureId }


type alias Structure_orientation_system_stream_cursor_value_inputOptionalFields =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , orientationSystemId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , structureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Type for the Structure\_orientation\_system\_stream\_cursor\_value\_input input object.
-}
type alias Structure_orientation_system_stream_cursor_value_input =
    { createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , orientationSystemId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , structureId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Encode a Structure\_orientation\_system\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeStructure_orientation_system_stream_cursor_value_input : Structure_orientation_system_stream_cursor_value_input -> Value
encodeStructure_orientation_system_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "orientationSystemId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.orientationSystemId ), ( "structureId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.structureId ) ]


buildStructure_orientation_system_updates :
    Structure_orientation_system_updatesRequiredFields
    -> (Structure_orientation_system_updatesOptionalFields -> Structure_orientation_system_updatesOptionalFields)
    -> Structure_orientation_system_updates
buildStructure_orientation_system_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Structure_orientation_system_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Structure_orientation_system_updatesRequiredFields =
    { where_ : Structure_orientation_system_bool_exp }


type alias Structure_orientation_system_updatesOptionalFields =
    { set_ : OptionalArgument Structure_orientation_system_set_input }


{-| Type alias for the `Structure_orientation_system_updates` attributes. Note that this type
needs to use the `Structure_orientation_system_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Structure_orientation_system_updatesRaw =
    { set_ : OptionalArgument Structure_orientation_system_set_input
    , where_ : Structure_orientation_system_bool_exp
    }


{-| Type for the Structure\_orientation\_system\_updates input object.
-}
type Structure_orientation_system_updates
    = Structure_orientation_system_updates Structure_orientation_system_updatesRaw


{-| Encode a Structure\_orientation\_system\_updates into a value that can be used as an argument.
-}
encodeStructure_orientation_system_updates : Structure_orientation_system_updates -> Value
encodeStructure_orientation_system_updates (Structure_orientation_system_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeStructure_orientation_system_set_input |> Encode.optional input____.set_ ), ( "where", encodeStructure_orientation_system_bool_exp input____.where_ |> Just ) ]


buildStructure_pk_columns_input :
    Structure_pk_columns_inputRequiredFields
    -> Structure_pk_columns_input
buildStructure_pk_columns_input required____ =
    { id = required____.id }


type alias Structure_pk_columns_inputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Type for the Structure\_pk\_columns\_input input object.
-}
type alias Structure_pk_columns_input =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| Encode a Structure\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeStructure_pk_columns_input : Structure_pk_columns_input -> Value
encodeStructure_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildStructure_set_input :
    (Structure_set_inputOptionalFields -> Structure_set_inputOptionalFields)
    -> Structure_set_input
buildStructure_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { address1 = Absent, address2 = Absent, city = Absent, createdAt = Absent, deploymentId = Absent, email = Absent, id = Absent, name = Absent, phone = Absent, postalCode = Absent, shortDesc = Absent, siret = Absent, updatedAt = Absent, website = Absent }
    in
    { address1 = optionals____.address1, address2 = optionals____.address2, city = optionals____.city, createdAt = optionals____.createdAt, deploymentId = optionals____.deploymentId, email = optionals____.email, id = optionals____.id, name = optionals____.name, phone = optionals____.phone, postalCode = optionals____.postalCode, shortDesc = optionals____.shortDesc, siret = optionals____.siret, updatedAt = optionals____.updatedAt, website = optionals____.website }


type alias Structure_set_inputOptionalFields =
    { address1 : OptionalArgument String
    , address2 : OptionalArgument String
    , city : OptionalArgument String
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deploymentId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , name : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , phone : OptionalArgument String
    , postalCode : OptionalArgument String
    , shortDesc : OptionalArgument String
    , siret : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , website : OptionalArgument String
    }


{-| Type for the Structure\_set\_input input object.
-}
type alias Structure_set_input =
    { address1 : OptionalArgument String
    , address2 : OptionalArgument String
    , city : OptionalArgument String
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deploymentId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , name : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , phone : OptionalArgument String
    , postalCode : OptionalArgument String
    , shortDesc : OptionalArgument String
    , siret : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , website : OptionalArgument String
    }


{-| Encode a Structure\_set\_input into a value that can be used as an argument.
-}
encodeStructure_set_input : Structure_set_input -> Value
encodeStructure_set_input input____ =
    Encode.maybeObject
        [ ( "address1", Encode.string |> Encode.optional input____.address1 ), ( "address2", Encode.string |> Encode.optional input____.address2 ), ( "city", Encode.string |> Encode.optional input____.city ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "deploymentId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.deploymentId ), ( "email", Encode.string |> Encode.optional input____.email ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "name", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.name ), ( "phone", Encode.string |> Encode.optional input____.phone ), ( "postalCode", Encode.string |> Encode.optional input____.postalCode ), ( "shortDesc", Encode.string |> Encode.optional input____.shortDesc ), ( "siret", Encode.string |> Encode.optional input____.siret ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ), ( "website", Encode.string |> Encode.optional input____.website ) ]


buildStructure_stream_cursor_input :
    Structure_stream_cursor_inputRequiredFields
    -> (Structure_stream_cursor_inputOptionalFields -> Structure_stream_cursor_inputOptionalFields)
    -> Structure_stream_cursor_input
buildStructure_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Structure_stream_cursor_inputRequiredFields =
    { initial_value : Structure_stream_cursor_value_input }


type alias Structure_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Structure\_stream\_cursor\_input input object.
-}
type alias Structure_stream_cursor_input =
    { initial_value : Structure_stream_cursor_value_input
    , ordering : OptionalArgument CdbGQL.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Structure\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeStructure_stream_cursor_input : Structure_stream_cursor_input -> Value
encodeStructure_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeStructure_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum CdbGQL.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildStructure_stream_cursor_value_input :
    (Structure_stream_cursor_value_inputOptionalFields -> Structure_stream_cursor_value_inputOptionalFields)
    -> Structure_stream_cursor_value_input
buildStructure_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { address1 = Absent, address2 = Absent, city = Absent, createdAt = Absent, deploymentId = Absent, email = Absent, id = Absent, name = Absent, phone = Absent, postalCode = Absent, shortDesc = Absent, siret = Absent, updatedAt = Absent, website = Absent }
    in
    { address1 = optionals____.address1, address2 = optionals____.address2, city = optionals____.city, createdAt = optionals____.createdAt, deploymentId = optionals____.deploymentId, email = optionals____.email, id = optionals____.id, name = optionals____.name, phone = optionals____.phone, postalCode = optionals____.postalCode, shortDesc = optionals____.shortDesc, siret = optionals____.siret, updatedAt = optionals____.updatedAt, website = optionals____.website }


type alias Structure_stream_cursor_value_inputOptionalFields =
    { address1 : OptionalArgument String
    , address2 : OptionalArgument String
    , city : OptionalArgument String
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deploymentId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , name : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , phone : OptionalArgument String
    , postalCode : OptionalArgument String
    , shortDesc : OptionalArgument String
    , siret : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , website : OptionalArgument String
    }


{-| Type for the Structure\_stream\_cursor\_value\_input input object.
-}
type alias Structure_stream_cursor_value_input =
    { address1 : OptionalArgument String
    , address2 : OptionalArgument String
    , city : OptionalArgument String
    , createdAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , deploymentId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , email : OptionalArgument String
    , id : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , name : OptionalArgument CdbGQL.ScalarCodecs.Citext
    , phone : OptionalArgument String
    , postalCode : OptionalArgument String
    , shortDesc : OptionalArgument String
    , siret : OptionalArgument String
    , updatedAt : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , website : OptionalArgument String
    }


{-| Encode a Structure\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeStructure_stream_cursor_value_input : Structure_stream_cursor_value_input -> Value
encodeStructure_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "address1", Encode.string |> Encode.optional input____.address1 ), ( "address2", Encode.string |> Encode.optional input____.address2 ), ( "city", Encode.string |> Encode.optional input____.city ), ( "createdAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.createdAt ), ( "deploymentId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.deploymentId ), ( "email", Encode.string |> Encode.optional input____.email ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "name", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecCitext) |> Encode.optional input____.name ), ( "phone", Encode.string |> Encode.optional input____.phone ), ( "postalCode", Encode.string |> Encode.optional input____.postalCode ), ( "shortDesc", Encode.string |> Encode.optional input____.shortDesc ), ( "siret", Encode.string |> Encode.optional input____.siret ), ( "updatedAt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updatedAt ), ( "website", Encode.string |> Encode.optional input____.website ) ]


buildStructure_updates :
    Structure_updatesRequiredFields
    -> (Structure_updatesOptionalFields -> Structure_updatesOptionalFields)
    -> Structure_updates
buildStructure_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Structure_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Structure_updatesRequiredFields =
    { where_ : Structure_bool_exp }


type alias Structure_updatesOptionalFields =
    { set_ : OptionalArgument Structure_set_input }


{-| Type alias for the `Structure_updates` attributes. Note that this type
needs to use the `Structure_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Structure_updatesRaw =
    { set_ : OptionalArgument Structure_set_input
    , where_ : Structure_bool_exp
    }


{-| Type for the Structure\_updates input object.
-}
type Structure_updates
    = Structure_updates Structure_updatesRaw


{-| Encode a Structure\_updates into a value that can be used as an argument.
-}
encodeStructure_updates : Structure_updates -> Value
encodeStructure_updates (Structure_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeStructure_set_input |> Encode.optional input____.set_ ), ( "where", encodeStructure_bool_exp input____.where_ |> Just ) ]


buildTimestamp_comparison_exp :
    (Timestamp_comparison_expOptionalFields -> Timestamp_comparison_expOptionalFields)
    -> Timestamp_comparison_exp
buildTimestamp_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals____.eq_, gt_ = optionals____.gt_, gte_ = optionals____.gte_, in_ = optionals____.in_, is_null_ = optionals____.is_null_, lt_ = optionals____.lt_, lte_ = optionals____.lte_, neq_ = optionals____.neq_, nin_ = optionals____.nin_ }


type alias Timestamp_comparison_expOptionalFields =
    { eq_ : OptionalArgument CdbGQL.ScalarCodecs.Timestamp
    , gt_ : OptionalArgument CdbGQL.ScalarCodecs.Timestamp
    , gte_ : OptionalArgument CdbGQL.ScalarCodecs.Timestamp
    , in_ : OptionalArgument (List CdbGQL.ScalarCodecs.Timestamp)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CdbGQL.ScalarCodecs.Timestamp
    , lte_ : OptionalArgument CdbGQL.ScalarCodecs.Timestamp
    , neq_ : OptionalArgument CdbGQL.ScalarCodecs.Timestamp
    , nin_ : OptionalArgument (List CdbGQL.ScalarCodecs.Timestamp)
    }


{-| Type for the Timestamp\_comparison\_exp input object.
-}
type alias Timestamp_comparison_exp =
    { eq_ : OptionalArgument CdbGQL.ScalarCodecs.Timestamp
    , gt_ : OptionalArgument CdbGQL.ScalarCodecs.Timestamp
    , gte_ : OptionalArgument CdbGQL.ScalarCodecs.Timestamp
    , in_ : OptionalArgument (List CdbGQL.ScalarCodecs.Timestamp)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CdbGQL.ScalarCodecs.Timestamp
    , lte_ : OptionalArgument CdbGQL.ScalarCodecs.Timestamp
    , neq_ : OptionalArgument CdbGQL.ScalarCodecs.Timestamp
    , nin_ : OptionalArgument (List CdbGQL.ScalarCodecs.Timestamp)
    }


{-| Encode a Timestamp\_comparison\_exp into a value that can be used as an argument.
-}
encodeTimestamp_comparison_exp : Timestamp_comparison_exp -> Value
encodeTimestamp_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamp) |> Encode.optional input____.eq_ ), ( "_gt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamp) |> Encode.optional input____.gt_ ), ( "_gte", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamp) |> Encode.optional input____.gte_ ), ( "_in", ((CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamp) |> Encode.list) |> Encode.optional input____.in_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_lt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamp) |> Encode.optional input____.lt_ ), ( "_lte", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamp) |> Encode.optional input____.lte_ ), ( "_neq", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamp) |> Encode.optional input____.neq_ ), ( "_nin", ((CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamp) |> Encode.list) |> Encode.optional input____.nin_ ) ]


buildTimestamptz_comparison_exp :
    (Timestamptz_comparison_expOptionalFields -> Timestamptz_comparison_expOptionalFields)
    -> Timestamptz_comparison_exp
buildTimestamptz_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals____.eq_, gt_ = optionals____.gt_, gte_ = optionals____.gte_, in_ = optionals____.in_, is_null_ = optionals____.is_null_, lt_ = optionals____.lt_, lte_ = optionals____.lte_, neq_ = optionals____.neq_, nin_ = optionals____.nin_ }


type alias Timestamptz_comparison_expOptionalFields =
    { eq_ : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , gt_ : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , gte_ : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , in_ : OptionalArgument (List CdbGQL.ScalarCodecs.Timestamptz)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , lte_ : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , neq_ : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , nin_ : OptionalArgument (List CdbGQL.ScalarCodecs.Timestamptz)
    }


{-| Type for the Timestamptz\_comparison\_exp input object.
-}
type alias Timestamptz_comparison_exp =
    { eq_ : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , gt_ : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , gte_ : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , in_ : OptionalArgument (List CdbGQL.ScalarCodecs.Timestamptz)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , lte_ : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , neq_ : OptionalArgument CdbGQL.ScalarCodecs.Timestamptz
    , nin_ : OptionalArgument (List CdbGQL.ScalarCodecs.Timestamptz)
    }


{-| Encode a Timestamptz\_comparison\_exp into a value that can be used as an argument.
-}
encodeTimestamptz_comparison_exp : Timestamptz_comparison_exp -> Value
encodeTimestamptz_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.eq_ ), ( "_gt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.gt_ ), ( "_gte", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.gte_ ), ( "_in", ((CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.list) |> Encode.optional input____.in_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_lt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.lt_ ), ( "_lte", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.lte_ ), ( "_neq", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.neq_ ), ( "_nin", ((CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.list) |> Encode.optional input____.nin_ ) ]


buildUpdateSocioProNotebookSituationInsertInput :
    UpdateSocioProNotebookSituationInsertInputRequiredFields
    -> UpdateSocioProNotebookSituationInsertInput
buildUpdateSocioProNotebookSituationInsertInput required____ =
    { notebookId = required____.notebookId, situationId = required____.situationId }


type alias UpdateSocioProNotebookSituationInsertInputRequiredFields =
    { notebookId : CdbGQL.ScalarCodecs.Uuid
    , situationId : CdbGQL.ScalarCodecs.Uuid
    }


{-| Type for the UpdateSocioProNotebookSituationInsertInput input object.
-}
type alias UpdateSocioProNotebookSituationInsertInput =
    { notebookId : CdbGQL.ScalarCodecs.Uuid
    , situationId : CdbGQL.ScalarCodecs.Uuid
    }


{-| Encode a UpdateSocioProNotebookSituationInsertInput into a value that can be used as an argument.
-}
encodeUpdateSocioProNotebookSituationInsertInput : UpdateSocioProNotebookSituationInsertInput -> Value
encodeUpdateSocioProNotebookSituationInsertInput input____ =
    Encode.maybeObject
        [ ( "notebookId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.notebookId |> Just ), ( "situationId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.situationId |> Just ) ]


buildUpdateSocioProProfessionalProjectInsertInput :
    (UpdateSocioProProfessionalProjectInsertInputOptionalFields -> UpdateSocioProProfessionalProjectInsertInputOptionalFields)
    -> UpdateSocioProProfessionalProjectInsertInput
buildUpdateSocioProProfessionalProjectInsertInput fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { contractTypeId = Absent, employmentTypeId = Absent, hourlyRate = Absent, mobilityRadius = Absent, notebookId = Absent, romeCodeId = Absent }
    in
    { contractTypeId = optionals____.contractTypeId, employmentTypeId = optionals____.employmentTypeId, hourlyRate = optionals____.hourlyRate, mobilityRadius = optionals____.mobilityRadius, notebookId = optionals____.notebookId, romeCodeId = optionals____.romeCodeId }


type alias UpdateSocioProProfessionalProjectInsertInputOptionalFields =
    { contractTypeId : OptionalArgument CdbGQL.Enum.UpdateSocioProContractTypeEnum.UpdateSocioProContractTypeEnum
    , employmentTypeId : OptionalArgument CdbGQL.Enum.UpdateSocioProEmploymentTypeEnum.UpdateSocioProEmploymentTypeEnum
    , hourlyRate : OptionalArgument Int
    , mobilityRadius : OptionalArgument Int
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , romeCodeId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Type for the UpdateSocioProProfessionalProjectInsertInput input object.
-}
type alias UpdateSocioProProfessionalProjectInsertInput =
    { contractTypeId : OptionalArgument CdbGQL.Enum.UpdateSocioProContractTypeEnum.UpdateSocioProContractTypeEnum
    , employmentTypeId : OptionalArgument CdbGQL.Enum.UpdateSocioProEmploymentTypeEnum.UpdateSocioProEmploymentTypeEnum
    , hourlyRate : OptionalArgument Int
    , mobilityRadius : OptionalArgument Int
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , romeCodeId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Encode a UpdateSocioProProfessionalProjectInsertInput into a value that can be used as an argument.
-}
encodeUpdateSocioProProfessionalProjectInsertInput : UpdateSocioProProfessionalProjectInsertInput -> Value
encodeUpdateSocioProProfessionalProjectInsertInput input____ =
    Encode.maybeObject
        [ ( "contractTypeId", Encode.enum CdbGQL.Enum.UpdateSocioProContractTypeEnum.toString |> Encode.optional input____.contractTypeId ), ( "employmentTypeId", Encode.enum CdbGQL.Enum.UpdateSocioProEmploymentTypeEnum.toString |> Encode.optional input____.employmentTypeId ), ( "hourlyRate", Encode.int |> Encode.optional input____.hourlyRate ), ( "mobilityRadius", Encode.int |> Encode.optional input____.mobilityRadius ), ( "notebookId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.notebookId ), ( "romeCodeId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.romeCodeId ) ]


buildUpdateSocioProProfessionalProjectSetInput :
    UpdateSocioProProfessionalProjectSetInputRequiredFields
    -> (UpdateSocioProProfessionalProjectSetInputOptionalFields -> UpdateSocioProProfessionalProjectSetInputOptionalFields)
    -> UpdateSocioProProfessionalProjectSetInput
buildUpdateSocioProProfessionalProjectSetInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { contractTypeId = Absent, employmentTypeId = Absent, hourlyRate = Absent, mobilityRadius = Absent, notebookId = Absent, romeCodeId = Absent }
    in
    { contractTypeId = optionals____.contractTypeId, employmentTypeId = optionals____.employmentTypeId, hourlyRate = optionals____.hourlyRate, id = required____.id, mobilityRadius = optionals____.mobilityRadius, notebookId = optionals____.notebookId, romeCodeId = optionals____.romeCodeId }


type alias UpdateSocioProProfessionalProjectSetInputRequiredFields =
    { id : CdbGQL.ScalarCodecs.Uuid }


type alias UpdateSocioProProfessionalProjectSetInputOptionalFields =
    { contractTypeId : OptionalArgument CdbGQL.Enum.UpdateSocioProContractTypeEnum.UpdateSocioProContractTypeEnum
    , employmentTypeId : OptionalArgument CdbGQL.Enum.UpdateSocioProEmploymentTypeEnum.UpdateSocioProEmploymentTypeEnum
    , hourlyRate : OptionalArgument Int
    , mobilityRadius : OptionalArgument Int
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , romeCodeId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Type for the UpdateSocioProProfessionalProjectSetInput input object.
-}
type alias UpdateSocioProProfessionalProjectSetInput =
    { contractTypeId : OptionalArgument CdbGQL.Enum.UpdateSocioProContractTypeEnum.UpdateSocioProContractTypeEnum
    , employmentTypeId : OptionalArgument CdbGQL.Enum.UpdateSocioProEmploymentTypeEnum.UpdateSocioProEmploymentTypeEnum
    , hourlyRate : OptionalArgument Int
    , id : CdbGQL.ScalarCodecs.Uuid
    , mobilityRadius : OptionalArgument Int
    , notebookId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , romeCodeId : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    }


{-| Encode a UpdateSocioProProfessionalProjectSetInput into a value that can be used as an argument.
-}
encodeUpdateSocioProProfessionalProjectSetInput : UpdateSocioProProfessionalProjectSetInput -> Value
encodeUpdateSocioProProfessionalProjectSetInput input____ =
    Encode.maybeObject
        [ ( "contractTypeId", Encode.enum CdbGQL.Enum.UpdateSocioProContractTypeEnum.toString |> Encode.optional input____.contractTypeId ), ( "employmentTypeId", Encode.enum CdbGQL.Enum.UpdateSocioProEmploymentTypeEnum.toString |> Encode.optional input____.employmentTypeId ), ( "hourlyRate", Encode.int |> Encode.optional input____.hourlyRate ), ( "id", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ), ( "mobilityRadius", Encode.int |> Encode.optional input____.mobilityRadius ), ( "notebookId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.notebookId ), ( "romeCodeId", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.romeCodeId ) ]


buildUuid_comparison_exp :
    (Uuid_comparison_expOptionalFields -> Uuid_comparison_expOptionalFields)
    -> Uuid_comparison_exp
buildUuid_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals____.eq_, gt_ = optionals____.gt_, gte_ = optionals____.gte_, in_ = optionals____.in_, is_null_ = optionals____.is_null_, lt_ = optionals____.lt_, lte_ = optionals____.lte_, neq_ = optionals____.neq_, nin_ = optionals____.nin_ }


type alias Uuid_comparison_expOptionalFields =
    { eq_ : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , gt_ : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , gte_ : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , in_ : OptionalArgument (List CdbGQL.ScalarCodecs.Uuid)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lte_ : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , neq_ : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , nin_ : OptionalArgument (List CdbGQL.ScalarCodecs.Uuid)
    }


{-| Type for the Uuid\_comparison\_exp input object.
-}
type alias Uuid_comparison_exp =
    { eq_ : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , gt_ : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , gte_ : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , in_ : OptionalArgument (List CdbGQL.ScalarCodecs.Uuid)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , lte_ : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , neq_ : OptionalArgument CdbGQL.ScalarCodecs.Uuid
    , nin_ : OptionalArgument (List CdbGQL.ScalarCodecs.Uuid)
    }


{-| Encode a Uuid\_comparison\_exp into a value that can be used as an argument.
-}
encodeUuid_comparison_exp : Uuid_comparison_exp -> Value
encodeUuid_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.eq_ ), ( "_gt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.gt_ ), ( "_gte", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.gte_ ), ( "_in", ((CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.list) |> Encode.optional input____.in_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_lt", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.lt_ ), ( "_lte", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.lte_ ), ( "_neq", (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.neq_ ), ( "_nin", ((CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.list) |> Encode.optional input____.nin_ ) ]
