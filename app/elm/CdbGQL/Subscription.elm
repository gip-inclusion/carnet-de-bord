-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module CdbGQL.Subscription exposing (..)

import CdbGQL.Enum.Account_info_select_column
import CdbGQL.Enum.Account_select_column
import CdbGQL.Enum.Action_status_select_column
import CdbGQL.Enum.Admin_cdb_select_column
import CdbGQL.Enum.Admin_structure_select_column
import CdbGQL.Enum.Admin_structure_structure_select_column
import CdbGQL.Enum.Beneficiary_select_column
import CdbGQL.Enum.Beneficiary_structure_select_column
import CdbGQL.Enum.Contract_type_select_column
import CdbGQL.Enum.Deployment_select_column
import CdbGQL.Enum.Employment_type_select_column
import CdbGQL.Enum.External_data_info_select_column
import CdbGQL.Enum.External_data_select_column
import CdbGQL.Enum.External_source_select_column
import CdbGQL.Enum.Manager_select_column
import CdbGQL.Enum.Notebook_action_select_column
import CdbGQL.Enum.Notebook_appointment_select_column
import CdbGQL.Enum.Notebook_event_select_column
import CdbGQL.Enum.Notebook_event_type_select_column
import CdbGQL.Enum.Notebook_focus_select_column
import CdbGQL.Enum.Notebook_info_select_column
import CdbGQL.Enum.Notebook_member_select_column
import CdbGQL.Enum.Notebook_public_view_select_column
import CdbGQL.Enum.Notebook_select_column
import CdbGQL.Enum.Notebook_situation_select_column
import CdbGQL.Enum.Notebook_target_select_column
import CdbGQL.Enum.Nps_rating_dismissal_select_column
import CdbGQL.Enum.Nps_rating_select_column
import CdbGQL.Enum.Orientation_manager_select_column
import CdbGQL.Enum.Orientation_request_select_column
import CdbGQL.Enum.Orientation_system_select_column
import CdbGQL.Enum.Orientation_type_select_column
import CdbGQL.Enum.Professional_orientation_system_select_column
import CdbGQL.Enum.Professional_project_select_column
import CdbGQL.Enum.Professional_select_column
import CdbGQL.Enum.Ref_action_select_column
import CdbGQL.Enum.Ref_situation_select_column
import CdbGQL.Enum.Ref_target_select_column
import CdbGQL.Enum.Ref_theme_select_column
import CdbGQL.Enum.Role_select_column
import CdbGQL.Enum.Rome_code_select_column
import CdbGQL.Enum.Rsa_closure_reason_select_column
import CdbGQL.Enum.Rsa_suspension_reason_select_column
import CdbGQL.Enum.Structure_orientation_system_select_column
import CdbGQL.Enum.Structure_select_column
import CdbGQL.InputObject
import CdbGQL.Interface
import CdbGQL.Object
import CdbGQL.Scalar
import CdbGQL.ScalarCodecs
import CdbGQL.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)


type alias AccountOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Account_select_column.Account_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Account_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Account_bool_exp
    }


{-| fetch data from the table: "account"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
account :
    (AccountOptionalArguments -> AccountOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Account
    -> SelectionSet (List decodesTo) RootSubscription
account fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Account_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeAccount_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeAccount_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "account" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias AccountAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Account_select_column.Account_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Account_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Account_bool_exp
    }


{-| fetch aggregated fields from the table: "account"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
account_aggregate :
    (AccountAggregateOptionalArguments -> AccountAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Account_aggregate
    -> SelectionSet decodesTo RootSubscription
account_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Account_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeAccount_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeAccount_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "account_aggregate" optionalArgs____ object____ Basics.identity


type alias AccountByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "account" using primary key columns
-}
account_by_pk :
    AccountByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Account
    -> SelectionSet (Maybe decodesTo) RootSubscription
account_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "account_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias AccountInfoOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Account_info_select_column.Account_info_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Account_info_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Account_info_bool_exp
    }


{-| fetch data from the table: "account\_info"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
account_info :
    (AccountInfoOptionalArguments -> AccountInfoOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Account_info
    -> SelectionSet (List decodesTo) RootSubscription
account_info fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Account_info_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeAccount_info_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeAccount_info_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "account_info" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias AccountInfoAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Account_info_select_column.Account_info_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Account_info_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Account_info_bool_exp
    }


{-| fetch aggregated fields from the table: "account\_info"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
account_info_aggregate :
    (AccountInfoAggregateOptionalArguments -> AccountInfoAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Account_info_aggregate
    -> SelectionSet decodesTo RootSubscription
account_info_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Account_info_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeAccount_info_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeAccount_info_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "account_info_aggregate" optionalArgs____ object____ Basics.identity


type alias AccountInfoStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Account_info_bool_exp }


type alias AccountInfoStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Account_info_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "account\_info"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
account_info_stream :
    (AccountInfoStreamOptionalArguments -> AccountInfoStreamOptionalArguments)
    -> AccountInfoStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Account_info
    -> SelectionSet (List decodesTo) RootSubscription
account_info_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeAccount_info_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "account_info_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeAccount_info_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias AccountStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Account_bool_exp }


type alias AccountStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Account_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "account"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
account_stream :
    (AccountStreamOptionalArguments -> AccountStreamOptionalArguments)
    -> AccountStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Account
    -> SelectionSet (List decodesTo) RootSubscription
account_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeAccount_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "account_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeAccount_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias ActionStatusOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Action_status_select_column.Action_status_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Action_status_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Action_status_bool_exp
    }


{-| fetch data from the table: "action\_status"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
action_status :
    (ActionStatusOptionalArguments -> ActionStatusOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Action_status
    -> SelectionSet (List decodesTo) RootSubscription
action_status fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Action_status_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeAction_status_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeAction_status_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "action_status" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias ActionStatusAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Action_status_select_column.Action_status_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Action_status_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Action_status_bool_exp
    }


{-| fetch aggregated fields from the table: "action\_status"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
action_status_aggregate :
    (ActionStatusAggregateOptionalArguments -> ActionStatusAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Action_status_aggregate
    -> SelectionSet decodesTo RootSubscription
action_status_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Action_status_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeAction_status_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeAction_status_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "action_status_aggregate" optionalArgs____ object____ Basics.identity


type alias ActionStatusByPkRequiredArguments =
    { status : String }


{-| fetch data from the table: "action\_status" using primary key columns
-}
action_status_by_pk :
    ActionStatusByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Action_status
    -> SelectionSet (Maybe decodesTo) RootSubscription
action_status_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "action_status_by_pk" [ Argument.required "status" requiredArgs____.status Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias ActionStatusStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Action_status_bool_exp }


type alias ActionStatusStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Action_status_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "action\_status"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
action_status_stream :
    (ActionStatusStreamOptionalArguments -> ActionStatusStreamOptionalArguments)
    -> ActionStatusStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Action_status
    -> SelectionSet (List decodesTo) RootSubscription
action_status_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeAction_status_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "action_status_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeAction_status_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias AdminCdbOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Admin_cdb_select_column.Admin_cdb_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Admin_cdb_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Admin_cdb_bool_exp
    }


{-| fetch data from the table: "admin\_cdb"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
admin_cdb :
    (AdminCdbOptionalArguments -> AdminCdbOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Admin_cdb
    -> SelectionSet (List decodesTo) RootSubscription
admin_cdb fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Admin_cdb_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeAdmin_cdb_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeAdmin_cdb_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "admin_cdb" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias AdminCdbAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Admin_cdb_select_column.Admin_cdb_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Admin_cdb_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Admin_cdb_bool_exp
    }


{-| fetch aggregated fields from the table: "admin\_cdb"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
admin_cdb_aggregate :
    (AdminCdbAggregateOptionalArguments -> AdminCdbAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Admin_cdb_aggregate
    -> SelectionSet decodesTo RootSubscription
admin_cdb_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Admin_cdb_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeAdmin_cdb_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeAdmin_cdb_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "admin_cdb_aggregate" optionalArgs____ object____ Basics.identity


type alias AdminCdbByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "admin\_cdb" using primary key columns
-}
admin_cdb_by_pk :
    AdminCdbByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Admin_cdb
    -> SelectionSet (Maybe decodesTo) RootSubscription
admin_cdb_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "admin_cdb_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias AdminCdbStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Admin_cdb_bool_exp }


type alias AdminCdbStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Admin_cdb_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "admin\_cdb"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
admin_cdb_stream :
    (AdminCdbStreamOptionalArguments -> AdminCdbStreamOptionalArguments)
    -> AdminCdbStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Admin_cdb
    -> SelectionSet (List decodesTo) RootSubscription
admin_cdb_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeAdmin_cdb_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "admin_cdb_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeAdmin_cdb_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias AdminStructureOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Admin_structure_select_column.Admin_structure_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Admin_structure_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Admin_structure_bool_exp
    }


{-| fetch data from the table: "admin\_structure"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
admin_structure :
    (AdminStructureOptionalArguments -> AdminStructureOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Admin_structure
    -> SelectionSet (List decodesTo) RootSubscription
admin_structure fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Admin_structure_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeAdmin_structure_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeAdmin_structure_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "admin_structure" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias AdminStructureAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Admin_structure_select_column.Admin_structure_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Admin_structure_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Admin_structure_bool_exp
    }


{-| fetch aggregated fields from the table: "admin\_structure"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
admin_structure_aggregate :
    (AdminStructureAggregateOptionalArguments -> AdminStructureAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Admin_structure_aggregate
    -> SelectionSet decodesTo RootSubscription
admin_structure_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Admin_structure_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeAdmin_structure_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeAdmin_structure_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "admin_structure_aggregate" optionalArgs____ object____ Basics.identity


type alias AdminStructureByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "admin\_structure" using primary key columns
-}
admin_structure_by_pk :
    AdminStructureByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Admin_structure
    -> SelectionSet (Maybe decodesTo) RootSubscription
admin_structure_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "admin_structure_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias AdminStructureStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Admin_structure_bool_exp }


type alias AdminStructureStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Admin_structure_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "admin\_structure"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
admin_structure_stream :
    (AdminStructureStreamOptionalArguments -> AdminStructureStreamOptionalArguments)
    -> AdminStructureStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Admin_structure
    -> SelectionSet (List decodesTo) RootSubscription
admin_structure_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeAdmin_structure_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "admin_structure_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeAdmin_structure_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias AdminStructureStructureOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Admin_structure_structure_select_column.Admin_structure_structure_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Admin_structure_structure_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Admin_structure_structure_bool_exp
    }


{-| fetch data from the table: "admin\_structure\_structure"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
admin_structure_structure :
    (AdminStructureStructureOptionalArguments -> AdminStructureStructureOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Admin_structure_structure
    -> SelectionSet (List decodesTo) RootSubscription
admin_structure_structure fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Admin_structure_structure_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeAdmin_structure_structure_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeAdmin_structure_structure_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "admin_structure_structure" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias AdminStructureStructureAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Admin_structure_structure_select_column.Admin_structure_structure_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Admin_structure_structure_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Admin_structure_structure_bool_exp
    }


{-| fetch aggregated fields from the table: "admin\_structure\_structure"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
admin_structure_structure_aggregate :
    (AdminStructureStructureAggregateOptionalArguments -> AdminStructureStructureAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Admin_structure_structure_aggregate
    -> SelectionSet decodesTo RootSubscription
admin_structure_structure_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Admin_structure_structure_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeAdmin_structure_structure_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeAdmin_structure_structure_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "admin_structure_structure_aggregate" optionalArgs____ object____ Basics.identity


type alias AdminStructureStructureByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "admin\_structure\_structure" using primary key columns
-}
admin_structure_structure_by_pk :
    AdminStructureStructureByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Admin_structure_structure
    -> SelectionSet (Maybe decodesTo) RootSubscription
admin_structure_structure_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "admin_structure_structure_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias AdminStructureStructureStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Admin_structure_structure_bool_exp }


type alias AdminStructureStructureStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Admin_structure_structure_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "admin\_structure\_structure"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
admin_structure_structure_stream :
    (AdminStructureStructureStreamOptionalArguments -> AdminStructureStructureStreamOptionalArguments)
    -> AdminStructureStructureStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Admin_structure_structure
    -> SelectionSet (List decodesTo) RootSubscription
admin_structure_structure_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeAdmin_structure_structure_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "admin_structure_structure_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeAdmin_structure_structure_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias BeneficiaryOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Beneficiary_select_column.Beneficiary_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Beneficiary_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Beneficiary_bool_exp
    }


{-| fetch data from the table: "beneficiary"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
beneficiary :
    (BeneficiaryOptionalArguments -> BeneficiaryOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary
    -> SelectionSet (List decodesTo) RootSubscription
beneficiary fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Beneficiary_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeBeneficiary_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeBeneficiary_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "beneficiary" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias BeneficiaryAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Beneficiary_select_column.Beneficiary_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Beneficiary_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Beneficiary_bool_exp
    }


{-| fetch aggregated fields from the table: "beneficiary"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
beneficiary_aggregate :
    (BeneficiaryAggregateOptionalArguments -> BeneficiaryAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary_aggregate
    -> SelectionSet decodesTo RootSubscription
beneficiary_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Beneficiary_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeBeneficiary_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeBeneficiary_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "beneficiary_aggregate" optionalArgs____ object____ Basics.identity


type alias BeneficiaryByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "beneficiary" using primary key columns
-}
beneficiary_by_pk :
    BeneficiaryByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary
    -> SelectionSet (Maybe decodesTo) RootSubscription
beneficiary_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "beneficiary_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias BeneficiaryStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Beneficiary_bool_exp }


type alias BeneficiaryStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Beneficiary_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "beneficiary"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
beneficiary_stream :
    (BeneficiaryStreamOptionalArguments -> BeneficiaryStreamOptionalArguments)
    -> BeneficiaryStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary
    -> SelectionSet (List decodesTo) RootSubscription
beneficiary_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeBeneficiary_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "beneficiary_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeBeneficiary_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias BeneficiaryStructureOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Beneficiary_structure_select_column.Beneficiary_structure_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Beneficiary_structure_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Beneficiary_structure_bool_exp
    }


{-| fetch data from the table: "beneficiary\_structure"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
beneficiary_structure :
    (BeneficiaryStructureOptionalArguments -> BeneficiaryStructureOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary_structure
    -> SelectionSet (List decodesTo) RootSubscription
beneficiary_structure fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Beneficiary_structure_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeBeneficiary_structure_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeBeneficiary_structure_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "beneficiary_structure" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias BeneficiaryStructureAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Beneficiary_structure_select_column.Beneficiary_structure_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Beneficiary_structure_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Beneficiary_structure_bool_exp
    }


{-| fetch aggregated fields from the table: "beneficiary\_structure"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
beneficiary_structure_aggregate :
    (BeneficiaryStructureAggregateOptionalArguments -> BeneficiaryStructureAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary_structure_aggregate
    -> SelectionSet decodesTo RootSubscription
beneficiary_structure_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Beneficiary_structure_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeBeneficiary_structure_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeBeneficiary_structure_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "beneficiary_structure_aggregate" optionalArgs____ object____ Basics.identity


type alias BeneficiaryStructureByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "beneficiary\_structure" using primary key columns
-}
beneficiary_structure_by_pk :
    BeneficiaryStructureByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary_structure
    -> SelectionSet (Maybe decodesTo) RootSubscription
beneficiary_structure_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "beneficiary_structure_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias BeneficiaryStructureStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Beneficiary_structure_bool_exp }


type alias BeneficiaryStructureStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Beneficiary_structure_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "beneficiary\_structure"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
beneficiary_structure_stream :
    (BeneficiaryStructureStreamOptionalArguments -> BeneficiaryStructureStreamOptionalArguments)
    -> BeneficiaryStructureStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary_structure
    -> SelectionSet (List decodesTo) RootSubscription
beneficiary_structure_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeBeneficiary_structure_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "beneficiary_structure_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeBeneficiary_structure_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias ContractTypeOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Contract_type_select_column.Contract_type_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Contract_type_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Contract_type_bool_exp
    }


{-| fetch data from the table: "contract\_type"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
contract_type :
    (ContractTypeOptionalArguments -> ContractTypeOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Contract_type
    -> SelectionSet (List decodesTo) RootSubscription
contract_type fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Contract_type_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeContract_type_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeContract_type_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "contract_type" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias ContractTypeAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Contract_type_select_column.Contract_type_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Contract_type_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Contract_type_bool_exp
    }


{-| fetch aggregated fields from the table: "contract\_type"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
contract_type_aggregate :
    (ContractTypeAggregateOptionalArguments -> ContractTypeAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Contract_type_aggregate
    -> SelectionSet decodesTo RootSubscription
contract_type_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Contract_type_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeContract_type_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeContract_type_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "contract_type_aggregate" optionalArgs____ object____ Basics.identity


type alias ContractTypeByPkRequiredArguments =
    { id : String }


{-| fetch data from the table: "contract\_type" using primary key columns
-}
contract_type_by_pk :
    ContractTypeByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Contract_type
    -> SelectionSet (Maybe decodesTo) RootSubscription
contract_type_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "contract_type_by_pk" [ Argument.required "id" requiredArgs____.id Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias ContractTypeStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Contract_type_bool_exp }


type alias ContractTypeStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Contract_type_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "contract\_type"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
contract_type_stream :
    (ContractTypeStreamOptionalArguments -> ContractTypeStreamOptionalArguments)
    -> ContractTypeStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Contract_type
    -> SelectionSet (List decodesTo) RootSubscription
contract_type_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeContract_type_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "contract_type_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeContract_type_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias DeploymentOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Deployment_select_column.Deployment_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Deployment_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Deployment_bool_exp
    }


{-| fetch data from the table: "deployment"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
deployment :
    (DeploymentOptionalArguments -> DeploymentOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Deployment
    -> SelectionSet (List decodesTo) RootSubscription
deployment fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Deployment_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeDeployment_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeDeployment_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "deployment" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias DeploymentAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Deployment_select_column.Deployment_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Deployment_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Deployment_bool_exp
    }


{-| fetch aggregated fields from the table: "deployment"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
deployment_aggregate :
    (DeploymentAggregateOptionalArguments -> DeploymentAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Deployment_aggregate
    -> SelectionSet decodesTo RootSubscription
deployment_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Deployment_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeDeployment_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeDeployment_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "deployment_aggregate" optionalArgs____ object____ Basics.identity


type alias DeploymentByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "deployment" using primary key columns
-}
deployment_by_pk :
    DeploymentByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Deployment
    -> SelectionSet (Maybe decodesTo) RootSubscription
deployment_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "deployment_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeploymentStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Deployment_bool_exp }


type alias DeploymentStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Deployment_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "deployment"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
deployment_stream :
    (DeploymentStreamOptionalArguments -> DeploymentStreamOptionalArguments)
    -> DeploymentStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Deployment
    -> SelectionSet (List decodesTo) RootSubscription
deployment_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeDeployment_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "deployment_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeDeployment_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias EmploymentTypeOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Employment_type_select_column.Employment_type_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Employment_type_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Employment_type_bool_exp
    }


{-| fetch data from the table: "employment\_type"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
employment_type :
    (EmploymentTypeOptionalArguments -> EmploymentTypeOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Employment_type
    -> SelectionSet (List decodesTo) RootSubscription
employment_type fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Employment_type_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeEmployment_type_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeEmployment_type_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "employment_type" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias EmploymentTypeAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Employment_type_select_column.Employment_type_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Employment_type_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Employment_type_bool_exp
    }


{-| fetch aggregated fields from the table: "employment\_type"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
employment_type_aggregate :
    (EmploymentTypeAggregateOptionalArguments -> EmploymentTypeAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Employment_type_aggregate
    -> SelectionSet decodesTo RootSubscription
employment_type_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Employment_type_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeEmployment_type_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeEmployment_type_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "employment_type_aggregate" optionalArgs____ object____ Basics.identity


type alias EmploymentTypeByPkRequiredArguments =
    { id : String }


{-| fetch data from the table: "employment\_type" using primary key columns
-}
employment_type_by_pk :
    EmploymentTypeByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Employment_type
    -> SelectionSet (Maybe decodesTo) RootSubscription
employment_type_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "employment_type_by_pk" [ Argument.required "id" requiredArgs____.id Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias EmploymentTypeStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Employment_type_bool_exp }


type alias EmploymentTypeStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Employment_type_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "employment\_type"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
employment_type_stream :
    (EmploymentTypeStreamOptionalArguments -> EmploymentTypeStreamOptionalArguments)
    -> EmploymentTypeStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Employment_type
    -> SelectionSet (List decodesTo) RootSubscription
employment_type_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeEmployment_type_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "employment_type_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeEmployment_type_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias ExternalDataOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.External_data_select_column.External_data_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.External_data_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.External_data_bool_exp
    }


{-| An array relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
external_data :
    (ExternalDataOptionalArguments -> ExternalDataOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.External_data
    -> SelectionSet (List decodesTo) RootSubscription
external_data fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.External_data_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeExternal_data_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeExternal_data_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "external_data" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias ExternalDataAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.External_data_select_column.External_data_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.External_data_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.External_data_bool_exp
    }


{-| An aggregate relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
external_data_aggregate :
    (ExternalDataAggregateOptionalArguments -> ExternalDataAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.External_data_aggregate
    -> SelectionSet decodesTo RootSubscription
external_data_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.External_data_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeExternal_data_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeExternal_data_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "external_data_aggregate" optionalArgs____ object____ Basics.identity


type alias ExternalDataByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "external\_data" using primary key columns
-}
external_data_by_pk :
    ExternalDataByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.External_data
    -> SelectionSet (Maybe decodesTo) RootSubscription
external_data_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "external_data_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias ExternalDataInfoOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.External_data_info_select_column.External_data_info_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.External_data_info_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.External_data_info_bool_exp
    }


{-| fetch data from the table: "external\_data\_info"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
external_data_info :
    (ExternalDataInfoOptionalArguments -> ExternalDataInfoOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.External_data_info
    -> SelectionSet (List decodesTo) RootSubscription
external_data_info fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.External_data_info_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeExternal_data_info_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeExternal_data_info_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "external_data_info" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias ExternalDataInfoAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.External_data_info_select_column.External_data_info_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.External_data_info_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.External_data_info_bool_exp
    }


{-| fetch aggregated fields from the table: "external\_data\_info"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
external_data_info_aggregate :
    (ExternalDataInfoAggregateOptionalArguments -> ExternalDataInfoAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.External_data_info_aggregate
    -> SelectionSet decodesTo RootSubscription
external_data_info_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.External_data_info_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeExternal_data_info_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeExternal_data_info_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "external_data_info_aggregate" optionalArgs____ object____ Basics.identity


type alias ExternalDataInfoByPkRequiredArguments =
    { external_data_id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "external\_data\_info" using primary key columns
-}
external_data_info_by_pk :
    ExternalDataInfoByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.External_data_info
    -> SelectionSet (Maybe decodesTo) RootSubscription
external_data_info_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "external_data_info_by_pk" [ Argument.required "external_data_id" requiredArgs____.external_data_id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias ExternalDataInfoStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.External_data_info_bool_exp }


type alias ExternalDataInfoStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.External_data_info_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "external\_data\_info"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
external_data_info_stream :
    (ExternalDataInfoStreamOptionalArguments -> ExternalDataInfoStreamOptionalArguments)
    -> ExternalDataInfoStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.External_data_info
    -> SelectionSet (List decodesTo) RootSubscription
external_data_info_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeExternal_data_info_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "external_data_info_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeExternal_data_info_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias ExternalDataStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.External_data_bool_exp }


type alias ExternalDataStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.External_data_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "external\_data"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
external_data_stream :
    (ExternalDataStreamOptionalArguments -> ExternalDataStreamOptionalArguments)
    -> ExternalDataStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.External_data
    -> SelectionSet (List decodesTo) RootSubscription
external_data_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeExternal_data_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "external_data_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeExternal_data_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias ExternalSourceOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.External_source_select_column.External_source_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.External_source_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.External_source_bool_exp
    }


{-| fetch data from the table: "external\_source"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
external_source :
    (ExternalSourceOptionalArguments -> ExternalSourceOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.External_source
    -> SelectionSet (List decodesTo) RootSubscription
external_source fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.External_source_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeExternal_source_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeExternal_source_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "external_source" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias ExternalSourceAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.External_source_select_column.External_source_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.External_source_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.External_source_bool_exp
    }


{-| fetch aggregated fields from the table: "external\_source"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
external_source_aggregate :
    (ExternalSourceAggregateOptionalArguments -> ExternalSourceAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.External_source_aggregate
    -> SelectionSet decodesTo RootSubscription
external_source_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.External_source_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeExternal_source_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeExternal_source_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "external_source_aggregate" optionalArgs____ object____ Basics.identity


type alias ExternalSourceByPkRequiredArguments =
    { value : String }


{-| fetch data from the table: "external\_source" using primary key columns
-}
external_source_by_pk :
    ExternalSourceByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.External_source
    -> SelectionSet (Maybe decodesTo) RootSubscription
external_source_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "external_source_by_pk" [ Argument.required "value" requiredArgs____.value Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias ExternalSourceStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.External_source_bool_exp }


type alias ExternalSourceStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.External_source_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "external\_source"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
external_source_stream :
    (ExternalSourceStreamOptionalArguments -> ExternalSourceStreamOptionalArguments)
    -> ExternalSourceStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.External_source
    -> SelectionSet (List decodesTo) RootSubscription
external_source_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeExternal_source_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "external_source_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeExternal_source_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias GetBeneficiariesFromNirOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Beneficiary_select_column.Beneficiary_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Beneficiary_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Beneficiary_bool_exp
    }


type alias GetBeneficiariesFromNirRequiredArguments =
    { args : CdbGQL.InputObject.Get_beneficiaries_from_nir_args }


{-| execute function "get\_beneficiaries\_from\_nir" which returns "beneficiary"

  - args - input parameters for function "get\_beneficiaries\_from\_nir"
  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
get_beneficiaries_from_nir :
    (GetBeneficiariesFromNirOptionalArguments -> GetBeneficiariesFromNirOptionalArguments)
    -> GetBeneficiariesFromNirRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary
    -> SelectionSet (List decodesTo) RootSubscription
get_beneficiaries_from_nir fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Beneficiary_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeBeneficiary_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeBeneficiary_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "get_beneficiaries_from_nir" (optionalArgs____ ++ [ Argument.required "args" requiredArgs____.args CdbGQL.InputObject.encodeGet_beneficiaries_from_nir_args ]) object____ (Basics.identity >> Decode.list)


type alias GetBeneficiariesFromNirAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Beneficiary_select_column.Beneficiary_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Beneficiary_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Beneficiary_bool_exp
    }


type alias GetBeneficiariesFromNirAggregateRequiredArguments =
    { args : CdbGQL.InputObject.Get_beneficiaries_from_nir_args }


{-| execute function "get\_beneficiaries\_from\_nir" and query aggregates on result of table type "beneficiary"

  - args - input parameters for function "get\_beneficiaries\_from\_nir\_aggregate"
  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
get_beneficiaries_from_nir_aggregate :
    (GetBeneficiariesFromNirAggregateOptionalArguments -> GetBeneficiariesFromNirAggregateOptionalArguments)
    -> GetBeneficiariesFromNirAggregateRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary_aggregate
    -> SelectionSet decodesTo RootSubscription
get_beneficiaries_from_nir_aggregate fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Beneficiary_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeBeneficiary_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeBeneficiary_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "get_beneficiaries_from_nir_aggregate" (optionalArgs____ ++ [ Argument.required "args" requiredArgs____.args CdbGQL.InputObject.encodeGet_beneficiaries_from_nir_args ]) object____ Basics.identity


type alias ManagerOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Manager_select_column.Manager_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Manager_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Manager_bool_exp
    }


{-| fetch data from the table: "manager"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
manager :
    (ManagerOptionalArguments -> ManagerOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Manager
    -> SelectionSet (List decodesTo) RootSubscription
manager fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Manager_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeManager_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeManager_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "manager" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias ManagerAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Manager_select_column.Manager_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Manager_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Manager_bool_exp
    }


{-| fetch aggregated fields from the table: "manager"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
manager_aggregate :
    (ManagerAggregateOptionalArguments -> ManagerAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Manager_aggregate
    -> SelectionSet decodesTo RootSubscription
manager_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Manager_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeManager_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeManager_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "manager_aggregate" optionalArgs____ object____ Basics.identity


type alias ManagerByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "manager" using primary key columns
-}
manager_by_pk :
    ManagerByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Manager
    -> SelectionSet (Maybe decodesTo) RootSubscription
manager_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "manager_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias ManagerStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Manager_bool_exp }


type alias ManagerStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Manager_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "manager"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
manager_stream :
    (ManagerStreamOptionalArguments -> ManagerStreamOptionalArguments)
    -> ManagerStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Manager
    -> SelectionSet (List decodesTo) RootSubscription
manager_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeManager_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "manager_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeManager_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias NotebookOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_select_column.Notebook_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_bool_exp
    }


{-| fetch data from the table: "notebook"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook :
    (NotebookOptionalArguments -> NotebookOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook
    -> SelectionSet (List decodesTo) RootSubscription
notebook fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias NotebookActionOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_action_select_column.Notebook_action_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_action_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_action_bool_exp
    }


{-| fetch data from the table: "notebook\_action"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_action :
    (NotebookActionOptionalArguments -> NotebookActionOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_action
    -> SelectionSet (List decodesTo) RootSubscription
notebook_action fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_action_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_action_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_action_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_action" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias NotebookActionAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_action_select_column.Notebook_action_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_action_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_action_bool_exp
    }


{-| fetch aggregated fields from the table: "notebook\_action"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_action_aggregate :
    (NotebookActionAggregateOptionalArguments -> NotebookActionAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_action_aggregate
    -> SelectionSet decodesTo RootSubscription
notebook_action_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_action_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_action_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_action_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_action_aggregate" optionalArgs____ object____ Basics.identity


type alias NotebookActionByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "notebook\_action" using primary key columns
-}
notebook_action_by_pk :
    NotebookActionByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_action
    -> SelectionSet (Maybe decodesTo) RootSubscription
notebook_action_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "notebook_action_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias NotebookActionStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Notebook_action_bool_exp }


type alias NotebookActionStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Notebook_action_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "notebook\_action"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
notebook_action_stream :
    (NotebookActionStreamOptionalArguments -> NotebookActionStreamOptionalArguments)
    -> NotebookActionStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_action
    -> SelectionSet (List decodesTo) RootSubscription
notebook_action_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_action_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_action_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeNotebook_action_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias NotebookAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_select_column.Notebook_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_bool_exp
    }


{-| fetch aggregated fields from the table: "notebook"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_aggregate :
    (NotebookAggregateOptionalArguments -> NotebookAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_aggregate
    -> SelectionSet decodesTo RootSubscription
notebook_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_aggregate" optionalArgs____ object____ Basics.identity


type alias NotebookAppointmentOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_appointment_select_column.Notebook_appointment_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_appointment_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_appointment_bool_exp
    }


{-| fetch data from the table: "notebook\_appointment"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_appointment :
    (NotebookAppointmentOptionalArguments -> NotebookAppointmentOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_appointment
    -> SelectionSet (List decodesTo) RootSubscription
notebook_appointment fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_appointment_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_appointment_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_appointment_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_appointment" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias NotebookAppointmentAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_appointment_select_column.Notebook_appointment_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_appointment_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_appointment_bool_exp
    }


{-| fetch aggregated fields from the table: "notebook\_appointment"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_appointment_aggregate :
    (NotebookAppointmentAggregateOptionalArguments -> NotebookAppointmentAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_appointment_aggregate
    -> SelectionSet decodesTo RootSubscription
notebook_appointment_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_appointment_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_appointment_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_appointment_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_appointment_aggregate" optionalArgs____ object____ Basics.identity


type alias NotebookAppointmentByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "notebook\_appointment" using primary key columns
-}
notebook_appointment_by_pk :
    NotebookAppointmentByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_appointment
    -> SelectionSet (Maybe decodesTo) RootSubscription
notebook_appointment_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "notebook_appointment_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias NotebookAppointmentStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Notebook_appointment_bool_exp }


type alias NotebookAppointmentStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Notebook_appointment_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "notebook\_appointment"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
notebook_appointment_stream :
    (NotebookAppointmentStreamOptionalArguments -> NotebookAppointmentStreamOptionalArguments)
    -> NotebookAppointmentStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_appointment
    -> SelectionSet (List decodesTo) RootSubscription
notebook_appointment_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_appointment_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_appointment_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeNotebook_appointment_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias NotebookByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "notebook" using primary key columns
-}
notebook_by_pk :
    NotebookByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook
    -> SelectionSet (Maybe decodesTo) RootSubscription
notebook_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "notebook_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias NotebookEventOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_event_select_column.Notebook_event_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_event_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_event_bool_exp
    }


{-| fetch data from the table: "notebook\_event"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_event :
    (NotebookEventOptionalArguments -> NotebookEventOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_event
    -> SelectionSet (List decodesTo) RootSubscription
notebook_event fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_event_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_event_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_event_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_event" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias NotebookEventAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_event_select_column.Notebook_event_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_event_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_event_bool_exp
    }


{-| fetch aggregated fields from the table: "notebook\_event"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_event_aggregate :
    (NotebookEventAggregateOptionalArguments -> NotebookEventAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_event_aggregate
    -> SelectionSet decodesTo RootSubscription
notebook_event_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_event_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_event_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_event_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_event_aggregate" optionalArgs____ object____ Basics.identity


type alias NotebookEventByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "notebook\_event" using primary key columns
-}
notebook_event_by_pk :
    NotebookEventByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_event
    -> SelectionSet (Maybe decodesTo) RootSubscription
notebook_event_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "notebook_event_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias NotebookEventStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Notebook_event_bool_exp }


type alias NotebookEventStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Notebook_event_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "notebook\_event"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
notebook_event_stream :
    (NotebookEventStreamOptionalArguments -> NotebookEventStreamOptionalArguments)
    -> NotebookEventStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_event
    -> SelectionSet (List decodesTo) RootSubscription
notebook_event_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_event_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_event_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeNotebook_event_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias NotebookEventTypeOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_event_type_select_column.Notebook_event_type_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_event_type_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_event_type_bool_exp
    }


{-| fetch data from the table: "notebook\_event\_type"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_event_type :
    (NotebookEventTypeOptionalArguments -> NotebookEventTypeOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_event_type
    -> SelectionSet (List decodesTo) RootSubscription
notebook_event_type fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_event_type_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_event_type_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_event_type_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_event_type" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias NotebookEventTypeAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_event_type_select_column.Notebook_event_type_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_event_type_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_event_type_bool_exp
    }


{-| fetch aggregated fields from the table: "notebook\_event\_type"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_event_type_aggregate :
    (NotebookEventTypeAggregateOptionalArguments -> NotebookEventTypeAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_event_type_aggregate
    -> SelectionSet decodesTo RootSubscription
notebook_event_type_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_event_type_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_event_type_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_event_type_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_event_type_aggregate" optionalArgs____ object____ Basics.identity


type alias NotebookEventTypeByPkRequiredArguments =
    { value : String }


{-| fetch data from the table: "notebook\_event\_type" using primary key columns
-}
notebook_event_type_by_pk :
    NotebookEventTypeByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_event_type
    -> SelectionSet (Maybe decodesTo) RootSubscription
notebook_event_type_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "notebook_event_type_by_pk" [ Argument.required "value" requiredArgs____.value Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias NotebookEventTypeStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Notebook_event_type_bool_exp }


type alias NotebookEventTypeStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Notebook_event_type_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "notebook\_event\_type"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
notebook_event_type_stream :
    (NotebookEventTypeStreamOptionalArguments -> NotebookEventTypeStreamOptionalArguments)
    -> NotebookEventTypeStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_event_type
    -> SelectionSet (List decodesTo) RootSubscription
notebook_event_type_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_event_type_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_event_type_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeNotebook_event_type_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias NotebookFocusOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_focus_select_column.Notebook_focus_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_focus_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_focus_bool_exp
    }


{-| fetch data from the table: "notebook\_focus"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_focus :
    (NotebookFocusOptionalArguments -> NotebookFocusOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_focus
    -> SelectionSet (List decodesTo) RootSubscription
notebook_focus fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_focus_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_focus_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_focus_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_focus" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias NotebookFocusAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_focus_select_column.Notebook_focus_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_focus_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_focus_bool_exp
    }


{-| fetch aggregated fields from the table: "notebook\_focus"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_focus_aggregate :
    (NotebookFocusAggregateOptionalArguments -> NotebookFocusAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_focus_aggregate
    -> SelectionSet decodesTo RootSubscription
notebook_focus_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_focus_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_focus_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_focus_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_focus_aggregate" optionalArgs____ object____ Basics.identity


type alias NotebookFocusByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "notebook\_focus" using primary key columns
-}
notebook_focus_by_pk :
    NotebookFocusByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_focus
    -> SelectionSet (Maybe decodesTo) RootSubscription
notebook_focus_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "notebook_focus_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias NotebookFocusStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Notebook_focus_bool_exp }


type alias NotebookFocusStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Notebook_focus_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "notebook\_focus"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
notebook_focus_stream :
    (NotebookFocusStreamOptionalArguments -> NotebookFocusStreamOptionalArguments)
    -> NotebookFocusStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_focus
    -> SelectionSet (List decodesTo) RootSubscription
notebook_focus_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_focus_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_focus_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeNotebook_focus_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias NotebookInfoOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_info_select_column.Notebook_info_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_info_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_info_bool_exp
    }


{-| fetch data from the table: "notebook\_info"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_info :
    (NotebookInfoOptionalArguments -> NotebookInfoOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_info
    -> SelectionSet (List decodesTo) RootSubscription
notebook_info fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_info_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_info_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_info_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_info" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias NotebookInfoAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_info_select_column.Notebook_info_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_info_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_info_bool_exp
    }


{-| fetch aggregated fields from the table: "notebook\_info"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_info_aggregate :
    (NotebookInfoAggregateOptionalArguments -> NotebookInfoAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_info_aggregate
    -> SelectionSet decodesTo RootSubscription
notebook_info_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_info_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_info_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_info_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_info_aggregate" optionalArgs____ object____ Basics.identity


type alias NotebookInfoByPkRequiredArguments =
    { notebookId : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "notebook\_info" using primary key columns
-}
notebook_info_by_pk :
    NotebookInfoByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_info
    -> SelectionSet (Maybe decodesTo) RootSubscription
notebook_info_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "notebook_info_by_pk" [ Argument.required "notebookId" requiredArgs____.notebookId (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias NotebookInfoStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Notebook_info_bool_exp }


type alias NotebookInfoStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Notebook_info_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "notebook\_info"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
notebook_info_stream :
    (NotebookInfoStreamOptionalArguments -> NotebookInfoStreamOptionalArguments)
    -> NotebookInfoStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_info
    -> SelectionSet (List decodesTo) RootSubscription
notebook_info_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_info_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_info_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeNotebook_info_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias NotebookMemberOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_member_select_column.Notebook_member_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_member_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_member_bool_exp
    }


{-| fetch data from the table: "notebook\_member"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_member :
    (NotebookMemberOptionalArguments -> NotebookMemberOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_member
    -> SelectionSet (List decodesTo) RootSubscription
notebook_member fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_member_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_member_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_member_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_member" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias NotebookMemberAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_member_select_column.Notebook_member_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_member_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_member_bool_exp
    }


{-| fetch aggregated fields from the table: "notebook\_member"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_member_aggregate :
    (NotebookMemberAggregateOptionalArguments -> NotebookMemberAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_member_aggregate
    -> SelectionSet decodesTo RootSubscription
notebook_member_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_member_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_member_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_member_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_member_aggregate" optionalArgs____ object____ Basics.identity


type alias NotebookMemberByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "notebook\_member" using primary key columns
-}
notebook_member_by_pk :
    NotebookMemberByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_member
    -> SelectionSet (Maybe decodesTo) RootSubscription
notebook_member_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "notebook_member_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias NotebookMemberStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Notebook_member_bool_exp }


type alias NotebookMemberStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Notebook_member_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "notebook\_member"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
notebook_member_stream :
    (NotebookMemberStreamOptionalArguments -> NotebookMemberStreamOptionalArguments)
    -> NotebookMemberStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_member
    -> SelectionSet (List decodesTo) RootSubscription
notebook_member_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_member_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_member_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeNotebook_member_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias NotebookPublicViewOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_public_view_select_column.Notebook_public_view_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_public_view_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_public_view_bool_exp
    }


{-| fetch data from the table: "notebook\_public\_view"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_public_view :
    (NotebookPublicViewOptionalArguments -> NotebookPublicViewOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_public_view
    -> SelectionSet (List decodesTo) RootSubscription
notebook_public_view fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_public_view_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_public_view_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_public_view_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_public_view" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias NotebookPublicViewAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_public_view_select_column.Notebook_public_view_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_public_view_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_public_view_bool_exp
    }


{-| fetch aggregated fields from the table: "notebook\_public\_view"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_public_view_aggregate :
    (NotebookPublicViewAggregateOptionalArguments -> NotebookPublicViewAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_public_view_aggregate
    -> SelectionSet decodesTo RootSubscription
notebook_public_view_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_public_view_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_public_view_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_public_view_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_public_view_aggregate" optionalArgs____ object____ Basics.identity


type alias NotebookPublicViewStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Notebook_public_view_bool_exp }


type alias NotebookPublicViewStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Notebook_public_view_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "notebook\_public\_view"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
notebook_public_view_stream :
    (NotebookPublicViewStreamOptionalArguments -> NotebookPublicViewStreamOptionalArguments)
    -> NotebookPublicViewStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_public_view
    -> SelectionSet (List decodesTo) RootSubscription
notebook_public_view_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_public_view_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_public_view_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeNotebook_public_view_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias NotebookSituationOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_situation_select_column.Notebook_situation_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_situation_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_situation_bool_exp
    }


{-| fetch data from the table: "notebook\_situation"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_situation :
    (NotebookSituationOptionalArguments -> NotebookSituationOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_situation
    -> SelectionSet (List decodesTo) RootSubscription
notebook_situation fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_situation_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_situation_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_situation_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_situation" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias NotebookSituationAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_situation_select_column.Notebook_situation_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_situation_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_situation_bool_exp
    }


{-| fetch aggregated fields from the table: "notebook\_situation"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_situation_aggregate :
    (NotebookSituationAggregateOptionalArguments -> NotebookSituationAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_situation_aggregate
    -> SelectionSet decodesTo RootSubscription
notebook_situation_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_situation_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_situation_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_situation_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_situation_aggregate" optionalArgs____ object____ Basics.identity


type alias NotebookSituationByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "notebook\_situation" using primary key columns
-}
notebook_situation_by_pk :
    NotebookSituationByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_situation
    -> SelectionSet (Maybe decodesTo) RootSubscription
notebook_situation_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "notebook_situation_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias NotebookSituationStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Notebook_situation_bool_exp }


type alias NotebookSituationStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Notebook_situation_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "notebook\_situation"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
notebook_situation_stream :
    (NotebookSituationStreamOptionalArguments -> NotebookSituationStreamOptionalArguments)
    -> NotebookSituationStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_situation
    -> SelectionSet (List decodesTo) RootSubscription
notebook_situation_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_situation_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_situation_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeNotebook_situation_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias NotebookStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Notebook_bool_exp }


type alias NotebookStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Notebook_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "notebook"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
notebook_stream :
    (NotebookStreamOptionalArguments -> NotebookStreamOptionalArguments)
    -> NotebookStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook
    -> SelectionSet (List decodesTo) RootSubscription
notebook_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeNotebook_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias NotebookTargetOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_target_select_column.Notebook_target_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_target_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_target_bool_exp
    }


{-| fetch data from the table: "notebook\_target"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_target :
    (NotebookTargetOptionalArguments -> NotebookTargetOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_target
    -> SelectionSet (List decodesTo) RootSubscription
notebook_target fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_target_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_target_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_target_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_target" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias NotebookTargetAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_target_select_column.Notebook_target_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_target_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_target_bool_exp
    }


{-| fetch aggregated fields from the table: "notebook\_target"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
notebook_target_aggregate :
    (NotebookTargetAggregateOptionalArguments -> NotebookTargetAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_target_aggregate
    -> SelectionSet decodesTo RootSubscription
notebook_target_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_target_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_target_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_target_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_target_aggregate" optionalArgs____ object____ Basics.identity


type alias NotebookTargetByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "notebook\_target" using primary key columns
-}
notebook_target_by_pk :
    NotebookTargetByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_target
    -> SelectionSet (Maybe decodesTo) RootSubscription
notebook_target_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "notebook_target_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias NotebookTargetStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Notebook_target_bool_exp }


type alias NotebookTargetStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Notebook_target_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "notebook\_target"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
notebook_target_stream :
    (NotebookTargetStreamOptionalArguments -> NotebookTargetStreamOptionalArguments)
    -> NotebookTargetStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_target
    -> SelectionSet (List decodesTo) RootSubscription
notebook_target_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_target_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "notebook_target_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeNotebook_target_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias NpsRatingOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Nps_rating_select_column.Nps_rating_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Nps_rating_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Nps_rating_bool_exp
    }


{-| fetch data from the table: "nps\_rating"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
nps_rating :
    (NpsRatingOptionalArguments -> NpsRatingOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Nps_rating
    -> SelectionSet (List decodesTo) RootSubscription
nps_rating fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Nps_rating_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNps_rating_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNps_rating_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "nps_rating" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias NpsRatingAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Nps_rating_select_column.Nps_rating_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Nps_rating_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Nps_rating_bool_exp
    }


{-| fetch aggregated fields from the table: "nps\_rating"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
nps_rating_aggregate :
    (NpsRatingAggregateOptionalArguments -> NpsRatingAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Nps_rating_aggregate
    -> SelectionSet decodesTo RootSubscription
nps_rating_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Nps_rating_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNps_rating_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNps_rating_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "nps_rating_aggregate" optionalArgs____ object____ Basics.identity


type alias NpsRatingByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "nps\_rating" using primary key columns
-}
nps_rating_by_pk :
    NpsRatingByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Nps_rating
    -> SelectionSet (Maybe decodesTo) RootSubscription
nps_rating_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "nps_rating_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias NpsRatingDismissalOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Nps_rating_dismissal_select_column.Nps_rating_dismissal_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Nps_rating_dismissal_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Nps_rating_dismissal_bool_exp
    }


{-| fetch data from the table: "nps\_rating\_dismissal"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
nps_rating_dismissal :
    (NpsRatingDismissalOptionalArguments -> NpsRatingDismissalOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Nps_rating_dismissal
    -> SelectionSet (List decodesTo) RootSubscription
nps_rating_dismissal fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Nps_rating_dismissal_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNps_rating_dismissal_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNps_rating_dismissal_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "nps_rating_dismissal" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias NpsRatingDismissalAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Nps_rating_dismissal_select_column.Nps_rating_dismissal_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Nps_rating_dismissal_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Nps_rating_dismissal_bool_exp
    }


{-| fetch aggregated fields from the table: "nps\_rating\_dismissal"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
nps_rating_dismissal_aggregate :
    (NpsRatingDismissalAggregateOptionalArguments -> NpsRatingDismissalAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Nps_rating_dismissal_aggregate
    -> SelectionSet decodesTo RootSubscription
nps_rating_dismissal_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Nps_rating_dismissal_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNps_rating_dismissal_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNps_rating_dismissal_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "nps_rating_dismissal_aggregate" optionalArgs____ object____ Basics.identity


type alias NpsRatingDismissalByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "nps\_rating\_dismissal" using primary key columns
-}
nps_rating_dismissal_by_pk :
    NpsRatingDismissalByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Nps_rating_dismissal
    -> SelectionSet (Maybe decodesTo) RootSubscription
nps_rating_dismissal_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "nps_rating_dismissal_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias NpsRatingDismissalStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Nps_rating_dismissal_bool_exp }


type alias NpsRatingDismissalStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Nps_rating_dismissal_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "nps\_rating\_dismissal"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
nps_rating_dismissal_stream :
    (NpsRatingDismissalStreamOptionalArguments -> NpsRatingDismissalStreamOptionalArguments)
    -> NpsRatingDismissalStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Nps_rating_dismissal
    -> SelectionSet (List decodesTo) RootSubscription
nps_rating_dismissal_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNps_rating_dismissal_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "nps_rating_dismissal_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeNps_rating_dismissal_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias NpsRatingStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Nps_rating_bool_exp }


type alias NpsRatingStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Nps_rating_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "nps\_rating"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
nps_rating_stream :
    (NpsRatingStreamOptionalArguments -> NpsRatingStreamOptionalArguments)
    -> NpsRatingStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Nps_rating
    -> SelectionSet (List decodesTo) RootSubscription
nps_rating_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNps_rating_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "nps_rating_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeNps_rating_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias OrientationManagerOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Orientation_manager_select_column.Orientation_manager_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Orientation_manager_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Orientation_manager_bool_exp
    }


{-| fetch data from the table: "orientation\_manager"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
orientation_manager :
    (OrientationManagerOptionalArguments -> OrientationManagerOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_manager
    -> SelectionSet (List decodesTo) RootSubscription
orientation_manager fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Orientation_manager_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeOrientation_manager_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeOrientation_manager_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "orientation_manager" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias OrientationManagerAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Orientation_manager_select_column.Orientation_manager_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Orientation_manager_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Orientation_manager_bool_exp
    }


{-| fetch aggregated fields from the table: "orientation\_manager"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
orientation_manager_aggregate :
    (OrientationManagerAggregateOptionalArguments -> OrientationManagerAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_manager_aggregate
    -> SelectionSet decodesTo RootSubscription
orientation_manager_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Orientation_manager_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeOrientation_manager_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeOrientation_manager_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "orientation_manager_aggregate" optionalArgs____ object____ Basics.identity


type alias OrientationManagerByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "orientation\_manager" using primary key columns
-}
orientation_manager_by_pk :
    OrientationManagerByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_manager
    -> SelectionSet (Maybe decodesTo) RootSubscription
orientation_manager_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "orientation_manager_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias OrientationManagerStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Orientation_manager_bool_exp }


type alias OrientationManagerStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Orientation_manager_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "orientation\_manager"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
orientation_manager_stream :
    (OrientationManagerStreamOptionalArguments -> OrientationManagerStreamOptionalArguments)
    -> OrientationManagerStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_manager
    -> SelectionSet (List decodesTo) RootSubscription
orientation_manager_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeOrientation_manager_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "orientation_manager_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeOrientation_manager_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias OrientationRequestOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Orientation_request_select_column.Orientation_request_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Orientation_request_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Orientation_request_bool_exp
    }


{-| fetch data from the table: "orientation\_request"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
orientation_request :
    (OrientationRequestOptionalArguments -> OrientationRequestOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_request
    -> SelectionSet (List decodesTo) RootSubscription
orientation_request fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Orientation_request_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeOrientation_request_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeOrientation_request_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "orientation_request" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias OrientationRequestAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Orientation_request_select_column.Orientation_request_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Orientation_request_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Orientation_request_bool_exp
    }


{-| fetch aggregated fields from the table: "orientation\_request"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
orientation_request_aggregate :
    (OrientationRequestAggregateOptionalArguments -> OrientationRequestAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_request_aggregate
    -> SelectionSet decodesTo RootSubscription
orientation_request_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Orientation_request_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeOrientation_request_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeOrientation_request_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "orientation_request_aggregate" optionalArgs____ object____ Basics.identity


type alias OrientationRequestByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "orientation\_request" using primary key columns
-}
orientation_request_by_pk :
    OrientationRequestByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_request
    -> SelectionSet (Maybe decodesTo) RootSubscription
orientation_request_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "orientation_request_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias OrientationRequestStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Orientation_request_bool_exp }


type alias OrientationRequestStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Orientation_request_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "orientation\_request"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
orientation_request_stream :
    (OrientationRequestStreamOptionalArguments -> OrientationRequestStreamOptionalArguments)
    -> OrientationRequestStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_request
    -> SelectionSet (List decodesTo) RootSubscription
orientation_request_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeOrientation_request_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "orientation_request_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeOrientation_request_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias OrientationSystemOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Orientation_system_select_column.Orientation_system_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Orientation_system_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Orientation_system_bool_exp
    }


{-| fetch data from the table: "orientation\_system"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
orientation_system :
    (OrientationSystemOptionalArguments -> OrientationSystemOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_system
    -> SelectionSet (List decodesTo) RootSubscription
orientation_system fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Orientation_system_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeOrientation_system_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeOrientation_system_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "orientation_system" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias OrientationSystemAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Orientation_system_select_column.Orientation_system_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Orientation_system_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Orientation_system_bool_exp
    }


{-| fetch aggregated fields from the table: "orientation\_system"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
orientation_system_aggregate :
    (OrientationSystemAggregateOptionalArguments -> OrientationSystemAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_system_aggregate
    -> SelectionSet decodesTo RootSubscription
orientation_system_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Orientation_system_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeOrientation_system_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeOrientation_system_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "orientation_system_aggregate" optionalArgs____ object____ Basics.identity


type alias OrientationSystemByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "orientation\_system" using primary key columns
-}
orientation_system_by_pk :
    OrientationSystemByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_system
    -> SelectionSet (Maybe decodesTo) RootSubscription
orientation_system_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "orientation_system_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias OrientationSystemStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Orientation_system_bool_exp }


type alias OrientationSystemStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Orientation_system_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "orientation\_system"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
orientation_system_stream :
    (OrientationSystemStreamOptionalArguments -> OrientationSystemStreamOptionalArguments)
    -> OrientationSystemStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_system
    -> SelectionSet (List decodesTo) RootSubscription
orientation_system_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeOrientation_system_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "orientation_system_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeOrientation_system_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias OrientationTypeOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Orientation_type_select_column.Orientation_type_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Orientation_type_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Orientation_type_bool_exp
    }


{-| fetch data from the table: "orientation\_type"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
orientation_type :
    (OrientationTypeOptionalArguments -> OrientationTypeOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_type
    -> SelectionSet (List decodesTo) RootSubscription
orientation_type fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Orientation_type_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeOrientation_type_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeOrientation_type_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "orientation_type" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias OrientationTypeAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Orientation_type_select_column.Orientation_type_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Orientation_type_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Orientation_type_bool_exp
    }


{-| fetch aggregated fields from the table: "orientation\_type"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
orientation_type_aggregate :
    (OrientationTypeAggregateOptionalArguments -> OrientationTypeAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_type_aggregate
    -> SelectionSet decodesTo RootSubscription
orientation_type_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Orientation_type_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeOrientation_type_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeOrientation_type_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "orientation_type_aggregate" optionalArgs____ object____ Basics.identity


type alias OrientationTypeByPkRequiredArguments =
    { id : String }


{-| fetch data from the table: "orientation\_type" using primary key columns
-}
orientation_type_by_pk :
    OrientationTypeByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_type
    -> SelectionSet (Maybe decodesTo) RootSubscription
orientation_type_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "orientation_type_by_pk" [ Argument.required "id" requiredArgs____.id Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias OrientationTypeStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Orientation_type_bool_exp }


type alias OrientationTypeStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Orientation_type_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "orientation\_type"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
orientation_type_stream :
    (OrientationTypeStreamOptionalArguments -> OrientationTypeStreamOptionalArguments)
    -> OrientationTypeStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_type
    -> SelectionSet (List decodesTo) RootSubscription
orientation_type_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeOrientation_type_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "orientation_type_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeOrientation_type_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias ProfessionalOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Professional_select_column.Professional_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Professional_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Professional_bool_exp
    }


{-| fetch data from the table: "professional"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
professional :
    (ProfessionalOptionalArguments -> ProfessionalOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Professional
    -> SelectionSet (List decodesTo) RootSubscription
professional fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Professional_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeProfessional_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeProfessional_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "professional" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias ProfessionalAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Professional_select_column.Professional_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Professional_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Professional_bool_exp
    }


{-| fetch aggregated fields from the table: "professional"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
professional_aggregate :
    (ProfessionalAggregateOptionalArguments -> ProfessionalAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Professional_aggregate
    -> SelectionSet decodesTo RootSubscription
professional_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Professional_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeProfessional_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeProfessional_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "professional_aggregate" optionalArgs____ object____ Basics.identity


type alias ProfessionalByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "professional" using primary key columns
-}
professional_by_pk :
    ProfessionalByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Professional
    -> SelectionSet (Maybe decodesTo) RootSubscription
professional_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "professional_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias ProfessionalOrientationSystemOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Professional_orientation_system_select_column.Professional_orientation_system_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Professional_orientation_system_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Professional_orientation_system_bool_exp
    }


{-| fetch data from the table: "professional\_orientation\_system"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
professional_orientation_system :
    (ProfessionalOrientationSystemOptionalArguments -> ProfessionalOrientationSystemOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Professional_orientation_system
    -> SelectionSet (List decodesTo) RootSubscription
professional_orientation_system fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Professional_orientation_system_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeProfessional_orientation_system_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeProfessional_orientation_system_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "professional_orientation_system" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias ProfessionalOrientationSystemAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Professional_orientation_system_select_column.Professional_orientation_system_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Professional_orientation_system_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Professional_orientation_system_bool_exp
    }


{-| fetch aggregated fields from the table: "professional\_orientation\_system"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
professional_orientation_system_aggregate :
    (ProfessionalOrientationSystemAggregateOptionalArguments -> ProfessionalOrientationSystemAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Professional_orientation_system_aggregate
    -> SelectionSet decodesTo RootSubscription
professional_orientation_system_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Professional_orientation_system_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeProfessional_orientation_system_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeProfessional_orientation_system_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "professional_orientation_system_aggregate" optionalArgs____ object____ Basics.identity


type alias ProfessionalOrientationSystemByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "professional\_orientation\_system" using primary key columns
-}
professional_orientation_system_by_pk :
    ProfessionalOrientationSystemByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Professional_orientation_system
    -> SelectionSet (Maybe decodesTo) RootSubscription
professional_orientation_system_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "professional_orientation_system_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias ProfessionalOrientationSystemStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Professional_orientation_system_bool_exp }


type alias ProfessionalOrientationSystemStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Professional_orientation_system_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "professional\_orientation\_system"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
professional_orientation_system_stream :
    (ProfessionalOrientationSystemStreamOptionalArguments -> ProfessionalOrientationSystemStreamOptionalArguments)
    -> ProfessionalOrientationSystemStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Professional_orientation_system
    -> SelectionSet (List decodesTo) RootSubscription
professional_orientation_system_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeProfessional_orientation_system_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "professional_orientation_system_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeProfessional_orientation_system_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias ProfessionalProjectOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Professional_project_select_column.Professional_project_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Professional_project_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Professional_project_bool_exp
    }


{-| fetch data from the table: "professional\_project"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
professional_project :
    (ProfessionalProjectOptionalArguments -> ProfessionalProjectOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Professional_project
    -> SelectionSet (List decodesTo) RootSubscription
professional_project fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Professional_project_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeProfessional_project_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeProfessional_project_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "professional_project" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias ProfessionalProjectAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Professional_project_select_column.Professional_project_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Professional_project_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Professional_project_bool_exp
    }


{-| fetch aggregated fields from the table: "professional\_project"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
professional_project_aggregate :
    (ProfessionalProjectAggregateOptionalArguments -> ProfessionalProjectAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Professional_project_aggregate
    -> SelectionSet decodesTo RootSubscription
professional_project_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Professional_project_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeProfessional_project_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeProfessional_project_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "professional_project_aggregate" optionalArgs____ object____ Basics.identity


type alias ProfessionalProjectByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "professional\_project" using primary key columns
-}
professional_project_by_pk :
    ProfessionalProjectByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Professional_project
    -> SelectionSet (Maybe decodesTo) RootSubscription
professional_project_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "professional_project_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias ProfessionalProjectStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Professional_project_bool_exp }


type alias ProfessionalProjectStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Professional_project_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "professional\_project"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
professional_project_stream :
    (ProfessionalProjectStreamOptionalArguments -> ProfessionalProjectStreamOptionalArguments)
    -> ProfessionalProjectStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Professional_project
    -> SelectionSet (List decodesTo) RootSubscription
professional_project_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeProfessional_project_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "professional_project_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeProfessional_project_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias ProfessionalStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Professional_bool_exp }


type alias ProfessionalStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Professional_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "professional"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
professional_stream :
    (ProfessionalStreamOptionalArguments -> ProfessionalStreamOptionalArguments)
    -> ProfessionalStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Professional
    -> SelectionSet (List decodesTo) RootSubscription
professional_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeProfessional_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "professional_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeProfessional_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias RefActionOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Ref_action_select_column.Ref_action_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Ref_action_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Ref_action_bool_exp
    }


{-| fetch data from the table: "ref\_action"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
ref_action :
    (RefActionOptionalArguments -> RefActionOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Ref_action
    -> SelectionSet (List decodesTo) RootSubscription
ref_action fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Ref_action_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRef_action_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRef_action_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "ref_action" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias RefActionAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Ref_action_select_column.Ref_action_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Ref_action_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Ref_action_bool_exp
    }


{-| fetch aggregated fields from the table: "ref\_action"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
ref_action_aggregate :
    (RefActionAggregateOptionalArguments -> RefActionAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Ref_action_aggregate
    -> SelectionSet decodesTo RootSubscription
ref_action_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Ref_action_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRef_action_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRef_action_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "ref_action_aggregate" optionalArgs____ object____ Basics.identity


type alias RefActionByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "ref\_action" using primary key columns
-}
ref_action_by_pk :
    RefActionByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_action
    -> SelectionSet (Maybe decodesTo) RootSubscription
ref_action_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "ref_action_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias RefActionStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Ref_action_bool_exp }


type alias RefActionStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Ref_action_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "ref\_action"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
ref_action_stream :
    (RefActionStreamOptionalArguments -> RefActionStreamOptionalArguments)
    -> RefActionStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_action
    -> SelectionSet (List decodesTo) RootSubscription
ref_action_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRef_action_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "ref_action_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeRef_action_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias RefSituationOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Ref_situation_select_column.Ref_situation_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Ref_situation_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Ref_situation_bool_exp
    }


{-| fetch data from the table: "ref\_situation"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
ref_situation :
    (RefSituationOptionalArguments -> RefSituationOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Ref_situation
    -> SelectionSet (List decodesTo) RootSubscription
ref_situation fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Ref_situation_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRef_situation_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRef_situation_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "ref_situation" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias RefSituationAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Ref_situation_select_column.Ref_situation_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Ref_situation_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Ref_situation_bool_exp
    }


{-| fetch aggregated fields from the table: "ref\_situation"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
ref_situation_aggregate :
    (RefSituationAggregateOptionalArguments -> RefSituationAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Ref_situation_aggregate
    -> SelectionSet decodesTo RootSubscription
ref_situation_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Ref_situation_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRef_situation_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRef_situation_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "ref_situation_aggregate" optionalArgs____ object____ Basics.identity


type alias RefSituationByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "ref\_situation" using primary key columns
-}
ref_situation_by_pk :
    RefSituationByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_situation
    -> SelectionSet (Maybe decodesTo) RootSubscription
ref_situation_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "ref_situation_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias RefSituationStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Ref_situation_bool_exp }


type alias RefSituationStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Ref_situation_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "ref\_situation"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
ref_situation_stream :
    (RefSituationStreamOptionalArguments -> RefSituationStreamOptionalArguments)
    -> RefSituationStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_situation
    -> SelectionSet (List decodesTo) RootSubscription
ref_situation_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRef_situation_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "ref_situation_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeRef_situation_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias RefTargetOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Ref_target_select_column.Ref_target_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Ref_target_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Ref_target_bool_exp
    }


{-| fetch data from the table: "ref\_target"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
ref_target :
    (RefTargetOptionalArguments -> RefTargetOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Ref_target
    -> SelectionSet (List decodesTo) RootSubscription
ref_target fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Ref_target_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRef_target_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRef_target_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "ref_target" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias RefTargetAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Ref_target_select_column.Ref_target_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Ref_target_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Ref_target_bool_exp
    }


{-| fetch aggregated fields from the table: "ref\_target"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
ref_target_aggregate :
    (RefTargetAggregateOptionalArguments -> RefTargetAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Ref_target_aggregate
    -> SelectionSet decodesTo RootSubscription
ref_target_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Ref_target_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRef_target_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRef_target_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "ref_target_aggregate" optionalArgs____ object____ Basics.identity


type alias RefTargetByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "ref\_target" using primary key columns
-}
ref_target_by_pk :
    RefTargetByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_target
    -> SelectionSet (Maybe decodesTo) RootSubscription
ref_target_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "ref_target_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias RefTargetStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Ref_target_bool_exp }


type alias RefTargetStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Ref_target_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "ref\_target"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
ref_target_stream :
    (RefTargetStreamOptionalArguments -> RefTargetStreamOptionalArguments)
    -> RefTargetStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_target
    -> SelectionSet (List decodesTo) RootSubscription
ref_target_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRef_target_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "ref_target_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeRef_target_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias RefThemeOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Ref_theme_select_column.Ref_theme_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Ref_theme_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Ref_theme_bool_exp
    }


{-| fetch data from the table: "ref\_theme"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
ref_theme :
    (RefThemeOptionalArguments -> RefThemeOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Ref_theme
    -> SelectionSet (List decodesTo) RootSubscription
ref_theme fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Ref_theme_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRef_theme_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRef_theme_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "ref_theme" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias RefThemeAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Ref_theme_select_column.Ref_theme_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Ref_theme_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Ref_theme_bool_exp
    }


{-| fetch aggregated fields from the table: "ref\_theme"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
ref_theme_aggregate :
    (RefThemeAggregateOptionalArguments -> RefThemeAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Ref_theme_aggregate
    -> SelectionSet decodesTo RootSubscription
ref_theme_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Ref_theme_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRef_theme_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRef_theme_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "ref_theme_aggregate" optionalArgs____ object____ Basics.identity


type alias RefThemeByPkRequiredArguments =
    { name : String }


{-| fetch data from the table: "ref\_theme" using primary key columns
-}
ref_theme_by_pk :
    RefThemeByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_theme
    -> SelectionSet (Maybe decodesTo) RootSubscription
ref_theme_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "ref_theme_by_pk" [ Argument.required "name" requiredArgs____.name Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias RefThemeStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Ref_theme_bool_exp }


type alias RefThemeStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Ref_theme_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "ref\_theme"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
ref_theme_stream :
    (RefThemeStreamOptionalArguments -> RefThemeStreamOptionalArguments)
    -> RefThemeStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_theme
    -> SelectionSet (List decodesTo) RootSubscription
ref_theme_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRef_theme_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "ref_theme_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeRef_theme_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias RoleOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Role_select_column.Role_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Role_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Role_bool_exp
    }


{-| fetch data from the table: "role"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
role :
    (RoleOptionalArguments -> RoleOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Role
    -> SelectionSet (List decodesTo) RootSubscription
role fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Role_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRole_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRole_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "role" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias RoleAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Role_select_column.Role_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Role_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Role_bool_exp
    }


{-| fetch aggregated fields from the table: "role"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
role_aggregate :
    (RoleAggregateOptionalArguments -> RoleAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Role_aggregate
    -> SelectionSet decodesTo RootSubscription
role_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Role_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRole_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRole_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "role_aggregate" optionalArgs____ object____ Basics.identity


type alias RoleByPkRequiredArguments =
    { label : String }


{-| fetch data from the table: "role" using primary key columns
-}
role_by_pk :
    RoleByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Role
    -> SelectionSet (Maybe decodesTo) RootSubscription
role_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "role_by_pk" [ Argument.required "label" requiredArgs____.label Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias RoleStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Role_bool_exp }


type alias RoleStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Role_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "role"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
role_stream :
    (RoleStreamOptionalArguments -> RoleStreamOptionalArguments)
    -> RoleStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Role
    -> SelectionSet (List decodesTo) RootSubscription
role_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRole_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "role_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeRole_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias RomeCodeOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Rome_code_select_column.Rome_code_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Rome_code_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Rome_code_bool_exp
    }


{-| fetch data from the table: "rome\_code"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
rome_code :
    (RomeCodeOptionalArguments -> RomeCodeOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Rome_code
    -> SelectionSet (List decodesTo) RootSubscription
rome_code fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Rome_code_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRome_code_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRome_code_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "rome_code" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias RomeCodeAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Rome_code_select_column.Rome_code_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Rome_code_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Rome_code_bool_exp
    }


{-| fetch aggregated fields from the table: "rome\_code"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
rome_code_aggregate :
    (RomeCodeAggregateOptionalArguments -> RomeCodeAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Rome_code_aggregate
    -> SelectionSet decodesTo RootSubscription
rome_code_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Rome_code_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRome_code_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRome_code_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "rome_code_aggregate" optionalArgs____ object____ Basics.identity


type alias RomeCodeByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "rome\_code" using primary key columns
-}
rome_code_by_pk :
    RomeCodeByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rome_code
    -> SelectionSet (Maybe decodesTo) RootSubscription
rome_code_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "rome_code_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias RomeCodeStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Rome_code_bool_exp }


type alias RomeCodeStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Rome_code_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "rome\_code"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
rome_code_stream :
    (RomeCodeStreamOptionalArguments -> RomeCodeStreamOptionalArguments)
    -> RomeCodeStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rome_code
    -> SelectionSet (List decodesTo) RootSubscription
rome_code_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRome_code_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "rome_code_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeRome_code_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias RsaClosureReasonOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Rsa_closure_reason_select_column.Rsa_closure_reason_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Rsa_closure_reason_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Rsa_closure_reason_bool_exp
    }


{-| fetch data from the table: "rsa\_closure\_reason"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
rsa_closure_reason :
    (RsaClosureReasonOptionalArguments -> RsaClosureReasonOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Rsa_closure_reason
    -> SelectionSet (List decodesTo) RootSubscription
rsa_closure_reason fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Rsa_closure_reason_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRsa_closure_reason_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRsa_closure_reason_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "rsa_closure_reason" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias RsaClosureReasonAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Rsa_closure_reason_select_column.Rsa_closure_reason_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Rsa_closure_reason_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Rsa_closure_reason_bool_exp
    }


{-| fetch aggregated fields from the table: "rsa\_closure\_reason"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
rsa_closure_reason_aggregate :
    (RsaClosureReasonAggregateOptionalArguments -> RsaClosureReasonAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Rsa_closure_reason_aggregate
    -> SelectionSet decodesTo RootSubscription
rsa_closure_reason_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Rsa_closure_reason_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRsa_closure_reason_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRsa_closure_reason_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "rsa_closure_reason_aggregate" optionalArgs____ object____ Basics.identity


type alias RsaClosureReasonByPkRequiredArguments =
    { code : String }


{-| fetch data from the table: "rsa\_closure\_reason" using primary key columns
-}
rsa_closure_reason_by_pk :
    RsaClosureReasonByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rsa_closure_reason
    -> SelectionSet (Maybe decodesTo) RootSubscription
rsa_closure_reason_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "rsa_closure_reason_by_pk" [ Argument.required "code" requiredArgs____.code Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias RsaClosureReasonStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Rsa_closure_reason_bool_exp }


type alias RsaClosureReasonStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Rsa_closure_reason_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "rsa\_closure\_reason"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
rsa_closure_reason_stream :
    (RsaClosureReasonStreamOptionalArguments -> RsaClosureReasonStreamOptionalArguments)
    -> RsaClosureReasonStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rsa_closure_reason
    -> SelectionSet (List decodesTo) RootSubscription
rsa_closure_reason_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRsa_closure_reason_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "rsa_closure_reason_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeRsa_closure_reason_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias RsaSuspensionReasonOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Rsa_suspension_reason_select_column.Rsa_suspension_reason_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Rsa_suspension_reason_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Rsa_suspension_reason_bool_exp
    }


{-| fetch data from the table: "rsa\_suspension\_reason"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
rsa_suspension_reason :
    (RsaSuspensionReasonOptionalArguments -> RsaSuspensionReasonOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Rsa_suspension_reason
    -> SelectionSet (List decodesTo) RootSubscription
rsa_suspension_reason fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Rsa_suspension_reason_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRsa_suspension_reason_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRsa_suspension_reason_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "rsa_suspension_reason" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias RsaSuspensionReasonAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Rsa_suspension_reason_select_column.Rsa_suspension_reason_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Rsa_suspension_reason_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Rsa_suspension_reason_bool_exp
    }


{-| fetch aggregated fields from the table: "rsa\_suspension\_reason"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
rsa_suspension_reason_aggregate :
    (RsaSuspensionReasonAggregateOptionalArguments -> RsaSuspensionReasonAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Rsa_suspension_reason_aggregate
    -> SelectionSet decodesTo RootSubscription
rsa_suspension_reason_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Rsa_suspension_reason_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRsa_suspension_reason_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRsa_suspension_reason_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "rsa_suspension_reason_aggregate" optionalArgs____ object____ Basics.identity


type alias RsaSuspensionReasonByPkRequiredArguments =
    { code : String }


{-| fetch data from the table: "rsa\_suspension\_reason" using primary key columns
-}
rsa_suspension_reason_by_pk :
    RsaSuspensionReasonByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rsa_suspension_reason
    -> SelectionSet (Maybe decodesTo) RootSubscription
rsa_suspension_reason_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "rsa_suspension_reason_by_pk" [ Argument.required "code" requiredArgs____.code Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias RsaSuspensionReasonStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Rsa_suspension_reason_bool_exp }


type alias RsaSuspensionReasonStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Rsa_suspension_reason_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "rsa\_suspension\_reason"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
rsa_suspension_reason_stream :
    (RsaSuspensionReasonStreamOptionalArguments -> RsaSuspensionReasonStreamOptionalArguments)
    -> RsaSuspensionReasonStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rsa_suspension_reason
    -> SelectionSet (List decodesTo) RootSubscription
rsa_suspension_reason_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRsa_suspension_reason_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "rsa_suspension_reason_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeRsa_suspension_reason_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias SearchBeneficiariesOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Beneficiary_select_column.Beneficiary_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Beneficiary_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Beneficiary_bool_exp
    }


type alias SearchBeneficiariesRequiredArguments =
    { args : CdbGQL.InputObject.Search_beneficiaries_args }


{-| execute function "search\_beneficiaries" which returns "beneficiary"

  - args - input parameters for function "search\_beneficiaries"
  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
search_beneficiaries :
    (SearchBeneficiariesOptionalArguments -> SearchBeneficiariesOptionalArguments)
    -> SearchBeneficiariesRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary
    -> SelectionSet (List decodesTo) RootSubscription
search_beneficiaries fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Beneficiary_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeBeneficiary_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeBeneficiary_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "search_beneficiaries" (optionalArgs____ ++ [ Argument.required "args" requiredArgs____.args CdbGQL.InputObject.encodeSearch_beneficiaries_args ]) object____ (Basics.identity >> Decode.list)


type alias SearchBeneficiariesAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Beneficiary_select_column.Beneficiary_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Beneficiary_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Beneficiary_bool_exp
    }


type alias SearchBeneficiariesAggregateRequiredArguments =
    { args : CdbGQL.InputObject.Search_beneficiaries_args }


{-| execute function "search\_beneficiaries" and query aggregates on result of table type "beneficiary"

  - args - input parameters for function "search\_beneficiaries\_aggregate"
  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
search_beneficiaries_aggregate :
    (SearchBeneficiariesAggregateOptionalArguments -> SearchBeneficiariesAggregateOptionalArguments)
    -> SearchBeneficiariesAggregateRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary_aggregate
    -> SelectionSet decodesTo RootSubscription
search_beneficiaries_aggregate fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Beneficiary_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeBeneficiary_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeBeneficiary_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "search_beneficiaries_aggregate" (optionalArgs____ ++ [ Argument.required "args" requiredArgs____.args CdbGQL.InputObject.encodeSearch_beneficiaries_args ]) object____ Basics.identity


type alias SearchNotebookMembersOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_member_select_column.Notebook_member_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_member_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_member_bool_exp
    }


type alias SearchNotebookMembersRequiredArguments =
    { args : CdbGQL.InputObject.Search_notebook_members_args }


{-| execute function "search\_notebook\_members" which returns "notebook\_member"

  - args - input parameters for function "search\_notebook\_members"
  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
search_notebook_members :
    (SearchNotebookMembersOptionalArguments -> SearchNotebookMembersOptionalArguments)
    -> SearchNotebookMembersRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_member
    -> SelectionSet (List decodesTo) RootSubscription
search_notebook_members fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_member_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_member_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_member_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "search_notebook_members" (optionalArgs____ ++ [ Argument.required "args" requiredArgs____.args CdbGQL.InputObject.encodeSearch_notebook_members_args ]) object____ (Basics.identity >> Decode.list)


type alias SearchNotebookMembersAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_member_select_column.Notebook_member_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_member_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_member_bool_exp
    }


type alias SearchNotebookMembersAggregateRequiredArguments =
    { args : CdbGQL.InputObject.Search_notebook_members_args }


{-| execute function "search\_notebook\_members" and query aggregates on result of table type "notebook\_member"

  - args - input parameters for function "search\_notebook\_members\_aggregate"
  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
search_notebook_members_aggregate :
    (SearchNotebookMembersAggregateOptionalArguments -> SearchNotebookMembersAggregateOptionalArguments)
    -> SearchNotebookMembersAggregateRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_member_aggregate
    -> SelectionSet decodesTo RootSubscription
search_notebook_members_aggregate fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_member_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_member_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_member_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "search_notebook_members_aggregate" (optionalArgs____ ++ [ Argument.required "args" requiredArgs____.args CdbGQL.InputObject.encodeSearch_notebook_members_args ]) object____ Basics.identity


type alias SearchPublicNotebooksOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_public_view_select_column.Notebook_public_view_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_public_view_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_public_view_bool_exp
    }


type alias SearchPublicNotebooksRequiredArguments =
    { args : CdbGQL.InputObject.Search_public_notebooks_args }


{-| execute function "search\_public\_notebooks" which returns "notebook\_public\_view"

  - args - input parameters for function "search\_public\_notebooks"
  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
search_public_notebooks :
    (SearchPublicNotebooksOptionalArguments -> SearchPublicNotebooksOptionalArguments)
    -> SearchPublicNotebooksRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_public_view
    -> SelectionSet (List decodesTo) RootSubscription
search_public_notebooks fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_public_view_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_public_view_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_public_view_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "search_public_notebooks" (optionalArgs____ ++ [ Argument.required "args" requiredArgs____.args CdbGQL.InputObject.encodeSearch_public_notebooks_args ]) object____ (Basics.identity >> Decode.list)


type alias SearchPublicNotebooksAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Notebook_public_view_select_column.Notebook_public_view_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Notebook_public_view_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Notebook_public_view_bool_exp
    }


type alias SearchPublicNotebooksAggregateRequiredArguments =
    { args : CdbGQL.InputObject.Search_public_notebooks_args }


{-| execute function "search\_public\_notebooks" and query aggregates on result of table type "notebook\_public\_view"

  - args - input parameters for function "search\_public\_notebooks\_aggregate"
  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
search_public_notebooks_aggregate :
    (SearchPublicNotebooksAggregateOptionalArguments -> SearchPublicNotebooksAggregateOptionalArguments)
    -> SearchPublicNotebooksAggregateRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_public_view_aggregate
    -> SelectionSet decodesTo RootSubscription
search_public_notebooks_aggregate fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Notebook_public_view_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeNotebook_public_view_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeNotebook_public_view_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "search_public_notebooks_aggregate" (optionalArgs____ ++ [ Argument.required "args" requiredArgs____.args CdbGQL.InputObject.encodeSearch_public_notebooks_args ]) object____ Basics.identity


type alias SearchRefActionOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Ref_action_select_column.Ref_action_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Ref_action_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Ref_action_bool_exp
    }


type alias SearchRefActionRequiredArguments =
    { args : CdbGQL.InputObject.Search_ref_action_args }


{-| execute function "search\_ref\_action" which returns "ref\_action"

  - args - input parameters for function "search\_ref\_action"
  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
search_ref_action :
    (SearchRefActionOptionalArguments -> SearchRefActionOptionalArguments)
    -> SearchRefActionRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_action
    -> SelectionSet (List decodesTo) RootSubscription
search_ref_action fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Ref_action_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRef_action_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRef_action_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "search_ref_action" (optionalArgs____ ++ [ Argument.required "args" requiredArgs____.args CdbGQL.InputObject.encodeSearch_ref_action_args ]) object____ (Basics.identity >> Decode.list)


type alias SearchRefActionAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Ref_action_select_column.Ref_action_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Ref_action_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Ref_action_bool_exp
    }


type alias SearchRefActionAggregateRequiredArguments =
    { args : CdbGQL.InputObject.Search_ref_action_args }


{-| execute function "search\_ref\_action" and query aggregates on result of table type "ref\_action"

  - args - input parameters for function "search\_ref\_action\_aggregate"
  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
search_ref_action_aggregate :
    (SearchRefActionAggregateOptionalArguments -> SearchRefActionAggregateOptionalArguments)
    -> SearchRefActionAggregateRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_action_aggregate
    -> SelectionSet decodesTo RootSubscription
search_ref_action_aggregate fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Ref_action_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRef_action_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRef_action_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "search_ref_action_aggregate" (optionalArgs____ ++ [ Argument.required "args" requiredArgs____.args CdbGQL.InputObject.encodeSearch_ref_action_args ]) object____ Basics.identity


type alias SearchRomeCodesOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Rome_code_select_column.Rome_code_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Rome_code_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Rome_code_bool_exp
    }


type alias SearchRomeCodesRequiredArguments =
    { args : CdbGQL.InputObject.Search_rome_codes_args }


{-| execute function "search\_rome\_codes" which returns "rome\_code"

  - args - input parameters for function "search\_rome\_codes"
  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
search_rome_codes :
    (SearchRomeCodesOptionalArguments -> SearchRomeCodesOptionalArguments)
    -> SearchRomeCodesRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rome_code
    -> SelectionSet (List decodesTo) RootSubscription
search_rome_codes fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Rome_code_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRome_code_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRome_code_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "search_rome_codes" (optionalArgs____ ++ [ Argument.required "args" requiredArgs____.args CdbGQL.InputObject.encodeSearch_rome_codes_args ]) object____ (Basics.identity >> Decode.list)


type alias SearchRomeCodesAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Rome_code_select_column.Rome_code_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Rome_code_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Rome_code_bool_exp
    }


type alias SearchRomeCodesAggregateRequiredArguments =
    { args : CdbGQL.InputObject.Search_rome_codes_args }


{-| execute function "search\_rome\_codes" and query aggregates on result of table type "rome\_code"

  - args - input parameters for function "search\_rome\_codes\_aggregate"
  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
search_rome_codes_aggregate :
    (SearchRomeCodesAggregateOptionalArguments -> SearchRomeCodesAggregateOptionalArguments)
    -> SearchRomeCodesAggregateRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rome_code_aggregate
    -> SelectionSet decodesTo RootSubscription
search_rome_codes_aggregate fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Rome_code_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeRome_code_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeRome_code_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "search_rome_codes_aggregate" (optionalArgs____ ++ [ Argument.required "args" requiredArgs____.args CdbGQL.InputObject.encodeSearch_rome_codes_args ]) object____ Basics.identity


type alias StructureOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Structure_select_column.Structure_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Structure_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Structure_bool_exp
    }


{-| fetch data from the table: "structure"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
structure :
    (StructureOptionalArguments -> StructureOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Structure
    -> SelectionSet (List decodesTo) RootSubscription
structure fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Structure_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeStructure_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeStructure_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "structure" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias StructureAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Structure_select_column.Structure_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Structure_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Structure_bool_exp
    }


{-| fetch aggregated fields from the table: "structure"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
structure_aggregate :
    (StructureAggregateOptionalArguments -> StructureAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Structure_aggregate
    -> SelectionSet decodesTo RootSubscription
structure_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Structure_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeStructure_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeStructure_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "structure_aggregate" optionalArgs____ object____ Basics.identity


type alias StructureByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "structure" using primary key columns
-}
structure_by_pk :
    StructureByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Structure
    -> SelectionSet (Maybe decodesTo) RootSubscription
structure_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "structure_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias StructureOrientationSystemOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Structure_orientation_system_select_column.Structure_orientation_system_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Structure_orientation_system_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Structure_orientation_system_bool_exp
    }


{-| fetch data from the table: "structure\_orientation\_system"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
structure_orientation_system :
    (StructureOrientationSystemOptionalArguments -> StructureOrientationSystemOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Structure_orientation_system
    -> SelectionSet (List decodesTo) RootSubscription
structure_orientation_system fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Structure_orientation_system_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeStructure_orientation_system_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeStructure_orientation_system_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "structure_orientation_system" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias StructureOrientationSystemAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List CdbGQL.Enum.Structure_orientation_system_select_column.Structure_orientation_system_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List CdbGQL.InputObject.Structure_orientation_system_order_by)
    , where_ : OptionalArgument CdbGQL.InputObject.Structure_orientation_system_bool_exp
    }


{-| fetch aggregated fields from the table: "structure\_orientation\_system"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
structure_orientation_system_aggregate :
    (StructureOrientationSystemAggregateOptionalArguments -> StructureOrientationSystemAggregateOptionalArguments)
    -> SelectionSet decodesTo CdbGQL.Object.Structure_orientation_system_aggregate
    -> SelectionSet decodesTo RootSubscription
structure_orientation_system_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum CdbGQL.Enum.Structure_orientation_system_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (CdbGQL.InputObject.encodeStructure_orientation_system_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeStructure_orientation_system_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "structure_orientation_system_aggregate" optionalArgs____ object____ Basics.identity


type alias StructureOrientationSystemByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| fetch data from the table: "structure\_orientation\_system" using primary key columns
-}
structure_orientation_system_by_pk :
    StructureOrientationSystemByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Structure_orientation_system
    -> SelectionSet (Maybe decodesTo) RootSubscription
structure_orientation_system_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "structure_orientation_system_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias StructureOrientationSystemStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Structure_orientation_system_bool_exp }


type alias StructureOrientationSystemStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Structure_orientation_system_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "structure\_orientation\_system"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
structure_orientation_system_stream :
    (StructureOrientationSystemStreamOptionalArguments -> StructureOrientationSystemStreamOptionalArguments)
    -> StructureOrientationSystemStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Structure_orientation_system
    -> SelectionSet (List decodesTo) RootSubscription
structure_orientation_system_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeStructure_orientation_system_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "structure_orientation_system_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeStructure_orientation_system_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias StructureStreamOptionalArguments =
    { where_ : OptionalArgument CdbGQL.InputObject.Structure_bool_exp }


type alias StructureStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe CdbGQL.InputObject.Structure_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "structure"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
structure_stream :
    (StructureStreamOptionalArguments -> StructureStreamOptionalArguments)
    -> StructureStreamRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Structure
    -> SelectionSet (List decodesTo) RootSubscription
structure_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ CdbGQL.InputObject.encodeStructure_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "structure_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (CdbGQL.InputObject.encodeStructure_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)
