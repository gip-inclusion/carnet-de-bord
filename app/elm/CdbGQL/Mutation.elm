-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module CdbGQL.Mutation exposing (..)

import CdbGQL.InputObject
import CdbGQL.Interface
import CdbGQL.Object
import CdbGQL.Scalar
import CdbGQL.ScalarCodecs
import CdbGQL.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)


type alias CreateNpsRatingRequiredArguments =
    { score : Int }


{-| Create NPS Rating
-}
create_nps_rating :
    CreateNpsRatingRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.NPSRatingOutput
    -> SelectionSet (Maybe decodesTo) RootMutation
create_nps_rating requiredArgs____ object____ =
    Object.selectionForCompositeField "create_nps_rating" [ Argument.required "score" requiredArgs____.score Encode.int ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteAccountRequiredArguments =
    { where_ : CdbGQL.InputObject.Account_bool_exp }


{-| delete data from the table: "account"

  - where\_ - filter the rows which have to be deleted

-}
delete_account :
    DeleteAccountRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Account_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_account requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_account" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeAccount_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteAccountByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "account"
-}
delete_account_by_pk :
    DeleteAccountByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Account
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_account_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_account_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteActionStatusRequiredArguments =
    { where_ : CdbGQL.InputObject.Action_status_bool_exp }


{-| delete data from the table: "action\_status"

  - where\_ - filter the rows which have to be deleted

-}
delete_action_status :
    DeleteActionStatusRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Action_status_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_action_status requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_action_status" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeAction_status_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteActionStatusByPkRequiredArguments =
    { status : String }


{-| delete single row from the table: "action\_status"
-}
delete_action_status_by_pk :
    DeleteActionStatusByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Action_status
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_action_status_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_action_status_by_pk" [ Argument.required "status" requiredArgs____.status Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteAdminCdbRequiredArguments =
    { where_ : CdbGQL.InputObject.Admin_cdb_bool_exp }


{-| delete data from the table: "admin\_cdb"

  - where\_ - filter the rows which have to be deleted

-}
delete_admin_cdb :
    DeleteAdminCdbRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Admin_cdb_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_admin_cdb requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_admin_cdb" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeAdmin_cdb_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteAdminCdbByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "admin\_cdb"
-}
delete_admin_cdb_by_pk :
    DeleteAdminCdbByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Admin_cdb
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_admin_cdb_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_admin_cdb_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteAdminStructureRequiredArguments =
    { where_ : CdbGQL.InputObject.Admin_structure_bool_exp }


{-| delete data from the table: "admin\_structure"

  - where\_ - filter the rows which have to be deleted

-}
delete_admin_structure :
    DeleteAdminStructureRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Admin_structure_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_admin_structure requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_admin_structure" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeAdmin_structure_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteAdminStructureByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "admin\_structure"
-}
delete_admin_structure_by_pk :
    DeleteAdminStructureByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Admin_structure
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_admin_structure_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_admin_structure_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteAdminStructureStructureRequiredArguments =
    { where_ : CdbGQL.InputObject.Admin_structure_structure_bool_exp }


{-| delete data from the table: "admin\_structure\_structure"

  - where\_ - filter the rows which have to be deleted

-}
delete_admin_structure_structure :
    DeleteAdminStructureStructureRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Admin_structure_structure_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_admin_structure_structure requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_admin_structure_structure" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeAdmin_structure_structure_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteAdminStructureStructureByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "admin\_structure\_structure"
-}
delete_admin_structure_structure_by_pk :
    DeleteAdminStructureStructureByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Admin_structure_structure
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_admin_structure_structure_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_admin_structure_structure_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteBeneficiaryRequiredArguments =
    { where_ : CdbGQL.InputObject.Beneficiary_bool_exp }


{-| delete data from the table: "beneficiary"

  - where\_ - filter the rows which have to be deleted

-}
delete_beneficiary :
    DeleteBeneficiaryRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_beneficiary requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_beneficiary" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeBeneficiary_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteBeneficiaryByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "beneficiary"
-}
delete_beneficiary_by_pk :
    DeleteBeneficiaryByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_beneficiary_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_beneficiary_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteBeneficiaryStructureRequiredArguments =
    { where_ : CdbGQL.InputObject.Beneficiary_structure_bool_exp }


{-| delete data from the table: "beneficiary\_structure"

  - where\_ - filter the rows which have to be deleted

-}
delete_beneficiary_structure :
    DeleteBeneficiaryStructureRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary_structure_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_beneficiary_structure requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_beneficiary_structure" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeBeneficiary_structure_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteBeneficiaryStructureByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "beneficiary\_structure"
-}
delete_beneficiary_structure_by_pk :
    DeleteBeneficiaryStructureByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary_structure
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_beneficiary_structure_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_beneficiary_structure_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteContractTypeRequiredArguments =
    { where_ : CdbGQL.InputObject.Contract_type_bool_exp }


{-| delete data from the table: "contract\_type"

  - where\_ - filter the rows which have to be deleted

-}
delete_contract_type :
    DeleteContractTypeRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Contract_type_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_contract_type requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_contract_type" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeContract_type_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteContractTypeByPkRequiredArguments =
    { id : String }


{-| delete single row from the table: "contract\_type"
-}
delete_contract_type_by_pk :
    DeleteContractTypeByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Contract_type
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_contract_type_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_contract_type_by_pk" [ Argument.required "id" requiredArgs____.id Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteDeploymentRequiredArguments =
    { where_ : CdbGQL.InputObject.Deployment_bool_exp }


{-| delete data from the table: "deployment"

  - where\_ - filter the rows which have to be deleted

-}
delete_deployment :
    DeleteDeploymentRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Deployment_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_deployment requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_deployment" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeDeployment_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteDeploymentByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "deployment"
-}
delete_deployment_by_pk :
    DeleteDeploymentByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Deployment
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_deployment_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_deployment_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteEmploymentTypeRequiredArguments =
    { where_ : CdbGQL.InputObject.Employment_type_bool_exp }


{-| delete data from the table: "employment\_type"

  - where\_ - filter the rows which have to be deleted

-}
delete_employment_type :
    DeleteEmploymentTypeRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Employment_type_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_employment_type requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_employment_type" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeEmployment_type_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteEmploymentTypeByPkRequiredArguments =
    { id : String }


{-| delete single row from the table: "employment\_type"
-}
delete_employment_type_by_pk :
    DeleteEmploymentTypeByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Employment_type
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_employment_type_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_employment_type_by_pk" [ Argument.required "id" requiredArgs____.id Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteExternalDataRequiredArguments =
    { where_ : CdbGQL.InputObject.External_data_bool_exp }


{-| delete data from the table: "external\_data"

  - where\_ - filter the rows which have to be deleted

-}
delete_external_data :
    DeleteExternalDataRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.External_data_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_external_data requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_external_data" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeExternal_data_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteExternalDataByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "external\_data"
-}
delete_external_data_by_pk :
    DeleteExternalDataByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.External_data
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_external_data_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_external_data_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteExternalDataInfoRequiredArguments =
    { where_ : CdbGQL.InputObject.External_data_info_bool_exp }


{-| delete data from the table: "external\_data\_info"

  - where\_ - filter the rows which have to be deleted

-}
delete_external_data_info :
    DeleteExternalDataInfoRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.External_data_info_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_external_data_info requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_external_data_info" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeExternal_data_info_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteExternalDataInfoByPkRequiredArguments =
    { external_data_id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "external\_data\_info"
-}
delete_external_data_info_by_pk :
    DeleteExternalDataInfoByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.External_data_info
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_external_data_info_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_external_data_info_by_pk" [ Argument.required "external_data_id" requiredArgs____.external_data_id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteExternalSourceRequiredArguments =
    { where_ : CdbGQL.InputObject.External_source_bool_exp }


{-| delete data from the table: "external\_source"

  - where\_ - filter the rows which have to be deleted

-}
delete_external_source :
    DeleteExternalSourceRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.External_source_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_external_source requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_external_source" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeExternal_source_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteExternalSourceByPkRequiredArguments =
    { value : String }


{-| delete single row from the table: "external\_source"
-}
delete_external_source_by_pk :
    DeleteExternalSourceByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.External_source
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_external_source_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_external_source_by_pk" [ Argument.required "value" requiredArgs____.value Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteManagerRequiredArguments =
    { where_ : CdbGQL.InputObject.Manager_bool_exp }


{-| delete data from the table: "manager"

  - where\_ - filter the rows which have to be deleted

-}
delete_manager :
    DeleteManagerRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Manager_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_manager requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_manager" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeManager_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteManagerByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "manager"
-}
delete_manager_by_pk :
    DeleteManagerByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Manager
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_manager_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_manager_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteNotebookRequiredArguments =
    { where_ : CdbGQL.InputObject.Notebook_bool_exp }


{-| delete data from the table: "notebook"

  - where\_ - filter the rows which have to be deleted

-}
delete_notebook :
    DeleteNotebookRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_notebook requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_notebook" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeNotebook_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteNotebookActionRequiredArguments =
    { where_ : CdbGQL.InputObject.Notebook_action_bool_exp }


{-| delete data from the table: "notebook\_action"

  - where\_ - filter the rows which have to be deleted

-}
delete_notebook_action :
    DeleteNotebookActionRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_action_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_notebook_action requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_notebook_action" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeNotebook_action_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteNotebookActionByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "notebook\_action"
-}
delete_notebook_action_by_pk :
    DeleteNotebookActionByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_action
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_notebook_action_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_notebook_action_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteNotebookAppointmentRequiredArguments =
    { where_ : CdbGQL.InputObject.Notebook_appointment_bool_exp }


{-| delete data from the table: "notebook\_appointment"

  - where\_ - filter the rows which have to be deleted

-}
delete_notebook_appointment :
    DeleteNotebookAppointmentRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_appointment_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_notebook_appointment requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_notebook_appointment" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeNotebook_appointment_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteNotebookAppointmentByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "notebook\_appointment"
-}
delete_notebook_appointment_by_pk :
    DeleteNotebookAppointmentByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_appointment
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_notebook_appointment_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_notebook_appointment_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteNotebookByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "notebook"
-}
delete_notebook_by_pk :
    DeleteNotebookByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_notebook_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_notebook_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteNotebookEventRequiredArguments =
    { where_ : CdbGQL.InputObject.Notebook_event_bool_exp }


{-| delete data from the table: "notebook\_event"

  - where\_ - filter the rows which have to be deleted

-}
delete_notebook_event :
    DeleteNotebookEventRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_event_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_notebook_event requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_notebook_event" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeNotebook_event_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteNotebookEventByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "notebook\_event"
-}
delete_notebook_event_by_pk :
    DeleteNotebookEventByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_event
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_notebook_event_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_notebook_event_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteNotebookEventTypeRequiredArguments =
    { where_ : CdbGQL.InputObject.Notebook_event_type_bool_exp }


{-| delete data from the table: "notebook\_event\_type"

  - where\_ - filter the rows which have to be deleted

-}
delete_notebook_event_type :
    DeleteNotebookEventTypeRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_event_type_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_notebook_event_type requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_notebook_event_type" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeNotebook_event_type_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteNotebookEventTypeByPkRequiredArguments =
    { value : String }


{-| delete single row from the table: "notebook\_event\_type"
-}
delete_notebook_event_type_by_pk :
    DeleteNotebookEventTypeByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_event_type
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_notebook_event_type_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_notebook_event_type_by_pk" [ Argument.required "value" requiredArgs____.value Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteNotebookFocusRequiredArguments =
    { where_ : CdbGQL.InputObject.Notebook_focus_bool_exp }


{-| delete data from the table: "notebook\_focus"

  - where\_ - filter the rows which have to be deleted

-}
delete_notebook_focus :
    DeleteNotebookFocusRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_focus_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_notebook_focus requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_notebook_focus" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeNotebook_focus_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteNotebookFocusByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "notebook\_focus"
-}
delete_notebook_focus_by_pk :
    DeleteNotebookFocusByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_focus
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_notebook_focus_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_notebook_focus_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteNotebookInfoRequiredArguments =
    { where_ : CdbGQL.InputObject.Notebook_info_bool_exp }


{-| delete data from the table: "notebook\_info"

  - where\_ - filter the rows which have to be deleted

-}
delete_notebook_info :
    DeleteNotebookInfoRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_info_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_notebook_info requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_notebook_info" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeNotebook_info_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteNotebookInfoByPkRequiredArguments =
    { notebookId : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "notebook\_info"
-}
delete_notebook_info_by_pk :
    DeleteNotebookInfoByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_info
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_notebook_info_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_notebook_info_by_pk" [ Argument.required "notebookId" requiredArgs____.notebookId (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteNotebookMemberRequiredArguments =
    { where_ : CdbGQL.InputObject.Notebook_member_bool_exp }


{-| delete data from the table: "notebook\_member"

  - where\_ - filter the rows which have to be deleted

-}
delete_notebook_member :
    DeleteNotebookMemberRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_member_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_notebook_member requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_notebook_member" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeNotebook_member_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteNotebookMemberByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "notebook\_member"
-}
delete_notebook_member_by_pk :
    DeleteNotebookMemberByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_member
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_notebook_member_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_notebook_member_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteNotebookPublicViewRequiredArguments =
    { where_ : CdbGQL.InputObject.Notebook_public_view_bool_exp }


{-| delete data from the table: "notebook\_public\_view"

  - where\_ - filter the rows which have to be deleted

-}
delete_notebook_public_view :
    DeleteNotebookPublicViewRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_public_view_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_notebook_public_view requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_notebook_public_view" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeNotebook_public_view_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteNotebookSituationRequiredArguments =
    { where_ : CdbGQL.InputObject.Notebook_situation_bool_exp }


{-| delete data from the table: "notebook\_situation"

  - where\_ - filter the rows which have to be deleted

-}
delete_notebook_situation :
    DeleteNotebookSituationRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_situation_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_notebook_situation requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_notebook_situation" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeNotebook_situation_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteNotebookSituationByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "notebook\_situation"
-}
delete_notebook_situation_by_pk :
    DeleteNotebookSituationByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_situation
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_notebook_situation_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_notebook_situation_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteNotebookTargetRequiredArguments =
    { where_ : CdbGQL.InputObject.Notebook_target_bool_exp }


{-| delete data from the table: "notebook\_target"

  - where\_ - filter the rows which have to be deleted

-}
delete_notebook_target :
    DeleteNotebookTargetRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_target_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_notebook_target requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_notebook_target" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeNotebook_target_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteNotebookTargetByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "notebook\_target"
-}
delete_notebook_target_by_pk :
    DeleteNotebookTargetByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_target
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_notebook_target_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_notebook_target_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteNpsRatingRequiredArguments =
    { where_ : CdbGQL.InputObject.Nps_rating_bool_exp }


{-| delete data from the table: "nps\_rating"

  - where\_ - filter the rows which have to be deleted

-}
delete_nps_rating :
    DeleteNpsRatingRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Nps_rating_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_nps_rating requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_nps_rating" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeNps_rating_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteNpsRatingByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "nps\_rating"
-}
delete_nps_rating_by_pk :
    DeleteNpsRatingByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Nps_rating
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_nps_rating_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_nps_rating_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteNpsRatingDismissalRequiredArguments =
    { where_ : CdbGQL.InputObject.Nps_rating_dismissal_bool_exp }


{-| delete data from the table: "nps\_rating\_dismissal"

  - where\_ - filter the rows which have to be deleted

-}
delete_nps_rating_dismissal :
    DeleteNpsRatingDismissalRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Nps_rating_dismissal_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_nps_rating_dismissal requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_nps_rating_dismissal" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeNps_rating_dismissal_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteNpsRatingDismissalByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "nps\_rating\_dismissal"
-}
delete_nps_rating_dismissal_by_pk :
    DeleteNpsRatingDismissalByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Nps_rating_dismissal
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_nps_rating_dismissal_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_nps_rating_dismissal_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteOrientationManagerRequiredArguments =
    { where_ : CdbGQL.InputObject.Orientation_manager_bool_exp }


{-| delete data from the table: "orientation\_manager"

  - where\_ - filter the rows which have to be deleted

-}
delete_orientation_manager :
    DeleteOrientationManagerRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_manager_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_orientation_manager requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_orientation_manager" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeOrientation_manager_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteOrientationManagerByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "orientation\_manager"
-}
delete_orientation_manager_by_pk :
    DeleteOrientationManagerByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_manager
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_orientation_manager_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_orientation_manager_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteOrientationRequestRequiredArguments =
    { where_ : CdbGQL.InputObject.Orientation_request_bool_exp }


{-| delete data from the table: "orientation\_request"

  - where\_ - filter the rows which have to be deleted

-}
delete_orientation_request :
    DeleteOrientationRequestRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_request_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_orientation_request requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_orientation_request" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeOrientation_request_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteOrientationRequestByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "orientation\_request"
-}
delete_orientation_request_by_pk :
    DeleteOrientationRequestByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_request
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_orientation_request_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_orientation_request_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteOrientationSystemRequiredArguments =
    { where_ : CdbGQL.InputObject.Orientation_system_bool_exp }


{-| delete data from the table: "orientation\_system"

  - where\_ - filter the rows which have to be deleted

-}
delete_orientation_system :
    DeleteOrientationSystemRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_system_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_orientation_system requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_orientation_system" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeOrientation_system_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteOrientationSystemByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "orientation\_system"
-}
delete_orientation_system_by_pk :
    DeleteOrientationSystemByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_system
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_orientation_system_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_orientation_system_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteOrientationTypeRequiredArguments =
    { where_ : CdbGQL.InputObject.Orientation_type_bool_exp }


{-| delete data from the table: "orientation\_type"

  - where\_ - filter the rows which have to be deleted

-}
delete_orientation_type :
    DeleteOrientationTypeRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_type_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_orientation_type requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_orientation_type" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeOrientation_type_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteOrientationTypeByPkRequiredArguments =
    { id : String }


{-| delete single row from the table: "orientation\_type"
-}
delete_orientation_type_by_pk :
    DeleteOrientationTypeByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_type
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_orientation_type_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_orientation_type_by_pk" [ Argument.required "id" requiredArgs____.id Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteProfessionalRequiredArguments =
    { where_ : CdbGQL.InputObject.Professional_bool_exp }


{-| delete data from the table: "professional"

  - where\_ - filter the rows which have to be deleted

-}
delete_professional :
    DeleteProfessionalRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Professional_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_professional requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_professional" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeProfessional_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteProfessionalByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "professional"
-}
delete_professional_by_pk :
    DeleteProfessionalByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Professional
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_professional_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_professional_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteProfessionalOrientationSystemRequiredArguments =
    { where_ : CdbGQL.InputObject.Professional_orientation_system_bool_exp }


{-| delete data from the table: "professional\_orientation\_system"

  - where\_ - filter the rows which have to be deleted

-}
delete_professional_orientation_system :
    DeleteProfessionalOrientationSystemRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Professional_orientation_system_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_professional_orientation_system requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_professional_orientation_system" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeProfessional_orientation_system_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteProfessionalOrientationSystemByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "professional\_orientation\_system"
-}
delete_professional_orientation_system_by_pk :
    DeleteProfessionalOrientationSystemByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Professional_orientation_system
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_professional_orientation_system_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_professional_orientation_system_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteProfessionalProjectRequiredArguments =
    { where_ : CdbGQL.InputObject.Professional_project_bool_exp }


{-| delete data from the table: "professional\_project"

  - where\_ - filter the rows which have to be deleted

-}
delete_professional_project :
    DeleteProfessionalProjectRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Professional_project_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_professional_project requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_professional_project" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeProfessional_project_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteProfessionalProjectByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "professional\_project"
-}
delete_professional_project_by_pk :
    DeleteProfessionalProjectByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Professional_project
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_professional_project_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_professional_project_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteRefActionRequiredArguments =
    { where_ : CdbGQL.InputObject.Ref_action_bool_exp }


{-| delete data from the table: "ref\_action"

  - where\_ - filter the rows which have to be deleted

-}
delete_ref_action :
    DeleteRefActionRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_action_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_ref_action requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_ref_action" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeRef_action_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteRefActionByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "ref\_action"
-}
delete_ref_action_by_pk :
    DeleteRefActionByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_action
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_ref_action_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_ref_action_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteRefSituationRequiredArguments =
    { where_ : CdbGQL.InputObject.Ref_situation_bool_exp }


{-| delete data from the table: "ref\_situation"

  - where\_ - filter the rows which have to be deleted

-}
delete_ref_situation :
    DeleteRefSituationRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_situation_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_ref_situation requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_ref_situation" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeRef_situation_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteRefSituationByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "ref\_situation"
-}
delete_ref_situation_by_pk :
    DeleteRefSituationByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_situation
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_ref_situation_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_ref_situation_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteRefTargetRequiredArguments =
    { where_ : CdbGQL.InputObject.Ref_target_bool_exp }


{-| delete data from the table: "ref\_target"

  - where\_ - filter the rows which have to be deleted

-}
delete_ref_target :
    DeleteRefTargetRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_target_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_ref_target requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_ref_target" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeRef_target_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteRefTargetByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "ref\_target"
-}
delete_ref_target_by_pk :
    DeleteRefTargetByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_target
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_ref_target_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_ref_target_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteRefThemeRequiredArguments =
    { where_ : CdbGQL.InputObject.Ref_theme_bool_exp }


{-| delete data from the table: "ref\_theme"

  - where\_ - filter the rows which have to be deleted

-}
delete_ref_theme :
    DeleteRefThemeRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_theme_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_ref_theme requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_ref_theme" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeRef_theme_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteRefThemeByPkRequiredArguments =
    { name : String }


{-| delete single row from the table: "ref\_theme"
-}
delete_ref_theme_by_pk :
    DeleteRefThemeByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_theme
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_ref_theme_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_ref_theme_by_pk" [ Argument.required "name" requiredArgs____.name Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteRoleRequiredArguments =
    { where_ : CdbGQL.InputObject.Role_bool_exp }


{-| delete data from the table: "role"

  - where\_ - filter the rows which have to be deleted

-}
delete_role :
    DeleteRoleRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Role_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_role requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_role" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeRole_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteRoleByPkRequiredArguments =
    { label : String }


{-| delete single row from the table: "role"
-}
delete_role_by_pk :
    DeleteRoleByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Role
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_role_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_role_by_pk" [ Argument.required "label" requiredArgs____.label Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteRomeCodeRequiredArguments =
    { where_ : CdbGQL.InputObject.Rome_code_bool_exp }


{-| delete data from the table: "rome\_code"

  - where\_ - filter the rows which have to be deleted

-}
delete_rome_code :
    DeleteRomeCodeRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rome_code_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_rome_code requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_rome_code" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeRome_code_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteRomeCodeByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "rome\_code"
-}
delete_rome_code_by_pk :
    DeleteRomeCodeByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rome_code
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_rome_code_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_rome_code_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteRsaClosureReasonRequiredArguments =
    { where_ : CdbGQL.InputObject.Rsa_closure_reason_bool_exp }


{-| delete data from the table: "rsa\_closure\_reason"

  - where\_ - filter the rows which have to be deleted

-}
delete_rsa_closure_reason :
    DeleteRsaClosureReasonRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rsa_closure_reason_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_rsa_closure_reason requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_rsa_closure_reason" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeRsa_closure_reason_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteRsaClosureReasonByPkRequiredArguments =
    { code : String }


{-| delete single row from the table: "rsa\_closure\_reason"
-}
delete_rsa_closure_reason_by_pk :
    DeleteRsaClosureReasonByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rsa_closure_reason
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_rsa_closure_reason_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_rsa_closure_reason_by_pk" [ Argument.required "code" requiredArgs____.code Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteRsaSuspensionReasonRequiredArguments =
    { where_ : CdbGQL.InputObject.Rsa_suspension_reason_bool_exp }


{-| delete data from the table: "rsa\_suspension\_reason"

  - where\_ - filter the rows which have to be deleted

-}
delete_rsa_suspension_reason :
    DeleteRsaSuspensionReasonRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rsa_suspension_reason_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_rsa_suspension_reason requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_rsa_suspension_reason" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeRsa_suspension_reason_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteRsaSuspensionReasonByPkRequiredArguments =
    { code : String }


{-| delete single row from the table: "rsa\_suspension\_reason"
-}
delete_rsa_suspension_reason_by_pk :
    DeleteRsaSuspensionReasonByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rsa_suspension_reason
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_rsa_suspension_reason_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_rsa_suspension_reason_by_pk" [ Argument.required "code" requiredArgs____.code Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteStructureRequiredArguments =
    { where_ : CdbGQL.InputObject.Structure_bool_exp }


{-| delete data from the table: "structure"

  - where\_ - filter the rows which have to be deleted

-}
delete_structure :
    DeleteStructureRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Structure_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_structure requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_structure" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeStructure_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteStructureByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "structure"
-}
delete_structure_by_pk :
    DeleteStructureByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Structure
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_structure_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_structure_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteStructureOrientationSystemRequiredArguments =
    { where_ : CdbGQL.InputObject.Structure_orientation_system_bool_exp }


{-| delete data from the table: "structure\_orientation\_system"

  - where\_ - filter the rows which have to be deleted

-}
delete_structure_orientation_system :
    DeleteStructureOrientationSystemRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Structure_orientation_system_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_structure_orientation_system requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_structure_orientation_system" [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeStructure_orientation_system_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteStructureOrientationSystemByPkRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid }


{-| delete single row from the table: "structure\_orientation\_system"
-}
delete_structure_orientation_system_by_pk :
    DeleteStructureOrientationSystemByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Structure_orientation_system
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_structure_orientation_system_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_structure_orientation_system_by_pk" [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias InsertAccountOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Account_on_conflict }


type alias InsertAccountRequiredArguments =
    { objects : List CdbGQL.InputObject.Account_insert_input }


{-| insert data into the table: "account"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_account :
    (InsertAccountOptionalArguments -> InsertAccountOptionalArguments)
    -> InsertAccountRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Account_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_account fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeAccount_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_account" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeAccount_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertAccountOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Account_on_conflict }


type alias InsertAccountOneRequiredArguments =
    { object : CdbGQL.InputObject.Account_insert_input }


{-| insert a single row into the table: "account"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_account_one :
    (InsertAccountOneOptionalArguments -> InsertAccountOneOptionalArguments)
    -> InsertAccountOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Account
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_account_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeAccount_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_account_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeAccount_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertActionStatusOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Action_status_on_conflict }


type alias InsertActionStatusRequiredArguments =
    { objects : List CdbGQL.InputObject.Action_status_insert_input }


{-| insert data into the table: "action\_status"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_action_status :
    (InsertActionStatusOptionalArguments -> InsertActionStatusOptionalArguments)
    -> InsertActionStatusRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Action_status_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_action_status fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeAction_status_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_action_status" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeAction_status_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertActionStatusOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Action_status_on_conflict }


type alias InsertActionStatusOneRequiredArguments =
    { object : CdbGQL.InputObject.Action_status_insert_input }


{-| insert a single row into the table: "action\_status"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_action_status_one :
    (InsertActionStatusOneOptionalArguments -> InsertActionStatusOneOptionalArguments)
    -> InsertActionStatusOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Action_status
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_action_status_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeAction_status_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_action_status_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeAction_status_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertAdminCdbOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Admin_cdb_on_conflict }


type alias InsertAdminCdbRequiredArguments =
    { objects : List CdbGQL.InputObject.Admin_cdb_insert_input }


{-| insert data into the table: "admin\_cdb"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_admin_cdb :
    (InsertAdminCdbOptionalArguments -> InsertAdminCdbOptionalArguments)
    -> InsertAdminCdbRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Admin_cdb_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_admin_cdb fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeAdmin_cdb_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_admin_cdb" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeAdmin_cdb_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertAdminCdbOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Admin_cdb_on_conflict }


type alias InsertAdminCdbOneRequiredArguments =
    { object : CdbGQL.InputObject.Admin_cdb_insert_input }


{-| insert a single row into the table: "admin\_cdb"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_admin_cdb_one :
    (InsertAdminCdbOneOptionalArguments -> InsertAdminCdbOneOptionalArguments)
    -> InsertAdminCdbOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Admin_cdb
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_admin_cdb_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeAdmin_cdb_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_admin_cdb_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeAdmin_cdb_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertAdminStructureOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Admin_structure_on_conflict }


type alias InsertAdminStructureRequiredArguments =
    { objects : List CdbGQL.InputObject.Admin_structure_insert_input }


{-| insert data into the table: "admin\_structure"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_admin_structure :
    (InsertAdminStructureOptionalArguments -> InsertAdminStructureOptionalArguments)
    -> InsertAdminStructureRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Admin_structure_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_admin_structure fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeAdmin_structure_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_admin_structure" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeAdmin_structure_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertAdminStructureOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Admin_structure_on_conflict }


type alias InsertAdminStructureOneRequiredArguments =
    { object : CdbGQL.InputObject.Admin_structure_insert_input }


{-| insert a single row into the table: "admin\_structure"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_admin_structure_one :
    (InsertAdminStructureOneOptionalArguments -> InsertAdminStructureOneOptionalArguments)
    -> InsertAdminStructureOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Admin_structure
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_admin_structure_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeAdmin_structure_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_admin_structure_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeAdmin_structure_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertAdminStructureStructureOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Admin_structure_structure_on_conflict }


type alias InsertAdminStructureStructureRequiredArguments =
    { objects : List CdbGQL.InputObject.Admin_structure_structure_insert_input }


{-| insert data into the table: "admin\_structure\_structure"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_admin_structure_structure :
    (InsertAdminStructureStructureOptionalArguments -> InsertAdminStructureStructureOptionalArguments)
    -> InsertAdminStructureStructureRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Admin_structure_structure_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_admin_structure_structure fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeAdmin_structure_structure_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_admin_structure_structure" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeAdmin_structure_structure_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertAdminStructureStructureOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Admin_structure_structure_on_conflict }


type alias InsertAdminStructureStructureOneRequiredArguments =
    { object : CdbGQL.InputObject.Admin_structure_structure_insert_input }


{-| insert a single row into the table: "admin\_structure\_structure"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_admin_structure_structure_one :
    (InsertAdminStructureStructureOneOptionalArguments -> InsertAdminStructureStructureOneOptionalArguments)
    -> InsertAdminStructureStructureOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Admin_structure_structure
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_admin_structure_structure_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeAdmin_structure_structure_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_admin_structure_structure_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeAdmin_structure_structure_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertBeneficiaryOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Beneficiary_on_conflict }


type alias InsertBeneficiaryRequiredArguments =
    { objects : List CdbGQL.InputObject.Beneficiary_insert_input }


{-| insert data into the table: "beneficiary"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_beneficiary :
    (InsertBeneficiaryOptionalArguments -> InsertBeneficiaryOptionalArguments)
    -> InsertBeneficiaryRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_beneficiary fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeBeneficiary_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_beneficiary" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeBeneficiary_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertBeneficiaryOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Beneficiary_on_conflict }


type alias InsertBeneficiaryOneRequiredArguments =
    { object : CdbGQL.InputObject.Beneficiary_insert_input }


{-| insert a single row into the table: "beneficiary"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_beneficiary_one :
    (InsertBeneficiaryOneOptionalArguments -> InsertBeneficiaryOneOptionalArguments)
    -> InsertBeneficiaryOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_beneficiary_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeBeneficiary_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_beneficiary_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeBeneficiary_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertBeneficiaryStructureOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Beneficiary_structure_on_conflict }


type alias InsertBeneficiaryStructureRequiredArguments =
    { objects : List CdbGQL.InputObject.Beneficiary_structure_insert_input }


{-| insert data into the table: "beneficiary\_structure"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_beneficiary_structure :
    (InsertBeneficiaryStructureOptionalArguments -> InsertBeneficiaryStructureOptionalArguments)
    -> InsertBeneficiaryStructureRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary_structure_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_beneficiary_structure fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeBeneficiary_structure_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_beneficiary_structure" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeBeneficiary_structure_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertBeneficiaryStructureOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Beneficiary_structure_on_conflict }


type alias InsertBeneficiaryStructureOneRequiredArguments =
    { object : CdbGQL.InputObject.Beneficiary_structure_insert_input }


{-| insert a single row into the table: "beneficiary\_structure"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_beneficiary_structure_one :
    (InsertBeneficiaryStructureOneOptionalArguments -> InsertBeneficiaryStructureOneOptionalArguments)
    -> InsertBeneficiaryStructureOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary_structure
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_beneficiary_structure_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeBeneficiary_structure_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_beneficiary_structure_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeBeneficiary_structure_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertContractTypeOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Contract_type_on_conflict }


type alias InsertContractTypeRequiredArguments =
    { objects : List CdbGQL.InputObject.Contract_type_insert_input }


{-| insert data into the table: "contract\_type"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_contract_type :
    (InsertContractTypeOptionalArguments -> InsertContractTypeOptionalArguments)
    -> InsertContractTypeRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Contract_type_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_contract_type fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeContract_type_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_contract_type" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeContract_type_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertContractTypeOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Contract_type_on_conflict }


type alias InsertContractTypeOneRequiredArguments =
    { object : CdbGQL.InputObject.Contract_type_insert_input }


{-| insert a single row into the table: "contract\_type"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_contract_type_one :
    (InsertContractTypeOneOptionalArguments -> InsertContractTypeOneOptionalArguments)
    -> InsertContractTypeOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Contract_type
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_contract_type_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeContract_type_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_contract_type_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeContract_type_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertDeploymentOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Deployment_on_conflict }


type alias InsertDeploymentRequiredArguments =
    { objects : List CdbGQL.InputObject.Deployment_insert_input }


{-| insert data into the table: "deployment"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_deployment :
    (InsertDeploymentOptionalArguments -> InsertDeploymentOptionalArguments)
    -> InsertDeploymentRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Deployment_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_deployment fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeDeployment_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_deployment" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeDeployment_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertDeploymentOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Deployment_on_conflict }


type alias InsertDeploymentOneRequiredArguments =
    { object : CdbGQL.InputObject.Deployment_insert_input }


{-| insert a single row into the table: "deployment"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_deployment_one :
    (InsertDeploymentOneOptionalArguments -> InsertDeploymentOneOptionalArguments)
    -> InsertDeploymentOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Deployment
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_deployment_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeDeployment_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_deployment_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeDeployment_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertEmploymentTypeOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Employment_type_on_conflict }


type alias InsertEmploymentTypeRequiredArguments =
    { objects : List CdbGQL.InputObject.Employment_type_insert_input }


{-| insert data into the table: "employment\_type"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_employment_type :
    (InsertEmploymentTypeOptionalArguments -> InsertEmploymentTypeOptionalArguments)
    -> InsertEmploymentTypeRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Employment_type_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_employment_type fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeEmployment_type_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_employment_type" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeEmployment_type_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertEmploymentTypeOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Employment_type_on_conflict }


type alias InsertEmploymentTypeOneRequiredArguments =
    { object : CdbGQL.InputObject.Employment_type_insert_input }


{-| insert a single row into the table: "employment\_type"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_employment_type_one :
    (InsertEmploymentTypeOneOptionalArguments -> InsertEmploymentTypeOneOptionalArguments)
    -> InsertEmploymentTypeOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Employment_type
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_employment_type_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeEmployment_type_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_employment_type_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeEmployment_type_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertExternalDataOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.External_data_on_conflict }


type alias InsertExternalDataRequiredArguments =
    { objects : List CdbGQL.InputObject.External_data_insert_input }


{-| insert data into the table: "external\_data"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_external_data :
    (InsertExternalDataOptionalArguments -> InsertExternalDataOptionalArguments)
    -> InsertExternalDataRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.External_data_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_external_data fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeExternal_data_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_external_data" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeExternal_data_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertExternalDataInfoOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.External_data_info_on_conflict }


type alias InsertExternalDataInfoRequiredArguments =
    { objects : List CdbGQL.InputObject.External_data_info_insert_input }


{-| insert data into the table: "external\_data\_info"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_external_data_info :
    (InsertExternalDataInfoOptionalArguments -> InsertExternalDataInfoOptionalArguments)
    -> InsertExternalDataInfoRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.External_data_info_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_external_data_info fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeExternal_data_info_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_external_data_info" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeExternal_data_info_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertExternalDataInfoOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.External_data_info_on_conflict }


type alias InsertExternalDataInfoOneRequiredArguments =
    { object : CdbGQL.InputObject.External_data_info_insert_input }


{-| insert a single row into the table: "external\_data\_info"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_external_data_info_one :
    (InsertExternalDataInfoOneOptionalArguments -> InsertExternalDataInfoOneOptionalArguments)
    -> InsertExternalDataInfoOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.External_data_info
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_external_data_info_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeExternal_data_info_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_external_data_info_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeExternal_data_info_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertExternalDataOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.External_data_on_conflict }


type alias InsertExternalDataOneRequiredArguments =
    { object : CdbGQL.InputObject.External_data_insert_input }


{-| insert a single row into the table: "external\_data"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_external_data_one :
    (InsertExternalDataOneOptionalArguments -> InsertExternalDataOneOptionalArguments)
    -> InsertExternalDataOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.External_data
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_external_data_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeExternal_data_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_external_data_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeExternal_data_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertExternalSourceOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.External_source_on_conflict }


type alias InsertExternalSourceRequiredArguments =
    { objects : List CdbGQL.InputObject.External_source_insert_input }


{-| insert data into the table: "external\_source"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_external_source :
    (InsertExternalSourceOptionalArguments -> InsertExternalSourceOptionalArguments)
    -> InsertExternalSourceRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.External_source_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_external_source fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeExternal_source_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_external_source" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeExternal_source_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertExternalSourceOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.External_source_on_conflict }


type alias InsertExternalSourceOneRequiredArguments =
    { object : CdbGQL.InputObject.External_source_insert_input }


{-| insert a single row into the table: "external\_source"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_external_source_one :
    (InsertExternalSourceOneOptionalArguments -> InsertExternalSourceOneOptionalArguments)
    -> InsertExternalSourceOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.External_source
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_external_source_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeExternal_source_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_external_source_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeExternal_source_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertManagerOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Manager_on_conflict }


type alias InsertManagerRequiredArguments =
    { objects : List CdbGQL.InputObject.Manager_insert_input }


{-| insert data into the table: "manager"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_manager :
    (InsertManagerOptionalArguments -> InsertManagerOptionalArguments)
    -> InsertManagerRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Manager_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_manager fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeManager_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_manager" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeManager_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertManagerOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Manager_on_conflict }


type alias InsertManagerOneRequiredArguments =
    { object : CdbGQL.InputObject.Manager_insert_input }


{-| insert a single row into the table: "manager"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_manager_one :
    (InsertManagerOneOptionalArguments -> InsertManagerOneOptionalArguments)
    -> InsertManagerOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Manager
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_manager_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeManager_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_manager_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeManager_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertNotebookOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Notebook_on_conflict }


type alias InsertNotebookRequiredArguments =
    { objects : List CdbGQL.InputObject.Notebook_insert_input }


{-| insert data into the table: "notebook"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_notebook :
    (InsertNotebookOptionalArguments -> InsertNotebookOptionalArguments)
    -> InsertNotebookRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_notebook fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeNotebook_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_notebook" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeNotebook_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertNotebookActionOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Notebook_action_on_conflict }


type alias InsertNotebookActionRequiredArguments =
    { objects : List CdbGQL.InputObject.Notebook_action_insert_input }


{-| insert data into the table: "notebook\_action"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_notebook_action :
    (InsertNotebookActionOptionalArguments -> InsertNotebookActionOptionalArguments)
    -> InsertNotebookActionRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_action_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_notebook_action fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeNotebook_action_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_notebook_action" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeNotebook_action_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertNotebookActionOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Notebook_action_on_conflict }


type alias InsertNotebookActionOneRequiredArguments =
    { object : CdbGQL.InputObject.Notebook_action_insert_input }


{-| insert a single row into the table: "notebook\_action"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_notebook_action_one :
    (InsertNotebookActionOneOptionalArguments -> InsertNotebookActionOneOptionalArguments)
    -> InsertNotebookActionOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_action
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_notebook_action_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeNotebook_action_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_notebook_action_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeNotebook_action_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertNotebookAppointmentOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Notebook_appointment_on_conflict }


type alias InsertNotebookAppointmentRequiredArguments =
    { objects : List CdbGQL.InputObject.Notebook_appointment_insert_input }


{-| insert data into the table: "notebook\_appointment"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_notebook_appointment :
    (InsertNotebookAppointmentOptionalArguments -> InsertNotebookAppointmentOptionalArguments)
    -> InsertNotebookAppointmentRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_appointment_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_notebook_appointment fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeNotebook_appointment_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_notebook_appointment" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeNotebook_appointment_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertNotebookAppointmentOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Notebook_appointment_on_conflict }


type alias InsertNotebookAppointmentOneRequiredArguments =
    { object : CdbGQL.InputObject.Notebook_appointment_insert_input }


{-| insert a single row into the table: "notebook\_appointment"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_notebook_appointment_one :
    (InsertNotebookAppointmentOneOptionalArguments -> InsertNotebookAppointmentOneOptionalArguments)
    -> InsertNotebookAppointmentOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_appointment
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_notebook_appointment_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeNotebook_appointment_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_notebook_appointment_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeNotebook_appointment_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertNotebookEventOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Notebook_event_on_conflict }


type alias InsertNotebookEventRequiredArguments =
    { objects : List CdbGQL.InputObject.Notebook_event_insert_input }


{-| insert data into the table: "notebook\_event"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_notebook_event :
    (InsertNotebookEventOptionalArguments -> InsertNotebookEventOptionalArguments)
    -> InsertNotebookEventRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_event_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_notebook_event fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeNotebook_event_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_notebook_event" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeNotebook_event_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertNotebookEventOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Notebook_event_on_conflict }


type alias InsertNotebookEventOneRequiredArguments =
    { object : CdbGQL.InputObject.Notebook_event_insert_input }


{-| insert a single row into the table: "notebook\_event"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_notebook_event_one :
    (InsertNotebookEventOneOptionalArguments -> InsertNotebookEventOneOptionalArguments)
    -> InsertNotebookEventOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_event
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_notebook_event_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeNotebook_event_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_notebook_event_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeNotebook_event_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertNotebookEventTypeOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Notebook_event_type_on_conflict }


type alias InsertNotebookEventTypeRequiredArguments =
    { objects : List CdbGQL.InputObject.Notebook_event_type_insert_input }


{-| insert data into the table: "notebook\_event\_type"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_notebook_event_type :
    (InsertNotebookEventTypeOptionalArguments -> InsertNotebookEventTypeOptionalArguments)
    -> InsertNotebookEventTypeRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_event_type_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_notebook_event_type fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeNotebook_event_type_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_notebook_event_type" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeNotebook_event_type_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertNotebookEventTypeOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Notebook_event_type_on_conflict }


type alias InsertNotebookEventTypeOneRequiredArguments =
    { object : CdbGQL.InputObject.Notebook_event_type_insert_input }


{-| insert a single row into the table: "notebook\_event\_type"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_notebook_event_type_one :
    (InsertNotebookEventTypeOneOptionalArguments -> InsertNotebookEventTypeOneOptionalArguments)
    -> InsertNotebookEventTypeOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_event_type
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_notebook_event_type_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeNotebook_event_type_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_notebook_event_type_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeNotebook_event_type_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertNotebookFocusOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Notebook_focus_on_conflict }


type alias InsertNotebookFocusRequiredArguments =
    { objects : List CdbGQL.InputObject.Notebook_focus_insert_input }


{-| insert data into the table: "notebook\_focus"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_notebook_focus :
    (InsertNotebookFocusOptionalArguments -> InsertNotebookFocusOptionalArguments)
    -> InsertNotebookFocusRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_focus_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_notebook_focus fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeNotebook_focus_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_notebook_focus" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeNotebook_focus_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertNotebookFocusOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Notebook_focus_on_conflict }


type alias InsertNotebookFocusOneRequiredArguments =
    { object : CdbGQL.InputObject.Notebook_focus_insert_input }


{-| insert a single row into the table: "notebook\_focus"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_notebook_focus_one :
    (InsertNotebookFocusOneOptionalArguments -> InsertNotebookFocusOneOptionalArguments)
    -> InsertNotebookFocusOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_focus
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_notebook_focus_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeNotebook_focus_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_notebook_focus_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeNotebook_focus_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertNotebookInfoOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Notebook_info_on_conflict }


type alias InsertNotebookInfoRequiredArguments =
    { objects : List CdbGQL.InputObject.Notebook_info_insert_input }


{-| insert data into the table: "notebook\_info"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_notebook_info :
    (InsertNotebookInfoOptionalArguments -> InsertNotebookInfoOptionalArguments)
    -> InsertNotebookInfoRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_info_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_notebook_info fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeNotebook_info_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_notebook_info" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeNotebook_info_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertNotebookInfoOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Notebook_info_on_conflict }


type alias InsertNotebookInfoOneRequiredArguments =
    { object : CdbGQL.InputObject.Notebook_info_insert_input }


{-| insert a single row into the table: "notebook\_info"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_notebook_info_one :
    (InsertNotebookInfoOneOptionalArguments -> InsertNotebookInfoOneOptionalArguments)
    -> InsertNotebookInfoOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_info
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_notebook_info_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeNotebook_info_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_notebook_info_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeNotebook_info_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertNotebookMemberOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Notebook_member_on_conflict }


type alias InsertNotebookMemberRequiredArguments =
    { objects : List CdbGQL.InputObject.Notebook_member_insert_input }


{-| insert data into the table: "notebook\_member"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_notebook_member :
    (InsertNotebookMemberOptionalArguments -> InsertNotebookMemberOptionalArguments)
    -> InsertNotebookMemberRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_member_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_notebook_member fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeNotebook_member_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_notebook_member" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeNotebook_member_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertNotebookMemberOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Notebook_member_on_conflict }


type alias InsertNotebookMemberOneRequiredArguments =
    { object : CdbGQL.InputObject.Notebook_member_insert_input }


{-| insert a single row into the table: "notebook\_member"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_notebook_member_one :
    (InsertNotebookMemberOneOptionalArguments -> InsertNotebookMemberOneOptionalArguments)
    -> InsertNotebookMemberOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_member
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_notebook_member_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeNotebook_member_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_notebook_member_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeNotebook_member_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertNotebookOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Notebook_on_conflict }


type alias InsertNotebookOneRequiredArguments =
    { object : CdbGQL.InputObject.Notebook_insert_input }


{-| insert a single row into the table: "notebook"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_notebook_one :
    (InsertNotebookOneOptionalArguments -> InsertNotebookOneOptionalArguments)
    -> InsertNotebookOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_notebook_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeNotebook_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_notebook_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeNotebook_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertNotebookPublicViewRequiredArguments =
    { objects : List CdbGQL.InputObject.Notebook_public_view_insert_input }


{-| insert data into the table: "notebook\_public\_view"

  - objects - the rows to be inserted

-}
insert_notebook_public_view :
    InsertNotebookPublicViewRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_public_view_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_notebook_public_view requiredArgs____ object____ =
    Object.selectionForCompositeField "insert_notebook_public_view" [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeNotebook_public_view_insert_input |> Encode.list) ] object____ (Basics.identity >> Decode.nullable)


type alias InsertNotebookPublicViewOneRequiredArguments =
    { object : CdbGQL.InputObject.Notebook_public_view_insert_input }


{-| insert a single row into the table: "notebook\_public\_view"

  - object - the row to be inserted

-}
insert_notebook_public_view_one :
    InsertNotebookPublicViewOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_public_view
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_notebook_public_view_one requiredArgs____ object____ =
    Object.selectionForCompositeField "insert_notebook_public_view_one" [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeNotebook_public_view_insert_input ] object____ (Basics.identity >> Decode.nullable)


type alias InsertNotebookSituationOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Notebook_situation_on_conflict }


type alias InsertNotebookSituationRequiredArguments =
    { objects : List CdbGQL.InputObject.Notebook_situation_insert_input }


{-| insert data into the table: "notebook\_situation"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_notebook_situation :
    (InsertNotebookSituationOptionalArguments -> InsertNotebookSituationOptionalArguments)
    -> InsertNotebookSituationRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_situation_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_notebook_situation fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeNotebook_situation_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_notebook_situation" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeNotebook_situation_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertNotebookSituationOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Notebook_situation_on_conflict }


type alias InsertNotebookSituationOneRequiredArguments =
    { object : CdbGQL.InputObject.Notebook_situation_insert_input }


{-| insert a single row into the table: "notebook\_situation"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_notebook_situation_one :
    (InsertNotebookSituationOneOptionalArguments -> InsertNotebookSituationOneOptionalArguments)
    -> InsertNotebookSituationOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_situation
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_notebook_situation_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeNotebook_situation_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_notebook_situation_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeNotebook_situation_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertNotebookTargetOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Notebook_target_on_conflict }


type alias InsertNotebookTargetRequiredArguments =
    { objects : List CdbGQL.InputObject.Notebook_target_insert_input }


{-| insert data into the table: "notebook\_target"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_notebook_target :
    (InsertNotebookTargetOptionalArguments -> InsertNotebookTargetOptionalArguments)
    -> InsertNotebookTargetRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_target_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_notebook_target fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeNotebook_target_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_notebook_target" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeNotebook_target_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertNotebookTargetOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Notebook_target_on_conflict }


type alias InsertNotebookTargetOneRequiredArguments =
    { object : CdbGQL.InputObject.Notebook_target_insert_input }


{-| insert a single row into the table: "notebook\_target"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_notebook_target_one :
    (InsertNotebookTargetOneOptionalArguments -> InsertNotebookTargetOneOptionalArguments)
    -> InsertNotebookTargetOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_target
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_notebook_target_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeNotebook_target_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_notebook_target_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeNotebook_target_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertNpsRatingOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Nps_rating_on_conflict }


type alias InsertNpsRatingRequiredArguments =
    { objects : List CdbGQL.InputObject.Nps_rating_insert_input }


{-| insert data into the table: "nps\_rating"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_nps_rating :
    (InsertNpsRatingOptionalArguments -> InsertNpsRatingOptionalArguments)
    -> InsertNpsRatingRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Nps_rating_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_nps_rating fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeNps_rating_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_nps_rating" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeNps_rating_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertNpsRatingDismissalOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Nps_rating_dismissal_on_conflict }


type alias InsertNpsRatingDismissalRequiredArguments =
    { objects : List CdbGQL.InputObject.Nps_rating_dismissal_insert_input }


{-| insert data into the table: "nps\_rating\_dismissal"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_nps_rating_dismissal :
    (InsertNpsRatingDismissalOptionalArguments -> InsertNpsRatingDismissalOptionalArguments)
    -> InsertNpsRatingDismissalRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Nps_rating_dismissal_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_nps_rating_dismissal fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeNps_rating_dismissal_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_nps_rating_dismissal" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeNps_rating_dismissal_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertNpsRatingDismissalOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Nps_rating_dismissal_on_conflict }


type alias InsertNpsRatingDismissalOneRequiredArguments =
    { object : CdbGQL.InputObject.Nps_rating_dismissal_insert_input }


{-| insert a single row into the table: "nps\_rating\_dismissal"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_nps_rating_dismissal_one :
    (InsertNpsRatingDismissalOneOptionalArguments -> InsertNpsRatingDismissalOneOptionalArguments)
    -> InsertNpsRatingDismissalOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Nps_rating_dismissal
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_nps_rating_dismissal_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeNps_rating_dismissal_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_nps_rating_dismissal_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeNps_rating_dismissal_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertNpsRatingOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Nps_rating_on_conflict }


type alias InsertNpsRatingOneRequiredArguments =
    { object : CdbGQL.InputObject.Nps_rating_insert_input }


{-| insert a single row into the table: "nps\_rating"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_nps_rating_one :
    (InsertNpsRatingOneOptionalArguments -> InsertNpsRatingOneOptionalArguments)
    -> InsertNpsRatingOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Nps_rating
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_nps_rating_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeNps_rating_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_nps_rating_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeNps_rating_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertOrientationManagerOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Orientation_manager_on_conflict }


type alias InsertOrientationManagerRequiredArguments =
    { objects : List CdbGQL.InputObject.Orientation_manager_insert_input }


{-| insert data into the table: "orientation\_manager"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_orientation_manager :
    (InsertOrientationManagerOptionalArguments -> InsertOrientationManagerOptionalArguments)
    -> InsertOrientationManagerRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_manager_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_orientation_manager fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeOrientation_manager_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_orientation_manager" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeOrientation_manager_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertOrientationManagerOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Orientation_manager_on_conflict }


type alias InsertOrientationManagerOneRequiredArguments =
    { object : CdbGQL.InputObject.Orientation_manager_insert_input }


{-| insert a single row into the table: "orientation\_manager"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_orientation_manager_one :
    (InsertOrientationManagerOneOptionalArguments -> InsertOrientationManagerOneOptionalArguments)
    -> InsertOrientationManagerOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_manager
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_orientation_manager_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeOrientation_manager_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_orientation_manager_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeOrientation_manager_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertOrientationRequestOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Orientation_request_on_conflict }


type alias InsertOrientationRequestRequiredArguments =
    { objects : List CdbGQL.InputObject.Orientation_request_insert_input }


{-| insert data into the table: "orientation\_request"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_orientation_request :
    (InsertOrientationRequestOptionalArguments -> InsertOrientationRequestOptionalArguments)
    -> InsertOrientationRequestRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_request_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_orientation_request fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeOrientation_request_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_orientation_request" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeOrientation_request_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertOrientationRequestOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Orientation_request_on_conflict }


type alias InsertOrientationRequestOneRequiredArguments =
    { object : CdbGQL.InputObject.Orientation_request_insert_input }


{-| insert a single row into the table: "orientation\_request"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_orientation_request_one :
    (InsertOrientationRequestOneOptionalArguments -> InsertOrientationRequestOneOptionalArguments)
    -> InsertOrientationRequestOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_request
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_orientation_request_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeOrientation_request_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_orientation_request_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeOrientation_request_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertOrientationSystemOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Orientation_system_on_conflict }


type alias InsertOrientationSystemRequiredArguments =
    { objects : List CdbGQL.InputObject.Orientation_system_insert_input }


{-| insert data into the table: "orientation\_system"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_orientation_system :
    (InsertOrientationSystemOptionalArguments -> InsertOrientationSystemOptionalArguments)
    -> InsertOrientationSystemRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_system_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_orientation_system fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeOrientation_system_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_orientation_system" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeOrientation_system_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertOrientationSystemOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Orientation_system_on_conflict }


type alias InsertOrientationSystemOneRequiredArguments =
    { object : CdbGQL.InputObject.Orientation_system_insert_input }


{-| insert a single row into the table: "orientation\_system"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_orientation_system_one :
    (InsertOrientationSystemOneOptionalArguments -> InsertOrientationSystemOneOptionalArguments)
    -> InsertOrientationSystemOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_system
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_orientation_system_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeOrientation_system_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_orientation_system_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeOrientation_system_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertOrientationTypeOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Orientation_type_on_conflict }


type alias InsertOrientationTypeRequiredArguments =
    { objects : List CdbGQL.InputObject.Orientation_type_insert_input }


{-| insert data into the table: "orientation\_type"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_orientation_type :
    (InsertOrientationTypeOptionalArguments -> InsertOrientationTypeOptionalArguments)
    -> InsertOrientationTypeRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_type_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_orientation_type fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeOrientation_type_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_orientation_type" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeOrientation_type_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertOrientationTypeOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Orientation_type_on_conflict }


type alias InsertOrientationTypeOneRequiredArguments =
    { object : CdbGQL.InputObject.Orientation_type_insert_input }


{-| insert a single row into the table: "orientation\_type"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_orientation_type_one :
    (InsertOrientationTypeOneOptionalArguments -> InsertOrientationTypeOneOptionalArguments)
    -> InsertOrientationTypeOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_type
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_orientation_type_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeOrientation_type_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_orientation_type_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeOrientation_type_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertProfessionalOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Professional_on_conflict }


type alias InsertProfessionalRequiredArguments =
    { objects : List CdbGQL.InputObject.Professional_insert_input }


{-| insert data into the table: "professional"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_professional :
    (InsertProfessionalOptionalArguments -> InsertProfessionalOptionalArguments)
    -> InsertProfessionalRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Professional_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_professional fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeProfessional_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_professional" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeProfessional_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertProfessionalOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Professional_on_conflict }


type alias InsertProfessionalOneRequiredArguments =
    { object : CdbGQL.InputObject.Professional_insert_input }


{-| insert a single row into the table: "professional"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_professional_one :
    (InsertProfessionalOneOptionalArguments -> InsertProfessionalOneOptionalArguments)
    -> InsertProfessionalOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Professional
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_professional_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeProfessional_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_professional_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeProfessional_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertProfessionalOrientationSystemOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Professional_orientation_system_on_conflict }


type alias InsertProfessionalOrientationSystemRequiredArguments =
    { objects : List CdbGQL.InputObject.Professional_orientation_system_insert_input }


{-| insert data into the table: "professional\_orientation\_system"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_professional_orientation_system :
    (InsertProfessionalOrientationSystemOptionalArguments -> InsertProfessionalOrientationSystemOptionalArguments)
    -> InsertProfessionalOrientationSystemRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Professional_orientation_system_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_professional_orientation_system fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeProfessional_orientation_system_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_professional_orientation_system" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeProfessional_orientation_system_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertProfessionalOrientationSystemOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Professional_orientation_system_on_conflict }


type alias InsertProfessionalOrientationSystemOneRequiredArguments =
    { object : CdbGQL.InputObject.Professional_orientation_system_insert_input }


{-| insert a single row into the table: "professional\_orientation\_system"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_professional_orientation_system_one :
    (InsertProfessionalOrientationSystemOneOptionalArguments -> InsertProfessionalOrientationSystemOneOptionalArguments)
    -> InsertProfessionalOrientationSystemOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Professional_orientation_system
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_professional_orientation_system_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeProfessional_orientation_system_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_professional_orientation_system_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeProfessional_orientation_system_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertProfessionalProjectOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Professional_project_on_conflict }


type alias InsertProfessionalProjectRequiredArguments =
    { objects : List CdbGQL.InputObject.Professional_project_insert_input }


{-| insert data into the table: "professional\_project"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_professional_project :
    (InsertProfessionalProjectOptionalArguments -> InsertProfessionalProjectOptionalArguments)
    -> InsertProfessionalProjectRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Professional_project_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_professional_project fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeProfessional_project_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_professional_project" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeProfessional_project_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertProfessionalProjectOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Professional_project_on_conflict }


type alias InsertProfessionalProjectOneRequiredArguments =
    { object : CdbGQL.InputObject.Professional_project_insert_input }


{-| insert a single row into the table: "professional\_project"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_professional_project_one :
    (InsertProfessionalProjectOneOptionalArguments -> InsertProfessionalProjectOneOptionalArguments)
    -> InsertProfessionalProjectOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Professional_project
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_professional_project_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeProfessional_project_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_professional_project_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeProfessional_project_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertRefActionOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Ref_action_on_conflict }


type alias InsertRefActionRequiredArguments =
    { objects : List CdbGQL.InputObject.Ref_action_insert_input }


{-| insert data into the table: "ref\_action"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_ref_action :
    (InsertRefActionOptionalArguments -> InsertRefActionOptionalArguments)
    -> InsertRefActionRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_action_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_ref_action fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeRef_action_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_ref_action" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeRef_action_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertRefActionOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Ref_action_on_conflict }


type alias InsertRefActionOneRequiredArguments =
    { object : CdbGQL.InputObject.Ref_action_insert_input }


{-| insert a single row into the table: "ref\_action"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_ref_action_one :
    (InsertRefActionOneOptionalArguments -> InsertRefActionOneOptionalArguments)
    -> InsertRefActionOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_action
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_ref_action_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeRef_action_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_ref_action_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeRef_action_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertRefSituationOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Ref_situation_on_conflict }


type alias InsertRefSituationRequiredArguments =
    { objects : List CdbGQL.InputObject.Ref_situation_insert_input }


{-| insert data into the table: "ref\_situation"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_ref_situation :
    (InsertRefSituationOptionalArguments -> InsertRefSituationOptionalArguments)
    -> InsertRefSituationRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_situation_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_ref_situation fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeRef_situation_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_ref_situation" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeRef_situation_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertRefSituationOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Ref_situation_on_conflict }


type alias InsertRefSituationOneRequiredArguments =
    { object : CdbGQL.InputObject.Ref_situation_insert_input }


{-| insert a single row into the table: "ref\_situation"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_ref_situation_one :
    (InsertRefSituationOneOptionalArguments -> InsertRefSituationOneOptionalArguments)
    -> InsertRefSituationOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_situation
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_ref_situation_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeRef_situation_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_ref_situation_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeRef_situation_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertRefTargetOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Ref_target_on_conflict }


type alias InsertRefTargetRequiredArguments =
    { objects : List CdbGQL.InputObject.Ref_target_insert_input }


{-| insert data into the table: "ref\_target"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_ref_target :
    (InsertRefTargetOptionalArguments -> InsertRefTargetOptionalArguments)
    -> InsertRefTargetRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_target_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_ref_target fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeRef_target_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_ref_target" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeRef_target_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertRefTargetOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Ref_target_on_conflict }


type alias InsertRefTargetOneRequiredArguments =
    { object : CdbGQL.InputObject.Ref_target_insert_input }


{-| insert a single row into the table: "ref\_target"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_ref_target_one :
    (InsertRefTargetOneOptionalArguments -> InsertRefTargetOneOptionalArguments)
    -> InsertRefTargetOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_target
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_ref_target_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeRef_target_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_ref_target_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeRef_target_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertRefThemeOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Ref_theme_on_conflict }


type alias InsertRefThemeRequiredArguments =
    { objects : List CdbGQL.InputObject.Ref_theme_insert_input }


{-| insert data into the table: "ref\_theme"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_ref_theme :
    (InsertRefThemeOptionalArguments -> InsertRefThemeOptionalArguments)
    -> InsertRefThemeRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_theme_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_ref_theme fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeRef_theme_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_ref_theme" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeRef_theme_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertRefThemeOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Ref_theme_on_conflict }


type alias InsertRefThemeOneRequiredArguments =
    { object : CdbGQL.InputObject.Ref_theme_insert_input }


{-| insert a single row into the table: "ref\_theme"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_ref_theme_one :
    (InsertRefThemeOneOptionalArguments -> InsertRefThemeOneOptionalArguments)
    -> InsertRefThemeOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_theme
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_ref_theme_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeRef_theme_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_ref_theme_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeRef_theme_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertRoleOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Role_on_conflict }


type alias InsertRoleRequiredArguments =
    { objects : List CdbGQL.InputObject.Role_insert_input }


{-| insert data into the table: "role"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_role :
    (InsertRoleOptionalArguments -> InsertRoleOptionalArguments)
    -> InsertRoleRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Role_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_role fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeRole_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_role" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeRole_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertRoleOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Role_on_conflict }


type alias InsertRoleOneRequiredArguments =
    { object : CdbGQL.InputObject.Role_insert_input }


{-| insert a single row into the table: "role"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_role_one :
    (InsertRoleOneOptionalArguments -> InsertRoleOneOptionalArguments)
    -> InsertRoleOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Role
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_role_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeRole_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_role_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeRole_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertRomeCodeOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Rome_code_on_conflict }


type alias InsertRomeCodeRequiredArguments =
    { objects : List CdbGQL.InputObject.Rome_code_insert_input }


{-| insert data into the table: "rome\_code"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_rome_code :
    (InsertRomeCodeOptionalArguments -> InsertRomeCodeOptionalArguments)
    -> InsertRomeCodeRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rome_code_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_rome_code fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeRome_code_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_rome_code" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeRome_code_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertRomeCodeOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Rome_code_on_conflict }


type alias InsertRomeCodeOneRequiredArguments =
    { object : CdbGQL.InputObject.Rome_code_insert_input }


{-| insert a single row into the table: "rome\_code"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_rome_code_one :
    (InsertRomeCodeOneOptionalArguments -> InsertRomeCodeOneOptionalArguments)
    -> InsertRomeCodeOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rome_code
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_rome_code_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeRome_code_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_rome_code_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeRome_code_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertRsaClosureReasonOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Rsa_closure_reason_on_conflict }


type alias InsertRsaClosureReasonRequiredArguments =
    { objects : List CdbGQL.InputObject.Rsa_closure_reason_insert_input }


{-| insert data into the table: "rsa\_closure\_reason"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_rsa_closure_reason :
    (InsertRsaClosureReasonOptionalArguments -> InsertRsaClosureReasonOptionalArguments)
    -> InsertRsaClosureReasonRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rsa_closure_reason_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_rsa_closure_reason fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeRsa_closure_reason_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_rsa_closure_reason" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeRsa_closure_reason_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertRsaClosureReasonOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Rsa_closure_reason_on_conflict }


type alias InsertRsaClosureReasonOneRequiredArguments =
    { object : CdbGQL.InputObject.Rsa_closure_reason_insert_input }


{-| insert a single row into the table: "rsa\_closure\_reason"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_rsa_closure_reason_one :
    (InsertRsaClosureReasonOneOptionalArguments -> InsertRsaClosureReasonOneOptionalArguments)
    -> InsertRsaClosureReasonOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rsa_closure_reason
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_rsa_closure_reason_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeRsa_closure_reason_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_rsa_closure_reason_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeRsa_closure_reason_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertRsaSuspensionReasonOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Rsa_suspension_reason_on_conflict }


type alias InsertRsaSuspensionReasonRequiredArguments =
    { objects : List CdbGQL.InputObject.Rsa_suspension_reason_insert_input }


{-| insert data into the table: "rsa\_suspension\_reason"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_rsa_suspension_reason :
    (InsertRsaSuspensionReasonOptionalArguments -> InsertRsaSuspensionReasonOptionalArguments)
    -> InsertRsaSuspensionReasonRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rsa_suspension_reason_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_rsa_suspension_reason fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeRsa_suspension_reason_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_rsa_suspension_reason" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeRsa_suspension_reason_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertRsaSuspensionReasonOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Rsa_suspension_reason_on_conflict }


type alias InsertRsaSuspensionReasonOneRequiredArguments =
    { object : CdbGQL.InputObject.Rsa_suspension_reason_insert_input }


{-| insert a single row into the table: "rsa\_suspension\_reason"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_rsa_suspension_reason_one :
    (InsertRsaSuspensionReasonOneOptionalArguments -> InsertRsaSuspensionReasonOneOptionalArguments)
    -> InsertRsaSuspensionReasonOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rsa_suspension_reason
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_rsa_suspension_reason_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeRsa_suspension_reason_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_rsa_suspension_reason_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeRsa_suspension_reason_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertStructureOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Structure_on_conflict }


type alias InsertStructureRequiredArguments =
    { objects : List CdbGQL.InputObject.Structure_insert_input }


{-| insert data into the table: "structure"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_structure :
    (InsertStructureOptionalArguments -> InsertStructureOptionalArguments)
    -> InsertStructureRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Structure_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_structure fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeStructure_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_structure" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeStructure_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertStructureOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Structure_on_conflict }


type alias InsertStructureOneRequiredArguments =
    { object : CdbGQL.InputObject.Structure_insert_input }


{-| insert a single row into the table: "structure"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_structure_one :
    (InsertStructureOneOptionalArguments -> InsertStructureOneOptionalArguments)
    -> InsertStructureOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Structure
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_structure_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeStructure_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_structure_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeStructure_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertStructureOrientationSystemOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Structure_orientation_system_on_conflict }


type alias InsertStructureOrientationSystemRequiredArguments =
    { objects : List CdbGQL.InputObject.Structure_orientation_system_insert_input }


{-| insert data into the table: "structure\_orientation\_system"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_structure_orientation_system :
    (InsertStructureOrientationSystemOptionalArguments -> InsertStructureOrientationSystemOptionalArguments)
    -> InsertStructureOrientationSystemRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Structure_orientation_system_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_structure_orientation_system fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeStructure_orientation_system_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_structure_orientation_system" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (CdbGQL.InputObject.encodeStructure_orientation_system_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertStructureOrientationSystemOneOptionalArguments =
    { on_conflict : OptionalArgument CdbGQL.InputObject.Structure_orientation_system_on_conflict }


type alias InsertStructureOrientationSystemOneRequiredArguments =
    { object : CdbGQL.InputObject.Structure_orientation_system_insert_input }


{-| insert a single row into the table: "structure\_orientation\_system"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_structure_orientation_system_one :
    (InsertStructureOrientationSystemOneOptionalArguments -> InsertStructureOrientationSystemOneOptionalArguments)
    -> InsertStructureOrientationSystemOneRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Structure_orientation_system
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_structure_orientation_system_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict CdbGQL.InputObject.encodeStructure_orientation_system_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_structure_orientation_system_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object CdbGQL.InputObject.encodeStructure_orientation_system_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateAccountOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Account_set_input }


type alias UpdateAccountRequiredArguments =
    { where_ : CdbGQL.InputObject.Account_bool_exp }


{-| update data of the table: "account"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_account :
    (UpdateAccountOptionalArguments -> UpdateAccountOptionalArguments)
    -> UpdateAccountRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Account_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_account fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeAccount_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_account" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeAccount_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateAccountByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Account_set_input }


type alias UpdateAccountByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Account_pk_columns_input }


{-| update single row of the table: "account"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_account_by_pk :
    (UpdateAccountByPkOptionalArguments -> UpdateAccountByPkOptionalArguments)
    -> UpdateAccountByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Account
    -> SelectionSet (Maybe decodesTo) RootMutation
update_account_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeAccount_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_account_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeAccount_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateAccountManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Account_updates }


{-| update multiples rows of table: "account"

  - updates - updates to execute, in order

-}
update_account_many :
    UpdateAccountManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Account_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_account_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_account_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeAccount_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateActionStatusOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Action_status_set_input }


type alias UpdateActionStatusRequiredArguments =
    { where_ : CdbGQL.InputObject.Action_status_bool_exp }


{-| update data of the table: "action\_status"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_action_status :
    (UpdateActionStatusOptionalArguments -> UpdateActionStatusOptionalArguments)
    -> UpdateActionStatusRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Action_status_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_action_status fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeAction_status_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_action_status" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeAction_status_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateActionStatusByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Action_status_set_input }


type alias UpdateActionStatusByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Action_status_pk_columns_input }


{-| update single row of the table: "action\_status"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_action_status_by_pk :
    (UpdateActionStatusByPkOptionalArguments -> UpdateActionStatusByPkOptionalArguments)
    -> UpdateActionStatusByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Action_status
    -> SelectionSet (Maybe decodesTo) RootMutation
update_action_status_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeAction_status_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_action_status_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeAction_status_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateActionStatusManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Action_status_updates }


{-| update multiples rows of table: "action\_status"

  - updates - updates to execute, in order

-}
update_action_status_many :
    UpdateActionStatusManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Action_status_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_action_status_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_action_status_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeAction_status_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateAdminCdbOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Admin_cdb_set_input }


type alias UpdateAdminCdbRequiredArguments =
    { where_ : CdbGQL.InputObject.Admin_cdb_bool_exp }


{-| update data of the table: "admin\_cdb"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_admin_cdb :
    (UpdateAdminCdbOptionalArguments -> UpdateAdminCdbOptionalArguments)
    -> UpdateAdminCdbRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Admin_cdb_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_admin_cdb fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeAdmin_cdb_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_admin_cdb" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeAdmin_cdb_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateAdminCdbByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Admin_cdb_set_input }


type alias UpdateAdminCdbByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Admin_cdb_pk_columns_input }


{-| update single row of the table: "admin\_cdb"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_admin_cdb_by_pk :
    (UpdateAdminCdbByPkOptionalArguments -> UpdateAdminCdbByPkOptionalArguments)
    -> UpdateAdminCdbByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Admin_cdb
    -> SelectionSet (Maybe decodesTo) RootMutation
update_admin_cdb_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeAdmin_cdb_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_admin_cdb_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeAdmin_cdb_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateAdminCdbManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Admin_cdb_updates }


{-| update multiples rows of table: "admin\_cdb"

  - updates - updates to execute, in order

-}
update_admin_cdb_many :
    UpdateAdminCdbManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Admin_cdb_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_admin_cdb_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_admin_cdb_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeAdmin_cdb_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateAdminStructureOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Admin_structure_set_input }


type alias UpdateAdminStructureRequiredArguments =
    { where_ : CdbGQL.InputObject.Admin_structure_bool_exp }


{-| update data of the table: "admin\_structure"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_admin_structure :
    (UpdateAdminStructureOptionalArguments -> UpdateAdminStructureOptionalArguments)
    -> UpdateAdminStructureRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Admin_structure_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_admin_structure fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeAdmin_structure_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_admin_structure" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeAdmin_structure_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateAdminStructureByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Admin_structure_set_input }


type alias UpdateAdminStructureByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Admin_structure_pk_columns_input }


{-| update single row of the table: "admin\_structure"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_admin_structure_by_pk :
    (UpdateAdminStructureByPkOptionalArguments -> UpdateAdminStructureByPkOptionalArguments)
    -> UpdateAdminStructureByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Admin_structure
    -> SelectionSet (Maybe decodesTo) RootMutation
update_admin_structure_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeAdmin_structure_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_admin_structure_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeAdmin_structure_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateAdminStructureManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Admin_structure_updates }


{-| update multiples rows of table: "admin\_structure"

  - updates - updates to execute, in order

-}
update_admin_structure_many :
    UpdateAdminStructureManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Admin_structure_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_admin_structure_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_admin_structure_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeAdmin_structure_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateAdminStructureStructureOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Admin_structure_structure_set_input }


type alias UpdateAdminStructureStructureRequiredArguments =
    { where_ : CdbGQL.InputObject.Admin_structure_structure_bool_exp }


{-| update data of the table: "admin\_structure\_structure"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_admin_structure_structure :
    (UpdateAdminStructureStructureOptionalArguments -> UpdateAdminStructureStructureOptionalArguments)
    -> UpdateAdminStructureStructureRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Admin_structure_structure_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_admin_structure_structure fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeAdmin_structure_structure_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_admin_structure_structure" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeAdmin_structure_structure_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateAdminStructureStructureByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Admin_structure_structure_set_input }


type alias UpdateAdminStructureStructureByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Admin_structure_structure_pk_columns_input }


{-| update single row of the table: "admin\_structure\_structure"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_admin_structure_structure_by_pk :
    (UpdateAdminStructureStructureByPkOptionalArguments -> UpdateAdminStructureStructureByPkOptionalArguments)
    -> UpdateAdminStructureStructureByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Admin_structure_structure
    -> SelectionSet (Maybe decodesTo) RootMutation
update_admin_structure_structure_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeAdmin_structure_structure_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_admin_structure_structure_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeAdmin_structure_structure_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateAdminStructureStructureManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Admin_structure_structure_updates }


{-| update multiples rows of table: "admin\_structure\_structure"

  - updates - updates to execute, in order

-}
update_admin_structure_structure_many :
    UpdateAdminStructureStructureManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Admin_structure_structure_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_admin_structure_structure_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_admin_structure_structure_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeAdmin_structure_structure_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateBeneficiaryOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Beneficiary_set_input }


type alias UpdateBeneficiaryRequiredArguments =
    { where_ : CdbGQL.InputObject.Beneficiary_bool_exp }


{-| update data of the table: "beneficiary"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_beneficiary :
    (UpdateBeneficiaryOptionalArguments -> UpdateBeneficiaryOptionalArguments)
    -> UpdateBeneficiaryRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_beneficiary fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeBeneficiary_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_beneficiary" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeBeneficiary_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateBeneficiaryByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Beneficiary_set_input }


type alias UpdateBeneficiaryByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Beneficiary_pk_columns_input }


{-| update single row of the table: "beneficiary"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_beneficiary_by_pk :
    (UpdateBeneficiaryByPkOptionalArguments -> UpdateBeneficiaryByPkOptionalArguments)
    -> UpdateBeneficiaryByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary
    -> SelectionSet (Maybe decodesTo) RootMutation
update_beneficiary_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeBeneficiary_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_beneficiary_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeBeneficiary_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateBeneficiaryManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Beneficiary_updates }


{-| update multiples rows of table: "beneficiary"

  - updates - updates to execute, in order

-}
update_beneficiary_many :
    UpdateBeneficiaryManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_beneficiary_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_beneficiary_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeBeneficiary_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateBeneficiaryStructureOptionalArguments =
    { append_ : OptionalArgument CdbGQL.InputObject.Beneficiary_structure_append_input
    , delete_at_path_ : OptionalArgument CdbGQL.InputObject.Beneficiary_structure_delete_at_path_input
    , delete_elem_ : OptionalArgument CdbGQL.InputObject.Beneficiary_structure_delete_elem_input
    , delete_key_ : OptionalArgument CdbGQL.InputObject.Beneficiary_structure_delete_key_input
    , prepend_ : OptionalArgument CdbGQL.InputObject.Beneficiary_structure_prepend_input
    , set_ : OptionalArgument CdbGQL.InputObject.Beneficiary_structure_set_input
    }


type alias UpdateBeneficiaryStructureRequiredArguments =
    { where_ : CdbGQL.InputObject.Beneficiary_structure_bool_exp }


{-| update data of the table: "beneficiary\_structure"

  - append\_ - append existing jsonb value of filtered columns with new jsonb value
  - delete\_at\_path\_ - delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  - delete\_elem\_ - delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  - delete\_key\_ - delete key/value pair or string element. key/value pairs are matched based on their key value
  - prepend\_ - prepend existing jsonb value of filtered columns with new jsonb value
  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_beneficiary_structure :
    (UpdateBeneficiaryStructureOptionalArguments -> UpdateBeneficiaryStructureOptionalArguments)
    -> UpdateBeneficiaryStructureRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary_structure_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_beneficiary_structure fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { append_ = Absent, delete_at_path_ = Absent, delete_elem_ = Absent, delete_key_ = Absent, prepend_ = Absent, set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_append" filledInOptionals____.append_ CdbGQL.InputObject.encodeBeneficiary_structure_append_input, Argument.optional "_delete_at_path" filledInOptionals____.delete_at_path_ CdbGQL.InputObject.encodeBeneficiary_structure_delete_at_path_input, Argument.optional "_delete_elem" filledInOptionals____.delete_elem_ CdbGQL.InputObject.encodeBeneficiary_structure_delete_elem_input, Argument.optional "_delete_key" filledInOptionals____.delete_key_ CdbGQL.InputObject.encodeBeneficiary_structure_delete_key_input, Argument.optional "_prepend" filledInOptionals____.prepend_ CdbGQL.InputObject.encodeBeneficiary_structure_prepend_input, Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeBeneficiary_structure_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_beneficiary_structure" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeBeneficiary_structure_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateBeneficiaryStructureByPkOptionalArguments =
    { append_ : OptionalArgument CdbGQL.InputObject.Beneficiary_structure_append_input
    , delete_at_path_ : OptionalArgument CdbGQL.InputObject.Beneficiary_structure_delete_at_path_input
    , delete_elem_ : OptionalArgument CdbGQL.InputObject.Beneficiary_structure_delete_elem_input
    , delete_key_ : OptionalArgument CdbGQL.InputObject.Beneficiary_structure_delete_key_input
    , prepend_ : OptionalArgument CdbGQL.InputObject.Beneficiary_structure_prepend_input
    , set_ : OptionalArgument CdbGQL.InputObject.Beneficiary_structure_set_input
    }


type alias UpdateBeneficiaryStructureByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Beneficiary_structure_pk_columns_input }


{-| update single row of the table: "beneficiary\_structure"

  - append\_ - append existing jsonb value of filtered columns with new jsonb value
  - delete\_at\_path\_ - delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  - delete\_elem\_ - delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  - delete\_key\_ - delete key/value pair or string element. key/value pairs are matched based on their key value
  - prepend\_ - prepend existing jsonb value of filtered columns with new jsonb value
  - set\_ - sets the columns of the filtered rows to the given values

-}
update_beneficiary_structure_by_pk :
    (UpdateBeneficiaryStructureByPkOptionalArguments -> UpdateBeneficiaryStructureByPkOptionalArguments)
    -> UpdateBeneficiaryStructureByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary_structure
    -> SelectionSet (Maybe decodesTo) RootMutation
update_beneficiary_structure_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { append_ = Absent, delete_at_path_ = Absent, delete_elem_ = Absent, delete_key_ = Absent, prepend_ = Absent, set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_append" filledInOptionals____.append_ CdbGQL.InputObject.encodeBeneficiary_structure_append_input, Argument.optional "_delete_at_path" filledInOptionals____.delete_at_path_ CdbGQL.InputObject.encodeBeneficiary_structure_delete_at_path_input, Argument.optional "_delete_elem" filledInOptionals____.delete_elem_ CdbGQL.InputObject.encodeBeneficiary_structure_delete_elem_input, Argument.optional "_delete_key" filledInOptionals____.delete_key_ CdbGQL.InputObject.encodeBeneficiary_structure_delete_key_input, Argument.optional "_prepend" filledInOptionals____.prepend_ CdbGQL.InputObject.encodeBeneficiary_structure_prepend_input, Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeBeneficiary_structure_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_beneficiary_structure_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeBeneficiary_structure_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateBeneficiaryStructureManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Beneficiary_structure_updates }


{-| update multiples rows of table: "beneficiary\_structure"

  - updates - updates to execute, in order

-}
update_beneficiary_structure_many :
    UpdateBeneficiaryStructureManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Beneficiary_structure_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_beneficiary_structure_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_beneficiary_structure_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeBeneficiary_structure_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateContractTypeOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Contract_type_set_input }


type alias UpdateContractTypeRequiredArguments =
    { where_ : CdbGQL.InputObject.Contract_type_bool_exp }


{-| update data of the table: "contract\_type"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_contract_type :
    (UpdateContractTypeOptionalArguments -> UpdateContractTypeOptionalArguments)
    -> UpdateContractTypeRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Contract_type_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_contract_type fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeContract_type_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_contract_type" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeContract_type_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateContractTypeByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Contract_type_set_input }


type alias UpdateContractTypeByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Contract_type_pk_columns_input }


{-| update single row of the table: "contract\_type"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_contract_type_by_pk :
    (UpdateContractTypeByPkOptionalArguments -> UpdateContractTypeByPkOptionalArguments)
    -> UpdateContractTypeByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Contract_type
    -> SelectionSet (Maybe decodesTo) RootMutation
update_contract_type_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeContract_type_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_contract_type_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeContract_type_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateContractTypeManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Contract_type_updates }


{-| update multiples rows of table: "contract\_type"

  - updates - updates to execute, in order

-}
update_contract_type_many :
    UpdateContractTypeManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Contract_type_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_contract_type_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_contract_type_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeContract_type_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateDeploymentOptionalArguments =
    { append_ : OptionalArgument CdbGQL.InputObject.Deployment_append_input
    , delete_at_path_ : OptionalArgument CdbGQL.InputObject.Deployment_delete_at_path_input
    , delete_elem_ : OptionalArgument CdbGQL.InputObject.Deployment_delete_elem_input
    , delete_key_ : OptionalArgument CdbGQL.InputObject.Deployment_delete_key_input
    , prepend_ : OptionalArgument CdbGQL.InputObject.Deployment_prepend_input
    , set_ : OptionalArgument CdbGQL.InputObject.Deployment_set_input
    }


type alias UpdateDeploymentRequiredArguments =
    { where_ : CdbGQL.InputObject.Deployment_bool_exp }


{-| update data of the table: "deployment"

  - append\_ - append existing jsonb value of filtered columns with new jsonb value
  - delete\_at\_path\_ - delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  - delete\_elem\_ - delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  - delete\_key\_ - delete key/value pair or string element. key/value pairs are matched based on their key value
  - prepend\_ - prepend existing jsonb value of filtered columns with new jsonb value
  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_deployment :
    (UpdateDeploymentOptionalArguments -> UpdateDeploymentOptionalArguments)
    -> UpdateDeploymentRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Deployment_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_deployment fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { append_ = Absent, delete_at_path_ = Absent, delete_elem_ = Absent, delete_key_ = Absent, prepend_ = Absent, set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_append" filledInOptionals____.append_ CdbGQL.InputObject.encodeDeployment_append_input, Argument.optional "_delete_at_path" filledInOptionals____.delete_at_path_ CdbGQL.InputObject.encodeDeployment_delete_at_path_input, Argument.optional "_delete_elem" filledInOptionals____.delete_elem_ CdbGQL.InputObject.encodeDeployment_delete_elem_input, Argument.optional "_delete_key" filledInOptionals____.delete_key_ CdbGQL.InputObject.encodeDeployment_delete_key_input, Argument.optional "_prepend" filledInOptionals____.prepend_ CdbGQL.InputObject.encodeDeployment_prepend_input, Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeDeployment_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_deployment" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeDeployment_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateDeploymentByPkOptionalArguments =
    { append_ : OptionalArgument CdbGQL.InputObject.Deployment_append_input
    , delete_at_path_ : OptionalArgument CdbGQL.InputObject.Deployment_delete_at_path_input
    , delete_elem_ : OptionalArgument CdbGQL.InputObject.Deployment_delete_elem_input
    , delete_key_ : OptionalArgument CdbGQL.InputObject.Deployment_delete_key_input
    , prepend_ : OptionalArgument CdbGQL.InputObject.Deployment_prepend_input
    , set_ : OptionalArgument CdbGQL.InputObject.Deployment_set_input
    }


type alias UpdateDeploymentByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Deployment_pk_columns_input }


{-| update single row of the table: "deployment"

  - append\_ - append existing jsonb value of filtered columns with new jsonb value
  - delete\_at\_path\_ - delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  - delete\_elem\_ - delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  - delete\_key\_ - delete key/value pair or string element. key/value pairs are matched based on their key value
  - prepend\_ - prepend existing jsonb value of filtered columns with new jsonb value
  - set\_ - sets the columns of the filtered rows to the given values

-}
update_deployment_by_pk :
    (UpdateDeploymentByPkOptionalArguments -> UpdateDeploymentByPkOptionalArguments)
    -> UpdateDeploymentByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Deployment
    -> SelectionSet (Maybe decodesTo) RootMutation
update_deployment_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { append_ = Absent, delete_at_path_ = Absent, delete_elem_ = Absent, delete_key_ = Absent, prepend_ = Absent, set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_append" filledInOptionals____.append_ CdbGQL.InputObject.encodeDeployment_append_input, Argument.optional "_delete_at_path" filledInOptionals____.delete_at_path_ CdbGQL.InputObject.encodeDeployment_delete_at_path_input, Argument.optional "_delete_elem" filledInOptionals____.delete_elem_ CdbGQL.InputObject.encodeDeployment_delete_elem_input, Argument.optional "_delete_key" filledInOptionals____.delete_key_ CdbGQL.InputObject.encodeDeployment_delete_key_input, Argument.optional "_prepend" filledInOptionals____.prepend_ CdbGQL.InputObject.encodeDeployment_prepend_input, Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeDeployment_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_deployment_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeDeployment_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateDeploymentManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Deployment_updates }


{-| update multiples rows of table: "deployment"

  - updates - updates to execute, in order

-}
update_deployment_many :
    UpdateDeploymentManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Deployment_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_deployment_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_deployment_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeDeployment_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateEmploymentTypeOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Employment_type_set_input }


type alias UpdateEmploymentTypeRequiredArguments =
    { where_ : CdbGQL.InputObject.Employment_type_bool_exp }


{-| update data of the table: "employment\_type"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_employment_type :
    (UpdateEmploymentTypeOptionalArguments -> UpdateEmploymentTypeOptionalArguments)
    -> UpdateEmploymentTypeRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Employment_type_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_employment_type fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeEmployment_type_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_employment_type" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeEmployment_type_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateEmploymentTypeByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Employment_type_set_input }


type alias UpdateEmploymentTypeByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Employment_type_pk_columns_input }


{-| update single row of the table: "employment\_type"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_employment_type_by_pk :
    (UpdateEmploymentTypeByPkOptionalArguments -> UpdateEmploymentTypeByPkOptionalArguments)
    -> UpdateEmploymentTypeByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Employment_type
    -> SelectionSet (Maybe decodesTo) RootMutation
update_employment_type_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeEmployment_type_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_employment_type_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeEmployment_type_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateEmploymentTypeManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Employment_type_updates }


{-| update multiples rows of table: "employment\_type"

  - updates - updates to execute, in order

-}
update_employment_type_many :
    UpdateEmploymentTypeManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Employment_type_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_employment_type_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_employment_type_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeEmployment_type_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateExternalDataOptionalArguments =
    { append_ : OptionalArgument CdbGQL.InputObject.External_data_append_input
    , delete_at_path_ : OptionalArgument CdbGQL.InputObject.External_data_delete_at_path_input
    , delete_elem_ : OptionalArgument CdbGQL.InputObject.External_data_delete_elem_input
    , delete_key_ : OptionalArgument CdbGQL.InputObject.External_data_delete_key_input
    , prepend_ : OptionalArgument CdbGQL.InputObject.External_data_prepend_input
    , set_ : OptionalArgument CdbGQL.InputObject.External_data_set_input
    }


type alias UpdateExternalDataRequiredArguments =
    { where_ : CdbGQL.InputObject.External_data_bool_exp }


{-| update data of the table: "external\_data"

  - append\_ - append existing jsonb value of filtered columns with new jsonb value
  - delete\_at\_path\_ - delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  - delete\_elem\_ - delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  - delete\_key\_ - delete key/value pair or string element. key/value pairs are matched based on their key value
  - prepend\_ - prepend existing jsonb value of filtered columns with new jsonb value
  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_external_data :
    (UpdateExternalDataOptionalArguments -> UpdateExternalDataOptionalArguments)
    -> UpdateExternalDataRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.External_data_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_external_data fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { append_ = Absent, delete_at_path_ = Absent, delete_elem_ = Absent, delete_key_ = Absent, prepend_ = Absent, set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_append" filledInOptionals____.append_ CdbGQL.InputObject.encodeExternal_data_append_input, Argument.optional "_delete_at_path" filledInOptionals____.delete_at_path_ CdbGQL.InputObject.encodeExternal_data_delete_at_path_input, Argument.optional "_delete_elem" filledInOptionals____.delete_elem_ CdbGQL.InputObject.encodeExternal_data_delete_elem_input, Argument.optional "_delete_key" filledInOptionals____.delete_key_ CdbGQL.InputObject.encodeExternal_data_delete_key_input, Argument.optional "_prepend" filledInOptionals____.prepend_ CdbGQL.InputObject.encodeExternal_data_prepend_input, Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeExternal_data_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_external_data" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeExternal_data_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateExternalDataByPkOptionalArguments =
    { append_ : OptionalArgument CdbGQL.InputObject.External_data_append_input
    , delete_at_path_ : OptionalArgument CdbGQL.InputObject.External_data_delete_at_path_input
    , delete_elem_ : OptionalArgument CdbGQL.InputObject.External_data_delete_elem_input
    , delete_key_ : OptionalArgument CdbGQL.InputObject.External_data_delete_key_input
    , prepend_ : OptionalArgument CdbGQL.InputObject.External_data_prepend_input
    , set_ : OptionalArgument CdbGQL.InputObject.External_data_set_input
    }


type alias UpdateExternalDataByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.External_data_pk_columns_input }


{-| update single row of the table: "external\_data"

  - append\_ - append existing jsonb value of filtered columns with new jsonb value
  - delete\_at\_path\_ - delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  - delete\_elem\_ - delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  - delete\_key\_ - delete key/value pair or string element. key/value pairs are matched based on their key value
  - prepend\_ - prepend existing jsonb value of filtered columns with new jsonb value
  - set\_ - sets the columns of the filtered rows to the given values

-}
update_external_data_by_pk :
    (UpdateExternalDataByPkOptionalArguments -> UpdateExternalDataByPkOptionalArguments)
    -> UpdateExternalDataByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.External_data
    -> SelectionSet (Maybe decodesTo) RootMutation
update_external_data_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { append_ = Absent, delete_at_path_ = Absent, delete_elem_ = Absent, delete_key_ = Absent, prepend_ = Absent, set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_append" filledInOptionals____.append_ CdbGQL.InputObject.encodeExternal_data_append_input, Argument.optional "_delete_at_path" filledInOptionals____.delete_at_path_ CdbGQL.InputObject.encodeExternal_data_delete_at_path_input, Argument.optional "_delete_elem" filledInOptionals____.delete_elem_ CdbGQL.InputObject.encodeExternal_data_delete_elem_input, Argument.optional "_delete_key" filledInOptionals____.delete_key_ CdbGQL.InputObject.encodeExternal_data_delete_key_input, Argument.optional "_prepend" filledInOptionals____.prepend_ CdbGQL.InputObject.encodeExternal_data_prepend_input, Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeExternal_data_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_external_data_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeExternal_data_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateExternalDataInfoOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.External_data_info_set_input }


type alias UpdateExternalDataInfoRequiredArguments =
    { where_ : CdbGQL.InputObject.External_data_info_bool_exp }


{-| update data of the table: "external\_data\_info"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_external_data_info :
    (UpdateExternalDataInfoOptionalArguments -> UpdateExternalDataInfoOptionalArguments)
    -> UpdateExternalDataInfoRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.External_data_info_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_external_data_info fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeExternal_data_info_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_external_data_info" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeExternal_data_info_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateExternalDataInfoByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.External_data_info_set_input }


type alias UpdateExternalDataInfoByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.External_data_info_pk_columns_input }


{-| update single row of the table: "external\_data\_info"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_external_data_info_by_pk :
    (UpdateExternalDataInfoByPkOptionalArguments -> UpdateExternalDataInfoByPkOptionalArguments)
    -> UpdateExternalDataInfoByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.External_data_info
    -> SelectionSet (Maybe decodesTo) RootMutation
update_external_data_info_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeExternal_data_info_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_external_data_info_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeExternal_data_info_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateExternalDataInfoManyRequiredArguments =
    { updates : List CdbGQL.InputObject.External_data_info_updates }


{-| update multiples rows of table: "external\_data\_info"

  - updates - updates to execute, in order

-}
update_external_data_info_many :
    UpdateExternalDataInfoManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.External_data_info_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_external_data_info_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_external_data_info_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeExternal_data_info_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateExternalDataManyRequiredArguments =
    { updates : List CdbGQL.InputObject.External_data_updates }


{-| update multiples rows of table: "external\_data"

  - updates - updates to execute, in order

-}
update_external_data_many :
    UpdateExternalDataManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.External_data_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_external_data_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_external_data_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeExternal_data_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateExternalSourceOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.External_source_set_input }


type alias UpdateExternalSourceRequiredArguments =
    { where_ : CdbGQL.InputObject.External_source_bool_exp }


{-| update data of the table: "external\_source"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_external_source :
    (UpdateExternalSourceOptionalArguments -> UpdateExternalSourceOptionalArguments)
    -> UpdateExternalSourceRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.External_source_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_external_source fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeExternal_source_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_external_source" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeExternal_source_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateExternalSourceByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.External_source_set_input }


type alias UpdateExternalSourceByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.External_source_pk_columns_input }


{-| update single row of the table: "external\_source"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_external_source_by_pk :
    (UpdateExternalSourceByPkOptionalArguments -> UpdateExternalSourceByPkOptionalArguments)
    -> UpdateExternalSourceByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.External_source
    -> SelectionSet (Maybe decodesTo) RootMutation
update_external_source_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeExternal_source_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_external_source_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeExternal_source_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateExternalSourceManyRequiredArguments =
    { updates : List CdbGQL.InputObject.External_source_updates }


{-| update multiples rows of table: "external\_source"

  - updates - updates to execute, in order

-}
update_external_source_many :
    UpdateExternalSourceManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.External_source_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_external_source_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_external_source_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeExternal_source_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateManagerOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Manager_set_input }


type alias UpdateManagerRequiredArguments =
    { where_ : CdbGQL.InputObject.Manager_bool_exp }


{-| update data of the table: "manager"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_manager :
    (UpdateManagerOptionalArguments -> UpdateManagerOptionalArguments)
    -> UpdateManagerRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Manager_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_manager fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeManager_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_manager" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeManager_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateManagerByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Manager_set_input }


type alias UpdateManagerByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Manager_pk_columns_input }


{-| update single row of the table: "manager"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_manager_by_pk :
    (UpdateManagerByPkOptionalArguments -> UpdateManagerByPkOptionalArguments)
    -> UpdateManagerByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Manager
    -> SelectionSet (Maybe decodesTo) RootMutation
update_manager_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeManager_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_manager_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeManager_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateManagerManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Manager_updates }


{-| update multiples rows of table: "manager"

  - updates - updates to execute, in order

-}
update_manager_many :
    UpdateManagerManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Manager_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_manager_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_manager_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeManager_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateNotebookOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Notebook_set_input }


type alias UpdateNotebookRequiredArguments =
    { where_ : CdbGQL.InputObject.Notebook_bool_exp }


{-| update data of the table: "notebook"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_notebook :
    (UpdateNotebookOptionalArguments -> UpdateNotebookOptionalArguments)
    -> UpdateNotebookRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_notebook fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeNotebook_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_notebook" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeNotebook_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateNotebookActionOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Notebook_action_set_input }


type alias UpdateNotebookActionRequiredArguments =
    { where_ : CdbGQL.InputObject.Notebook_action_bool_exp }


{-| update data of the table: "notebook\_action"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_notebook_action :
    (UpdateNotebookActionOptionalArguments -> UpdateNotebookActionOptionalArguments)
    -> UpdateNotebookActionRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_action_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_notebook_action fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeNotebook_action_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_notebook_action" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeNotebook_action_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateNotebookActionByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Notebook_action_set_input }


type alias UpdateNotebookActionByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Notebook_action_pk_columns_input }


{-| update single row of the table: "notebook\_action"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_notebook_action_by_pk :
    (UpdateNotebookActionByPkOptionalArguments -> UpdateNotebookActionByPkOptionalArguments)
    -> UpdateNotebookActionByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_action
    -> SelectionSet (Maybe decodesTo) RootMutation
update_notebook_action_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeNotebook_action_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_notebook_action_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeNotebook_action_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateNotebookActionManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Notebook_action_updates }


{-| update multiples rows of table: "notebook\_action"

  - updates - updates to execute, in order

-}
update_notebook_action_many :
    UpdateNotebookActionManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_action_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_notebook_action_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_notebook_action_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeNotebook_action_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateNotebookAppointmentOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Notebook_appointment_set_input }


type alias UpdateNotebookAppointmentRequiredArguments =
    { where_ : CdbGQL.InputObject.Notebook_appointment_bool_exp }


{-| update data of the table: "notebook\_appointment"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_notebook_appointment :
    (UpdateNotebookAppointmentOptionalArguments -> UpdateNotebookAppointmentOptionalArguments)
    -> UpdateNotebookAppointmentRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_appointment_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_notebook_appointment fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeNotebook_appointment_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_notebook_appointment" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeNotebook_appointment_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateNotebookAppointmentByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Notebook_appointment_set_input }


type alias UpdateNotebookAppointmentByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Notebook_appointment_pk_columns_input }


{-| update single row of the table: "notebook\_appointment"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_notebook_appointment_by_pk :
    (UpdateNotebookAppointmentByPkOptionalArguments -> UpdateNotebookAppointmentByPkOptionalArguments)
    -> UpdateNotebookAppointmentByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_appointment
    -> SelectionSet (Maybe decodesTo) RootMutation
update_notebook_appointment_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeNotebook_appointment_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_notebook_appointment_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeNotebook_appointment_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateNotebookAppointmentManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Notebook_appointment_updates }


{-| update multiples rows of table: "notebook\_appointment"

  - updates - updates to execute, in order

-}
update_notebook_appointment_many :
    UpdateNotebookAppointmentManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_appointment_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_notebook_appointment_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_notebook_appointment_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeNotebook_appointment_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateNotebookByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Notebook_set_input }


type alias UpdateNotebookByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Notebook_pk_columns_input }


{-| update single row of the table: "notebook"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_notebook_by_pk :
    (UpdateNotebookByPkOptionalArguments -> UpdateNotebookByPkOptionalArguments)
    -> UpdateNotebookByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook
    -> SelectionSet (Maybe decodesTo) RootMutation
update_notebook_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeNotebook_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_notebook_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeNotebook_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateNotebookEventOptionalArguments =
    { append_ : OptionalArgument CdbGQL.InputObject.Notebook_event_append_input
    , delete_at_path_ : OptionalArgument CdbGQL.InputObject.Notebook_event_delete_at_path_input
    , delete_elem_ : OptionalArgument CdbGQL.InputObject.Notebook_event_delete_elem_input
    , delete_key_ : OptionalArgument CdbGQL.InputObject.Notebook_event_delete_key_input
    , prepend_ : OptionalArgument CdbGQL.InputObject.Notebook_event_prepend_input
    , set_ : OptionalArgument CdbGQL.InputObject.Notebook_event_set_input
    }


type alias UpdateNotebookEventRequiredArguments =
    { where_ : CdbGQL.InputObject.Notebook_event_bool_exp }


{-| update data of the table: "notebook\_event"

  - append\_ - append existing jsonb value of filtered columns with new jsonb value
  - delete\_at\_path\_ - delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  - delete\_elem\_ - delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  - delete\_key\_ - delete key/value pair or string element. key/value pairs are matched based on their key value
  - prepend\_ - prepend existing jsonb value of filtered columns with new jsonb value
  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_notebook_event :
    (UpdateNotebookEventOptionalArguments -> UpdateNotebookEventOptionalArguments)
    -> UpdateNotebookEventRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_event_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_notebook_event fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { append_ = Absent, delete_at_path_ = Absent, delete_elem_ = Absent, delete_key_ = Absent, prepend_ = Absent, set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_append" filledInOptionals____.append_ CdbGQL.InputObject.encodeNotebook_event_append_input, Argument.optional "_delete_at_path" filledInOptionals____.delete_at_path_ CdbGQL.InputObject.encodeNotebook_event_delete_at_path_input, Argument.optional "_delete_elem" filledInOptionals____.delete_elem_ CdbGQL.InputObject.encodeNotebook_event_delete_elem_input, Argument.optional "_delete_key" filledInOptionals____.delete_key_ CdbGQL.InputObject.encodeNotebook_event_delete_key_input, Argument.optional "_prepend" filledInOptionals____.prepend_ CdbGQL.InputObject.encodeNotebook_event_prepend_input, Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeNotebook_event_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_notebook_event" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeNotebook_event_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateNotebookEventByPkOptionalArguments =
    { append_ : OptionalArgument CdbGQL.InputObject.Notebook_event_append_input
    , delete_at_path_ : OptionalArgument CdbGQL.InputObject.Notebook_event_delete_at_path_input
    , delete_elem_ : OptionalArgument CdbGQL.InputObject.Notebook_event_delete_elem_input
    , delete_key_ : OptionalArgument CdbGQL.InputObject.Notebook_event_delete_key_input
    , prepend_ : OptionalArgument CdbGQL.InputObject.Notebook_event_prepend_input
    , set_ : OptionalArgument CdbGQL.InputObject.Notebook_event_set_input
    }


type alias UpdateNotebookEventByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Notebook_event_pk_columns_input }


{-| update single row of the table: "notebook\_event"

  - append\_ - append existing jsonb value of filtered columns with new jsonb value
  - delete\_at\_path\_ - delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  - delete\_elem\_ - delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  - delete\_key\_ - delete key/value pair or string element. key/value pairs are matched based on their key value
  - prepend\_ - prepend existing jsonb value of filtered columns with new jsonb value
  - set\_ - sets the columns of the filtered rows to the given values

-}
update_notebook_event_by_pk :
    (UpdateNotebookEventByPkOptionalArguments -> UpdateNotebookEventByPkOptionalArguments)
    -> UpdateNotebookEventByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_event
    -> SelectionSet (Maybe decodesTo) RootMutation
update_notebook_event_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { append_ = Absent, delete_at_path_ = Absent, delete_elem_ = Absent, delete_key_ = Absent, prepend_ = Absent, set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_append" filledInOptionals____.append_ CdbGQL.InputObject.encodeNotebook_event_append_input, Argument.optional "_delete_at_path" filledInOptionals____.delete_at_path_ CdbGQL.InputObject.encodeNotebook_event_delete_at_path_input, Argument.optional "_delete_elem" filledInOptionals____.delete_elem_ CdbGQL.InputObject.encodeNotebook_event_delete_elem_input, Argument.optional "_delete_key" filledInOptionals____.delete_key_ CdbGQL.InputObject.encodeNotebook_event_delete_key_input, Argument.optional "_prepend" filledInOptionals____.prepend_ CdbGQL.InputObject.encodeNotebook_event_prepend_input, Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeNotebook_event_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_notebook_event_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeNotebook_event_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateNotebookEventManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Notebook_event_updates }


{-| update multiples rows of table: "notebook\_event"

  - updates - updates to execute, in order

-}
update_notebook_event_many :
    UpdateNotebookEventManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_event_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_notebook_event_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_notebook_event_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeNotebook_event_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateNotebookEventTypeOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Notebook_event_type_set_input }


type alias UpdateNotebookEventTypeRequiredArguments =
    { where_ : CdbGQL.InputObject.Notebook_event_type_bool_exp }


{-| update data of the table: "notebook\_event\_type"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_notebook_event_type :
    (UpdateNotebookEventTypeOptionalArguments -> UpdateNotebookEventTypeOptionalArguments)
    -> UpdateNotebookEventTypeRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_event_type_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_notebook_event_type fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeNotebook_event_type_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_notebook_event_type" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeNotebook_event_type_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateNotebookEventTypeByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Notebook_event_type_set_input }


type alias UpdateNotebookEventTypeByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Notebook_event_type_pk_columns_input }


{-| update single row of the table: "notebook\_event\_type"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_notebook_event_type_by_pk :
    (UpdateNotebookEventTypeByPkOptionalArguments -> UpdateNotebookEventTypeByPkOptionalArguments)
    -> UpdateNotebookEventTypeByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_event_type
    -> SelectionSet (Maybe decodesTo) RootMutation
update_notebook_event_type_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeNotebook_event_type_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_notebook_event_type_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeNotebook_event_type_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateNotebookEventTypeManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Notebook_event_type_updates }


{-| update multiples rows of table: "notebook\_event\_type"

  - updates - updates to execute, in order

-}
update_notebook_event_type_many :
    UpdateNotebookEventTypeManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_event_type_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_notebook_event_type_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_notebook_event_type_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeNotebook_event_type_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateNotebookFocusOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Notebook_focus_set_input }


type alias UpdateNotebookFocusRequiredArguments =
    { where_ : CdbGQL.InputObject.Notebook_focus_bool_exp }


{-| update data of the table: "notebook\_focus"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_notebook_focus :
    (UpdateNotebookFocusOptionalArguments -> UpdateNotebookFocusOptionalArguments)
    -> UpdateNotebookFocusRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_focus_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_notebook_focus fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeNotebook_focus_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_notebook_focus" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeNotebook_focus_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateNotebookFocusByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Notebook_focus_set_input }


type alias UpdateNotebookFocusByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Notebook_focus_pk_columns_input }


{-| update single row of the table: "notebook\_focus"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_notebook_focus_by_pk :
    (UpdateNotebookFocusByPkOptionalArguments -> UpdateNotebookFocusByPkOptionalArguments)
    -> UpdateNotebookFocusByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_focus
    -> SelectionSet (Maybe decodesTo) RootMutation
update_notebook_focus_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeNotebook_focus_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_notebook_focus_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeNotebook_focus_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateNotebookFocusManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Notebook_focus_updates }


{-| update multiples rows of table: "notebook\_focus"

  - updates - updates to execute, in order

-}
update_notebook_focus_many :
    UpdateNotebookFocusManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_focus_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_notebook_focus_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_notebook_focus_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeNotebook_focus_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateNotebookInfoOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Notebook_info_set_input }


type alias UpdateNotebookInfoRequiredArguments =
    { where_ : CdbGQL.InputObject.Notebook_info_bool_exp }


{-| update data of the table: "notebook\_info"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_notebook_info :
    (UpdateNotebookInfoOptionalArguments -> UpdateNotebookInfoOptionalArguments)
    -> UpdateNotebookInfoRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_info_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_notebook_info fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeNotebook_info_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_notebook_info" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeNotebook_info_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateNotebookInfoByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Notebook_info_set_input }


type alias UpdateNotebookInfoByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Notebook_info_pk_columns_input }


{-| update single row of the table: "notebook\_info"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_notebook_info_by_pk :
    (UpdateNotebookInfoByPkOptionalArguments -> UpdateNotebookInfoByPkOptionalArguments)
    -> UpdateNotebookInfoByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_info
    -> SelectionSet (Maybe decodesTo) RootMutation
update_notebook_info_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeNotebook_info_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_notebook_info_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeNotebook_info_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateNotebookInfoManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Notebook_info_updates }


{-| update multiples rows of table: "notebook\_info"

  - updates - updates to execute, in order

-}
update_notebook_info_many :
    UpdateNotebookInfoManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_info_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_notebook_info_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_notebook_info_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeNotebook_info_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateNotebookManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Notebook_updates }


{-| update multiples rows of table: "notebook"

  - updates - updates to execute, in order

-}
update_notebook_many :
    UpdateNotebookManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_notebook_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_notebook_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeNotebook_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateNotebookMemberOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Notebook_member_set_input }


type alias UpdateNotebookMemberRequiredArguments =
    { where_ : CdbGQL.InputObject.Notebook_member_bool_exp }


{-| update data of the table: "notebook\_member"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_notebook_member :
    (UpdateNotebookMemberOptionalArguments -> UpdateNotebookMemberOptionalArguments)
    -> UpdateNotebookMemberRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_member_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_notebook_member fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeNotebook_member_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_notebook_member" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeNotebook_member_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateNotebookMemberByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Notebook_member_set_input }


type alias UpdateNotebookMemberByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Notebook_member_pk_columns_input }


{-| update single row of the table: "notebook\_member"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_notebook_member_by_pk :
    (UpdateNotebookMemberByPkOptionalArguments -> UpdateNotebookMemberByPkOptionalArguments)
    -> UpdateNotebookMemberByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_member
    -> SelectionSet (Maybe decodesTo) RootMutation
update_notebook_member_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeNotebook_member_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_notebook_member_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeNotebook_member_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateNotebookMemberManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Notebook_member_updates }


{-| update multiples rows of table: "notebook\_member"

  - updates - updates to execute, in order

-}
update_notebook_member_many :
    UpdateNotebookMemberManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_member_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_notebook_member_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_notebook_member_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeNotebook_member_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateNotebookPublicViewOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Notebook_public_view_set_input }


type alias UpdateNotebookPublicViewRequiredArguments =
    { where_ : CdbGQL.InputObject.Notebook_public_view_bool_exp }


{-| update data of the table: "notebook\_public\_view"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_notebook_public_view :
    (UpdateNotebookPublicViewOptionalArguments -> UpdateNotebookPublicViewOptionalArguments)
    -> UpdateNotebookPublicViewRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_public_view_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_notebook_public_view fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeNotebook_public_view_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_notebook_public_view" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeNotebook_public_view_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateNotebookPublicViewManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Notebook_public_view_updates }


{-| update multiples rows of table: "notebook\_public\_view"

  - updates - updates to execute, in order

-}
update_notebook_public_view_many :
    UpdateNotebookPublicViewManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_public_view_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_notebook_public_view_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_notebook_public_view_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeNotebook_public_view_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateNotebookSituationOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Notebook_situation_set_input }


type alias UpdateNotebookSituationRequiredArguments =
    { where_ : CdbGQL.InputObject.Notebook_situation_bool_exp }


{-| update data of the table: "notebook\_situation"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_notebook_situation :
    (UpdateNotebookSituationOptionalArguments -> UpdateNotebookSituationOptionalArguments)
    -> UpdateNotebookSituationRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_situation_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_notebook_situation fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeNotebook_situation_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_notebook_situation" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeNotebook_situation_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateNotebookSituationByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Notebook_situation_set_input }


type alias UpdateNotebookSituationByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Notebook_situation_pk_columns_input }


{-| update single row of the table: "notebook\_situation"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_notebook_situation_by_pk :
    (UpdateNotebookSituationByPkOptionalArguments -> UpdateNotebookSituationByPkOptionalArguments)
    -> UpdateNotebookSituationByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_situation
    -> SelectionSet (Maybe decodesTo) RootMutation
update_notebook_situation_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeNotebook_situation_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_notebook_situation_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeNotebook_situation_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateNotebookSituationManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Notebook_situation_updates }


{-| update multiples rows of table: "notebook\_situation"

  - updates - updates to execute, in order

-}
update_notebook_situation_many :
    UpdateNotebookSituationManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_situation_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_notebook_situation_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_notebook_situation_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeNotebook_situation_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateNotebookTargetOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Notebook_target_set_input }


type alias UpdateNotebookTargetRequiredArguments =
    { where_ : CdbGQL.InputObject.Notebook_target_bool_exp }


{-| update data of the table: "notebook\_target"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_notebook_target :
    (UpdateNotebookTargetOptionalArguments -> UpdateNotebookTargetOptionalArguments)
    -> UpdateNotebookTargetRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_target_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_notebook_target fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeNotebook_target_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_notebook_target" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeNotebook_target_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateNotebookTargetByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Notebook_target_set_input }


type alias UpdateNotebookTargetByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Notebook_target_pk_columns_input }


{-| update single row of the table: "notebook\_target"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_notebook_target_by_pk :
    (UpdateNotebookTargetByPkOptionalArguments -> UpdateNotebookTargetByPkOptionalArguments)
    -> UpdateNotebookTargetByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_target
    -> SelectionSet (Maybe decodesTo) RootMutation
update_notebook_target_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeNotebook_target_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_notebook_target_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeNotebook_target_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateNotebookTargetManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Notebook_target_updates }


{-| update multiples rows of table: "notebook\_target"

  - updates - updates to execute, in order

-}
update_notebook_target_many :
    UpdateNotebookTargetManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Notebook_target_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_notebook_target_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_notebook_target_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeNotebook_target_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateNpsRatingOptionalArguments =
    { inc_ : OptionalArgument CdbGQL.InputObject.Nps_rating_inc_input
    , set_ : OptionalArgument CdbGQL.InputObject.Nps_rating_set_input
    }


type alias UpdateNpsRatingRequiredArguments =
    { where_ : CdbGQL.InputObject.Nps_rating_bool_exp }


{-| update data of the table: "nps\_rating"

  - inc\_ - increments the numeric columns with given value of the filtered values
  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_nps_rating :
    (UpdateNpsRatingOptionalArguments -> UpdateNpsRatingOptionalArguments)
    -> UpdateNpsRatingRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Nps_rating_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_nps_rating fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { inc_ = Absent, set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_inc" filledInOptionals____.inc_ CdbGQL.InputObject.encodeNps_rating_inc_input, Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeNps_rating_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_nps_rating" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeNps_rating_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateNpsRatingByPkOptionalArguments =
    { inc_ : OptionalArgument CdbGQL.InputObject.Nps_rating_inc_input
    , set_ : OptionalArgument CdbGQL.InputObject.Nps_rating_set_input
    }


type alias UpdateNpsRatingByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Nps_rating_pk_columns_input }


{-| update single row of the table: "nps\_rating"

  - inc\_ - increments the numeric columns with given value of the filtered values
  - set\_ - sets the columns of the filtered rows to the given values

-}
update_nps_rating_by_pk :
    (UpdateNpsRatingByPkOptionalArguments -> UpdateNpsRatingByPkOptionalArguments)
    -> UpdateNpsRatingByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Nps_rating
    -> SelectionSet (Maybe decodesTo) RootMutation
update_nps_rating_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { inc_ = Absent, set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_inc" filledInOptionals____.inc_ CdbGQL.InputObject.encodeNps_rating_inc_input, Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeNps_rating_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_nps_rating_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeNps_rating_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateNpsRatingDismissalOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Nps_rating_dismissal_set_input }


type alias UpdateNpsRatingDismissalRequiredArguments =
    { where_ : CdbGQL.InputObject.Nps_rating_dismissal_bool_exp }


{-| update data of the table: "nps\_rating\_dismissal"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_nps_rating_dismissal :
    (UpdateNpsRatingDismissalOptionalArguments -> UpdateNpsRatingDismissalOptionalArguments)
    -> UpdateNpsRatingDismissalRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Nps_rating_dismissal_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_nps_rating_dismissal fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeNps_rating_dismissal_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_nps_rating_dismissal" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeNps_rating_dismissal_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateNpsRatingDismissalByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Nps_rating_dismissal_set_input }


type alias UpdateNpsRatingDismissalByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Nps_rating_dismissal_pk_columns_input }


{-| update single row of the table: "nps\_rating\_dismissal"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_nps_rating_dismissal_by_pk :
    (UpdateNpsRatingDismissalByPkOptionalArguments -> UpdateNpsRatingDismissalByPkOptionalArguments)
    -> UpdateNpsRatingDismissalByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Nps_rating_dismissal
    -> SelectionSet (Maybe decodesTo) RootMutation
update_nps_rating_dismissal_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeNps_rating_dismissal_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_nps_rating_dismissal_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeNps_rating_dismissal_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateNpsRatingDismissalManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Nps_rating_dismissal_updates }


{-| update multiples rows of table: "nps\_rating\_dismissal"

  - updates - updates to execute, in order

-}
update_nps_rating_dismissal_many :
    UpdateNpsRatingDismissalManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Nps_rating_dismissal_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_nps_rating_dismissal_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_nps_rating_dismissal_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeNps_rating_dismissal_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateNpsRatingManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Nps_rating_updates }


{-| update multiples rows of table: "nps\_rating"

  - updates - updates to execute, in order

-}
update_nps_rating_many :
    UpdateNpsRatingManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Nps_rating_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_nps_rating_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_nps_rating_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeNps_rating_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateOrientationManagerOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Orientation_manager_set_input }


type alias UpdateOrientationManagerRequiredArguments =
    { where_ : CdbGQL.InputObject.Orientation_manager_bool_exp }


{-| update data of the table: "orientation\_manager"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_orientation_manager :
    (UpdateOrientationManagerOptionalArguments -> UpdateOrientationManagerOptionalArguments)
    -> UpdateOrientationManagerRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_manager_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_orientation_manager fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeOrientation_manager_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_orientation_manager" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeOrientation_manager_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateOrientationManagerByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Orientation_manager_set_input }


type alias UpdateOrientationManagerByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Orientation_manager_pk_columns_input }


{-| update single row of the table: "orientation\_manager"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_orientation_manager_by_pk :
    (UpdateOrientationManagerByPkOptionalArguments -> UpdateOrientationManagerByPkOptionalArguments)
    -> UpdateOrientationManagerByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_manager
    -> SelectionSet (Maybe decodesTo) RootMutation
update_orientation_manager_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeOrientation_manager_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_orientation_manager_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeOrientation_manager_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateOrientationManagerManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Orientation_manager_updates }


{-| update multiples rows of table: "orientation\_manager"

  - updates - updates to execute, in order

-}
update_orientation_manager_many :
    UpdateOrientationManagerManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_manager_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_orientation_manager_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_orientation_manager_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeOrientation_manager_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateOrientationRequestOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Orientation_request_set_input }


type alias UpdateOrientationRequestRequiredArguments =
    { where_ : CdbGQL.InputObject.Orientation_request_bool_exp }


{-| update data of the table: "orientation\_request"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_orientation_request :
    (UpdateOrientationRequestOptionalArguments -> UpdateOrientationRequestOptionalArguments)
    -> UpdateOrientationRequestRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_request_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_orientation_request fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeOrientation_request_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_orientation_request" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeOrientation_request_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateOrientationRequestByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Orientation_request_set_input }


type alias UpdateOrientationRequestByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Orientation_request_pk_columns_input }


{-| update single row of the table: "orientation\_request"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_orientation_request_by_pk :
    (UpdateOrientationRequestByPkOptionalArguments -> UpdateOrientationRequestByPkOptionalArguments)
    -> UpdateOrientationRequestByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_request
    -> SelectionSet (Maybe decodesTo) RootMutation
update_orientation_request_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeOrientation_request_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_orientation_request_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeOrientation_request_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateOrientationRequestManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Orientation_request_updates }


{-| update multiples rows of table: "orientation\_request"

  - updates - updates to execute, in order

-}
update_orientation_request_many :
    UpdateOrientationRequestManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_request_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_orientation_request_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_orientation_request_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeOrientation_request_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateOrientationSystemOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Orientation_system_set_input }


type alias UpdateOrientationSystemRequiredArguments =
    { where_ : CdbGQL.InputObject.Orientation_system_bool_exp }


{-| update data of the table: "orientation\_system"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_orientation_system :
    (UpdateOrientationSystemOptionalArguments -> UpdateOrientationSystemOptionalArguments)
    -> UpdateOrientationSystemRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_system_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_orientation_system fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeOrientation_system_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_orientation_system" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeOrientation_system_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateOrientationSystemByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Orientation_system_set_input }


type alias UpdateOrientationSystemByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Orientation_system_pk_columns_input }


{-| update single row of the table: "orientation\_system"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_orientation_system_by_pk :
    (UpdateOrientationSystemByPkOptionalArguments -> UpdateOrientationSystemByPkOptionalArguments)
    -> UpdateOrientationSystemByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_system
    -> SelectionSet (Maybe decodesTo) RootMutation
update_orientation_system_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeOrientation_system_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_orientation_system_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeOrientation_system_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateOrientationSystemManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Orientation_system_updates }


{-| update multiples rows of table: "orientation\_system"

  - updates - updates to execute, in order

-}
update_orientation_system_many :
    UpdateOrientationSystemManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_system_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_orientation_system_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_orientation_system_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeOrientation_system_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateOrientationTypeOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Orientation_type_set_input }


type alias UpdateOrientationTypeRequiredArguments =
    { where_ : CdbGQL.InputObject.Orientation_type_bool_exp }


{-| update data of the table: "orientation\_type"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_orientation_type :
    (UpdateOrientationTypeOptionalArguments -> UpdateOrientationTypeOptionalArguments)
    -> UpdateOrientationTypeRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_type_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_orientation_type fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeOrientation_type_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_orientation_type" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeOrientation_type_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateOrientationTypeByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Orientation_type_set_input }


type alias UpdateOrientationTypeByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Orientation_type_pk_columns_input }


{-| update single row of the table: "orientation\_type"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_orientation_type_by_pk :
    (UpdateOrientationTypeByPkOptionalArguments -> UpdateOrientationTypeByPkOptionalArguments)
    -> UpdateOrientationTypeByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_type
    -> SelectionSet (Maybe decodesTo) RootMutation
update_orientation_type_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeOrientation_type_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_orientation_type_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeOrientation_type_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateOrientationTypeManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Orientation_type_updates }


{-| update multiples rows of table: "orientation\_type"

  - updates - updates to execute, in order

-}
update_orientation_type_many :
    UpdateOrientationTypeManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Orientation_type_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_orientation_type_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_orientation_type_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeOrientation_type_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateProfessionalOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Professional_set_input }


type alias UpdateProfessionalRequiredArguments =
    { where_ : CdbGQL.InputObject.Professional_bool_exp }


{-| update data of the table: "professional"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_professional :
    (UpdateProfessionalOptionalArguments -> UpdateProfessionalOptionalArguments)
    -> UpdateProfessionalRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Professional_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_professional fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeProfessional_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_professional" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeProfessional_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateProfessionalByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Professional_set_input }


type alias UpdateProfessionalByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Professional_pk_columns_input }


{-| update single row of the table: "professional"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_professional_by_pk :
    (UpdateProfessionalByPkOptionalArguments -> UpdateProfessionalByPkOptionalArguments)
    -> UpdateProfessionalByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Professional
    -> SelectionSet (Maybe decodesTo) RootMutation
update_professional_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeProfessional_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_professional_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeProfessional_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateProfessionalManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Professional_updates }


{-| update multiples rows of table: "professional"

  - updates - updates to execute, in order

-}
update_professional_many :
    UpdateProfessionalManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Professional_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_professional_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_professional_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeProfessional_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateProfessionalOrientationSystemOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Professional_orientation_system_set_input }


type alias UpdateProfessionalOrientationSystemRequiredArguments =
    { where_ : CdbGQL.InputObject.Professional_orientation_system_bool_exp }


{-| update data of the table: "professional\_orientation\_system"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_professional_orientation_system :
    (UpdateProfessionalOrientationSystemOptionalArguments -> UpdateProfessionalOrientationSystemOptionalArguments)
    -> UpdateProfessionalOrientationSystemRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Professional_orientation_system_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_professional_orientation_system fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeProfessional_orientation_system_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_professional_orientation_system" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeProfessional_orientation_system_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateProfessionalOrientationSystemByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Professional_orientation_system_set_input }


type alias UpdateProfessionalOrientationSystemByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Professional_orientation_system_pk_columns_input }


{-| update single row of the table: "professional\_orientation\_system"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_professional_orientation_system_by_pk :
    (UpdateProfessionalOrientationSystemByPkOptionalArguments -> UpdateProfessionalOrientationSystemByPkOptionalArguments)
    -> UpdateProfessionalOrientationSystemByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Professional_orientation_system
    -> SelectionSet (Maybe decodesTo) RootMutation
update_professional_orientation_system_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeProfessional_orientation_system_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_professional_orientation_system_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeProfessional_orientation_system_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateProfessionalOrientationSystemManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Professional_orientation_system_updates }


{-| update multiples rows of table: "professional\_orientation\_system"

  - updates - updates to execute, in order

-}
update_professional_orientation_system_many :
    UpdateProfessionalOrientationSystemManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Professional_orientation_system_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_professional_orientation_system_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_professional_orientation_system_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeProfessional_orientation_system_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateProfessionalProjectOptionalArguments =
    { inc_ : OptionalArgument CdbGQL.InputObject.Professional_project_inc_input
    , set_ : OptionalArgument CdbGQL.InputObject.Professional_project_set_input
    }


type alias UpdateProfessionalProjectRequiredArguments =
    { where_ : CdbGQL.InputObject.Professional_project_bool_exp }


{-| update data of the table: "professional\_project"

  - inc\_ - increments the numeric columns with given value of the filtered values
  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_professional_project :
    (UpdateProfessionalProjectOptionalArguments -> UpdateProfessionalProjectOptionalArguments)
    -> UpdateProfessionalProjectRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Professional_project_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_professional_project fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { inc_ = Absent, set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_inc" filledInOptionals____.inc_ CdbGQL.InputObject.encodeProfessional_project_inc_input, Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeProfessional_project_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_professional_project" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeProfessional_project_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateProfessionalProjectByPkOptionalArguments =
    { inc_ : OptionalArgument CdbGQL.InputObject.Professional_project_inc_input
    , set_ : OptionalArgument CdbGQL.InputObject.Professional_project_set_input
    }


type alias UpdateProfessionalProjectByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Professional_project_pk_columns_input }


{-| update single row of the table: "professional\_project"

  - inc\_ - increments the numeric columns with given value of the filtered values
  - set\_ - sets the columns of the filtered rows to the given values

-}
update_professional_project_by_pk :
    (UpdateProfessionalProjectByPkOptionalArguments -> UpdateProfessionalProjectByPkOptionalArguments)
    -> UpdateProfessionalProjectByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Professional_project
    -> SelectionSet (Maybe decodesTo) RootMutation
update_professional_project_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { inc_ = Absent, set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_inc" filledInOptionals____.inc_ CdbGQL.InputObject.encodeProfessional_project_inc_input, Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeProfessional_project_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_professional_project_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeProfessional_project_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateProfessionalProjectManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Professional_project_updates }


{-| update multiples rows of table: "professional\_project"

  - updates - updates to execute, in order

-}
update_professional_project_many :
    UpdateProfessionalProjectManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Professional_project_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_professional_project_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_professional_project_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeProfessional_project_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateRefActionOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Ref_action_set_input }


type alias UpdateRefActionRequiredArguments =
    { where_ : CdbGQL.InputObject.Ref_action_bool_exp }


{-| update data of the table: "ref\_action"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_ref_action :
    (UpdateRefActionOptionalArguments -> UpdateRefActionOptionalArguments)
    -> UpdateRefActionRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_action_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_ref_action fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeRef_action_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_ref_action" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeRef_action_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateRefActionByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Ref_action_set_input }


type alias UpdateRefActionByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Ref_action_pk_columns_input }


{-| update single row of the table: "ref\_action"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_ref_action_by_pk :
    (UpdateRefActionByPkOptionalArguments -> UpdateRefActionByPkOptionalArguments)
    -> UpdateRefActionByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_action
    -> SelectionSet (Maybe decodesTo) RootMutation
update_ref_action_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeRef_action_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_ref_action_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeRef_action_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateRefActionManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Ref_action_updates }


{-| update multiples rows of table: "ref\_action"

  - updates - updates to execute, in order

-}
update_ref_action_many :
    UpdateRefActionManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_action_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_ref_action_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_ref_action_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeRef_action_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateRefSituationOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Ref_situation_set_input }


type alias UpdateRefSituationRequiredArguments =
    { where_ : CdbGQL.InputObject.Ref_situation_bool_exp }


{-| update data of the table: "ref\_situation"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_ref_situation :
    (UpdateRefSituationOptionalArguments -> UpdateRefSituationOptionalArguments)
    -> UpdateRefSituationRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_situation_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_ref_situation fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeRef_situation_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_ref_situation" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeRef_situation_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateRefSituationByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Ref_situation_set_input }


type alias UpdateRefSituationByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Ref_situation_pk_columns_input }


{-| update single row of the table: "ref\_situation"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_ref_situation_by_pk :
    (UpdateRefSituationByPkOptionalArguments -> UpdateRefSituationByPkOptionalArguments)
    -> UpdateRefSituationByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_situation
    -> SelectionSet (Maybe decodesTo) RootMutation
update_ref_situation_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeRef_situation_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_ref_situation_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeRef_situation_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateRefSituationManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Ref_situation_updates }


{-| update multiples rows of table: "ref\_situation"

  - updates - updates to execute, in order

-}
update_ref_situation_many :
    UpdateRefSituationManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_situation_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_ref_situation_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_ref_situation_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeRef_situation_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateRefTargetOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Ref_target_set_input }


type alias UpdateRefTargetRequiredArguments =
    { where_ : CdbGQL.InputObject.Ref_target_bool_exp }


{-| update data of the table: "ref\_target"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_ref_target :
    (UpdateRefTargetOptionalArguments -> UpdateRefTargetOptionalArguments)
    -> UpdateRefTargetRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_target_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_ref_target fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeRef_target_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_ref_target" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeRef_target_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateRefTargetByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Ref_target_set_input }


type alias UpdateRefTargetByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Ref_target_pk_columns_input }


{-| update single row of the table: "ref\_target"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_ref_target_by_pk :
    (UpdateRefTargetByPkOptionalArguments -> UpdateRefTargetByPkOptionalArguments)
    -> UpdateRefTargetByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_target
    -> SelectionSet (Maybe decodesTo) RootMutation
update_ref_target_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeRef_target_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_ref_target_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeRef_target_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateRefTargetManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Ref_target_updates }


{-| update multiples rows of table: "ref\_target"

  - updates - updates to execute, in order

-}
update_ref_target_many :
    UpdateRefTargetManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_target_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_ref_target_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_ref_target_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeRef_target_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateRefThemeOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Ref_theme_set_input }


type alias UpdateRefThemeRequiredArguments =
    { where_ : CdbGQL.InputObject.Ref_theme_bool_exp }


{-| update data of the table: "ref\_theme"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_ref_theme :
    (UpdateRefThemeOptionalArguments -> UpdateRefThemeOptionalArguments)
    -> UpdateRefThemeRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_theme_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_ref_theme fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeRef_theme_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_ref_theme" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeRef_theme_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateRefThemeByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Ref_theme_set_input }


type alias UpdateRefThemeByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Ref_theme_pk_columns_input }


{-| update single row of the table: "ref\_theme"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_ref_theme_by_pk :
    (UpdateRefThemeByPkOptionalArguments -> UpdateRefThemeByPkOptionalArguments)
    -> UpdateRefThemeByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_theme
    -> SelectionSet (Maybe decodesTo) RootMutation
update_ref_theme_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeRef_theme_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_ref_theme_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeRef_theme_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateRefThemeManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Ref_theme_updates }


{-| update multiples rows of table: "ref\_theme"

  - updates - updates to execute, in order

-}
update_ref_theme_many :
    UpdateRefThemeManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Ref_theme_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_ref_theme_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_ref_theme_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeRef_theme_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateRoleOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Role_set_input }


type alias UpdateRoleRequiredArguments =
    { where_ : CdbGQL.InputObject.Role_bool_exp }


{-| update data of the table: "role"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_role :
    (UpdateRoleOptionalArguments -> UpdateRoleOptionalArguments)
    -> UpdateRoleRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Role_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_role fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeRole_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_role" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeRole_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateRoleByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Role_set_input }


type alias UpdateRoleByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Role_pk_columns_input }


{-| update single row of the table: "role"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_role_by_pk :
    (UpdateRoleByPkOptionalArguments -> UpdateRoleByPkOptionalArguments)
    -> UpdateRoleByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Role
    -> SelectionSet (Maybe decodesTo) RootMutation
update_role_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeRole_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_role_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeRole_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateRoleManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Role_updates }


{-| update multiples rows of table: "role"

  - updates - updates to execute, in order

-}
update_role_many :
    UpdateRoleManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Role_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_role_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_role_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeRole_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateRomeCodeOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Rome_code_set_input }


type alias UpdateRomeCodeRequiredArguments =
    { where_ : CdbGQL.InputObject.Rome_code_bool_exp }


{-| update data of the table: "rome\_code"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_rome_code :
    (UpdateRomeCodeOptionalArguments -> UpdateRomeCodeOptionalArguments)
    -> UpdateRomeCodeRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rome_code_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_rome_code fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeRome_code_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_rome_code" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeRome_code_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateRomeCodeByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Rome_code_set_input }


type alias UpdateRomeCodeByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Rome_code_pk_columns_input }


{-| update single row of the table: "rome\_code"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_rome_code_by_pk :
    (UpdateRomeCodeByPkOptionalArguments -> UpdateRomeCodeByPkOptionalArguments)
    -> UpdateRomeCodeByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rome_code
    -> SelectionSet (Maybe decodesTo) RootMutation
update_rome_code_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeRome_code_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_rome_code_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeRome_code_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateRomeCodeManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Rome_code_updates }


{-| update multiples rows of table: "rome\_code"

  - updates - updates to execute, in order

-}
update_rome_code_many :
    UpdateRomeCodeManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rome_code_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_rome_code_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_rome_code_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeRome_code_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateRsaClosureReasonOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Rsa_closure_reason_set_input }


type alias UpdateRsaClosureReasonRequiredArguments =
    { where_ : CdbGQL.InputObject.Rsa_closure_reason_bool_exp }


{-| update data of the table: "rsa\_closure\_reason"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_rsa_closure_reason :
    (UpdateRsaClosureReasonOptionalArguments -> UpdateRsaClosureReasonOptionalArguments)
    -> UpdateRsaClosureReasonRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rsa_closure_reason_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_rsa_closure_reason fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeRsa_closure_reason_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_rsa_closure_reason" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeRsa_closure_reason_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateRsaClosureReasonByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Rsa_closure_reason_set_input }


type alias UpdateRsaClosureReasonByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Rsa_closure_reason_pk_columns_input }


{-| update single row of the table: "rsa\_closure\_reason"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_rsa_closure_reason_by_pk :
    (UpdateRsaClosureReasonByPkOptionalArguments -> UpdateRsaClosureReasonByPkOptionalArguments)
    -> UpdateRsaClosureReasonByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rsa_closure_reason
    -> SelectionSet (Maybe decodesTo) RootMutation
update_rsa_closure_reason_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeRsa_closure_reason_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_rsa_closure_reason_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeRsa_closure_reason_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateRsaClosureReasonManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Rsa_closure_reason_updates }


{-| update multiples rows of table: "rsa\_closure\_reason"

  - updates - updates to execute, in order

-}
update_rsa_closure_reason_many :
    UpdateRsaClosureReasonManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rsa_closure_reason_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_rsa_closure_reason_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_rsa_closure_reason_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeRsa_closure_reason_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateRsaSuspensionReasonOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Rsa_suspension_reason_set_input }


type alias UpdateRsaSuspensionReasonRequiredArguments =
    { where_ : CdbGQL.InputObject.Rsa_suspension_reason_bool_exp }


{-| update data of the table: "rsa\_suspension\_reason"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_rsa_suspension_reason :
    (UpdateRsaSuspensionReasonOptionalArguments -> UpdateRsaSuspensionReasonOptionalArguments)
    -> UpdateRsaSuspensionReasonRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rsa_suspension_reason_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_rsa_suspension_reason fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeRsa_suspension_reason_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_rsa_suspension_reason" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeRsa_suspension_reason_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateRsaSuspensionReasonByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Rsa_suspension_reason_set_input }


type alias UpdateRsaSuspensionReasonByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Rsa_suspension_reason_pk_columns_input }


{-| update single row of the table: "rsa\_suspension\_reason"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_rsa_suspension_reason_by_pk :
    (UpdateRsaSuspensionReasonByPkOptionalArguments -> UpdateRsaSuspensionReasonByPkOptionalArguments)
    -> UpdateRsaSuspensionReasonByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rsa_suspension_reason
    -> SelectionSet (Maybe decodesTo) RootMutation
update_rsa_suspension_reason_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeRsa_suspension_reason_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_rsa_suspension_reason_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeRsa_suspension_reason_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateRsaSuspensionReasonManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Rsa_suspension_reason_updates }


{-| update multiples rows of table: "rsa\_suspension\_reason"

  - updates - updates to execute, in order

-}
update_rsa_suspension_reason_many :
    UpdateRsaSuspensionReasonManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Rsa_suspension_reason_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_rsa_suspension_reason_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_rsa_suspension_reason_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeRsa_suspension_reason_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateSocioProOptionalArguments =
    { educationLevel : OptionalArgument String
    , lastJobEndedAt : OptionalArgument CdbGQL.ScalarCodecs.Date
    , rightRqth : OptionalArgument Bool
    , workSituation : OptionalArgument String
    , workSituationDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    , workSituationEndDate : OptionalArgument CdbGQL.ScalarCodecs.Date
    }


type alias UpdateSocioProRequiredArguments =
    { id : CdbGQL.ScalarCodecs.Uuid
    , professionalProjectIdsToDelete : List CdbGQL.ScalarCodecs.Uuid
    , professionalProjectsToAdd : List CdbGQL.InputObject.UpdateSocioProProfessionalProjectInsertInput
    , professionalProjectsToUpdate : List CdbGQL.InputObject.UpdateSocioProProfessionalProjectSetInput
    , situationIdsToDelete : List CdbGQL.ScalarCodecs.Uuid
    , situationIdsToDelete : List CdbGQL.ScalarCodecs.Uuid
    , situationsToAdd : List CdbGQL.InputObject.UpdateSocioProNotebookSituationInsertInput
    }


{-| Update professionnal project and create notebook event
-}
update_socio_pro :
    (UpdateSocioProOptionalArguments -> UpdateSocioProOptionalArguments)
    -> UpdateSocioProRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.UpdateSocioProOutput
    -> SelectionSet (Maybe decodesTo) RootMutation
update_socio_pro fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { educationLevel = Absent, lastJobEndedAt = Absent, rightRqth = Absent, workSituation = Absent, workSituationDate = Absent, workSituationEndDate = Absent }

        optionalArgs____ =
            [ Argument.optional "educationLevel" filledInOptionals____.educationLevel Encode.string, Argument.optional "lastJobEndedAt" filledInOptionals____.lastJobEndedAt (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate), Argument.optional "rightRqth" filledInOptionals____.rightRqth Encode.bool, Argument.optional "workSituation" filledInOptionals____.workSituation Encode.string, Argument.optional "workSituationDate" filledInOptionals____.workSituationDate (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate), Argument.optional "workSituationEndDate" filledInOptionals____.workSituationEndDate (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecDate) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_socio_pro" (optionalArgs____ ++ [ Argument.required "id" requiredArgs____.id (CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid), Argument.required "professionalProjectIdsToDelete" requiredArgs____.professionalProjectIdsToDelete ((CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.list), Argument.required "professionalProjectsToAdd" requiredArgs____.professionalProjectsToAdd (CdbGQL.InputObject.encodeUpdateSocioProProfessionalProjectInsertInput |> Encode.list), Argument.required "professionalProjectsToUpdate" requiredArgs____.professionalProjectsToUpdate (CdbGQL.InputObject.encodeUpdateSocioProProfessionalProjectSetInput |> Encode.list), Argument.required "situationIdsToDelete" requiredArgs____.situationIdsToDelete ((CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.list), Argument.required "situationIdsToDelete" requiredArgs____.situationIdsToDelete ((CdbGQL.ScalarCodecs.codecs |> CdbGQL.Scalar.unwrapEncoder .codecUuid) |> Encode.list), Argument.required "situationsToAdd" requiredArgs____.situationsToAdd (CdbGQL.InputObject.encodeUpdateSocioProNotebookSituationInsertInput |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateStructureOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Structure_set_input }


type alias UpdateStructureRequiredArguments =
    { where_ : CdbGQL.InputObject.Structure_bool_exp }


{-| update data of the table: "structure"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_structure :
    (UpdateStructureOptionalArguments -> UpdateStructureOptionalArguments)
    -> UpdateStructureRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Structure_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_structure fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeStructure_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_structure" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeStructure_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateStructureByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Structure_set_input }


type alias UpdateStructureByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Structure_pk_columns_input }


{-| update single row of the table: "structure"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_structure_by_pk :
    (UpdateStructureByPkOptionalArguments -> UpdateStructureByPkOptionalArguments)
    -> UpdateStructureByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Structure
    -> SelectionSet (Maybe decodesTo) RootMutation
update_structure_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeStructure_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_structure_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeStructure_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateStructureManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Structure_updates }


{-| update multiples rows of table: "structure"

  - updates - updates to execute, in order

-}
update_structure_many :
    UpdateStructureManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Structure_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_structure_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_structure_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeStructure_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateStructureOrientationSystemOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Structure_orientation_system_set_input }


type alias UpdateStructureOrientationSystemRequiredArguments =
    { where_ : CdbGQL.InputObject.Structure_orientation_system_bool_exp }


{-| update data of the table: "structure\_orientation\_system"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_structure_orientation_system :
    (UpdateStructureOrientationSystemOptionalArguments -> UpdateStructureOrientationSystemOptionalArguments)
    -> UpdateStructureOrientationSystemRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Structure_orientation_system_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_structure_orientation_system fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeStructure_orientation_system_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_structure_orientation_system" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ CdbGQL.InputObject.encodeStructure_orientation_system_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateStructureOrientationSystemByPkOptionalArguments =
    { set_ : OptionalArgument CdbGQL.InputObject.Structure_orientation_system_set_input }


type alias UpdateStructureOrientationSystemByPkRequiredArguments =
    { pk_columns : CdbGQL.InputObject.Structure_orientation_system_pk_columns_input }


{-| update single row of the table: "structure\_orientation\_system"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_structure_orientation_system_by_pk :
    (UpdateStructureOrientationSystemByPkOptionalArguments -> UpdateStructureOrientationSystemByPkOptionalArguments)
    -> UpdateStructureOrientationSystemByPkRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Structure_orientation_system
    -> SelectionSet (Maybe decodesTo) RootMutation
update_structure_orientation_system_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ CdbGQL.InputObject.encodeStructure_orientation_system_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_structure_orientation_system_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns CdbGQL.InputObject.encodeStructure_orientation_system_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateStructureOrientationSystemManyRequiredArguments =
    { updates : List CdbGQL.InputObject.Structure_orientation_system_updates }


{-| update multiples rows of table: "structure\_orientation\_system"

  - updates - updates to execute, in order

-}
update_structure_orientation_system_many :
    UpdateStructureOrientationSystemManyRequiredArguments
    -> SelectionSet decodesTo CdbGQL.Object.Structure_orientation_system_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_structure_orientation_system_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_structure_orientation_system_many" [ Argument.required "updates" requiredArgs____.updates (CdbGQL.InputObject.encodeStructure_orientation_system_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)
